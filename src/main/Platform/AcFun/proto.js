/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
import * as $protobuf from "protobufjs/minimal";

// Common aliases
const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
const $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

export const AcFunDanmu = $root.AcFunDanmu = (() => {

    /**
     * Namespace AcFunDanmu.
     * @exports AcFunDanmu
     * @namespace
     */
    const AcFunDanmu = {};

    AcFunDanmu.AccessPoint = (function() {

        /**
         * Properties of an AccessPoint.
         * @memberof AcFunDanmu
         * @interface IAccessPoint
         * @property {AcFunDanmu.AccessPoint.AddressType|null} [addressType] AccessPoint addressType
         * @property {number|null} [port] AccessPoint port
         * @property {number|null} [ipV4] AccessPoint ipV4
         * @property {Uint8Array|null} [ipV6] AccessPoint ipV6
         * @property {string|null} [domain] AccessPoint domain
         */

        /**
         * Constructs a new AccessPoint.
         * @memberof AcFunDanmu
         * @classdesc Represents an AccessPoint.
         * @implements IAccessPoint
         * @constructor
         * @param {AcFunDanmu.IAccessPoint=} [properties] Properties to set
         */
        function AccessPoint(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccessPoint addressType.
         * @member {AcFunDanmu.AccessPoint.AddressType} addressType
         * @memberof AcFunDanmu.AccessPoint
         * @instance
         */
        AccessPoint.prototype.addressType = 0;

        /**
         * AccessPoint port.
         * @member {number} port
         * @memberof AcFunDanmu.AccessPoint
         * @instance
         */
        AccessPoint.prototype.port = 0;

        /**
         * AccessPoint ipV4.
         * @member {number} ipV4
         * @memberof AcFunDanmu.AccessPoint
         * @instance
         */
        AccessPoint.prototype.ipV4 = 0;

        /**
         * AccessPoint ipV6.
         * @member {Uint8Array} ipV6
         * @memberof AcFunDanmu.AccessPoint
         * @instance
         */
        AccessPoint.prototype.ipV6 = $util.newBuffer([]);

        /**
         * AccessPoint domain.
         * @member {string} domain
         * @memberof AcFunDanmu.AccessPoint
         * @instance
         */
        AccessPoint.prototype.domain = "";

        /**
         * Creates a new AccessPoint instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.AccessPoint
         * @static
         * @param {AcFunDanmu.IAccessPoint=} [properties] Properties to set
         * @returns {AcFunDanmu.AccessPoint} AccessPoint instance
         */
        AccessPoint.create = function create(properties) {
            return new AccessPoint(properties);
        };

        /**
         * Encodes the specified AccessPoint message. Does not implicitly {@link AcFunDanmu.AccessPoint.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.AccessPoint
         * @static
         * @param {AcFunDanmu.IAccessPoint} message AccessPoint message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccessPoint.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.addressType != null && Object.hasOwnProperty.call(message, "addressType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.addressType);
            if (message.port != null && Object.hasOwnProperty.call(message, "port"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.port);
            if (message.ipV4 != null && Object.hasOwnProperty.call(message, "ipV4"))
                writer.uint32(/* id 3, wireType 5 =*/29).fixed32(message.ipV4);
            if (message.ipV6 != null && Object.hasOwnProperty.call(message, "ipV6"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.ipV6);
            if (message.domain != null && Object.hasOwnProperty.call(message, "domain"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.domain);
            return writer;
        };

        /**
         * Encodes the specified AccessPoint message, length delimited. Does not implicitly {@link AcFunDanmu.AccessPoint.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.AccessPoint
         * @static
         * @param {AcFunDanmu.IAccessPoint} message AccessPoint message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccessPoint.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccessPoint message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.AccessPoint
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.AccessPoint} AccessPoint
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccessPoint.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.AccessPoint();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.addressType = reader.int32();
                    break;
                case 2:
                    message.port = reader.uint32();
                    break;
                case 3:
                    message.ipV4 = reader.fixed32();
                    break;
                case 4:
                    message.ipV6 = reader.bytes();
                    break;
                case 5:
                    message.domain = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AccessPoint message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.AccessPoint
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.AccessPoint} AccessPoint
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccessPoint.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AccessPoint message.
         * @function verify
         * @memberof AcFunDanmu.AccessPoint
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AccessPoint.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.addressType != null && message.hasOwnProperty("addressType"))
                switch (message.addressType) {
                default:
                    return "addressType: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.port != null && message.hasOwnProperty("port"))
                if (!$util.isInteger(message.port))
                    return "port: integer expected";
            if (message.ipV4 != null && message.hasOwnProperty("ipV4"))
                if (!$util.isInteger(message.ipV4))
                    return "ipV4: integer expected";
            if (message.ipV6 != null && message.hasOwnProperty("ipV6"))
                if (!(message.ipV6 && typeof message.ipV6.length === "number" || $util.isString(message.ipV6)))
                    return "ipV6: buffer expected";
            if (message.domain != null && message.hasOwnProperty("domain"))
                if (!$util.isString(message.domain))
                    return "domain: string expected";
            return null;
        };

        /**
         * Creates an AccessPoint message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.AccessPoint
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.AccessPoint} AccessPoint
         */
        AccessPoint.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.AccessPoint)
                return object;
            let message = new $root.AcFunDanmu.AccessPoint();
            switch (object.addressType) {
            case "kIPV4":
            case 0:
                message.addressType = 0;
                break;
            case "kIPV6":
            case 1:
                message.addressType = 1;
                break;
            case "kDomain":
            case 2:
                message.addressType = 2;
                break;
            }
            if (object.port != null)
                message.port = object.port >>> 0;
            if (object.ipV4 != null)
                message.ipV4 = object.ipV4 >>> 0;
            if (object.ipV6 != null)
                if (typeof object.ipV6 === "string")
                    $util.base64.decode(object.ipV6, message.ipV6 = $util.newBuffer($util.base64.length(object.ipV6)), 0);
                else if (object.ipV6.length)
                    message.ipV6 = object.ipV6;
            if (object.domain != null)
                message.domain = String(object.domain);
            return message;
        };

        /**
         * Creates a plain object from an AccessPoint message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.AccessPoint
         * @static
         * @param {AcFunDanmu.AccessPoint} message AccessPoint
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccessPoint.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.addressType = options.enums === String ? "kIPV4" : 0;
                object.port = 0;
                object.ipV4 = 0;
                if (options.bytes === String)
                    object.ipV6 = "";
                else {
                    object.ipV6 = [];
                    if (options.bytes !== Array)
                        object.ipV6 = $util.newBuffer(object.ipV6);
                }
                object.domain = "";
            }
            if (message.addressType != null && message.hasOwnProperty("addressType"))
                object.addressType = options.enums === String ? $root.AcFunDanmu.AccessPoint.AddressType[message.addressType] : message.addressType;
            if (message.port != null && message.hasOwnProperty("port"))
                object.port = message.port;
            if (message.ipV4 != null && message.hasOwnProperty("ipV4"))
                object.ipV4 = message.ipV4;
            if (message.ipV6 != null && message.hasOwnProperty("ipV6"))
                object.ipV6 = options.bytes === String ? $util.base64.encode(message.ipV6, 0, message.ipV6.length) : options.bytes === Array ? Array.prototype.slice.call(message.ipV6) : message.ipV6;
            if (message.domain != null && message.hasOwnProperty("domain"))
                object.domain = message.domain;
            return object;
        };

        /**
         * Converts this AccessPoint to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.AccessPoint
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccessPoint.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * AddressType enum.
         * @name AcFunDanmu.AccessPoint.AddressType
         * @enum {number}
         * @property {number} kIPV4=0 kIPV4 value
         * @property {number} kIPV6=1 kIPV6 value
         * @property {number} kDomain=2 kDomain value
         */
        AccessPoint.AddressType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "kIPV4"] = 0;
            values[valuesById[1] = "kIPV6"] = 1;
            values[valuesById[2] = "kDomain"] = 2;
            return values;
        })();

        return AccessPoint;
    })();

    AcFunDanmu.AccessPointsConfig = (function() {

        /**
         * Properties of an AccessPointsConfig.
         * @memberof AcFunDanmu
         * @interface IAccessPointsConfig
         * @property {Array.<AcFunDanmu.IAccessPoint>|null} [optimalAps] AccessPointsConfig optimalAps
         * @property {Array.<AcFunDanmu.IAccessPoint>|null} [backupAps] AccessPointsConfig backupAps
         * @property {Array.<number>|null} [availablePorts] AccessPointsConfig availablePorts
         * @property {AcFunDanmu.IAccessPoint|null} [foreceLastConnectedAp] AccessPointsConfig foreceLastConnectedAp
         */

        /**
         * Constructs a new AccessPointsConfig.
         * @memberof AcFunDanmu
         * @classdesc Represents an AccessPointsConfig.
         * @implements IAccessPointsConfig
         * @constructor
         * @param {AcFunDanmu.IAccessPointsConfig=} [properties] Properties to set
         */
        function AccessPointsConfig(properties) {
            this.optimalAps = [];
            this.backupAps = [];
            this.availablePorts = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccessPointsConfig optimalAps.
         * @member {Array.<AcFunDanmu.IAccessPoint>} optimalAps
         * @memberof AcFunDanmu.AccessPointsConfig
         * @instance
         */
        AccessPointsConfig.prototype.optimalAps = $util.emptyArray;

        /**
         * AccessPointsConfig backupAps.
         * @member {Array.<AcFunDanmu.IAccessPoint>} backupAps
         * @memberof AcFunDanmu.AccessPointsConfig
         * @instance
         */
        AccessPointsConfig.prototype.backupAps = $util.emptyArray;

        /**
         * AccessPointsConfig availablePorts.
         * @member {Array.<number>} availablePorts
         * @memberof AcFunDanmu.AccessPointsConfig
         * @instance
         */
        AccessPointsConfig.prototype.availablePorts = $util.emptyArray;

        /**
         * AccessPointsConfig foreceLastConnectedAp.
         * @member {AcFunDanmu.IAccessPoint|null|undefined} foreceLastConnectedAp
         * @memberof AcFunDanmu.AccessPointsConfig
         * @instance
         */
        AccessPointsConfig.prototype.foreceLastConnectedAp = null;

        /**
         * Creates a new AccessPointsConfig instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.AccessPointsConfig
         * @static
         * @param {AcFunDanmu.IAccessPointsConfig=} [properties] Properties to set
         * @returns {AcFunDanmu.AccessPointsConfig} AccessPointsConfig instance
         */
        AccessPointsConfig.create = function create(properties) {
            return new AccessPointsConfig(properties);
        };

        /**
         * Encodes the specified AccessPointsConfig message. Does not implicitly {@link AcFunDanmu.AccessPointsConfig.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.AccessPointsConfig
         * @static
         * @param {AcFunDanmu.IAccessPointsConfig} message AccessPointsConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccessPointsConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.optimalAps != null && message.optimalAps.length)
                for (let i = 0; i < message.optimalAps.length; ++i)
                    $root.AcFunDanmu.AccessPoint.encode(message.optimalAps[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.backupAps != null && message.backupAps.length)
                for (let i = 0; i < message.backupAps.length; ++i)
                    $root.AcFunDanmu.AccessPoint.encode(message.backupAps[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.availablePorts != null && message.availablePorts.length) {
                writer.uint32(/* id 3, wireType 2 =*/26).fork();
                for (let i = 0; i < message.availablePorts.length; ++i)
                    writer.uint32(message.availablePorts[i]);
                writer.ldelim();
            }
            if (message.foreceLastConnectedAp != null && Object.hasOwnProperty.call(message, "foreceLastConnectedAp"))
                $root.AcFunDanmu.AccessPoint.encode(message.foreceLastConnectedAp, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified AccessPointsConfig message, length delimited. Does not implicitly {@link AcFunDanmu.AccessPointsConfig.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.AccessPointsConfig
         * @static
         * @param {AcFunDanmu.IAccessPointsConfig} message AccessPointsConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccessPointsConfig.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccessPointsConfig message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.AccessPointsConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.AccessPointsConfig} AccessPointsConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccessPointsConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.AccessPointsConfig();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.optimalAps && message.optimalAps.length))
                        message.optimalAps = [];
                    message.optimalAps.push($root.AcFunDanmu.AccessPoint.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.backupAps && message.backupAps.length))
                        message.backupAps = [];
                    message.backupAps.push($root.AcFunDanmu.AccessPoint.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.availablePorts && message.availablePorts.length))
                        message.availablePorts = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.availablePorts.push(reader.uint32());
                    } else
                        message.availablePorts.push(reader.uint32());
                    break;
                case 4:
                    message.foreceLastConnectedAp = $root.AcFunDanmu.AccessPoint.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AccessPointsConfig message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.AccessPointsConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.AccessPointsConfig} AccessPointsConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccessPointsConfig.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AccessPointsConfig message.
         * @function verify
         * @memberof AcFunDanmu.AccessPointsConfig
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AccessPointsConfig.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.optimalAps != null && message.hasOwnProperty("optimalAps")) {
                if (!Array.isArray(message.optimalAps))
                    return "optimalAps: array expected";
                for (let i = 0; i < message.optimalAps.length; ++i) {
                    let error = $root.AcFunDanmu.AccessPoint.verify(message.optimalAps[i]);
                    if (error)
                        return "optimalAps." + error;
                }
            }
            if (message.backupAps != null && message.hasOwnProperty("backupAps")) {
                if (!Array.isArray(message.backupAps))
                    return "backupAps: array expected";
                for (let i = 0; i < message.backupAps.length; ++i) {
                    let error = $root.AcFunDanmu.AccessPoint.verify(message.backupAps[i]);
                    if (error)
                        return "backupAps." + error;
                }
            }
            if (message.availablePorts != null && message.hasOwnProperty("availablePorts")) {
                if (!Array.isArray(message.availablePorts))
                    return "availablePorts: array expected";
                for (let i = 0; i < message.availablePorts.length; ++i)
                    if (!$util.isInteger(message.availablePorts[i]))
                        return "availablePorts: integer[] expected";
            }
            if (message.foreceLastConnectedAp != null && message.hasOwnProperty("foreceLastConnectedAp")) {
                let error = $root.AcFunDanmu.AccessPoint.verify(message.foreceLastConnectedAp);
                if (error)
                    return "foreceLastConnectedAp." + error;
            }
            return null;
        };

        /**
         * Creates an AccessPointsConfig message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.AccessPointsConfig
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.AccessPointsConfig} AccessPointsConfig
         */
        AccessPointsConfig.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.AccessPointsConfig)
                return object;
            let message = new $root.AcFunDanmu.AccessPointsConfig();
            if (object.optimalAps) {
                if (!Array.isArray(object.optimalAps))
                    throw TypeError(".AcFunDanmu.AccessPointsConfig.optimalAps: array expected");
                message.optimalAps = [];
                for (let i = 0; i < object.optimalAps.length; ++i) {
                    if (typeof object.optimalAps[i] !== "object")
                        throw TypeError(".AcFunDanmu.AccessPointsConfig.optimalAps: object expected");
                    message.optimalAps[i] = $root.AcFunDanmu.AccessPoint.fromObject(object.optimalAps[i]);
                }
            }
            if (object.backupAps) {
                if (!Array.isArray(object.backupAps))
                    throw TypeError(".AcFunDanmu.AccessPointsConfig.backupAps: array expected");
                message.backupAps = [];
                for (let i = 0; i < object.backupAps.length; ++i) {
                    if (typeof object.backupAps[i] !== "object")
                        throw TypeError(".AcFunDanmu.AccessPointsConfig.backupAps: object expected");
                    message.backupAps[i] = $root.AcFunDanmu.AccessPoint.fromObject(object.backupAps[i]);
                }
            }
            if (object.availablePorts) {
                if (!Array.isArray(object.availablePorts))
                    throw TypeError(".AcFunDanmu.AccessPointsConfig.availablePorts: array expected");
                message.availablePorts = [];
                for (let i = 0; i < object.availablePorts.length; ++i)
                    message.availablePorts[i] = object.availablePorts[i] >>> 0;
            }
            if (object.foreceLastConnectedAp != null) {
                if (typeof object.foreceLastConnectedAp !== "object")
                    throw TypeError(".AcFunDanmu.AccessPointsConfig.foreceLastConnectedAp: object expected");
                message.foreceLastConnectedAp = $root.AcFunDanmu.AccessPoint.fromObject(object.foreceLastConnectedAp);
            }
            return message;
        };

        /**
         * Creates a plain object from an AccessPointsConfig message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.AccessPointsConfig
         * @static
         * @param {AcFunDanmu.AccessPointsConfig} message AccessPointsConfig
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccessPointsConfig.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.optimalAps = [];
                object.backupAps = [];
                object.availablePorts = [];
            }
            if (options.defaults)
                object.foreceLastConnectedAp = null;
            if (message.optimalAps && message.optimalAps.length) {
                object.optimalAps = [];
                for (let j = 0; j < message.optimalAps.length; ++j)
                    object.optimalAps[j] = $root.AcFunDanmu.AccessPoint.toObject(message.optimalAps[j], options);
            }
            if (message.backupAps && message.backupAps.length) {
                object.backupAps = [];
                for (let j = 0; j < message.backupAps.length; ++j)
                    object.backupAps[j] = $root.AcFunDanmu.AccessPoint.toObject(message.backupAps[j], options);
            }
            if (message.availablePorts && message.availablePorts.length) {
                object.availablePorts = [];
                for (let j = 0; j < message.availablePorts.length; ++j)
                    object.availablePorts[j] = message.availablePorts[j];
            }
            if (message.foreceLastConnectedAp != null && message.hasOwnProperty("foreceLastConnectedAp"))
                object.foreceLastConnectedAp = $root.AcFunDanmu.AccessPoint.toObject(message.foreceLastConnectedAp, options);
            return object;
        };

        /**
         * Converts this AccessPointsConfig to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.AccessPointsConfig
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccessPointsConfig.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AccessPointsConfig;
    })();

    AcFunDanmu.AcFunUserInfo = (function() {

        /**
         * Properties of an AcFunUserInfo.
         * @memberof AcFunDanmu
         * @interface IAcFunUserInfo
         * @property {number|Long|null} [userId] AcFunUserInfo userId
         * @property {string|null} [name] AcFunUserInfo name
         */

        /**
         * Constructs a new AcFunUserInfo.
         * @memberof AcFunDanmu
         * @classdesc Represents an AcFunUserInfo.
         * @implements IAcFunUserInfo
         * @constructor
         * @param {AcFunDanmu.IAcFunUserInfo=} [properties] Properties to set
         */
        function AcFunUserInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AcFunUserInfo userId.
         * @member {number|Long} userId
         * @memberof AcFunDanmu.AcFunUserInfo
         * @instance
         */
        AcFunUserInfo.prototype.userId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AcFunUserInfo name.
         * @member {string} name
         * @memberof AcFunDanmu.AcFunUserInfo
         * @instance
         */
        AcFunUserInfo.prototype.name = "";

        /**
         * Creates a new AcFunUserInfo instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.AcFunUserInfo
         * @static
         * @param {AcFunDanmu.IAcFunUserInfo=} [properties] Properties to set
         * @returns {AcFunDanmu.AcFunUserInfo} AcFunUserInfo instance
         */
        AcFunUserInfo.create = function create(properties) {
            return new AcFunUserInfo(properties);
        };

        /**
         * Encodes the specified AcFunUserInfo message. Does not implicitly {@link AcFunDanmu.AcFunUserInfo.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.AcFunUserInfo
         * @static
         * @param {AcFunDanmu.IAcFunUserInfo} message AcFunUserInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AcFunUserInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.userId);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            return writer;
        };

        /**
         * Encodes the specified AcFunUserInfo message, length delimited. Does not implicitly {@link AcFunDanmu.AcFunUserInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.AcFunUserInfo
         * @static
         * @param {AcFunDanmu.IAcFunUserInfo} message AcFunUserInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AcFunUserInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AcFunUserInfo message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.AcFunUserInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.AcFunUserInfo} AcFunUserInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AcFunUserInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.AcFunUserInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userId = reader.int64();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AcFunUserInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.AcFunUserInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.AcFunUserInfo} AcFunUserInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AcFunUserInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AcFunUserInfo message.
         * @function verify
         * @memberof AcFunDanmu.AcFunUserInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AcFunUserInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isInteger(message.userId) && !(message.userId && $util.isInteger(message.userId.low) && $util.isInteger(message.userId.high)))
                    return "userId: integer|Long expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            return null;
        };

        /**
         * Creates an AcFunUserInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.AcFunUserInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.AcFunUserInfo} AcFunUserInfo
         */
        AcFunUserInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.AcFunUserInfo)
                return object;
            let message = new $root.AcFunDanmu.AcFunUserInfo();
            if (object.userId != null)
                if ($util.Long)
                    (message.userId = $util.Long.fromValue(object.userId)).unsigned = false;
                else if (typeof object.userId === "string")
                    message.userId = parseInt(object.userId, 10);
                else if (typeof object.userId === "number")
                    message.userId = object.userId;
                else if (typeof object.userId === "object")
                    message.userId = new $util.LongBits(object.userId.low >>> 0, object.userId.high >>> 0).toNumber();
            if (object.name != null)
                message.name = String(object.name);
            return message;
        };

        /**
         * Creates a plain object from an AcFunUserInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.AcFunUserInfo
         * @static
         * @param {AcFunDanmu.AcFunUserInfo} message AcFunUserInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AcFunUserInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.userId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.userId = options.longs === String ? "0" : 0;
                object.name = "";
            }
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (typeof message.userId === "number")
                    object.userId = options.longs === String ? String(message.userId) : message.userId;
                else
                    object.userId = options.longs === String ? $util.Long.prototype.toString.call(message.userId) : options.longs === Number ? new $util.LongBits(message.userId.low >>> 0, message.userId.high >>> 0).toNumber() : message.userId;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            return object;
        };

        /**
         * Converts this AcFunUserInfo to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.AcFunUserInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AcFunUserInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AcFunUserInfo;
    })();

    AcFunDanmu.AcfunActionSignalThrowBanana = (function() {

        /**
         * Properties of an AcfunActionSignalThrowBanana.
         * @memberof AcFunDanmu
         * @interface IAcfunActionSignalThrowBanana
         * @property {AcFunDanmu.IAcFunUserInfo|null} [visitor] AcfunActionSignalThrowBanana visitor
         * @property {number|null} [count] AcfunActionSignalThrowBanana count
         * @property {number|Long|null} [sendTimeMs] AcfunActionSignalThrowBanana sendTimeMs
         */

        /**
         * Constructs a new AcfunActionSignalThrowBanana.
         * @memberof AcFunDanmu
         * @classdesc Represents an AcfunActionSignalThrowBanana.
         * @implements IAcfunActionSignalThrowBanana
         * @constructor
         * @param {AcFunDanmu.IAcfunActionSignalThrowBanana=} [properties] Properties to set
         */
        function AcfunActionSignalThrowBanana(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AcfunActionSignalThrowBanana visitor.
         * @member {AcFunDanmu.IAcFunUserInfo|null|undefined} visitor
         * @memberof AcFunDanmu.AcfunActionSignalThrowBanana
         * @instance
         */
        AcfunActionSignalThrowBanana.prototype.visitor = null;

        /**
         * AcfunActionSignalThrowBanana count.
         * @member {number} count
         * @memberof AcFunDanmu.AcfunActionSignalThrowBanana
         * @instance
         */
        AcfunActionSignalThrowBanana.prototype.count = 0;

        /**
         * AcfunActionSignalThrowBanana sendTimeMs.
         * @member {number|Long} sendTimeMs
         * @memberof AcFunDanmu.AcfunActionSignalThrowBanana
         * @instance
         */
        AcfunActionSignalThrowBanana.prototype.sendTimeMs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new AcfunActionSignalThrowBanana instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.AcfunActionSignalThrowBanana
         * @static
         * @param {AcFunDanmu.IAcfunActionSignalThrowBanana=} [properties] Properties to set
         * @returns {AcFunDanmu.AcfunActionSignalThrowBanana} AcfunActionSignalThrowBanana instance
         */
        AcfunActionSignalThrowBanana.create = function create(properties) {
            return new AcfunActionSignalThrowBanana(properties);
        };

        /**
         * Encodes the specified AcfunActionSignalThrowBanana message. Does not implicitly {@link AcFunDanmu.AcfunActionSignalThrowBanana.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.AcfunActionSignalThrowBanana
         * @static
         * @param {AcFunDanmu.IAcfunActionSignalThrowBanana} message AcfunActionSignalThrowBanana message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AcfunActionSignalThrowBanana.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.visitor != null && Object.hasOwnProperty.call(message, "visitor"))
                $root.AcFunDanmu.AcFunUserInfo.encode(message.visitor, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.count);
            if (message.sendTimeMs != null && Object.hasOwnProperty.call(message, "sendTimeMs"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.sendTimeMs);
            return writer;
        };

        /**
         * Encodes the specified AcfunActionSignalThrowBanana message, length delimited. Does not implicitly {@link AcFunDanmu.AcfunActionSignalThrowBanana.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.AcfunActionSignalThrowBanana
         * @static
         * @param {AcFunDanmu.IAcfunActionSignalThrowBanana} message AcfunActionSignalThrowBanana message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AcfunActionSignalThrowBanana.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AcfunActionSignalThrowBanana message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.AcfunActionSignalThrowBanana
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.AcfunActionSignalThrowBanana} AcfunActionSignalThrowBanana
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AcfunActionSignalThrowBanana.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.AcfunActionSignalThrowBanana();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.visitor = $root.AcFunDanmu.AcFunUserInfo.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.count = reader.int32();
                    break;
                case 3:
                    message.sendTimeMs = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AcfunActionSignalThrowBanana message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.AcfunActionSignalThrowBanana
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.AcfunActionSignalThrowBanana} AcfunActionSignalThrowBanana
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AcfunActionSignalThrowBanana.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AcfunActionSignalThrowBanana message.
         * @function verify
         * @memberof AcFunDanmu.AcfunActionSignalThrowBanana
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AcfunActionSignalThrowBanana.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.visitor != null && message.hasOwnProperty("visitor")) {
                let error = $root.AcFunDanmu.AcFunUserInfo.verify(message.visitor);
                if (error)
                    return "visitor." + error;
            }
            if (message.count != null && message.hasOwnProperty("count"))
                if (!$util.isInteger(message.count))
                    return "count: integer expected";
            if (message.sendTimeMs != null && message.hasOwnProperty("sendTimeMs"))
                if (!$util.isInteger(message.sendTimeMs) && !(message.sendTimeMs && $util.isInteger(message.sendTimeMs.low) && $util.isInteger(message.sendTimeMs.high)))
                    return "sendTimeMs: integer|Long expected";
            return null;
        };

        /**
         * Creates an AcfunActionSignalThrowBanana message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.AcfunActionSignalThrowBanana
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.AcfunActionSignalThrowBanana} AcfunActionSignalThrowBanana
         */
        AcfunActionSignalThrowBanana.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.AcfunActionSignalThrowBanana)
                return object;
            let message = new $root.AcFunDanmu.AcfunActionSignalThrowBanana();
            if (object.visitor != null) {
                if (typeof object.visitor !== "object")
                    throw TypeError(".AcFunDanmu.AcfunActionSignalThrowBanana.visitor: object expected");
                message.visitor = $root.AcFunDanmu.AcFunUserInfo.fromObject(object.visitor);
            }
            if (object.count != null)
                message.count = object.count | 0;
            if (object.sendTimeMs != null)
                if ($util.Long)
                    (message.sendTimeMs = $util.Long.fromValue(object.sendTimeMs)).unsigned = false;
                else if (typeof object.sendTimeMs === "string")
                    message.sendTimeMs = parseInt(object.sendTimeMs, 10);
                else if (typeof object.sendTimeMs === "number")
                    message.sendTimeMs = object.sendTimeMs;
                else if (typeof object.sendTimeMs === "object")
                    message.sendTimeMs = new $util.LongBits(object.sendTimeMs.low >>> 0, object.sendTimeMs.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an AcfunActionSignalThrowBanana message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.AcfunActionSignalThrowBanana
         * @static
         * @param {AcFunDanmu.AcfunActionSignalThrowBanana} message AcfunActionSignalThrowBanana
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AcfunActionSignalThrowBanana.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.visitor = null;
                object.count = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.sendTimeMs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.sendTimeMs = options.longs === String ? "0" : 0;
            }
            if (message.visitor != null && message.hasOwnProperty("visitor"))
                object.visitor = $root.AcFunDanmu.AcFunUserInfo.toObject(message.visitor, options);
            if (message.count != null && message.hasOwnProperty("count"))
                object.count = message.count;
            if (message.sendTimeMs != null && message.hasOwnProperty("sendTimeMs"))
                if (typeof message.sendTimeMs === "number")
                    object.sendTimeMs = options.longs === String ? String(message.sendTimeMs) : message.sendTimeMs;
                else
                    object.sendTimeMs = options.longs === String ? $util.Long.prototype.toString.call(message.sendTimeMs) : options.longs === Number ? new $util.LongBits(message.sendTimeMs.low >>> 0, message.sendTimeMs.high >>> 0).toNumber() : message.sendTimeMs;
            return object;
        };

        /**
         * Converts this AcfunActionSignalThrowBanana to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.AcfunActionSignalThrowBanana
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AcfunActionSignalThrowBanana.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AcfunActionSignalThrowBanana;
    })();

    AcFunDanmu.AcfunStateSignalDisplayInfo = (function() {

        /**
         * Properties of an AcfunStateSignalDisplayInfo.
         * @memberof AcFunDanmu
         * @interface IAcfunStateSignalDisplayInfo
         * @property {string|null} [bananaCount] AcfunStateSignalDisplayInfo bananaCount
         */

        /**
         * Constructs a new AcfunStateSignalDisplayInfo.
         * @memberof AcFunDanmu
         * @classdesc Represents an AcfunStateSignalDisplayInfo.
         * @implements IAcfunStateSignalDisplayInfo
         * @constructor
         * @param {AcFunDanmu.IAcfunStateSignalDisplayInfo=} [properties] Properties to set
         */
        function AcfunStateSignalDisplayInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AcfunStateSignalDisplayInfo bananaCount.
         * @member {string} bananaCount
         * @memberof AcFunDanmu.AcfunStateSignalDisplayInfo
         * @instance
         */
        AcfunStateSignalDisplayInfo.prototype.bananaCount = "";

        /**
         * Creates a new AcfunStateSignalDisplayInfo instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.AcfunStateSignalDisplayInfo
         * @static
         * @param {AcFunDanmu.IAcfunStateSignalDisplayInfo=} [properties] Properties to set
         * @returns {AcFunDanmu.AcfunStateSignalDisplayInfo} AcfunStateSignalDisplayInfo instance
         */
        AcfunStateSignalDisplayInfo.create = function create(properties) {
            return new AcfunStateSignalDisplayInfo(properties);
        };

        /**
         * Encodes the specified AcfunStateSignalDisplayInfo message. Does not implicitly {@link AcFunDanmu.AcfunStateSignalDisplayInfo.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.AcfunStateSignalDisplayInfo
         * @static
         * @param {AcFunDanmu.IAcfunStateSignalDisplayInfo} message AcfunStateSignalDisplayInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AcfunStateSignalDisplayInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bananaCount != null && Object.hasOwnProperty.call(message, "bananaCount"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.bananaCount);
            return writer;
        };

        /**
         * Encodes the specified AcfunStateSignalDisplayInfo message, length delimited. Does not implicitly {@link AcFunDanmu.AcfunStateSignalDisplayInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.AcfunStateSignalDisplayInfo
         * @static
         * @param {AcFunDanmu.IAcfunStateSignalDisplayInfo} message AcfunStateSignalDisplayInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AcfunStateSignalDisplayInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AcfunStateSignalDisplayInfo message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.AcfunStateSignalDisplayInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.AcfunStateSignalDisplayInfo} AcfunStateSignalDisplayInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AcfunStateSignalDisplayInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.AcfunStateSignalDisplayInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.bananaCount = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AcfunStateSignalDisplayInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.AcfunStateSignalDisplayInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.AcfunStateSignalDisplayInfo} AcfunStateSignalDisplayInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AcfunStateSignalDisplayInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AcfunStateSignalDisplayInfo message.
         * @function verify
         * @memberof AcFunDanmu.AcfunStateSignalDisplayInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AcfunStateSignalDisplayInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.bananaCount != null && message.hasOwnProperty("bananaCount"))
                if (!$util.isString(message.bananaCount))
                    return "bananaCount: string expected";
            return null;
        };

        /**
         * Creates an AcfunStateSignalDisplayInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.AcfunStateSignalDisplayInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.AcfunStateSignalDisplayInfo} AcfunStateSignalDisplayInfo
         */
        AcfunStateSignalDisplayInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.AcfunStateSignalDisplayInfo)
                return object;
            let message = new $root.AcFunDanmu.AcfunStateSignalDisplayInfo();
            if (object.bananaCount != null)
                message.bananaCount = String(object.bananaCount);
            return message;
        };

        /**
         * Creates a plain object from an AcfunStateSignalDisplayInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.AcfunStateSignalDisplayInfo
         * @static
         * @param {AcFunDanmu.AcfunStateSignalDisplayInfo} message AcfunStateSignalDisplayInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AcfunStateSignalDisplayInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.bananaCount = "";
            if (message.bananaCount != null && message.hasOwnProperty("bananaCount"))
                object.bananaCount = message.bananaCount;
            return object;
        };

        /**
         * Converts this AcfunStateSignalDisplayInfo to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.AcfunStateSignalDisplayInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AcfunStateSignalDisplayInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AcfunStateSignalDisplayInfo;
    })();

    AcFunDanmu.AppInfo = (function() {

        /**
         * Properties of an AppInfo.
         * @memberof AcFunDanmu
         * @interface IAppInfo
         * @property {string|null} [appName] AppInfo appName
         * @property {string|null} [appVersion] AppInfo appVersion
         * @property {string|null} [appChannel] AppInfo appChannel
         * @property {string|null} [sdkVersion] AppInfo sdkVersion
         * @property {string|null} [extensionInfo] AppInfo extensionInfo
         */

        /**
         * Constructs a new AppInfo.
         * @memberof AcFunDanmu
         * @classdesc Represents an AppInfo.
         * @implements IAppInfo
         * @constructor
         * @param {AcFunDanmu.IAppInfo=} [properties] Properties to set
         */
        function AppInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AppInfo appName.
         * @member {string} appName
         * @memberof AcFunDanmu.AppInfo
         * @instance
         */
        AppInfo.prototype.appName = "";

        /**
         * AppInfo appVersion.
         * @member {string} appVersion
         * @memberof AcFunDanmu.AppInfo
         * @instance
         */
        AppInfo.prototype.appVersion = "";

        /**
         * AppInfo appChannel.
         * @member {string} appChannel
         * @memberof AcFunDanmu.AppInfo
         * @instance
         */
        AppInfo.prototype.appChannel = "";

        /**
         * AppInfo sdkVersion.
         * @member {string} sdkVersion
         * @memberof AcFunDanmu.AppInfo
         * @instance
         */
        AppInfo.prototype.sdkVersion = "";

        /**
         * AppInfo extensionInfo.
         * @member {string} extensionInfo
         * @memberof AcFunDanmu.AppInfo
         * @instance
         */
        AppInfo.prototype.extensionInfo = "";

        /**
         * Creates a new AppInfo instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.AppInfo
         * @static
         * @param {AcFunDanmu.IAppInfo=} [properties] Properties to set
         * @returns {AcFunDanmu.AppInfo} AppInfo instance
         */
        AppInfo.create = function create(properties) {
            return new AppInfo(properties);
        };

        /**
         * Encodes the specified AppInfo message. Does not implicitly {@link AcFunDanmu.AppInfo.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.AppInfo
         * @static
         * @param {AcFunDanmu.IAppInfo} message AppInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AppInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.appName != null && Object.hasOwnProperty.call(message, "appName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.appName);
            if (message.appVersion != null && Object.hasOwnProperty.call(message, "appVersion"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.appVersion);
            if (message.appChannel != null && Object.hasOwnProperty.call(message, "appChannel"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.appChannel);
            if (message.sdkVersion != null && Object.hasOwnProperty.call(message, "sdkVersion"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.sdkVersion);
            if (message.extensionInfo != null && Object.hasOwnProperty.call(message, "extensionInfo"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.extensionInfo);
            return writer;
        };

        /**
         * Encodes the specified AppInfo message, length delimited. Does not implicitly {@link AcFunDanmu.AppInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.AppInfo
         * @static
         * @param {AcFunDanmu.IAppInfo} message AppInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AppInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AppInfo message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.AppInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.AppInfo} AppInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AppInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.AppInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.appName = reader.string();
                    break;
                case 2:
                    message.appVersion = reader.string();
                    break;
                case 3:
                    message.appChannel = reader.string();
                    break;
                case 4:
                    message.sdkVersion = reader.string();
                    break;
                case 11:
                    message.extensionInfo = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AppInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.AppInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.AppInfo} AppInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AppInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AppInfo message.
         * @function verify
         * @memberof AcFunDanmu.AppInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AppInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.appName != null && message.hasOwnProperty("appName"))
                if (!$util.isString(message.appName))
                    return "appName: string expected";
            if (message.appVersion != null && message.hasOwnProperty("appVersion"))
                if (!$util.isString(message.appVersion))
                    return "appVersion: string expected";
            if (message.appChannel != null && message.hasOwnProperty("appChannel"))
                if (!$util.isString(message.appChannel))
                    return "appChannel: string expected";
            if (message.sdkVersion != null && message.hasOwnProperty("sdkVersion"))
                if (!$util.isString(message.sdkVersion))
                    return "sdkVersion: string expected";
            if (message.extensionInfo != null && message.hasOwnProperty("extensionInfo"))
                if (!$util.isString(message.extensionInfo))
                    return "extensionInfo: string expected";
            return null;
        };

        /**
         * Creates an AppInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.AppInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.AppInfo} AppInfo
         */
        AppInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.AppInfo)
                return object;
            let message = new $root.AcFunDanmu.AppInfo();
            if (object.appName != null)
                message.appName = String(object.appName);
            if (object.appVersion != null)
                message.appVersion = String(object.appVersion);
            if (object.appChannel != null)
                message.appChannel = String(object.appChannel);
            if (object.sdkVersion != null)
                message.sdkVersion = String(object.sdkVersion);
            if (object.extensionInfo != null)
                message.extensionInfo = String(object.extensionInfo);
            return message;
        };

        /**
         * Creates a plain object from an AppInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.AppInfo
         * @static
         * @param {AcFunDanmu.AppInfo} message AppInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AppInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.appName = "";
                object.appVersion = "";
                object.appChannel = "";
                object.sdkVersion = "";
                object.extensionInfo = "";
            }
            if (message.appName != null && message.hasOwnProperty("appName"))
                object.appName = message.appName;
            if (message.appVersion != null && message.hasOwnProperty("appVersion"))
                object.appVersion = message.appVersion;
            if (message.appChannel != null && message.hasOwnProperty("appChannel"))
                object.appChannel = message.appChannel;
            if (message.sdkVersion != null && message.hasOwnProperty("sdkVersion"))
                object.sdkVersion = message.sdkVersion;
            if (message.extensionInfo != null && message.hasOwnProperty("extensionInfo"))
                object.extensionInfo = message.extensionInfo;
            return object;
        };

        /**
         * Converts this AppInfo to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.AppInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AppInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AppInfo;
    })();

    AcFunDanmu.DeviceInfo = (function() {

        /**
         * Properties of a DeviceInfo.
         * @memberof AcFunDanmu
         * @interface IDeviceInfo
         * @property {AcFunDanmu.DeviceInfo.PlatformType|null} [platformType] DeviceInfo platformType
         * @property {string|null} [osVersion] DeviceInfo osVersion
         * @property {string|null} [deviceModel] DeviceInfo deviceModel
         * @property {Uint8Array|null} [imeiMd5] DeviceInfo imeiMd5
         * @property {string|null} [deviceId] DeviceInfo deviceId
         * @property {string|null} [softDid] DeviceInfo softDid
         * @property {string|null} [kwaiDid] DeviceInfo kwaiDid
         * @property {string|null} [manufacturer] DeviceInfo manufacturer
         * @property {string|null} [deviceName] DeviceInfo deviceName
         */

        /**
         * Constructs a new DeviceInfo.
         * @memberof AcFunDanmu
         * @classdesc Represents a DeviceInfo.
         * @implements IDeviceInfo
         * @constructor
         * @param {AcFunDanmu.IDeviceInfo=} [properties] Properties to set
         */
        function DeviceInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeviceInfo platformType.
         * @member {AcFunDanmu.DeviceInfo.PlatformType} platformType
         * @memberof AcFunDanmu.DeviceInfo
         * @instance
         */
        DeviceInfo.prototype.platformType = 0;

        /**
         * DeviceInfo osVersion.
         * @member {string} osVersion
         * @memberof AcFunDanmu.DeviceInfo
         * @instance
         */
        DeviceInfo.prototype.osVersion = "";

        /**
         * DeviceInfo deviceModel.
         * @member {string} deviceModel
         * @memberof AcFunDanmu.DeviceInfo
         * @instance
         */
        DeviceInfo.prototype.deviceModel = "";

        /**
         * DeviceInfo imeiMd5.
         * @member {Uint8Array} imeiMd5
         * @memberof AcFunDanmu.DeviceInfo
         * @instance
         */
        DeviceInfo.prototype.imeiMd5 = $util.newBuffer([]);

        /**
         * DeviceInfo deviceId.
         * @member {string} deviceId
         * @memberof AcFunDanmu.DeviceInfo
         * @instance
         */
        DeviceInfo.prototype.deviceId = "";

        /**
         * DeviceInfo softDid.
         * @member {string} softDid
         * @memberof AcFunDanmu.DeviceInfo
         * @instance
         */
        DeviceInfo.prototype.softDid = "";

        /**
         * DeviceInfo kwaiDid.
         * @member {string} kwaiDid
         * @memberof AcFunDanmu.DeviceInfo
         * @instance
         */
        DeviceInfo.prototype.kwaiDid = "";

        /**
         * DeviceInfo manufacturer.
         * @member {string} manufacturer
         * @memberof AcFunDanmu.DeviceInfo
         * @instance
         */
        DeviceInfo.prototype.manufacturer = "";

        /**
         * DeviceInfo deviceName.
         * @member {string} deviceName
         * @memberof AcFunDanmu.DeviceInfo
         * @instance
         */
        DeviceInfo.prototype.deviceName = "";

        /**
         * Creates a new DeviceInfo instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.DeviceInfo
         * @static
         * @param {AcFunDanmu.IDeviceInfo=} [properties] Properties to set
         * @returns {AcFunDanmu.DeviceInfo} DeviceInfo instance
         */
        DeviceInfo.create = function create(properties) {
            return new DeviceInfo(properties);
        };

        /**
         * Encodes the specified DeviceInfo message. Does not implicitly {@link AcFunDanmu.DeviceInfo.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.DeviceInfo
         * @static
         * @param {AcFunDanmu.IDeviceInfo} message DeviceInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.platformType != null && Object.hasOwnProperty.call(message, "platformType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.platformType);
            if (message.osVersion != null && Object.hasOwnProperty.call(message, "osVersion"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.osVersion);
            if (message.deviceModel != null && Object.hasOwnProperty.call(message, "deviceModel"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.deviceModel);
            if (message.imeiMd5 != null && Object.hasOwnProperty.call(message, "imeiMd5"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.imeiMd5);
            if (message.deviceId != null && Object.hasOwnProperty.call(message, "deviceId"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.deviceId);
            if (message.softDid != null && Object.hasOwnProperty.call(message, "softDid"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.softDid);
            if (message.kwaiDid != null && Object.hasOwnProperty.call(message, "kwaiDid"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.kwaiDid);
            if (message.manufacturer != null && Object.hasOwnProperty.call(message, "manufacturer"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.manufacturer);
            if (message.deviceName != null && Object.hasOwnProperty.call(message, "deviceName"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.deviceName);
            return writer;
        };

        /**
         * Encodes the specified DeviceInfo message, length delimited. Does not implicitly {@link AcFunDanmu.DeviceInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.DeviceInfo
         * @static
         * @param {AcFunDanmu.IDeviceInfo} message DeviceInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeviceInfo message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.DeviceInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.DeviceInfo} DeviceInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.DeviceInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.platformType = reader.int32();
                    break;
                case 2:
                    message.osVersion = reader.string();
                    break;
                case 3:
                    message.deviceModel = reader.string();
                    break;
                case 4:
                    message.imeiMd5 = reader.bytes();
                    break;
                case 5:
                    message.deviceId = reader.string();
                    break;
                case 6:
                    message.softDid = reader.string();
                    break;
                case 7:
                    message.kwaiDid = reader.string();
                    break;
                case 8:
                    message.manufacturer = reader.string();
                    break;
                case 9:
                    message.deviceName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeviceInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.DeviceInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.DeviceInfo} DeviceInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeviceInfo message.
         * @function verify
         * @memberof AcFunDanmu.DeviceInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeviceInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.platformType != null && message.hasOwnProperty("platformType"))
                switch (message.platformType) {
                default:
                    return "platformType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                    break;
                }
            if (message.osVersion != null && message.hasOwnProperty("osVersion"))
                if (!$util.isString(message.osVersion))
                    return "osVersion: string expected";
            if (message.deviceModel != null && message.hasOwnProperty("deviceModel"))
                if (!$util.isString(message.deviceModel))
                    return "deviceModel: string expected";
            if (message.imeiMd5 != null && message.hasOwnProperty("imeiMd5"))
                if (!(message.imeiMd5 && typeof message.imeiMd5.length === "number" || $util.isString(message.imeiMd5)))
                    return "imeiMd5: buffer expected";
            if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                if (!$util.isString(message.deviceId))
                    return "deviceId: string expected";
            if (message.softDid != null && message.hasOwnProperty("softDid"))
                if (!$util.isString(message.softDid))
                    return "softDid: string expected";
            if (message.kwaiDid != null && message.hasOwnProperty("kwaiDid"))
                if (!$util.isString(message.kwaiDid))
                    return "kwaiDid: string expected";
            if (message.manufacturer != null && message.hasOwnProperty("manufacturer"))
                if (!$util.isString(message.manufacturer))
                    return "manufacturer: string expected";
            if (message.deviceName != null && message.hasOwnProperty("deviceName"))
                if (!$util.isString(message.deviceName))
                    return "deviceName: string expected";
            return null;
        };

        /**
         * Creates a DeviceInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.DeviceInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.DeviceInfo} DeviceInfo
         */
        DeviceInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.DeviceInfo)
                return object;
            let message = new $root.AcFunDanmu.DeviceInfo();
            switch (object.platformType) {
            case "kInvalid":
            case 0:
                message.platformType = 0;
                break;
            case "kAndroid":
            case 1:
                message.platformType = 1;
                break;
            case "kiOS":
            case 2:
                message.platformType = 2;
                break;
            case "kWindows":
            case 3:
                message.platformType = 3;
                break;
            case "WECHAT_ANDROID":
            case 4:
                message.platformType = 4;
                break;
            case "WECHAT_IOS":
            case 5:
                message.platformType = 5;
                break;
            case "H5":
            case 6:
                message.platformType = 6;
                break;
            case "H5_ANDROID":
            case 7:
                message.platformType = 7;
                break;
            case "H5_IOS":
            case 8:
                message.platformType = 8;
                break;
            case "H5_WINDOWS":
            case 9:
                message.platformType = 9;
                break;
            case "H5_MAC":
            case 10:
                message.platformType = 10;
                break;
            case "kPlatformNum":
            case 11:
                message.platformType = 11;
                break;
            }
            if (object.osVersion != null)
                message.osVersion = String(object.osVersion);
            if (object.deviceModel != null)
                message.deviceModel = String(object.deviceModel);
            if (object.imeiMd5 != null)
                if (typeof object.imeiMd5 === "string")
                    $util.base64.decode(object.imeiMd5, message.imeiMd5 = $util.newBuffer($util.base64.length(object.imeiMd5)), 0);
                else if (object.imeiMd5.length)
                    message.imeiMd5 = object.imeiMd5;
            if (object.deviceId != null)
                message.deviceId = String(object.deviceId);
            if (object.softDid != null)
                message.softDid = String(object.softDid);
            if (object.kwaiDid != null)
                message.kwaiDid = String(object.kwaiDid);
            if (object.manufacturer != null)
                message.manufacturer = String(object.manufacturer);
            if (object.deviceName != null)
                message.deviceName = String(object.deviceName);
            return message;
        };

        /**
         * Creates a plain object from a DeviceInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.DeviceInfo
         * @static
         * @param {AcFunDanmu.DeviceInfo} message DeviceInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeviceInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.platformType = options.enums === String ? "kInvalid" : 0;
                object.osVersion = "";
                object.deviceModel = "";
                if (options.bytes === String)
                    object.imeiMd5 = "";
                else {
                    object.imeiMd5 = [];
                    if (options.bytes !== Array)
                        object.imeiMd5 = $util.newBuffer(object.imeiMd5);
                }
                object.deviceId = "";
                object.softDid = "";
                object.kwaiDid = "";
                object.manufacturer = "";
                object.deviceName = "";
            }
            if (message.platformType != null && message.hasOwnProperty("platformType"))
                object.platformType = options.enums === String ? $root.AcFunDanmu.DeviceInfo.PlatformType[message.platformType] : message.platformType;
            if (message.osVersion != null && message.hasOwnProperty("osVersion"))
                object.osVersion = message.osVersion;
            if (message.deviceModel != null && message.hasOwnProperty("deviceModel"))
                object.deviceModel = message.deviceModel;
            if (message.imeiMd5 != null && message.hasOwnProperty("imeiMd5"))
                object.imeiMd5 = options.bytes === String ? $util.base64.encode(message.imeiMd5, 0, message.imeiMd5.length) : options.bytes === Array ? Array.prototype.slice.call(message.imeiMd5) : message.imeiMd5;
            if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                object.deviceId = message.deviceId;
            if (message.softDid != null && message.hasOwnProperty("softDid"))
                object.softDid = message.softDid;
            if (message.kwaiDid != null && message.hasOwnProperty("kwaiDid"))
                object.kwaiDid = message.kwaiDid;
            if (message.manufacturer != null && message.hasOwnProperty("manufacturer"))
                object.manufacturer = message.manufacturer;
            if (message.deviceName != null && message.hasOwnProperty("deviceName"))
                object.deviceName = message.deviceName;
            return object;
        };

        /**
         * Converts this DeviceInfo to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.DeviceInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeviceInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * PlatformType enum.
         * @name AcFunDanmu.DeviceInfo.PlatformType
         * @enum {number}
         * @property {number} kInvalid=0 kInvalid value
         * @property {number} kAndroid=1 kAndroid value
         * @property {number} kiOS=2 kiOS value
         * @property {number} kWindows=3 kWindows value
         * @property {number} WECHAT_ANDROID=4 WECHAT_ANDROID value
         * @property {number} WECHAT_IOS=5 WECHAT_IOS value
         * @property {number} H5=6 H5 value
         * @property {number} H5_ANDROID=7 H5_ANDROID value
         * @property {number} H5_IOS=8 H5_IOS value
         * @property {number} H5_WINDOWS=9 H5_WINDOWS value
         * @property {number} H5_MAC=10 H5_MAC value
         * @property {number} kPlatformNum=11 kPlatformNum value
         */
        DeviceInfo.PlatformType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "kInvalid"] = 0;
            values[valuesById[1] = "kAndroid"] = 1;
            values[valuesById[2] = "kiOS"] = 2;
            values[valuesById[3] = "kWindows"] = 3;
            values[valuesById[4] = "WECHAT_ANDROID"] = 4;
            values[valuesById[5] = "WECHAT_IOS"] = 5;
            values[valuesById[6] = "H5"] = 6;
            values[valuesById[7] = "H5_ANDROID"] = 7;
            values[valuesById[8] = "H5_IOS"] = 8;
            values[valuesById[9] = "H5_WINDOWS"] = 9;
            values[valuesById[10] = "H5_MAC"] = 10;
            values[valuesById[11] = "kPlatformNum"] = 11;
            return values;
        })();

        return DeviceInfo;
    })();

    AcFunDanmu.DownstreamPayload = (function() {

        /**
         * Properties of a DownstreamPayload.
         * @memberof AcFunDanmu
         * @interface IDownstreamPayload
         * @property {string|null} [command] DownstreamPayload command
         * @property {number|Long|null} [seqId] DownstreamPayload seqId
         * @property {number|null} [errorCode] DownstreamPayload errorCode
         * @property {Uint8Array|null} [payloadData] DownstreamPayload payloadData
         * @property {string|null} [errorMsg] DownstreamPayload errorMsg
         * @property {Uint8Array|null} [errorData] DownstreamPayload errorData
         * @property {string|null} [subBiz] DownstreamPayload subBiz
         */

        /**
         * Constructs a new DownstreamPayload.
         * @memberof AcFunDanmu
         * @classdesc Represents a DownstreamPayload.
         * @implements IDownstreamPayload
         * @constructor
         * @param {AcFunDanmu.IDownstreamPayload=} [properties] Properties to set
         */
        function DownstreamPayload(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DownstreamPayload command.
         * @member {string} command
         * @memberof AcFunDanmu.DownstreamPayload
         * @instance
         */
        DownstreamPayload.prototype.command = "";

        /**
         * DownstreamPayload seqId.
         * @member {number|Long} seqId
         * @memberof AcFunDanmu.DownstreamPayload
         * @instance
         */
        DownstreamPayload.prototype.seqId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * DownstreamPayload errorCode.
         * @member {number} errorCode
         * @memberof AcFunDanmu.DownstreamPayload
         * @instance
         */
        DownstreamPayload.prototype.errorCode = 0;

        /**
         * DownstreamPayload payloadData.
         * @member {Uint8Array} payloadData
         * @memberof AcFunDanmu.DownstreamPayload
         * @instance
         */
        DownstreamPayload.prototype.payloadData = $util.newBuffer([]);

        /**
         * DownstreamPayload errorMsg.
         * @member {string} errorMsg
         * @memberof AcFunDanmu.DownstreamPayload
         * @instance
         */
        DownstreamPayload.prototype.errorMsg = "";

        /**
         * DownstreamPayload errorData.
         * @member {Uint8Array} errorData
         * @memberof AcFunDanmu.DownstreamPayload
         * @instance
         */
        DownstreamPayload.prototype.errorData = $util.newBuffer([]);

        /**
         * DownstreamPayload subBiz.
         * @member {string} subBiz
         * @memberof AcFunDanmu.DownstreamPayload
         * @instance
         */
        DownstreamPayload.prototype.subBiz = "";

        /**
         * Creates a new DownstreamPayload instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.DownstreamPayload
         * @static
         * @param {AcFunDanmu.IDownstreamPayload=} [properties] Properties to set
         * @returns {AcFunDanmu.DownstreamPayload} DownstreamPayload instance
         */
        DownstreamPayload.create = function create(properties) {
            return new DownstreamPayload(properties);
        };

        /**
         * Encodes the specified DownstreamPayload message. Does not implicitly {@link AcFunDanmu.DownstreamPayload.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.DownstreamPayload
         * @static
         * @param {AcFunDanmu.IDownstreamPayload} message DownstreamPayload message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DownstreamPayload.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.command != null && Object.hasOwnProperty.call(message, "command"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.command);
            if (message.seqId != null && Object.hasOwnProperty.call(message, "seqId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.seqId);
            if (message.errorCode != null && Object.hasOwnProperty.call(message, "errorCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errorCode);
            if (message.payloadData != null && Object.hasOwnProperty.call(message, "payloadData"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.payloadData);
            if (message.errorMsg != null && Object.hasOwnProperty.call(message, "errorMsg"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.errorMsg);
            if (message.errorData != null && Object.hasOwnProperty.call(message, "errorData"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.errorData);
            if (message.subBiz != null && Object.hasOwnProperty.call(message, "subBiz"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.subBiz);
            return writer;
        };

        /**
         * Encodes the specified DownstreamPayload message, length delimited. Does not implicitly {@link AcFunDanmu.DownstreamPayload.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.DownstreamPayload
         * @static
         * @param {AcFunDanmu.IDownstreamPayload} message DownstreamPayload message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DownstreamPayload.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DownstreamPayload message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.DownstreamPayload
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.DownstreamPayload} DownstreamPayload
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DownstreamPayload.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.DownstreamPayload();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.command = reader.string();
                    break;
                case 2:
                    message.seqId = reader.int64();
                    break;
                case 3:
                    message.errorCode = reader.int32();
                    break;
                case 4:
                    message.payloadData = reader.bytes();
                    break;
                case 5:
                    message.errorMsg = reader.string();
                    break;
                case 6:
                    message.errorData = reader.bytes();
                    break;
                case 7:
                    message.subBiz = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DownstreamPayload message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.DownstreamPayload
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.DownstreamPayload} DownstreamPayload
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DownstreamPayload.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DownstreamPayload message.
         * @function verify
         * @memberof AcFunDanmu.DownstreamPayload
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DownstreamPayload.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.command != null && message.hasOwnProperty("command"))
                if (!$util.isString(message.command))
                    return "command: string expected";
            if (message.seqId != null && message.hasOwnProperty("seqId"))
                if (!$util.isInteger(message.seqId) && !(message.seqId && $util.isInteger(message.seqId.low) && $util.isInteger(message.seqId.high)))
                    return "seqId: integer|Long expected";
            if (message.errorCode != null && message.hasOwnProperty("errorCode"))
                if (!$util.isInteger(message.errorCode))
                    return "errorCode: integer expected";
            if (message.payloadData != null && message.hasOwnProperty("payloadData"))
                if (!(message.payloadData && typeof message.payloadData.length === "number" || $util.isString(message.payloadData)))
                    return "payloadData: buffer expected";
            if (message.errorMsg != null && message.hasOwnProperty("errorMsg"))
                if (!$util.isString(message.errorMsg))
                    return "errorMsg: string expected";
            if (message.errorData != null && message.hasOwnProperty("errorData"))
                if (!(message.errorData && typeof message.errorData.length === "number" || $util.isString(message.errorData)))
                    return "errorData: buffer expected";
            if (message.subBiz != null && message.hasOwnProperty("subBiz"))
                if (!$util.isString(message.subBiz))
                    return "subBiz: string expected";
            return null;
        };

        /**
         * Creates a DownstreamPayload message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.DownstreamPayload
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.DownstreamPayload} DownstreamPayload
         */
        DownstreamPayload.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.DownstreamPayload)
                return object;
            let message = new $root.AcFunDanmu.DownstreamPayload();
            if (object.command != null)
                message.command = String(object.command);
            if (object.seqId != null)
                if ($util.Long)
                    (message.seqId = $util.Long.fromValue(object.seqId)).unsigned = false;
                else if (typeof object.seqId === "string")
                    message.seqId = parseInt(object.seqId, 10);
                else if (typeof object.seqId === "number")
                    message.seqId = object.seqId;
                else if (typeof object.seqId === "object")
                    message.seqId = new $util.LongBits(object.seqId.low >>> 0, object.seqId.high >>> 0).toNumber();
            if (object.errorCode != null)
                message.errorCode = object.errorCode | 0;
            if (object.payloadData != null)
                if (typeof object.payloadData === "string")
                    $util.base64.decode(object.payloadData, message.payloadData = $util.newBuffer($util.base64.length(object.payloadData)), 0);
                else if (object.payloadData.length)
                    message.payloadData = object.payloadData;
            if (object.errorMsg != null)
                message.errorMsg = String(object.errorMsg);
            if (object.errorData != null)
                if (typeof object.errorData === "string")
                    $util.base64.decode(object.errorData, message.errorData = $util.newBuffer($util.base64.length(object.errorData)), 0);
                else if (object.errorData.length)
                    message.errorData = object.errorData;
            if (object.subBiz != null)
                message.subBiz = String(object.subBiz);
            return message;
        };

        /**
         * Creates a plain object from a DownstreamPayload message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.DownstreamPayload
         * @static
         * @param {AcFunDanmu.DownstreamPayload} message DownstreamPayload
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DownstreamPayload.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.command = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.seqId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.seqId = options.longs === String ? "0" : 0;
                object.errorCode = 0;
                if (options.bytes === String)
                    object.payloadData = "";
                else {
                    object.payloadData = [];
                    if (options.bytes !== Array)
                        object.payloadData = $util.newBuffer(object.payloadData);
                }
                object.errorMsg = "";
                if (options.bytes === String)
                    object.errorData = "";
                else {
                    object.errorData = [];
                    if (options.bytes !== Array)
                        object.errorData = $util.newBuffer(object.errorData);
                }
                object.subBiz = "";
            }
            if (message.command != null && message.hasOwnProperty("command"))
                object.command = message.command;
            if (message.seqId != null && message.hasOwnProperty("seqId"))
                if (typeof message.seqId === "number")
                    object.seqId = options.longs === String ? String(message.seqId) : message.seqId;
                else
                    object.seqId = options.longs === String ? $util.Long.prototype.toString.call(message.seqId) : options.longs === Number ? new $util.LongBits(message.seqId.low >>> 0, message.seqId.high >>> 0).toNumber() : message.seqId;
            if (message.errorCode != null && message.hasOwnProperty("errorCode"))
                object.errorCode = message.errorCode;
            if (message.payloadData != null && message.hasOwnProperty("payloadData"))
                object.payloadData = options.bytes === String ? $util.base64.encode(message.payloadData, 0, message.payloadData.length) : options.bytes === Array ? Array.prototype.slice.call(message.payloadData) : message.payloadData;
            if (message.errorMsg != null && message.hasOwnProperty("errorMsg"))
                object.errorMsg = message.errorMsg;
            if (message.errorData != null && message.hasOwnProperty("errorData"))
                object.errorData = options.bytes === String ? $util.base64.encode(message.errorData, 0, message.errorData.length) : options.bytes === Array ? Array.prototype.slice.call(message.errorData) : message.errorData;
            if (message.subBiz != null && message.hasOwnProperty("subBiz"))
                object.subBiz = message.subBiz;
            return object;
        };

        /**
         * Converts this DownstreamPayload to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.DownstreamPayload
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DownstreamPayload.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DownstreamPayload;
    })();

    AcFunDanmu.EnvInfo = (function() {

        /**
         * Properties of an EnvInfo.
         * @memberof AcFunDanmu
         * @interface IEnvInfo
         * @property {AcFunDanmu.EnvInfo.NetworkType|null} [networkType] EnvInfo networkType
         * @property {Uint8Array|null} [appName] EnvInfo appName
         */

        /**
         * Constructs a new EnvInfo.
         * @memberof AcFunDanmu
         * @classdesc Represents an EnvInfo.
         * @implements IEnvInfo
         * @constructor
         * @param {AcFunDanmu.IEnvInfo=} [properties] Properties to set
         */
        function EnvInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EnvInfo networkType.
         * @member {AcFunDanmu.EnvInfo.NetworkType} networkType
         * @memberof AcFunDanmu.EnvInfo
         * @instance
         */
        EnvInfo.prototype.networkType = 0;

        /**
         * EnvInfo appName.
         * @member {Uint8Array} appName
         * @memberof AcFunDanmu.EnvInfo
         * @instance
         */
        EnvInfo.prototype.appName = $util.newBuffer([]);

        /**
         * Creates a new EnvInfo instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.EnvInfo
         * @static
         * @param {AcFunDanmu.IEnvInfo=} [properties] Properties to set
         * @returns {AcFunDanmu.EnvInfo} EnvInfo instance
         */
        EnvInfo.create = function create(properties) {
            return new EnvInfo(properties);
        };

        /**
         * Encodes the specified EnvInfo message. Does not implicitly {@link AcFunDanmu.EnvInfo.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.EnvInfo
         * @static
         * @param {AcFunDanmu.IEnvInfo} message EnvInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnvInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.networkType != null && Object.hasOwnProperty.call(message, "networkType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.networkType);
            if (message.appName != null && Object.hasOwnProperty.call(message, "appName"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.appName);
            return writer;
        };

        /**
         * Encodes the specified EnvInfo message, length delimited. Does not implicitly {@link AcFunDanmu.EnvInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.EnvInfo
         * @static
         * @param {AcFunDanmu.IEnvInfo} message EnvInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnvInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EnvInfo message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.EnvInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.EnvInfo} EnvInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnvInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.EnvInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.networkType = reader.int32();
                    break;
                case 2:
                    message.appName = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EnvInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.EnvInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.EnvInfo} EnvInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnvInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EnvInfo message.
         * @function verify
         * @memberof AcFunDanmu.EnvInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EnvInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.networkType != null && message.hasOwnProperty("networkType"))
                switch (message.networkType) {
                default:
                    return "networkType: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.appName != null && message.hasOwnProperty("appName"))
                if (!(message.appName && typeof message.appName.length === "number" || $util.isString(message.appName)))
                    return "appName: buffer expected";
            return null;
        };

        /**
         * Creates an EnvInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.EnvInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.EnvInfo} EnvInfo
         */
        EnvInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.EnvInfo)
                return object;
            let message = new $root.AcFunDanmu.EnvInfo();
            switch (object.networkType) {
            case "kInvalid":
            case 0:
                message.networkType = 0;
                break;
            case "kWIFI":
            case 1:
                message.networkType = 1;
                break;
            case "kCellular":
            case 2:
                message.networkType = 2;
                break;
            }
            if (object.appName != null)
                if (typeof object.appName === "string")
                    $util.base64.decode(object.appName, message.appName = $util.newBuffer($util.base64.length(object.appName)), 0);
                else if (object.appName.length)
                    message.appName = object.appName;
            return message;
        };

        /**
         * Creates a plain object from an EnvInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.EnvInfo
         * @static
         * @param {AcFunDanmu.EnvInfo} message EnvInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EnvInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.networkType = options.enums === String ? "kInvalid" : 0;
                if (options.bytes === String)
                    object.appName = "";
                else {
                    object.appName = [];
                    if (options.bytes !== Array)
                        object.appName = $util.newBuffer(object.appName);
                }
            }
            if (message.networkType != null && message.hasOwnProperty("networkType"))
                object.networkType = options.enums === String ? $root.AcFunDanmu.EnvInfo.NetworkType[message.networkType] : message.networkType;
            if (message.appName != null && message.hasOwnProperty("appName"))
                object.appName = options.bytes === String ? $util.base64.encode(message.appName, 0, message.appName.length) : options.bytes === Array ? Array.prototype.slice.call(message.appName) : message.appName;
            return object;
        };

        /**
         * Converts this EnvInfo to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.EnvInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EnvInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * NetworkType enum.
         * @name AcFunDanmu.EnvInfo.NetworkType
         * @enum {number}
         * @property {number} kInvalid=0 kInvalid value
         * @property {number} kWIFI=1 kWIFI value
         * @property {number} kCellular=2 kCellular value
         */
        EnvInfo.NetworkType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "kInvalid"] = 0;
            values[valuesById[1] = "kWIFI"] = 1;
            values[valuesById[2] = "kCellular"] = 2;
            return values;
        })();

        return EnvInfo;
    })();

    AcFunDanmu.FrontendInfo = (function() {

        /**
         * Properties of a FrontendInfo.
         * @memberof AcFunDanmu
         * @interface IFrontendInfo
         * @property {string|null} [ip] FrontendInfo ip
         * @property {number|null} [port] FrontendInfo port
         */

        /**
         * Constructs a new FrontendInfo.
         * @memberof AcFunDanmu
         * @classdesc Represents a FrontendInfo.
         * @implements IFrontendInfo
         * @constructor
         * @param {AcFunDanmu.IFrontendInfo=} [properties] Properties to set
         */
        function FrontendInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FrontendInfo ip.
         * @member {string} ip
         * @memberof AcFunDanmu.FrontendInfo
         * @instance
         */
        FrontendInfo.prototype.ip = "";

        /**
         * FrontendInfo port.
         * @member {number} port
         * @memberof AcFunDanmu.FrontendInfo
         * @instance
         */
        FrontendInfo.prototype.port = 0;

        /**
         * Creates a new FrontendInfo instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.FrontendInfo
         * @static
         * @param {AcFunDanmu.IFrontendInfo=} [properties] Properties to set
         * @returns {AcFunDanmu.FrontendInfo} FrontendInfo instance
         */
        FrontendInfo.create = function create(properties) {
            return new FrontendInfo(properties);
        };

        /**
         * Encodes the specified FrontendInfo message. Does not implicitly {@link AcFunDanmu.FrontendInfo.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.FrontendInfo
         * @static
         * @param {AcFunDanmu.IFrontendInfo} message FrontendInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FrontendInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ip != null && Object.hasOwnProperty.call(message, "ip"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.ip);
            if (message.port != null && Object.hasOwnProperty.call(message, "port"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.port);
            return writer;
        };

        /**
         * Encodes the specified FrontendInfo message, length delimited. Does not implicitly {@link AcFunDanmu.FrontendInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.FrontendInfo
         * @static
         * @param {AcFunDanmu.IFrontendInfo} message FrontendInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FrontendInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FrontendInfo message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.FrontendInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.FrontendInfo} FrontendInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FrontendInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.FrontendInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ip = reader.string();
                    break;
                case 2:
                    message.port = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FrontendInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.FrontendInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.FrontendInfo} FrontendInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FrontendInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FrontendInfo message.
         * @function verify
         * @memberof AcFunDanmu.FrontendInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FrontendInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ip != null && message.hasOwnProperty("ip"))
                if (!$util.isString(message.ip))
                    return "ip: string expected";
            if (message.port != null && message.hasOwnProperty("port"))
                if (!$util.isInteger(message.port))
                    return "port: integer expected";
            return null;
        };

        /**
         * Creates a FrontendInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.FrontendInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.FrontendInfo} FrontendInfo
         */
        FrontendInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.FrontendInfo)
                return object;
            let message = new $root.AcFunDanmu.FrontendInfo();
            if (object.ip != null)
                message.ip = String(object.ip);
            if (object.port != null)
                message.port = object.port | 0;
            return message;
        };

        /**
         * Creates a plain object from a FrontendInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.FrontendInfo
         * @static
         * @param {AcFunDanmu.FrontendInfo} message FrontendInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FrontendInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.ip = "";
                object.port = 0;
            }
            if (message.ip != null && message.hasOwnProperty("ip"))
                object.ip = message.ip;
            if (message.port != null && message.hasOwnProperty("port"))
                object.port = message.port;
            return object;
        };

        /**
         * Converts this FrontendInfo to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.FrontendInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FrontendInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FrontendInfo;
    })();

    AcFunDanmu.Im = (function() {

        /**
         * Namespace Im.
         * @memberof AcFunDanmu
         * @namespace
         */
        const Im = {};

        Im.Basic = (function() {

            /**
             * Properties of a Basic.
             * @memberof AcFunDanmu.Im
             * @interface IBasic
             */

            /**
             * Constructs a new Basic.
             * @memberof AcFunDanmu.Im
             * @classdesc Represents a Basic.
             * @implements IBasic
             * @constructor
             * @param {AcFunDanmu.Im.IBasic=} [properties] Properties to set
             */
            function Basic(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new Basic instance using the specified properties.
             * @function create
             * @memberof AcFunDanmu.Im.Basic
             * @static
             * @param {AcFunDanmu.Im.IBasic=} [properties] Properties to set
             * @returns {AcFunDanmu.Im.Basic} Basic instance
             */
            Basic.create = function create(properties) {
                return new Basic(properties);
            };

            /**
             * Encodes the specified Basic message. Does not implicitly {@link AcFunDanmu.Im.Basic.verify|verify} messages.
             * @function encode
             * @memberof AcFunDanmu.Im.Basic
             * @static
             * @param {AcFunDanmu.Im.IBasic} message Basic message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Basic.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified Basic message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Basic.verify|verify} messages.
             * @function encodeDelimited
             * @memberof AcFunDanmu.Im.Basic
             * @static
             * @param {AcFunDanmu.Im.IBasic} message Basic message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Basic.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Basic message from the specified reader or buffer.
             * @function decode
             * @memberof AcFunDanmu.Im.Basic
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {AcFunDanmu.Im.Basic} Basic
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Basic.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Basic();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Basic message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof AcFunDanmu.Im.Basic
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {AcFunDanmu.Im.Basic} Basic
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Basic.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Basic message.
             * @function verify
             * @memberof AcFunDanmu.Im.Basic
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Basic.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a Basic message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof AcFunDanmu.Im.Basic
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {AcFunDanmu.Im.Basic} Basic
             */
            Basic.fromObject = function fromObject(object) {
                if (object instanceof $root.AcFunDanmu.Im.Basic)
                    return object;
                return new $root.AcFunDanmu.Im.Basic();
            };

            /**
             * Creates a plain object from a Basic message. Also converts values to other types if specified.
             * @function toObject
             * @memberof AcFunDanmu.Im.Basic
             * @static
             * @param {AcFunDanmu.Im.Basic} message Basic
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Basic.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this Basic to JSON.
             * @function toJSON
             * @memberof AcFunDanmu.Im.Basic
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Basic.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            Basic.PacketHeader = (function() {

                /**
                 * Properties of a PacketHeader.
                 * @memberof AcFunDanmu.Im.Basic
                 * @interface IPacketHeader
                 * @property {number|null} [appId] PacketHeader appId
                 * @property {number|Long|null} [uid] PacketHeader uid
                 * @property {number|Long|null} [instanceId] PacketHeader instanceId
                 * @property {number|null} [flags] PacketHeader flags
                 * @property {AcFunDanmu.Im.Basic.PacketHeader.EncodingType|null} [encodingType] PacketHeader encodingType
                 * @property {number|null} [decodedPayloadLen] PacketHeader decodedPayloadLen
                 * @property {AcFunDanmu.Im.Basic.PacketHeader.EncryptionMode|null} [encryptionMode] PacketHeader encryptionMode
                 * @property {AcFunDanmu.Im.Basic.ITokenInfo|null} [tokenInfo] PacketHeader tokenInfo
                 * @property {number|Long|null} [seqId] PacketHeader seqId
                 * @property {Array.<AcFunDanmu.Im.Basic.PacketHeader.Feature>|null} [features] PacketHeader features
                 * @property {string|null} [kpn] PacketHeader kpn
                 */

                /**
                 * Constructs a new PacketHeader.
                 * @memberof AcFunDanmu.Im.Basic
                 * @classdesc Represents a PacketHeader.
                 * @implements IPacketHeader
                 * @constructor
                 * @param {AcFunDanmu.Im.Basic.IPacketHeader=} [properties] Properties to set
                 */
                function PacketHeader(properties) {
                    this.features = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PacketHeader appId.
                 * @member {number} appId
                 * @memberof AcFunDanmu.Im.Basic.PacketHeader
                 * @instance
                 */
                PacketHeader.prototype.appId = 0;

                /**
                 * PacketHeader uid.
                 * @member {number|Long} uid
                 * @memberof AcFunDanmu.Im.Basic.PacketHeader
                 * @instance
                 */
                PacketHeader.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * PacketHeader instanceId.
                 * @member {number|Long} instanceId
                 * @memberof AcFunDanmu.Im.Basic.PacketHeader
                 * @instance
                 */
                PacketHeader.prototype.instanceId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * PacketHeader flags.
                 * @member {number} flags
                 * @memberof AcFunDanmu.Im.Basic.PacketHeader
                 * @instance
                 */
                PacketHeader.prototype.flags = 0;

                /**
                 * PacketHeader encodingType.
                 * @member {AcFunDanmu.Im.Basic.PacketHeader.EncodingType} encodingType
                 * @memberof AcFunDanmu.Im.Basic.PacketHeader
                 * @instance
                 */
                PacketHeader.prototype.encodingType = 0;

                /**
                 * PacketHeader decodedPayloadLen.
                 * @member {number} decodedPayloadLen
                 * @memberof AcFunDanmu.Im.Basic.PacketHeader
                 * @instance
                 */
                PacketHeader.prototype.decodedPayloadLen = 0;

                /**
                 * PacketHeader encryptionMode.
                 * @member {AcFunDanmu.Im.Basic.PacketHeader.EncryptionMode} encryptionMode
                 * @memberof AcFunDanmu.Im.Basic.PacketHeader
                 * @instance
                 */
                PacketHeader.prototype.encryptionMode = 0;

                /**
                 * PacketHeader tokenInfo.
                 * @member {AcFunDanmu.Im.Basic.ITokenInfo|null|undefined} tokenInfo
                 * @memberof AcFunDanmu.Im.Basic.PacketHeader
                 * @instance
                 */
                PacketHeader.prototype.tokenInfo = null;

                /**
                 * PacketHeader seqId.
                 * @member {number|Long} seqId
                 * @memberof AcFunDanmu.Im.Basic.PacketHeader
                 * @instance
                 */
                PacketHeader.prototype.seqId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * PacketHeader features.
                 * @member {Array.<AcFunDanmu.Im.Basic.PacketHeader.Feature>} features
                 * @memberof AcFunDanmu.Im.Basic.PacketHeader
                 * @instance
                 */
                PacketHeader.prototype.features = $util.emptyArray;

                /**
                 * PacketHeader kpn.
                 * @member {string} kpn
                 * @memberof AcFunDanmu.Im.Basic.PacketHeader
                 * @instance
                 */
                PacketHeader.prototype.kpn = "";

                /**
                 * Creates a new PacketHeader instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Basic.PacketHeader
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IPacketHeader=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Basic.PacketHeader} PacketHeader instance
                 */
                PacketHeader.create = function create(properties) {
                    return new PacketHeader(properties);
                };

                /**
                 * Encodes the specified PacketHeader message. Does not implicitly {@link AcFunDanmu.Im.Basic.PacketHeader.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Basic.PacketHeader
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IPacketHeader} message PacketHeader message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PacketHeader.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.appId != null && Object.hasOwnProperty.call(message, "appId"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.appId);
                    if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int64(message.uid);
                    if (message.instanceId != null && Object.hasOwnProperty.call(message, "instanceId"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int64(message.instanceId);
                    if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                        writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.flags);
                    if (message.encodingType != null && Object.hasOwnProperty.call(message, "encodingType"))
                        writer.uint32(/* id 6, wireType 0 =*/48).int32(message.encodingType);
                    if (message.decodedPayloadLen != null && Object.hasOwnProperty.call(message, "decodedPayloadLen"))
                        writer.uint32(/* id 7, wireType 0 =*/56).int32(message.decodedPayloadLen);
                    if (message.encryptionMode != null && Object.hasOwnProperty.call(message, "encryptionMode"))
                        writer.uint32(/* id 8, wireType 0 =*/64).int32(message.encryptionMode);
                    if (message.tokenInfo != null && Object.hasOwnProperty.call(message, "tokenInfo"))
                        $root.AcFunDanmu.Im.Basic.TokenInfo.encode(message.tokenInfo, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if (message.seqId != null && Object.hasOwnProperty.call(message, "seqId"))
                        writer.uint32(/* id 10, wireType 0 =*/80).int64(message.seqId);
                    if (message.features != null && message.features.length) {
                        writer.uint32(/* id 11, wireType 2 =*/90).fork();
                        for (let i = 0; i < message.features.length; ++i)
                            writer.int32(message.features[i]);
                        writer.ldelim();
                    }
                    if (message.kpn != null && Object.hasOwnProperty.call(message, "kpn"))
                        writer.uint32(/* id 12, wireType 2 =*/98).string(message.kpn);
                    return writer;
                };

                /**
                 * Encodes the specified PacketHeader message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Basic.PacketHeader.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Basic.PacketHeader
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IPacketHeader} message PacketHeader message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PacketHeader.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a PacketHeader message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Basic.PacketHeader
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Basic.PacketHeader} PacketHeader
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PacketHeader.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Basic.PacketHeader();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.appId = reader.int32();
                            break;
                        case 2:
                            message.uid = reader.int64();
                            break;
                        case 3:
                            message.instanceId = reader.int64();
                            break;
                        case 5:
                            message.flags = reader.uint32();
                            break;
                        case 6:
                            message.encodingType = reader.int32();
                            break;
                        case 7:
                            message.decodedPayloadLen = reader.int32();
                            break;
                        case 8:
                            message.encryptionMode = reader.int32();
                            break;
                        case 9:
                            message.tokenInfo = $root.AcFunDanmu.Im.Basic.TokenInfo.decode(reader, reader.uint32());
                            break;
                        case 10:
                            message.seqId = reader.int64();
                            break;
                        case 11:
                            if (!(message.features && message.features.length))
                                message.features = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.features.push(reader.int32());
                            } else
                                message.features.push(reader.int32());
                            break;
                        case 12:
                            message.kpn = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a PacketHeader message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Basic.PacketHeader
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Basic.PacketHeader} PacketHeader
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PacketHeader.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a PacketHeader message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Basic.PacketHeader
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PacketHeader.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.appId != null && message.hasOwnProperty("appId"))
                        if (!$util.isInteger(message.appId))
                            return "appId: integer expected";
                    if (message.uid != null && message.hasOwnProperty("uid"))
                        if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                            return "uid: integer|Long expected";
                    if (message.instanceId != null && message.hasOwnProperty("instanceId"))
                        if (!$util.isInteger(message.instanceId) && !(message.instanceId && $util.isInteger(message.instanceId.low) && $util.isInteger(message.instanceId.high)))
                            return "instanceId: integer|Long expected";
                    if (message.flags != null && message.hasOwnProperty("flags"))
                        if (!$util.isInteger(message.flags))
                            return "flags: integer expected";
                    if (message.encodingType != null && message.hasOwnProperty("encodingType"))
                        switch (message.encodingType) {
                        default:
                            return "encodingType: enum value expected";
                        case 0:
                        case 1:
                            break;
                        }
                    if (message.decodedPayloadLen != null && message.hasOwnProperty("decodedPayloadLen"))
                        if (!$util.isInteger(message.decodedPayloadLen))
                            return "decodedPayloadLen: integer expected";
                    if (message.encryptionMode != null && message.hasOwnProperty("encryptionMode"))
                        switch (message.encryptionMode) {
                        default:
                            return "encryptionMode: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (message.tokenInfo != null && message.hasOwnProperty("tokenInfo")) {
                        let error = $root.AcFunDanmu.Im.Basic.TokenInfo.verify(message.tokenInfo);
                        if (error)
                            return "tokenInfo." + error;
                    }
                    if (message.seqId != null && message.hasOwnProperty("seqId"))
                        if (!$util.isInteger(message.seqId) && !(message.seqId && $util.isInteger(message.seqId.low) && $util.isInteger(message.seqId.high)))
                            return "seqId: integer|Long expected";
                    if (message.features != null && message.hasOwnProperty("features")) {
                        if (!Array.isArray(message.features))
                            return "features: array expected";
                        for (let i = 0; i < message.features.length; ++i)
                            switch (message.features[i]) {
                            default:
                                return "features: enum value[] expected";
                            case 0:
                            case 1:
                                break;
                            }
                    }
                    if (message.kpn != null && message.hasOwnProperty("kpn"))
                        if (!$util.isString(message.kpn))
                            return "kpn: string expected";
                    return null;
                };

                /**
                 * Creates a PacketHeader message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Basic.PacketHeader
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Basic.PacketHeader} PacketHeader
                 */
                PacketHeader.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Basic.PacketHeader)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Basic.PacketHeader();
                    if (object.appId != null)
                        message.appId = object.appId | 0;
                    if (object.uid != null)
                        if ($util.Long)
                            (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                        else if (typeof object.uid === "string")
                            message.uid = parseInt(object.uid, 10);
                        else if (typeof object.uid === "number")
                            message.uid = object.uid;
                        else if (typeof object.uid === "object")
                            message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
                    if (object.instanceId != null)
                        if ($util.Long)
                            (message.instanceId = $util.Long.fromValue(object.instanceId)).unsigned = false;
                        else if (typeof object.instanceId === "string")
                            message.instanceId = parseInt(object.instanceId, 10);
                        else if (typeof object.instanceId === "number")
                            message.instanceId = object.instanceId;
                        else if (typeof object.instanceId === "object")
                            message.instanceId = new $util.LongBits(object.instanceId.low >>> 0, object.instanceId.high >>> 0).toNumber();
                    if (object.flags != null)
                        message.flags = object.flags >>> 0;
                    switch (object.encodingType) {
                    case "kEncodingNone":
                    case 0:
                        message.encodingType = 0;
                        break;
                    case "kEncodingLz4":
                    case 1:
                        message.encodingType = 1;
                        break;
                    }
                    if (object.decodedPayloadLen != null)
                        message.decodedPayloadLen = object.decodedPayloadLen | 0;
                    switch (object.encryptionMode) {
                    case "kEncryptionNone":
                    case 0:
                        message.encryptionMode = 0;
                        break;
                    case "kEncryptionServiceToken":
                    case 1:
                        message.encryptionMode = 1;
                        break;
                    case "kEncryptionSessionKey":
                    case 2:
                        message.encryptionMode = 2;
                        break;
                    }
                    if (object.tokenInfo != null) {
                        if (typeof object.tokenInfo !== "object")
                            throw TypeError(".AcFunDanmu.Im.Basic.PacketHeader.tokenInfo: object expected");
                        message.tokenInfo = $root.AcFunDanmu.Im.Basic.TokenInfo.fromObject(object.tokenInfo);
                    }
                    if (object.seqId != null)
                        if ($util.Long)
                            (message.seqId = $util.Long.fromValue(object.seqId)).unsigned = false;
                        else if (typeof object.seqId === "string")
                            message.seqId = parseInt(object.seqId, 10);
                        else if (typeof object.seqId === "number")
                            message.seqId = object.seqId;
                        else if (typeof object.seqId === "object")
                            message.seqId = new $util.LongBits(object.seqId.low >>> 0, object.seqId.high >>> 0).toNumber();
                    if (object.features) {
                        if (!Array.isArray(object.features))
                            throw TypeError(".AcFunDanmu.Im.Basic.PacketHeader.features: array expected");
                        message.features = [];
                        for (let i = 0; i < object.features.length; ++i)
                            switch (object.features[i]) {
                            default:
                            case "kReserve":
                            case 0:
                                message.features[i] = 0;
                                break;
                            case "kCompressLz4":
                            case 1:
                                message.features[i] = 1;
                                break;
                            }
                    }
                    if (object.kpn != null)
                        message.kpn = String(object.kpn);
                    return message;
                };

                /**
                 * Creates a plain object from a PacketHeader message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Basic.PacketHeader
                 * @static
                 * @param {AcFunDanmu.Im.Basic.PacketHeader} message PacketHeader
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PacketHeader.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.features = [];
                    if (options.defaults) {
                        object.appId = 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.uid = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.instanceId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.instanceId = options.longs === String ? "0" : 0;
                        object.flags = 0;
                        object.encodingType = options.enums === String ? "kEncodingNone" : 0;
                        object.decodedPayloadLen = 0;
                        object.encryptionMode = options.enums === String ? "kEncryptionNone" : 0;
                        object.tokenInfo = null;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.seqId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.seqId = options.longs === String ? "0" : 0;
                        object.kpn = "";
                    }
                    if (message.appId != null && message.hasOwnProperty("appId"))
                        object.appId = message.appId;
                    if (message.uid != null && message.hasOwnProperty("uid"))
                        if (typeof message.uid === "number")
                            object.uid = options.longs === String ? String(message.uid) : message.uid;
                        else
                            object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
                    if (message.instanceId != null && message.hasOwnProperty("instanceId"))
                        if (typeof message.instanceId === "number")
                            object.instanceId = options.longs === String ? String(message.instanceId) : message.instanceId;
                        else
                            object.instanceId = options.longs === String ? $util.Long.prototype.toString.call(message.instanceId) : options.longs === Number ? new $util.LongBits(message.instanceId.low >>> 0, message.instanceId.high >>> 0).toNumber() : message.instanceId;
                    if (message.flags != null && message.hasOwnProperty("flags"))
                        object.flags = message.flags;
                    if (message.encodingType != null && message.hasOwnProperty("encodingType"))
                        object.encodingType = options.enums === String ? $root.AcFunDanmu.Im.Basic.PacketHeader.EncodingType[message.encodingType] : message.encodingType;
                    if (message.decodedPayloadLen != null && message.hasOwnProperty("decodedPayloadLen"))
                        object.decodedPayloadLen = message.decodedPayloadLen;
                    if (message.encryptionMode != null && message.hasOwnProperty("encryptionMode"))
                        object.encryptionMode = options.enums === String ? $root.AcFunDanmu.Im.Basic.PacketHeader.EncryptionMode[message.encryptionMode] : message.encryptionMode;
                    if (message.tokenInfo != null && message.hasOwnProperty("tokenInfo"))
                        object.tokenInfo = $root.AcFunDanmu.Im.Basic.TokenInfo.toObject(message.tokenInfo, options);
                    if (message.seqId != null && message.hasOwnProperty("seqId"))
                        if (typeof message.seqId === "number")
                            object.seqId = options.longs === String ? String(message.seqId) : message.seqId;
                        else
                            object.seqId = options.longs === String ? $util.Long.prototype.toString.call(message.seqId) : options.longs === Number ? new $util.LongBits(message.seqId.low >>> 0, message.seqId.high >>> 0).toNumber() : message.seqId;
                    if (message.features && message.features.length) {
                        object.features = [];
                        for (let j = 0; j < message.features.length; ++j)
                            object.features[j] = options.enums === String ? $root.AcFunDanmu.Im.Basic.PacketHeader.Feature[message.features[j]] : message.features[j];
                    }
                    if (message.kpn != null && message.hasOwnProperty("kpn"))
                        object.kpn = message.kpn;
                    return object;
                };

                /**
                 * Converts this PacketHeader to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Basic.PacketHeader
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PacketHeader.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Flags enum.
                 * @name AcFunDanmu.Im.Basic.PacketHeader.Flags
                 * @enum {number}
                 * @property {number} kDirUpstream=0 kDirUpstream value
                 * @property {number} kDirDownstream=1 kDirDownstream value
                 * @property {number} kDirMask=1 kDirMask value
                 */
                PacketHeader.Flags = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "kDirUpstream"] = 0;
                    values[valuesById[1] = "kDirDownstream"] = 1;
                    values["kDirMask"] = 1;
                    return values;
                })();

                /**
                 * EncodingType enum.
                 * @name AcFunDanmu.Im.Basic.PacketHeader.EncodingType
                 * @enum {number}
                 * @property {number} kEncodingNone=0 kEncodingNone value
                 * @property {number} kEncodingLz4=1 kEncodingLz4 value
                 */
                PacketHeader.EncodingType = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "kEncodingNone"] = 0;
                    values[valuesById[1] = "kEncodingLz4"] = 1;
                    return values;
                })();

                /**
                 * EncryptionMode enum.
                 * @name AcFunDanmu.Im.Basic.PacketHeader.EncryptionMode
                 * @enum {number}
                 * @property {number} kEncryptionNone=0 kEncryptionNone value
                 * @property {number} kEncryptionServiceToken=1 kEncryptionServiceToken value
                 * @property {number} kEncryptionSessionKey=2 kEncryptionSessionKey value
                 */
                PacketHeader.EncryptionMode = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "kEncryptionNone"] = 0;
                    values[valuesById[1] = "kEncryptionServiceToken"] = 1;
                    values[valuesById[2] = "kEncryptionSessionKey"] = 2;
                    return values;
                })();

                /**
                 * Feature enum.
                 * @name AcFunDanmu.Im.Basic.PacketHeader.Feature
                 * @enum {number}
                 * @property {number} kReserve=0 kReserve value
                 * @property {number} kCompressLz4=1 kCompressLz4 value
                 */
                PacketHeader.Feature = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "kReserve"] = 0;
                    values[valuesById[1] = "kCompressLz4"] = 1;
                    return values;
                })();

                return PacketHeader;
            })();

            Basic.User = (function() {

                /**
                 * Properties of a User.
                 * @memberof AcFunDanmu.Im.Basic
                 * @interface IUser
                 * @property {number|null} [appId] User appId
                 * @property {number|Long|null} [uid] User uid
                 */

                /**
                 * Constructs a new User.
                 * @memberof AcFunDanmu.Im.Basic
                 * @classdesc Represents a User.
                 * @implements IUser
                 * @constructor
                 * @param {AcFunDanmu.Im.Basic.IUser=} [properties] Properties to set
                 */
                function User(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * User appId.
                 * @member {number} appId
                 * @memberof AcFunDanmu.Im.Basic.User
                 * @instance
                 */
                User.prototype.appId = 0;

                /**
                 * User uid.
                 * @member {number|Long} uid
                 * @memberof AcFunDanmu.Im.Basic.User
                 * @instance
                 */
                User.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Creates a new User instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Basic.User
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IUser=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Basic.User} User instance
                 */
                User.create = function create(properties) {
                    return new User(properties);
                };

                /**
                 * Encodes the specified User message. Does not implicitly {@link AcFunDanmu.Im.Basic.User.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Basic.User
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IUser} message User message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                User.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.appId != null && Object.hasOwnProperty.call(message, "appId"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.appId);
                    if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int64(message.uid);
                    return writer;
                };

                /**
                 * Encodes the specified User message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Basic.User.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Basic.User
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IUser} message User message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                User.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a User message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Basic.User
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Basic.User} User
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                User.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Basic.User();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.appId = reader.int32();
                            break;
                        case 2:
                            message.uid = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a User message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Basic.User
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Basic.User} User
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                User.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a User message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Basic.User
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                User.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.appId != null && message.hasOwnProperty("appId"))
                        if (!$util.isInteger(message.appId))
                            return "appId: integer expected";
                    if (message.uid != null && message.hasOwnProperty("uid"))
                        if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                            return "uid: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a User message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Basic.User
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Basic.User} User
                 */
                User.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Basic.User)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Basic.User();
                    if (object.appId != null)
                        message.appId = object.appId | 0;
                    if (object.uid != null)
                        if ($util.Long)
                            (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                        else if (typeof object.uid === "string")
                            message.uid = parseInt(object.uid, 10);
                        else if (typeof object.uid === "number")
                            message.uid = object.uid;
                        else if (typeof object.uid === "object")
                            message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
                    return message;
                };

                /**
                 * Creates a plain object from a User message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Basic.User
                 * @static
                 * @param {AcFunDanmu.Im.Basic.User} message User
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                User.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.appId = 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.uid = options.longs === String ? "0" : 0;
                    }
                    if (message.appId != null && message.hasOwnProperty("appId"))
                        object.appId = message.appId;
                    if (message.uid != null && message.hasOwnProperty("uid"))
                        if (typeof message.uid === "number")
                            object.uid = options.longs === String ? String(message.uid) : message.uid;
                        else
                            object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
                    return object;
                };

                /**
                 * Converts this User to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Basic.User
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                User.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return User;
            })();

            Basic.UserInstance = (function() {

                /**
                 * Properties of a UserInstance.
                 * @memberof AcFunDanmu.Im.Basic
                 * @interface IUserInstance
                 * @property {AcFunDanmu.Im.Basic.IUser|null} [user] UserInstance user
                 * @property {number|Long|null} [instanceId] UserInstance instanceId
                 */

                /**
                 * Constructs a new UserInstance.
                 * @memberof AcFunDanmu.Im.Basic
                 * @classdesc Represents a UserInstance.
                 * @implements IUserInstance
                 * @constructor
                 * @param {AcFunDanmu.Im.Basic.IUserInstance=} [properties] Properties to set
                 */
                function UserInstance(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * UserInstance user.
                 * @member {AcFunDanmu.Im.Basic.IUser|null|undefined} user
                 * @memberof AcFunDanmu.Im.Basic.UserInstance
                 * @instance
                 */
                UserInstance.prototype.user = null;

                /**
                 * UserInstance instanceId.
                 * @member {number|Long} instanceId
                 * @memberof AcFunDanmu.Im.Basic.UserInstance
                 * @instance
                 */
                UserInstance.prototype.instanceId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Creates a new UserInstance instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Basic.UserInstance
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IUserInstance=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Basic.UserInstance} UserInstance instance
                 */
                UserInstance.create = function create(properties) {
                    return new UserInstance(properties);
                };

                /**
                 * Encodes the specified UserInstance message. Does not implicitly {@link AcFunDanmu.Im.Basic.UserInstance.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Basic.UserInstance
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IUserInstance} message UserInstance message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UserInstance.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.user != null && Object.hasOwnProperty.call(message, "user"))
                        $root.AcFunDanmu.Im.Basic.User.encode(message.user, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.instanceId != null && Object.hasOwnProperty.call(message, "instanceId"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int64(message.instanceId);
                    return writer;
                };

                /**
                 * Encodes the specified UserInstance message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Basic.UserInstance.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Basic.UserInstance
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IUserInstance} message UserInstance message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UserInstance.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a UserInstance message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Basic.UserInstance
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Basic.UserInstance} UserInstance
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UserInstance.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Basic.UserInstance();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.user = $root.AcFunDanmu.Im.Basic.User.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.instanceId = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a UserInstance message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Basic.UserInstance
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Basic.UserInstance} UserInstance
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UserInstance.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a UserInstance message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Basic.UserInstance
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                UserInstance.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.user != null && message.hasOwnProperty("user")) {
                        let error = $root.AcFunDanmu.Im.Basic.User.verify(message.user);
                        if (error)
                            return "user." + error;
                    }
                    if (message.instanceId != null && message.hasOwnProperty("instanceId"))
                        if (!$util.isInteger(message.instanceId) && !(message.instanceId && $util.isInteger(message.instanceId.low) && $util.isInteger(message.instanceId.high)))
                            return "instanceId: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a UserInstance message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Basic.UserInstance
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Basic.UserInstance} UserInstance
                 */
                UserInstance.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Basic.UserInstance)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Basic.UserInstance();
                    if (object.user != null) {
                        if (typeof object.user !== "object")
                            throw TypeError(".AcFunDanmu.Im.Basic.UserInstance.user: object expected");
                        message.user = $root.AcFunDanmu.Im.Basic.User.fromObject(object.user);
                    }
                    if (object.instanceId != null)
                        if ($util.Long)
                            (message.instanceId = $util.Long.fromValue(object.instanceId)).unsigned = false;
                        else if (typeof object.instanceId === "string")
                            message.instanceId = parseInt(object.instanceId, 10);
                        else if (typeof object.instanceId === "number")
                            message.instanceId = object.instanceId;
                        else if (typeof object.instanceId === "object")
                            message.instanceId = new $util.LongBits(object.instanceId.low >>> 0, object.instanceId.high >>> 0).toNumber();
                    return message;
                };

                /**
                 * Creates a plain object from a UserInstance message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Basic.UserInstance
                 * @static
                 * @param {AcFunDanmu.Im.Basic.UserInstance} message UserInstance
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                UserInstance.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.user = null;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.instanceId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.instanceId = options.longs === String ? "0" : 0;
                    }
                    if (message.user != null && message.hasOwnProperty("user"))
                        object.user = $root.AcFunDanmu.Im.Basic.User.toObject(message.user, options);
                    if (message.instanceId != null && message.hasOwnProperty("instanceId"))
                        if (typeof message.instanceId === "number")
                            object.instanceId = options.longs === String ? String(message.instanceId) : message.instanceId;
                        else
                            object.instanceId = options.longs === String ? $util.Long.prototype.toString.call(message.instanceId) : options.longs === Number ? new $util.LongBits(message.instanceId.low >>> 0, message.instanceId.high >>> 0).toNumber() : message.instanceId;
                    return object;
                };

                /**
                 * Converts this UserInstance to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Basic.UserInstance
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                UserInstance.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return UserInstance;
            })();

            Basic.UpstreamPayload = (function() {

                /**
                 * Properties of an UpstreamPayload.
                 * @memberof AcFunDanmu.Im.Basic
                 * @interface IUpstreamPayload
                 * @property {string|null} [command] UpstreamPayload command
                 * @property {number|Long|null} [seqId] UpstreamPayload seqId
                 * @property {number|null} [retryCount] UpstreamPayload retryCount
                 * @property {Uint8Array|null} [payloadData] UpstreamPayload payloadData
                 * @property {AcFunDanmu.Im.Basic.IUserInstance|null} [userInstance] UpstreamPayload userInstance
                 * @property {number|null} [errorCode] UpstreamPayload errorCode
                 * @property {AcFunDanmu.Im.Basic.ISettingInfo|null} [settingInfo] UpstreamPayload settingInfo
                 * @property {AcFunDanmu.Im.Basic.IRequestBasicInfo|null} [requestBasicInfo] UpstreamPayload requestBasicInfo
                 * @property {string|null} [subBiz] UpstreamPayload subBiz
                 * @property {AcFunDanmu.Im.Basic.IFrontendInfo|null} [frontendInfo] UpstreamPayload frontendInfo
                 * @property {string|null} [kpn] UpstreamPayload kpn
                 * @property {boolean|null} [anonymouseUser] UpstreamPayload anonymouseUser
                 */

                /**
                 * Constructs a new UpstreamPayload.
                 * @memberof AcFunDanmu.Im.Basic
                 * @classdesc Represents an UpstreamPayload.
                 * @implements IUpstreamPayload
                 * @constructor
                 * @param {AcFunDanmu.Im.Basic.IUpstreamPayload=} [properties] Properties to set
                 */
                function UpstreamPayload(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * UpstreamPayload command.
                 * @member {string} command
                 * @memberof AcFunDanmu.Im.Basic.UpstreamPayload
                 * @instance
                 */
                UpstreamPayload.prototype.command = "";

                /**
                 * UpstreamPayload seqId.
                 * @member {number|Long} seqId
                 * @memberof AcFunDanmu.Im.Basic.UpstreamPayload
                 * @instance
                 */
                UpstreamPayload.prototype.seqId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * UpstreamPayload retryCount.
                 * @member {number} retryCount
                 * @memberof AcFunDanmu.Im.Basic.UpstreamPayload
                 * @instance
                 */
                UpstreamPayload.prototype.retryCount = 0;

                /**
                 * UpstreamPayload payloadData.
                 * @member {Uint8Array} payloadData
                 * @memberof AcFunDanmu.Im.Basic.UpstreamPayload
                 * @instance
                 */
                UpstreamPayload.prototype.payloadData = $util.newBuffer([]);

                /**
                 * UpstreamPayload userInstance.
                 * @member {AcFunDanmu.Im.Basic.IUserInstance|null|undefined} userInstance
                 * @memberof AcFunDanmu.Im.Basic.UpstreamPayload
                 * @instance
                 */
                UpstreamPayload.prototype.userInstance = null;

                /**
                 * UpstreamPayload errorCode.
                 * @member {number} errorCode
                 * @memberof AcFunDanmu.Im.Basic.UpstreamPayload
                 * @instance
                 */
                UpstreamPayload.prototype.errorCode = 0;

                /**
                 * UpstreamPayload settingInfo.
                 * @member {AcFunDanmu.Im.Basic.ISettingInfo|null|undefined} settingInfo
                 * @memberof AcFunDanmu.Im.Basic.UpstreamPayload
                 * @instance
                 */
                UpstreamPayload.prototype.settingInfo = null;

                /**
                 * UpstreamPayload requestBasicInfo.
                 * @member {AcFunDanmu.Im.Basic.IRequestBasicInfo|null|undefined} requestBasicInfo
                 * @memberof AcFunDanmu.Im.Basic.UpstreamPayload
                 * @instance
                 */
                UpstreamPayload.prototype.requestBasicInfo = null;

                /**
                 * UpstreamPayload subBiz.
                 * @member {string} subBiz
                 * @memberof AcFunDanmu.Im.Basic.UpstreamPayload
                 * @instance
                 */
                UpstreamPayload.prototype.subBiz = "";

                /**
                 * UpstreamPayload frontendInfo.
                 * @member {AcFunDanmu.Im.Basic.IFrontendInfo|null|undefined} frontendInfo
                 * @memberof AcFunDanmu.Im.Basic.UpstreamPayload
                 * @instance
                 */
                UpstreamPayload.prototype.frontendInfo = null;

                /**
                 * UpstreamPayload kpn.
                 * @member {string} kpn
                 * @memberof AcFunDanmu.Im.Basic.UpstreamPayload
                 * @instance
                 */
                UpstreamPayload.prototype.kpn = "";

                /**
                 * UpstreamPayload anonymouseUser.
                 * @member {boolean} anonymouseUser
                 * @memberof AcFunDanmu.Im.Basic.UpstreamPayload
                 * @instance
                 */
                UpstreamPayload.prototype.anonymouseUser = false;

                /**
                 * Creates a new UpstreamPayload instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Basic.UpstreamPayload
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IUpstreamPayload=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Basic.UpstreamPayload} UpstreamPayload instance
                 */
                UpstreamPayload.create = function create(properties) {
                    return new UpstreamPayload(properties);
                };

                /**
                 * Encodes the specified UpstreamPayload message. Does not implicitly {@link AcFunDanmu.Im.Basic.UpstreamPayload.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Basic.UpstreamPayload
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IUpstreamPayload} message UpstreamPayload message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UpstreamPayload.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.command != null && Object.hasOwnProperty.call(message, "command"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.command);
                    if (message.seqId != null && Object.hasOwnProperty.call(message, "seqId"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int64(message.seqId);
                    if (message.retryCount != null && Object.hasOwnProperty.call(message, "retryCount"))
                        writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.retryCount);
                    if (message.payloadData != null && Object.hasOwnProperty.call(message, "payloadData"))
                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.payloadData);
                    if (message.userInstance != null && Object.hasOwnProperty.call(message, "userInstance"))
                        $root.AcFunDanmu.Im.Basic.UserInstance.encode(message.userInstance, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.errorCode != null && Object.hasOwnProperty.call(message, "errorCode"))
                        writer.uint32(/* id 6, wireType 0 =*/48).int32(message.errorCode);
                    if (message.settingInfo != null && Object.hasOwnProperty.call(message, "settingInfo"))
                        $root.AcFunDanmu.Im.Basic.SettingInfo.encode(message.settingInfo, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.requestBasicInfo != null && Object.hasOwnProperty.call(message, "requestBasicInfo"))
                        $root.AcFunDanmu.Im.Basic.RequestBasicInfo.encode(message.requestBasicInfo, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.subBiz != null && Object.hasOwnProperty.call(message, "subBiz"))
                        writer.uint32(/* id 9, wireType 2 =*/74).string(message.subBiz);
                    if (message.frontendInfo != null && Object.hasOwnProperty.call(message, "frontendInfo"))
                        $root.AcFunDanmu.Im.Basic.FrontendInfo.encode(message.frontendInfo, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                    if (message.kpn != null && Object.hasOwnProperty.call(message, "kpn"))
                        writer.uint32(/* id 11, wireType 2 =*/90).string(message.kpn);
                    if (message.anonymouseUser != null && Object.hasOwnProperty.call(message, "anonymouseUser"))
                        writer.uint32(/* id 12, wireType 0 =*/96).bool(message.anonymouseUser);
                    return writer;
                };

                /**
                 * Encodes the specified UpstreamPayload message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Basic.UpstreamPayload.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Basic.UpstreamPayload
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IUpstreamPayload} message UpstreamPayload message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UpstreamPayload.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an UpstreamPayload message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Basic.UpstreamPayload
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Basic.UpstreamPayload} UpstreamPayload
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UpstreamPayload.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Basic.UpstreamPayload();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.command = reader.string();
                            break;
                        case 2:
                            message.seqId = reader.int64();
                            break;
                        case 3:
                            message.retryCount = reader.uint32();
                            break;
                        case 4:
                            message.payloadData = reader.bytes();
                            break;
                        case 5:
                            message.userInstance = $root.AcFunDanmu.Im.Basic.UserInstance.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.errorCode = reader.int32();
                            break;
                        case 7:
                            message.settingInfo = $root.AcFunDanmu.Im.Basic.SettingInfo.decode(reader, reader.uint32());
                            break;
                        case 8:
                            message.requestBasicInfo = $root.AcFunDanmu.Im.Basic.RequestBasicInfo.decode(reader, reader.uint32());
                            break;
                        case 9:
                            message.subBiz = reader.string();
                            break;
                        case 10:
                            message.frontendInfo = $root.AcFunDanmu.Im.Basic.FrontendInfo.decode(reader, reader.uint32());
                            break;
                        case 11:
                            message.kpn = reader.string();
                            break;
                        case 12:
                            message.anonymouseUser = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an UpstreamPayload message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Basic.UpstreamPayload
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Basic.UpstreamPayload} UpstreamPayload
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UpstreamPayload.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an UpstreamPayload message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Basic.UpstreamPayload
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                UpstreamPayload.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.command != null && message.hasOwnProperty("command"))
                        if (!$util.isString(message.command))
                            return "command: string expected";
                    if (message.seqId != null && message.hasOwnProperty("seqId"))
                        if (!$util.isInteger(message.seqId) && !(message.seqId && $util.isInteger(message.seqId.low) && $util.isInteger(message.seqId.high)))
                            return "seqId: integer|Long expected";
                    if (message.retryCount != null && message.hasOwnProperty("retryCount"))
                        if (!$util.isInteger(message.retryCount))
                            return "retryCount: integer expected";
                    if (message.payloadData != null && message.hasOwnProperty("payloadData"))
                        if (!(message.payloadData && typeof message.payloadData.length === "number" || $util.isString(message.payloadData)))
                            return "payloadData: buffer expected";
                    if (message.userInstance != null && message.hasOwnProperty("userInstance")) {
                        let error = $root.AcFunDanmu.Im.Basic.UserInstance.verify(message.userInstance);
                        if (error)
                            return "userInstance." + error;
                    }
                    if (message.errorCode != null && message.hasOwnProperty("errorCode"))
                        if (!$util.isInteger(message.errorCode))
                            return "errorCode: integer expected";
                    if (message.settingInfo != null && message.hasOwnProperty("settingInfo")) {
                        let error = $root.AcFunDanmu.Im.Basic.SettingInfo.verify(message.settingInfo);
                        if (error)
                            return "settingInfo." + error;
                    }
                    if (message.requestBasicInfo != null && message.hasOwnProperty("requestBasicInfo")) {
                        let error = $root.AcFunDanmu.Im.Basic.RequestBasicInfo.verify(message.requestBasicInfo);
                        if (error)
                            return "requestBasicInfo." + error;
                    }
                    if (message.subBiz != null && message.hasOwnProperty("subBiz"))
                        if (!$util.isString(message.subBiz))
                            return "subBiz: string expected";
                    if (message.frontendInfo != null && message.hasOwnProperty("frontendInfo")) {
                        let error = $root.AcFunDanmu.Im.Basic.FrontendInfo.verify(message.frontendInfo);
                        if (error)
                            return "frontendInfo." + error;
                    }
                    if (message.kpn != null && message.hasOwnProperty("kpn"))
                        if (!$util.isString(message.kpn))
                            return "kpn: string expected";
                    if (message.anonymouseUser != null && message.hasOwnProperty("anonymouseUser"))
                        if (typeof message.anonymouseUser !== "boolean")
                            return "anonymouseUser: boolean expected";
                    return null;
                };

                /**
                 * Creates an UpstreamPayload message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Basic.UpstreamPayload
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Basic.UpstreamPayload} UpstreamPayload
                 */
                UpstreamPayload.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Basic.UpstreamPayload)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Basic.UpstreamPayload();
                    if (object.command != null)
                        message.command = String(object.command);
                    if (object.seqId != null)
                        if ($util.Long)
                            (message.seqId = $util.Long.fromValue(object.seqId)).unsigned = false;
                        else if (typeof object.seqId === "string")
                            message.seqId = parseInt(object.seqId, 10);
                        else if (typeof object.seqId === "number")
                            message.seqId = object.seqId;
                        else if (typeof object.seqId === "object")
                            message.seqId = new $util.LongBits(object.seqId.low >>> 0, object.seqId.high >>> 0).toNumber();
                    if (object.retryCount != null)
                        message.retryCount = object.retryCount >>> 0;
                    if (object.payloadData != null)
                        if (typeof object.payloadData === "string")
                            $util.base64.decode(object.payloadData, message.payloadData = $util.newBuffer($util.base64.length(object.payloadData)), 0);
                        else if (object.payloadData.length)
                            message.payloadData = object.payloadData;
                    if (object.userInstance != null) {
                        if (typeof object.userInstance !== "object")
                            throw TypeError(".AcFunDanmu.Im.Basic.UpstreamPayload.userInstance: object expected");
                        message.userInstance = $root.AcFunDanmu.Im.Basic.UserInstance.fromObject(object.userInstance);
                    }
                    if (object.errorCode != null)
                        message.errorCode = object.errorCode | 0;
                    if (object.settingInfo != null) {
                        if (typeof object.settingInfo !== "object")
                            throw TypeError(".AcFunDanmu.Im.Basic.UpstreamPayload.settingInfo: object expected");
                        message.settingInfo = $root.AcFunDanmu.Im.Basic.SettingInfo.fromObject(object.settingInfo);
                    }
                    if (object.requestBasicInfo != null) {
                        if (typeof object.requestBasicInfo !== "object")
                            throw TypeError(".AcFunDanmu.Im.Basic.UpstreamPayload.requestBasicInfo: object expected");
                        message.requestBasicInfo = $root.AcFunDanmu.Im.Basic.RequestBasicInfo.fromObject(object.requestBasicInfo);
                    }
                    if (object.subBiz != null)
                        message.subBiz = String(object.subBiz);
                    if (object.frontendInfo != null) {
                        if (typeof object.frontendInfo !== "object")
                            throw TypeError(".AcFunDanmu.Im.Basic.UpstreamPayload.frontendInfo: object expected");
                        message.frontendInfo = $root.AcFunDanmu.Im.Basic.FrontendInfo.fromObject(object.frontendInfo);
                    }
                    if (object.kpn != null)
                        message.kpn = String(object.kpn);
                    if (object.anonymouseUser != null)
                        message.anonymouseUser = Boolean(object.anonymouseUser);
                    return message;
                };

                /**
                 * Creates a plain object from an UpstreamPayload message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Basic.UpstreamPayload
                 * @static
                 * @param {AcFunDanmu.Im.Basic.UpstreamPayload} message UpstreamPayload
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                UpstreamPayload.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.command = "";
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.seqId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.seqId = options.longs === String ? "0" : 0;
                        object.retryCount = 0;
                        if (options.bytes === String)
                            object.payloadData = "";
                        else {
                            object.payloadData = [];
                            if (options.bytes !== Array)
                                object.payloadData = $util.newBuffer(object.payloadData);
                        }
                        object.userInstance = null;
                        object.errorCode = 0;
                        object.settingInfo = null;
                        object.requestBasicInfo = null;
                        object.subBiz = "";
                        object.frontendInfo = null;
                        object.kpn = "";
                        object.anonymouseUser = false;
                    }
                    if (message.command != null && message.hasOwnProperty("command"))
                        object.command = message.command;
                    if (message.seqId != null && message.hasOwnProperty("seqId"))
                        if (typeof message.seqId === "number")
                            object.seqId = options.longs === String ? String(message.seqId) : message.seqId;
                        else
                            object.seqId = options.longs === String ? $util.Long.prototype.toString.call(message.seqId) : options.longs === Number ? new $util.LongBits(message.seqId.low >>> 0, message.seqId.high >>> 0).toNumber() : message.seqId;
                    if (message.retryCount != null && message.hasOwnProperty("retryCount"))
                        object.retryCount = message.retryCount;
                    if (message.payloadData != null && message.hasOwnProperty("payloadData"))
                        object.payloadData = options.bytes === String ? $util.base64.encode(message.payloadData, 0, message.payloadData.length) : options.bytes === Array ? Array.prototype.slice.call(message.payloadData) : message.payloadData;
                    if (message.userInstance != null && message.hasOwnProperty("userInstance"))
                        object.userInstance = $root.AcFunDanmu.Im.Basic.UserInstance.toObject(message.userInstance, options);
                    if (message.errorCode != null && message.hasOwnProperty("errorCode"))
                        object.errorCode = message.errorCode;
                    if (message.settingInfo != null && message.hasOwnProperty("settingInfo"))
                        object.settingInfo = $root.AcFunDanmu.Im.Basic.SettingInfo.toObject(message.settingInfo, options);
                    if (message.requestBasicInfo != null && message.hasOwnProperty("requestBasicInfo"))
                        object.requestBasicInfo = $root.AcFunDanmu.Im.Basic.RequestBasicInfo.toObject(message.requestBasicInfo, options);
                    if (message.subBiz != null && message.hasOwnProperty("subBiz"))
                        object.subBiz = message.subBiz;
                    if (message.frontendInfo != null && message.hasOwnProperty("frontendInfo"))
                        object.frontendInfo = $root.AcFunDanmu.Im.Basic.FrontendInfo.toObject(message.frontendInfo, options);
                    if (message.kpn != null && message.hasOwnProperty("kpn"))
                        object.kpn = message.kpn;
                    if (message.anonymouseUser != null && message.hasOwnProperty("anonymouseUser"))
                        object.anonymouseUser = message.anonymouseUser;
                    return object;
                };

                /**
                 * Converts this UpstreamPayload to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Basic.UpstreamPayload
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                UpstreamPayload.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return UpstreamPayload;
            })();

            Basic.DownstreamPayload = (function() {

                /**
                 * Properties of a DownstreamPayload.
                 * @memberof AcFunDanmu.Im.Basic
                 * @interface IDownstreamPayload
                 * @property {string|null} [command] DownstreamPayload command
                 * @property {number|Long|null} [seqId] DownstreamPayload seqId
                 * @property {number|null} [errorCode] DownstreamPayload errorCode
                 * @property {Uint8Array|null} [payloadData] DownstreamPayload payloadData
                 * @property {string|null} [errorMsg] DownstreamPayload errorMsg
                 * @property {Uint8Array|null} [errorData] DownstreamPayload errorData
                 * @property {string|null} [subBiz] DownstreamPayload subBiz
                 */

                /**
                 * Constructs a new DownstreamPayload.
                 * @memberof AcFunDanmu.Im.Basic
                 * @classdesc Represents a DownstreamPayload.
                 * @implements IDownstreamPayload
                 * @constructor
                 * @param {AcFunDanmu.Im.Basic.IDownstreamPayload=} [properties] Properties to set
                 */
                function DownstreamPayload(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DownstreamPayload command.
                 * @member {string} command
                 * @memberof AcFunDanmu.Im.Basic.DownstreamPayload
                 * @instance
                 */
                DownstreamPayload.prototype.command = "";

                /**
                 * DownstreamPayload seqId.
                 * @member {number|Long} seqId
                 * @memberof AcFunDanmu.Im.Basic.DownstreamPayload
                 * @instance
                 */
                DownstreamPayload.prototype.seqId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * DownstreamPayload errorCode.
                 * @member {number} errorCode
                 * @memberof AcFunDanmu.Im.Basic.DownstreamPayload
                 * @instance
                 */
                DownstreamPayload.prototype.errorCode = 0;

                /**
                 * DownstreamPayload payloadData.
                 * @member {Uint8Array} payloadData
                 * @memberof AcFunDanmu.Im.Basic.DownstreamPayload
                 * @instance
                 */
                DownstreamPayload.prototype.payloadData = $util.newBuffer([]);

                /**
                 * DownstreamPayload errorMsg.
                 * @member {string} errorMsg
                 * @memberof AcFunDanmu.Im.Basic.DownstreamPayload
                 * @instance
                 */
                DownstreamPayload.prototype.errorMsg = "";

                /**
                 * DownstreamPayload errorData.
                 * @member {Uint8Array} errorData
                 * @memberof AcFunDanmu.Im.Basic.DownstreamPayload
                 * @instance
                 */
                DownstreamPayload.prototype.errorData = $util.newBuffer([]);

                /**
                 * DownstreamPayload subBiz.
                 * @member {string} subBiz
                 * @memberof AcFunDanmu.Im.Basic.DownstreamPayload
                 * @instance
                 */
                DownstreamPayload.prototype.subBiz = "";

                /**
                 * Creates a new DownstreamPayload instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Basic.DownstreamPayload
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IDownstreamPayload=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Basic.DownstreamPayload} DownstreamPayload instance
                 */
                DownstreamPayload.create = function create(properties) {
                    return new DownstreamPayload(properties);
                };

                /**
                 * Encodes the specified DownstreamPayload message. Does not implicitly {@link AcFunDanmu.Im.Basic.DownstreamPayload.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Basic.DownstreamPayload
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IDownstreamPayload} message DownstreamPayload message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DownstreamPayload.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.command != null && Object.hasOwnProperty.call(message, "command"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.command);
                    if (message.seqId != null && Object.hasOwnProperty.call(message, "seqId"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int64(message.seqId);
                    if (message.errorCode != null && Object.hasOwnProperty.call(message, "errorCode"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errorCode);
                    if (message.payloadData != null && Object.hasOwnProperty.call(message, "payloadData"))
                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.payloadData);
                    if (message.errorMsg != null && Object.hasOwnProperty.call(message, "errorMsg"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.errorMsg);
                    if (message.errorData != null && Object.hasOwnProperty.call(message, "errorData"))
                        writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.errorData);
                    if (message.subBiz != null && Object.hasOwnProperty.call(message, "subBiz"))
                        writer.uint32(/* id 7, wireType 2 =*/58).string(message.subBiz);
                    return writer;
                };

                /**
                 * Encodes the specified DownstreamPayload message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Basic.DownstreamPayload.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Basic.DownstreamPayload
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IDownstreamPayload} message DownstreamPayload message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DownstreamPayload.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a DownstreamPayload message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Basic.DownstreamPayload
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Basic.DownstreamPayload} DownstreamPayload
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DownstreamPayload.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Basic.DownstreamPayload();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.command = reader.string();
                            break;
                        case 2:
                            message.seqId = reader.int64();
                            break;
                        case 3:
                            message.errorCode = reader.int32();
                            break;
                        case 4:
                            message.payloadData = reader.bytes();
                            break;
                        case 5:
                            message.errorMsg = reader.string();
                            break;
                        case 6:
                            message.errorData = reader.bytes();
                            break;
                        case 7:
                            message.subBiz = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a DownstreamPayload message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Basic.DownstreamPayload
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Basic.DownstreamPayload} DownstreamPayload
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DownstreamPayload.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a DownstreamPayload message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Basic.DownstreamPayload
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DownstreamPayload.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.command != null && message.hasOwnProperty("command"))
                        if (!$util.isString(message.command))
                            return "command: string expected";
                    if (message.seqId != null && message.hasOwnProperty("seqId"))
                        if (!$util.isInteger(message.seqId) && !(message.seqId && $util.isInteger(message.seqId.low) && $util.isInteger(message.seqId.high)))
                            return "seqId: integer|Long expected";
                    if (message.errorCode != null && message.hasOwnProperty("errorCode"))
                        if (!$util.isInteger(message.errorCode))
                            return "errorCode: integer expected";
                    if (message.payloadData != null && message.hasOwnProperty("payloadData"))
                        if (!(message.payloadData && typeof message.payloadData.length === "number" || $util.isString(message.payloadData)))
                            return "payloadData: buffer expected";
                    if (message.errorMsg != null && message.hasOwnProperty("errorMsg"))
                        if (!$util.isString(message.errorMsg))
                            return "errorMsg: string expected";
                    if (message.errorData != null && message.hasOwnProperty("errorData"))
                        if (!(message.errorData && typeof message.errorData.length === "number" || $util.isString(message.errorData)))
                            return "errorData: buffer expected";
                    if (message.subBiz != null && message.hasOwnProperty("subBiz"))
                        if (!$util.isString(message.subBiz))
                            return "subBiz: string expected";
                    return null;
                };

                /**
                 * Creates a DownstreamPayload message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Basic.DownstreamPayload
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Basic.DownstreamPayload} DownstreamPayload
                 */
                DownstreamPayload.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Basic.DownstreamPayload)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Basic.DownstreamPayload();
                    if (object.command != null)
                        message.command = String(object.command);
                    if (object.seqId != null)
                        if ($util.Long)
                            (message.seqId = $util.Long.fromValue(object.seqId)).unsigned = false;
                        else if (typeof object.seqId === "string")
                            message.seqId = parseInt(object.seqId, 10);
                        else if (typeof object.seqId === "number")
                            message.seqId = object.seqId;
                        else if (typeof object.seqId === "object")
                            message.seqId = new $util.LongBits(object.seqId.low >>> 0, object.seqId.high >>> 0).toNumber();
                    if (object.errorCode != null)
                        message.errorCode = object.errorCode | 0;
                    if (object.payloadData != null)
                        if (typeof object.payloadData === "string")
                            $util.base64.decode(object.payloadData, message.payloadData = $util.newBuffer($util.base64.length(object.payloadData)), 0);
                        else if (object.payloadData.length)
                            message.payloadData = object.payloadData;
                    if (object.errorMsg != null)
                        message.errorMsg = String(object.errorMsg);
                    if (object.errorData != null)
                        if (typeof object.errorData === "string")
                            $util.base64.decode(object.errorData, message.errorData = $util.newBuffer($util.base64.length(object.errorData)), 0);
                        else if (object.errorData.length)
                            message.errorData = object.errorData;
                    if (object.subBiz != null)
                        message.subBiz = String(object.subBiz);
                    return message;
                };

                /**
                 * Creates a plain object from a DownstreamPayload message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Basic.DownstreamPayload
                 * @static
                 * @param {AcFunDanmu.Im.Basic.DownstreamPayload} message DownstreamPayload
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DownstreamPayload.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.command = "";
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.seqId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.seqId = options.longs === String ? "0" : 0;
                        object.errorCode = 0;
                        if (options.bytes === String)
                            object.payloadData = "";
                        else {
                            object.payloadData = [];
                            if (options.bytes !== Array)
                                object.payloadData = $util.newBuffer(object.payloadData);
                        }
                        object.errorMsg = "";
                        if (options.bytes === String)
                            object.errorData = "";
                        else {
                            object.errorData = [];
                            if (options.bytes !== Array)
                                object.errorData = $util.newBuffer(object.errorData);
                        }
                        object.subBiz = "";
                    }
                    if (message.command != null && message.hasOwnProperty("command"))
                        object.command = message.command;
                    if (message.seqId != null && message.hasOwnProperty("seqId"))
                        if (typeof message.seqId === "number")
                            object.seqId = options.longs === String ? String(message.seqId) : message.seqId;
                        else
                            object.seqId = options.longs === String ? $util.Long.prototype.toString.call(message.seqId) : options.longs === Number ? new $util.LongBits(message.seqId.low >>> 0, message.seqId.high >>> 0).toNumber() : message.seqId;
                    if (message.errorCode != null && message.hasOwnProperty("errorCode"))
                        object.errorCode = message.errorCode;
                    if (message.payloadData != null && message.hasOwnProperty("payloadData"))
                        object.payloadData = options.bytes === String ? $util.base64.encode(message.payloadData, 0, message.payloadData.length) : options.bytes === Array ? Array.prototype.slice.call(message.payloadData) : message.payloadData;
                    if (message.errorMsg != null && message.hasOwnProperty("errorMsg"))
                        object.errorMsg = message.errorMsg;
                    if (message.errorData != null && message.hasOwnProperty("errorData"))
                        object.errorData = options.bytes === String ? $util.base64.encode(message.errorData, 0, message.errorData.length) : options.bytes === Array ? Array.prototype.slice.call(message.errorData) : message.errorData;
                    if (message.subBiz != null && message.hasOwnProperty("subBiz"))
                        object.subBiz = message.subBiz;
                    return object;
                };

                /**
                 * Converts this DownstreamPayload to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Basic.DownstreamPayload
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DownstreamPayload.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DownstreamPayload;
            })();

            Basic.PingRequest = (function() {

                /**
                 * Properties of a PingRequest.
                 * @memberof AcFunDanmu.Im.Basic
                 * @interface IPingRequest
                 * @property {AcFunDanmu.Im.Basic.PingRequest.PingType|null} [pingType] PingRequest pingType
                 * @property {number|null} [pingRound] PingRequest pingRound
                 */

                /**
                 * Constructs a new PingRequest.
                 * @memberof AcFunDanmu.Im.Basic
                 * @classdesc Represents a PingRequest.
                 * @implements IPingRequest
                 * @constructor
                 * @param {AcFunDanmu.Im.Basic.IPingRequest=} [properties] Properties to set
                 */
                function PingRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PingRequest pingType.
                 * @member {AcFunDanmu.Im.Basic.PingRequest.PingType} pingType
                 * @memberof AcFunDanmu.Im.Basic.PingRequest
                 * @instance
                 */
                PingRequest.prototype.pingType = 0;

                /**
                 * PingRequest pingRound.
                 * @member {number} pingRound
                 * @memberof AcFunDanmu.Im.Basic.PingRequest
                 * @instance
                 */
                PingRequest.prototype.pingRound = 0;

                /**
                 * Creates a new PingRequest instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Basic.PingRequest
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IPingRequest=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Basic.PingRequest} PingRequest instance
                 */
                PingRequest.create = function create(properties) {
                    return new PingRequest(properties);
                };

                /**
                 * Encodes the specified PingRequest message. Does not implicitly {@link AcFunDanmu.Im.Basic.PingRequest.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Basic.PingRequest
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IPingRequest} message PingRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PingRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.pingType != null && Object.hasOwnProperty.call(message, "pingType"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.pingType);
                    if (message.pingRound != null && Object.hasOwnProperty.call(message, "pingRound"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.pingRound);
                    return writer;
                };

                /**
                 * Encodes the specified PingRequest message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Basic.PingRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Basic.PingRequest
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IPingRequest} message PingRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PingRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a PingRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Basic.PingRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Basic.PingRequest} PingRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PingRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Basic.PingRequest();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.pingType = reader.int32();
                            break;
                        case 2:
                            message.pingRound = reader.uint32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a PingRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Basic.PingRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Basic.PingRequest} PingRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PingRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a PingRequest message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Basic.PingRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PingRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.pingType != null && message.hasOwnProperty("pingType"))
                        switch (message.pingType) {
                        default:
                            return "pingType: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (message.pingRound != null && message.hasOwnProperty("pingRound"))
                        if (!$util.isInteger(message.pingRound))
                            return "pingRound: integer expected";
                    return null;
                };

                /**
                 * Creates a PingRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Basic.PingRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Basic.PingRequest} PingRequest
                 */
                PingRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Basic.PingRequest)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Basic.PingRequest();
                    switch (object.pingType) {
                    case "kInvalid":
                    case 0:
                        message.pingType = 0;
                        break;
                    case "kPriorRegister":
                    case 1:
                        message.pingType = 1;
                        break;
                    case "kPostRegister":
                    case 2:
                        message.pingType = 2;
                        break;
                    }
                    if (object.pingRound != null)
                        message.pingRound = object.pingRound >>> 0;
                    return message;
                };

                /**
                 * Creates a plain object from a PingRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Basic.PingRequest
                 * @static
                 * @param {AcFunDanmu.Im.Basic.PingRequest} message PingRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PingRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.pingType = options.enums === String ? "kInvalid" : 0;
                        object.pingRound = 0;
                    }
                    if (message.pingType != null && message.hasOwnProperty("pingType"))
                        object.pingType = options.enums === String ? $root.AcFunDanmu.Im.Basic.PingRequest.PingType[message.pingType] : message.pingType;
                    if (message.pingRound != null && message.hasOwnProperty("pingRound"))
                        object.pingRound = message.pingRound;
                    return object;
                };

                /**
                 * Converts this PingRequest to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Basic.PingRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PingRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * PingType enum.
                 * @name AcFunDanmu.Im.Basic.PingRequest.PingType
                 * @enum {number}
                 * @property {number} kInvalid=0 kInvalid value
                 * @property {number} kPriorRegister=1 kPriorRegister value
                 * @property {number} kPostRegister=2 kPostRegister value
                 */
                PingRequest.PingType = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "kInvalid"] = 0;
                    values[valuesById[1] = "kPriorRegister"] = 1;
                    values[valuesById[2] = "kPostRegister"] = 2;
                    return values;
                })();

                return PingRequest;
            })();

            Basic.PingResponse = (function() {

                /**
                 * Properties of a PingResponse.
                 * @memberof AcFunDanmu.Im.Basic
                 * @interface IPingResponse
                 * @property {number|null} [serverTimestamp] PingResponse serverTimestamp
                 * @property {number|null} [clientIp] PingResponse clientIp
                 * @property {number|null} [redirectIp] PingResponse redirectIp
                 * @property {number|null} [redirectPort] PingResponse redirectPort
                 */

                /**
                 * Constructs a new PingResponse.
                 * @memberof AcFunDanmu.Im.Basic
                 * @classdesc Represents a PingResponse.
                 * @implements IPingResponse
                 * @constructor
                 * @param {AcFunDanmu.Im.Basic.IPingResponse=} [properties] Properties to set
                 */
                function PingResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PingResponse serverTimestamp.
                 * @member {number} serverTimestamp
                 * @memberof AcFunDanmu.Im.Basic.PingResponse
                 * @instance
                 */
                PingResponse.prototype.serverTimestamp = 0;

                /**
                 * PingResponse clientIp.
                 * @member {number} clientIp
                 * @memberof AcFunDanmu.Im.Basic.PingResponse
                 * @instance
                 */
                PingResponse.prototype.clientIp = 0;

                /**
                 * PingResponse redirectIp.
                 * @member {number} redirectIp
                 * @memberof AcFunDanmu.Im.Basic.PingResponse
                 * @instance
                 */
                PingResponse.prototype.redirectIp = 0;

                /**
                 * PingResponse redirectPort.
                 * @member {number} redirectPort
                 * @memberof AcFunDanmu.Im.Basic.PingResponse
                 * @instance
                 */
                PingResponse.prototype.redirectPort = 0;

                /**
                 * Creates a new PingResponse instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Basic.PingResponse
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IPingResponse=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Basic.PingResponse} PingResponse instance
                 */
                PingResponse.create = function create(properties) {
                    return new PingResponse(properties);
                };

                /**
                 * Encodes the specified PingResponse message. Does not implicitly {@link AcFunDanmu.Im.Basic.PingResponse.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Basic.PingResponse
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IPingResponse} message PingResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PingResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.serverTimestamp != null && Object.hasOwnProperty.call(message, "serverTimestamp"))
                        writer.uint32(/* id 1, wireType 5 =*/13).sfixed32(message.serverTimestamp);
                    if (message.clientIp != null && Object.hasOwnProperty.call(message, "clientIp"))
                        writer.uint32(/* id 2, wireType 5 =*/21).fixed32(message.clientIp);
                    if (message.redirectIp != null && Object.hasOwnProperty.call(message, "redirectIp"))
                        writer.uint32(/* id 3, wireType 5 =*/29).fixed32(message.redirectIp);
                    if (message.redirectPort != null && Object.hasOwnProperty.call(message, "redirectPort"))
                        writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.redirectPort);
                    return writer;
                };

                /**
                 * Encodes the specified PingResponse message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Basic.PingResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Basic.PingResponse
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IPingResponse} message PingResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PingResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a PingResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Basic.PingResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Basic.PingResponse} PingResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PingResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Basic.PingResponse();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.serverTimestamp = reader.sfixed32();
                            break;
                        case 2:
                            message.clientIp = reader.fixed32();
                            break;
                        case 3:
                            message.redirectIp = reader.fixed32();
                            break;
                        case 4:
                            message.redirectPort = reader.uint32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a PingResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Basic.PingResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Basic.PingResponse} PingResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PingResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a PingResponse message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Basic.PingResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PingResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.serverTimestamp != null && message.hasOwnProperty("serverTimestamp"))
                        if (!$util.isInteger(message.serverTimestamp))
                            return "serverTimestamp: integer expected";
                    if (message.clientIp != null && message.hasOwnProperty("clientIp"))
                        if (!$util.isInteger(message.clientIp))
                            return "clientIp: integer expected";
                    if (message.redirectIp != null && message.hasOwnProperty("redirectIp"))
                        if (!$util.isInteger(message.redirectIp))
                            return "redirectIp: integer expected";
                    if (message.redirectPort != null && message.hasOwnProperty("redirectPort"))
                        if (!$util.isInteger(message.redirectPort))
                            return "redirectPort: integer expected";
                    return null;
                };

                /**
                 * Creates a PingResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Basic.PingResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Basic.PingResponse} PingResponse
                 */
                PingResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Basic.PingResponse)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Basic.PingResponse();
                    if (object.serverTimestamp != null)
                        message.serverTimestamp = object.serverTimestamp | 0;
                    if (object.clientIp != null)
                        message.clientIp = object.clientIp >>> 0;
                    if (object.redirectIp != null)
                        message.redirectIp = object.redirectIp >>> 0;
                    if (object.redirectPort != null)
                        message.redirectPort = object.redirectPort >>> 0;
                    return message;
                };

                /**
                 * Creates a plain object from a PingResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Basic.PingResponse
                 * @static
                 * @param {AcFunDanmu.Im.Basic.PingResponse} message PingResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PingResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.serverTimestamp = 0;
                        object.clientIp = 0;
                        object.redirectIp = 0;
                        object.redirectPort = 0;
                    }
                    if (message.serverTimestamp != null && message.hasOwnProperty("serverTimestamp"))
                        object.serverTimestamp = message.serverTimestamp;
                    if (message.clientIp != null && message.hasOwnProperty("clientIp"))
                        object.clientIp = message.clientIp;
                    if (message.redirectIp != null && message.hasOwnProperty("redirectIp"))
                        object.redirectIp = message.redirectIp;
                    if (message.redirectPort != null && message.hasOwnProperty("redirectPort"))
                        object.redirectPort = message.redirectPort;
                    return object;
                };

                /**
                 * Converts this PingResponse to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Basic.PingResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PingResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return PingResponse;
            })();

            Basic.RegisterRequest = (function() {

                /**
                 * Properties of a RegisterRequest.
                 * @memberof AcFunDanmu.Im.Basic
                 * @interface IRegisterRequest
                 * @property {AcFunDanmu.Im.Basic.IAppInfo|null} [appInfo] RegisterRequest appInfo
                 * @property {AcFunDanmu.Im.Basic.IDeviceInfo|null} [deviceInfo] RegisterRequest deviceInfo
                 * @property {AcFunDanmu.Im.Basic.IEnvInfo|null} [envInfo] RegisterRequest envInfo
                 * @property {AcFunDanmu.Im.Basic.RegisterRequest.PresenceStatus|null} [presenceStatus] RegisterRequest presenceStatus
                 * @property {AcFunDanmu.Im.Basic.RegisterRequest.ActiveStatus|null} [appActiveStatus] RegisterRequest appActiveStatus
                 * @property {Uint8Array|null} [appCustomStatus] RegisterRequest appCustomStatus
                 * @property {AcFunDanmu.Im.Basic.IPushServiceToken|null} [pushServiceToken] RegisterRequest pushServiceToken
                 * @property {number|Long|null} [instanceId] RegisterRequest instanceId
                 * @property {Array.<AcFunDanmu.Im.Basic.IPushServiceToken>|null} [pushServiceTokenList] RegisterRequest pushServiceTokenList
                 * @property {number|null} [keepaliveIntervalSec] RegisterRequest keepaliveIntervalSec
                 * @property {AcFunDanmu.Im.Basic.IZtCommonInfo|null} [ztCommonInfo] RegisterRequest ztCommonInfo
                 */

                /**
                 * Constructs a new RegisterRequest.
                 * @memberof AcFunDanmu.Im.Basic
                 * @classdesc Represents a RegisterRequest.
                 * @implements IRegisterRequest
                 * @constructor
                 * @param {AcFunDanmu.Im.Basic.IRegisterRequest=} [properties] Properties to set
                 */
                function RegisterRequest(properties) {
                    this.pushServiceTokenList = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * RegisterRequest appInfo.
                 * @member {AcFunDanmu.Im.Basic.IAppInfo|null|undefined} appInfo
                 * @memberof AcFunDanmu.Im.Basic.RegisterRequest
                 * @instance
                 */
                RegisterRequest.prototype.appInfo = null;

                /**
                 * RegisterRequest deviceInfo.
                 * @member {AcFunDanmu.Im.Basic.IDeviceInfo|null|undefined} deviceInfo
                 * @memberof AcFunDanmu.Im.Basic.RegisterRequest
                 * @instance
                 */
                RegisterRequest.prototype.deviceInfo = null;

                /**
                 * RegisterRequest envInfo.
                 * @member {AcFunDanmu.Im.Basic.IEnvInfo|null|undefined} envInfo
                 * @memberof AcFunDanmu.Im.Basic.RegisterRequest
                 * @instance
                 */
                RegisterRequest.prototype.envInfo = null;

                /**
                 * RegisterRequest presenceStatus.
                 * @member {AcFunDanmu.Im.Basic.RegisterRequest.PresenceStatus} presenceStatus
                 * @memberof AcFunDanmu.Im.Basic.RegisterRequest
                 * @instance
                 */
                RegisterRequest.prototype.presenceStatus = 0;

                /**
                 * RegisterRequest appActiveStatus.
                 * @member {AcFunDanmu.Im.Basic.RegisterRequest.ActiveStatus} appActiveStatus
                 * @memberof AcFunDanmu.Im.Basic.RegisterRequest
                 * @instance
                 */
                RegisterRequest.prototype.appActiveStatus = 0;

                /**
                 * RegisterRequest appCustomStatus.
                 * @member {Uint8Array} appCustomStatus
                 * @memberof AcFunDanmu.Im.Basic.RegisterRequest
                 * @instance
                 */
                RegisterRequest.prototype.appCustomStatus = $util.newBuffer([]);

                /**
                 * RegisterRequest pushServiceToken.
                 * @member {AcFunDanmu.Im.Basic.IPushServiceToken|null|undefined} pushServiceToken
                 * @memberof AcFunDanmu.Im.Basic.RegisterRequest
                 * @instance
                 */
                RegisterRequest.prototype.pushServiceToken = null;

                /**
                 * RegisterRequest instanceId.
                 * @member {number|Long} instanceId
                 * @memberof AcFunDanmu.Im.Basic.RegisterRequest
                 * @instance
                 */
                RegisterRequest.prototype.instanceId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * RegisterRequest pushServiceTokenList.
                 * @member {Array.<AcFunDanmu.Im.Basic.IPushServiceToken>} pushServiceTokenList
                 * @memberof AcFunDanmu.Im.Basic.RegisterRequest
                 * @instance
                 */
                RegisterRequest.prototype.pushServiceTokenList = $util.emptyArray;

                /**
                 * RegisterRequest keepaliveIntervalSec.
                 * @member {number} keepaliveIntervalSec
                 * @memberof AcFunDanmu.Im.Basic.RegisterRequest
                 * @instance
                 */
                RegisterRequest.prototype.keepaliveIntervalSec = 0;

                /**
                 * RegisterRequest ztCommonInfo.
                 * @member {AcFunDanmu.Im.Basic.IZtCommonInfo|null|undefined} ztCommonInfo
                 * @memberof AcFunDanmu.Im.Basic.RegisterRequest
                 * @instance
                 */
                RegisterRequest.prototype.ztCommonInfo = null;

                /**
                 * Creates a new RegisterRequest instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Basic.RegisterRequest
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IRegisterRequest=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Basic.RegisterRequest} RegisterRequest instance
                 */
                RegisterRequest.create = function create(properties) {
                    return new RegisterRequest(properties);
                };

                /**
                 * Encodes the specified RegisterRequest message. Does not implicitly {@link AcFunDanmu.Im.Basic.RegisterRequest.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Basic.RegisterRequest
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IRegisterRequest} message RegisterRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RegisterRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.appInfo != null && Object.hasOwnProperty.call(message, "appInfo"))
                        $root.AcFunDanmu.Im.Basic.AppInfo.encode(message.appInfo, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.deviceInfo != null && Object.hasOwnProperty.call(message, "deviceInfo"))
                        $root.AcFunDanmu.Im.Basic.DeviceInfo.encode(message.deviceInfo, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.envInfo != null && Object.hasOwnProperty.call(message, "envInfo"))
                        $root.AcFunDanmu.Im.Basic.EnvInfo.encode(message.envInfo, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.presenceStatus != null && Object.hasOwnProperty.call(message, "presenceStatus"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.presenceStatus);
                    if (message.appActiveStatus != null && Object.hasOwnProperty.call(message, "appActiveStatus"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.appActiveStatus);
                    if (message.appCustomStatus != null && Object.hasOwnProperty.call(message, "appCustomStatus"))
                        writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.appCustomStatus);
                    if (message.pushServiceToken != null && Object.hasOwnProperty.call(message, "pushServiceToken"))
                        $root.AcFunDanmu.Im.Basic.PushServiceToken.encode(message.pushServiceToken, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.instanceId != null && Object.hasOwnProperty.call(message, "instanceId"))
                        writer.uint32(/* id 8, wireType 0 =*/64).int64(message.instanceId);
                    if (message.pushServiceTokenList != null && message.pushServiceTokenList.length)
                        for (let i = 0; i < message.pushServiceTokenList.length; ++i)
                            $root.AcFunDanmu.Im.Basic.PushServiceToken.encode(message.pushServiceTokenList[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if (message.keepaliveIntervalSec != null && Object.hasOwnProperty.call(message, "keepaliveIntervalSec"))
                        writer.uint32(/* id 10, wireType 0 =*/80).int32(message.keepaliveIntervalSec);
                    if (message.ztCommonInfo != null && Object.hasOwnProperty.call(message, "ztCommonInfo"))
                        $root.AcFunDanmu.Im.Basic.ZtCommonInfo.encode(message.ztCommonInfo, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified RegisterRequest message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Basic.RegisterRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Basic.RegisterRequest
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IRegisterRequest} message RegisterRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RegisterRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a RegisterRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Basic.RegisterRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Basic.RegisterRequest} RegisterRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RegisterRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Basic.RegisterRequest();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.appInfo = $root.AcFunDanmu.Im.Basic.AppInfo.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.deviceInfo = $root.AcFunDanmu.Im.Basic.DeviceInfo.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.envInfo = $root.AcFunDanmu.Im.Basic.EnvInfo.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.presenceStatus = reader.int32();
                            break;
                        case 5:
                            message.appActiveStatus = reader.int32();
                            break;
                        case 6:
                            message.appCustomStatus = reader.bytes();
                            break;
                        case 7:
                            message.pushServiceToken = $root.AcFunDanmu.Im.Basic.PushServiceToken.decode(reader, reader.uint32());
                            break;
                        case 8:
                            message.instanceId = reader.int64();
                            break;
                        case 9:
                            if (!(message.pushServiceTokenList && message.pushServiceTokenList.length))
                                message.pushServiceTokenList = [];
                            message.pushServiceTokenList.push($root.AcFunDanmu.Im.Basic.PushServiceToken.decode(reader, reader.uint32()));
                            break;
                        case 10:
                            message.keepaliveIntervalSec = reader.int32();
                            break;
                        case 11:
                            message.ztCommonInfo = $root.AcFunDanmu.Im.Basic.ZtCommonInfo.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a RegisterRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Basic.RegisterRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Basic.RegisterRequest} RegisterRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RegisterRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a RegisterRequest message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Basic.RegisterRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                RegisterRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.appInfo != null && message.hasOwnProperty("appInfo")) {
                        let error = $root.AcFunDanmu.Im.Basic.AppInfo.verify(message.appInfo);
                        if (error)
                            return "appInfo." + error;
                    }
                    if (message.deviceInfo != null && message.hasOwnProperty("deviceInfo")) {
                        let error = $root.AcFunDanmu.Im.Basic.DeviceInfo.verify(message.deviceInfo);
                        if (error)
                            return "deviceInfo." + error;
                    }
                    if (message.envInfo != null && message.hasOwnProperty("envInfo")) {
                        let error = $root.AcFunDanmu.Im.Basic.EnvInfo.verify(message.envInfo);
                        if (error)
                            return "envInfo." + error;
                    }
                    if (message.presenceStatus != null && message.hasOwnProperty("presenceStatus"))
                        switch (message.presenceStatus) {
                        default:
                            return "presenceStatus: enum value expected";
                        case 0:
                        case 1:
                            break;
                        }
                    if (message.appActiveStatus != null && message.hasOwnProperty("appActiveStatus"))
                        switch (message.appActiveStatus) {
                        default:
                            return "appActiveStatus: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (message.appCustomStatus != null && message.hasOwnProperty("appCustomStatus"))
                        if (!(message.appCustomStatus && typeof message.appCustomStatus.length === "number" || $util.isString(message.appCustomStatus)))
                            return "appCustomStatus: buffer expected";
                    if (message.pushServiceToken != null && message.hasOwnProperty("pushServiceToken")) {
                        let error = $root.AcFunDanmu.Im.Basic.PushServiceToken.verify(message.pushServiceToken);
                        if (error)
                            return "pushServiceToken." + error;
                    }
                    if (message.instanceId != null && message.hasOwnProperty("instanceId"))
                        if (!$util.isInteger(message.instanceId) && !(message.instanceId && $util.isInteger(message.instanceId.low) && $util.isInteger(message.instanceId.high)))
                            return "instanceId: integer|Long expected";
                    if (message.pushServiceTokenList != null && message.hasOwnProperty("pushServiceTokenList")) {
                        if (!Array.isArray(message.pushServiceTokenList))
                            return "pushServiceTokenList: array expected";
                        for (let i = 0; i < message.pushServiceTokenList.length; ++i) {
                            let error = $root.AcFunDanmu.Im.Basic.PushServiceToken.verify(message.pushServiceTokenList[i]);
                            if (error)
                                return "pushServiceTokenList." + error;
                        }
                    }
                    if (message.keepaliveIntervalSec != null && message.hasOwnProperty("keepaliveIntervalSec"))
                        if (!$util.isInteger(message.keepaliveIntervalSec))
                            return "keepaliveIntervalSec: integer expected";
                    if (message.ztCommonInfo != null && message.hasOwnProperty("ztCommonInfo")) {
                        let error = $root.AcFunDanmu.Im.Basic.ZtCommonInfo.verify(message.ztCommonInfo);
                        if (error)
                            return "ztCommonInfo." + error;
                    }
                    return null;
                };

                /**
                 * Creates a RegisterRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Basic.RegisterRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Basic.RegisterRequest} RegisterRequest
                 */
                RegisterRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Basic.RegisterRequest)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Basic.RegisterRequest();
                    if (object.appInfo != null) {
                        if (typeof object.appInfo !== "object")
                            throw TypeError(".AcFunDanmu.Im.Basic.RegisterRequest.appInfo: object expected");
                        message.appInfo = $root.AcFunDanmu.Im.Basic.AppInfo.fromObject(object.appInfo);
                    }
                    if (object.deviceInfo != null) {
                        if (typeof object.deviceInfo !== "object")
                            throw TypeError(".AcFunDanmu.Im.Basic.RegisterRequest.deviceInfo: object expected");
                        message.deviceInfo = $root.AcFunDanmu.Im.Basic.DeviceInfo.fromObject(object.deviceInfo);
                    }
                    if (object.envInfo != null) {
                        if (typeof object.envInfo !== "object")
                            throw TypeError(".AcFunDanmu.Im.Basic.RegisterRequest.envInfo: object expected");
                        message.envInfo = $root.AcFunDanmu.Im.Basic.EnvInfo.fromObject(object.envInfo);
                    }
                    switch (object.presenceStatus) {
                    case "kPresenceOffline":
                    case 0:
                        message.presenceStatus = 0;
                        break;
                    case "kPresenceOnline":
                    case 1:
                        message.presenceStatus = 1;
                        break;
                    }
                    switch (object.appActiveStatus) {
                    case "kInvalid":
                    case 0:
                        message.appActiveStatus = 0;
                        break;
                    case "kAppInForeground":
                    case 1:
                        message.appActiveStatus = 1;
                        break;
                    case "kAppinBackground":
                    case 2:
                        message.appActiveStatus = 2;
                        break;
                    }
                    if (object.appCustomStatus != null)
                        if (typeof object.appCustomStatus === "string")
                            $util.base64.decode(object.appCustomStatus, message.appCustomStatus = $util.newBuffer($util.base64.length(object.appCustomStatus)), 0);
                        else if (object.appCustomStatus.length)
                            message.appCustomStatus = object.appCustomStatus;
                    if (object.pushServiceToken != null) {
                        if (typeof object.pushServiceToken !== "object")
                            throw TypeError(".AcFunDanmu.Im.Basic.RegisterRequest.pushServiceToken: object expected");
                        message.pushServiceToken = $root.AcFunDanmu.Im.Basic.PushServiceToken.fromObject(object.pushServiceToken);
                    }
                    if (object.instanceId != null)
                        if ($util.Long)
                            (message.instanceId = $util.Long.fromValue(object.instanceId)).unsigned = false;
                        else if (typeof object.instanceId === "string")
                            message.instanceId = parseInt(object.instanceId, 10);
                        else if (typeof object.instanceId === "number")
                            message.instanceId = object.instanceId;
                        else if (typeof object.instanceId === "object")
                            message.instanceId = new $util.LongBits(object.instanceId.low >>> 0, object.instanceId.high >>> 0).toNumber();
                    if (object.pushServiceTokenList) {
                        if (!Array.isArray(object.pushServiceTokenList))
                            throw TypeError(".AcFunDanmu.Im.Basic.RegisterRequest.pushServiceTokenList: array expected");
                        message.pushServiceTokenList = [];
                        for (let i = 0; i < object.pushServiceTokenList.length; ++i) {
                            if (typeof object.pushServiceTokenList[i] !== "object")
                                throw TypeError(".AcFunDanmu.Im.Basic.RegisterRequest.pushServiceTokenList: object expected");
                            message.pushServiceTokenList[i] = $root.AcFunDanmu.Im.Basic.PushServiceToken.fromObject(object.pushServiceTokenList[i]);
                        }
                    }
                    if (object.keepaliveIntervalSec != null)
                        message.keepaliveIntervalSec = object.keepaliveIntervalSec | 0;
                    if (object.ztCommonInfo != null) {
                        if (typeof object.ztCommonInfo !== "object")
                            throw TypeError(".AcFunDanmu.Im.Basic.RegisterRequest.ztCommonInfo: object expected");
                        message.ztCommonInfo = $root.AcFunDanmu.Im.Basic.ZtCommonInfo.fromObject(object.ztCommonInfo);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a RegisterRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Basic.RegisterRequest
                 * @static
                 * @param {AcFunDanmu.Im.Basic.RegisterRequest} message RegisterRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RegisterRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.pushServiceTokenList = [];
                    if (options.defaults) {
                        object.appInfo = null;
                        object.deviceInfo = null;
                        object.envInfo = null;
                        object.presenceStatus = options.enums === String ? "kPresenceOffline" : 0;
                        object.appActiveStatus = options.enums === String ? "kInvalid" : 0;
                        if (options.bytes === String)
                            object.appCustomStatus = "";
                        else {
                            object.appCustomStatus = [];
                            if (options.bytes !== Array)
                                object.appCustomStatus = $util.newBuffer(object.appCustomStatus);
                        }
                        object.pushServiceToken = null;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.instanceId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.instanceId = options.longs === String ? "0" : 0;
                        object.keepaliveIntervalSec = 0;
                        object.ztCommonInfo = null;
                    }
                    if (message.appInfo != null && message.hasOwnProperty("appInfo"))
                        object.appInfo = $root.AcFunDanmu.Im.Basic.AppInfo.toObject(message.appInfo, options);
                    if (message.deviceInfo != null && message.hasOwnProperty("deviceInfo"))
                        object.deviceInfo = $root.AcFunDanmu.Im.Basic.DeviceInfo.toObject(message.deviceInfo, options);
                    if (message.envInfo != null && message.hasOwnProperty("envInfo"))
                        object.envInfo = $root.AcFunDanmu.Im.Basic.EnvInfo.toObject(message.envInfo, options);
                    if (message.presenceStatus != null && message.hasOwnProperty("presenceStatus"))
                        object.presenceStatus = options.enums === String ? $root.AcFunDanmu.Im.Basic.RegisterRequest.PresenceStatus[message.presenceStatus] : message.presenceStatus;
                    if (message.appActiveStatus != null && message.hasOwnProperty("appActiveStatus"))
                        object.appActiveStatus = options.enums === String ? $root.AcFunDanmu.Im.Basic.RegisterRequest.ActiveStatus[message.appActiveStatus] : message.appActiveStatus;
                    if (message.appCustomStatus != null && message.hasOwnProperty("appCustomStatus"))
                        object.appCustomStatus = options.bytes === String ? $util.base64.encode(message.appCustomStatus, 0, message.appCustomStatus.length) : options.bytes === Array ? Array.prototype.slice.call(message.appCustomStatus) : message.appCustomStatus;
                    if (message.pushServiceToken != null && message.hasOwnProperty("pushServiceToken"))
                        object.pushServiceToken = $root.AcFunDanmu.Im.Basic.PushServiceToken.toObject(message.pushServiceToken, options);
                    if (message.instanceId != null && message.hasOwnProperty("instanceId"))
                        if (typeof message.instanceId === "number")
                            object.instanceId = options.longs === String ? String(message.instanceId) : message.instanceId;
                        else
                            object.instanceId = options.longs === String ? $util.Long.prototype.toString.call(message.instanceId) : options.longs === Number ? new $util.LongBits(message.instanceId.low >>> 0, message.instanceId.high >>> 0).toNumber() : message.instanceId;
                    if (message.pushServiceTokenList && message.pushServiceTokenList.length) {
                        object.pushServiceTokenList = [];
                        for (let j = 0; j < message.pushServiceTokenList.length; ++j)
                            object.pushServiceTokenList[j] = $root.AcFunDanmu.Im.Basic.PushServiceToken.toObject(message.pushServiceTokenList[j], options);
                    }
                    if (message.keepaliveIntervalSec != null && message.hasOwnProperty("keepaliveIntervalSec"))
                        object.keepaliveIntervalSec = message.keepaliveIntervalSec;
                    if (message.ztCommonInfo != null && message.hasOwnProperty("ztCommonInfo"))
                        object.ztCommonInfo = $root.AcFunDanmu.Im.Basic.ZtCommonInfo.toObject(message.ztCommonInfo, options);
                    return object;
                };

                /**
                 * Converts this RegisterRequest to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Basic.RegisterRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                RegisterRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * PresenceStatus enum.
                 * @name AcFunDanmu.Im.Basic.RegisterRequest.PresenceStatus
                 * @enum {number}
                 * @property {number} kPresenceOffline=0 kPresenceOffline value
                 * @property {number} kPresenceOnline=1 kPresenceOnline value
                 */
                RegisterRequest.PresenceStatus = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "kPresenceOffline"] = 0;
                    values[valuesById[1] = "kPresenceOnline"] = 1;
                    return values;
                })();

                /**
                 * ActiveStatus enum.
                 * @name AcFunDanmu.Im.Basic.RegisterRequest.ActiveStatus
                 * @enum {number}
                 * @property {number} kInvalid=0 kInvalid value
                 * @property {number} kAppInForeground=1 kAppInForeground value
                 * @property {number} kAppinBackground=2 kAppinBackground value
                 */
                RegisterRequest.ActiveStatus = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "kInvalid"] = 0;
                    values[valuesById[1] = "kAppInForeground"] = 1;
                    values[valuesById[2] = "kAppinBackground"] = 2;
                    return values;
                })();

                return RegisterRequest;
            })();

            Basic.RegisterResponse = (function() {

                /**
                 * Properties of a RegisterResponse.
                 * @memberof AcFunDanmu.Im.Basic
                 * @interface IRegisterResponse
                 * @property {AcFunDanmu.Im.Basic.IAccessPointsConfig|null} [accessPointsConfig] RegisterResponse accessPointsConfig
                 * @property {Uint8Array|null} [sessKey] RegisterResponse sessKey
                 * @property {number|Long|null} [instanceId] RegisterResponse instanceId
                 * @property {AcFunDanmu.Im.Basic.ISdkOption|null} [sdkOption] RegisterResponse sdkOption
                 * @property {AcFunDanmu.Im.Basic.IAccessPointsConfig|null} [accessPointsCOnfigIpv6] RegisterResponse accessPointsCOnfigIpv6
                 */

                /**
                 * Constructs a new RegisterResponse.
                 * @memberof AcFunDanmu.Im.Basic
                 * @classdesc Represents a RegisterResponse.
                 * @implements IRegisterResponse
                 * @constructor
                 * @param {AcFunDanmu.Im.Basic.IRegisterResponse=} [properties] Properties to set
                 */
                function RegisterResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * RegisterResponse accessPointsConfig.
                 * @member {AcFunDanmu.Im.Basic.IAccessPointsConfig|null|undefined} accessPointsConfig
                 * @memberof AcFunDanmu.Im.Basic.RegisterResponse
                 * @instance
                 */
                RegisterResponse.prototype.accessPointsConfig = null;

                /**
                 * RegisterResponse sessKey.
                 * @member {Uint8Array} sessKey
                 * @memberof AcFunDanmu.Im.Basic.RegisterResponse
                 * @instance
                 */
                RegisterResponse.prototype.sessKey = $util.newBuffer([]);

                /**
                 * RegisterResponse instanceId.
                 * @member {number|Long} instanceId
                 * @memberof AcFunDanmu.Im.Basic.RegisterResponse
                 * @instance
                 */
                RegisterResponse.prototype.instanceId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * RegisterResponse sdkOption.
                 * @member {AcFunDanmu.Im.Basic.ISdkOption|null|undefined} sdkOption
                 * @memberof AcFunDanmu.Im.Basic.RegisterResponse
                 * @instance
                 */
                RegisterResponse.prototype.sdkOption = null;

                /**
                 * RegisterResponse accessPointsCOnfigIpv6.
                 * @member {AcFunDanmu.Im.Basic.IAccessPointsConfig|null|undefined} accessPointsCOnfigIpv6
                 * @memberof AcFunDanmu.Im.Basic.RegisterResponse
                 * @instance
                 */
                RegisterResponse.prototype.accessPointsCOnfigIpv6 = null;

                /**
                 * Creates a new RegisterResponse instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Basic.RegisterResponse
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IRegisterResponse=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Basic.RegisterResponse} RegisterResponse instance
                 */
                RegisterResponse.create = function create(properties) {
                    return new RegisterResponse(properties);
                };

                /**
                 * Encodes the specified RegisterResponse message. Does not implicitly {@link AcFunDanmu.Im.Basic.RegisterResponse.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Basic.RegisterResponse
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IRegisterResponse} message RegisterResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RegisterResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.accessPointsConfig != null && Object.hasOwnProperty.call(message, "accessPointsConfig"))
                        $root.AcFunDanmu.Im.Basic.AccessPointsConfig.encode(message.accessPointsConfig, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.sessKey != null && Object.hasOwnProperty.call(message, "sessKey"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.sessKey);
                    if (message.instanceId != null && Object.hasOwnProperty.call(message, "instanceId"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int64(message.instanceId);
                    if (message.sdkOption != null && Object.hasOwnProperty.call(message, "sdkOption"))
                        $root.AcFunDanmu.Im.Basic.SdkOption.encode(message.sdkOption, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.accessPointsCOnfigIpv6 != null && Object.hasOwnProperty.call(message, "accessPointsCOnfigIpv6"))
                        $root.AcFunDanmu.Im.Basic.AccessPointsConfig.encode(message.accessPointsCOnfigIpv6, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified RegisterResponse message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Basic.RegisterResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Basic.RegisterResponse
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IRegisterResponse} message RegisterResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RegisterResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a RegisterResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Basic.RegisterResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Basic.RegisterResponse} RegisterResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RegisterResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Basic.RegisterResponse();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.accessPointsConfig = $root.AcFunDanmu.Im.Basic.AccessPointsConfig.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.sessKey = reader.bytes();
                            break;
                        case 3:
                            message.instanceId = reader.int64();
                            break;
                        case 4:
                            message.sdkOption = $root.AcFunDanmu.Im.Basic.SdkOption.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.accessPointsCOnfigIpv6 = $root.AcFunDanmu.Im.Basic.AccessPointsConfig.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a RegisterResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Basic.RegisterResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Basic.RegisterResponse} RegisterResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RegisterResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a RegisterResponse message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Basic.RegisterResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                RegisterResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.accessPointsConfig != null && message.hasOwnProperty("accessPointsConfig")) {
                        let error = $root.AcFunDanmu.Im.Basic.AccessPointsConfig.verify(message.accessPointsConfig);
                        if (error)
                            return "accessPointsConfig." + error;
                    }
                    if (message.sessKey != null && message.hasOwnProperty("sessKey"))
                        if (!(message.sessKey && typeof message.sessKey.length === "number" || $util.isString(message.sessKey)))
                            return "sessKey: buffer expected";
                    if (message.instanceId != null && message.hasOwnProperty("instanceId"))
                        if (!$util.isInteger(message.instanceId) && !(message.instanceId && $util.isInteger(message.instanceId.low) && $util.isInteger(message.instanceId.high)))
                            return "instanceId: integer|Long expected";
                    if (message.sdkOption != null && message.hasOwnProperty("sdkOption")) {
                        let error = $root.AcFunDanmu.Im.Basic.SdkOption.verify(message.sdkOption);
                        if (error)
                            return "sdkOption." + error;
                    }
                    if (message.accessPointsCOnfigIpv6 != null && message.hasOwnProperty("accessPointsCOnfigIpv6")) {
                        let error = $root.AcFunDanmu.Im.Basic.AccessPointsConfig.verify(message.accessPointsCOnfigIpv6);
                        if (error)
                            return "accessPointsCOnfigIpv6." + error;
                    }
                    return null;
                };

                /**
                 * Creates a RegisterResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Basic.RegisterResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Basic.RegisterResponse} RegisterResponse
                 */
                RegisterResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Basic.RegisterResponse)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Basic.RegisterResponse();
                    if (object.accessPointsConfig != null) {
                        if (typeof object.accessPointsConfig !== "object")
                            throw TypeError(".AcFunDanmu.Im.Basic.RegisterResponse.accessPointsConfig: object expected");
                        message.accessPointsConfig = $root.AcFunDanmu.Im.Basic.AccessPointsConfig.fromObject(object.accessPointsConfig);
                    }
                    if (object.sessKey != null)
                        if (typeof object.sessKey === "string")
                            $util.base64.decode(object.sessKey, message.sessKey = $util.newBuffer($util.base64.length(object.sessKey)), 0);
                        else if (object.sessKey.length)
                            message.sessKey = object.sessKey;
                    if (object.instanceId != null)
                        if ($util.Long)
                            (message.instanceId = $util.Long.fromValue(object.instanceId)).unsigned = false;
                        else if (typeof object.instanceId === "string")
                            message.instanceId = parseInt(object.instanceId, 10);
                        else if (typeof object.instanceId === "number")
                            message.instanceId = object.instanceId;
                        else if (typeof object.instanceId === "object")
                            message.instanceId = new $util.LongBits(object.instanceId.low >>> 0, object.instanceId.high >>> 0).toNumber();
                    if (object.sdkOption != null) {
                        if (typeof object.sdkOption !== "object")
                            throw TypeError(".AcFunDanmu.Im.Basic.RegisterResponse.sdkOption: object expected");
                        message.sdkOption = $root.AcFunDanmu.Im.Basic.SdkOption.fromObject(object.sdkOption);
                    }
                    if (object.accessPointsCOnfigIpv6 != null) {
                        if (typeof object.accessPointsCOnfigIpv6 !== "object")
                            throw TypeError(".AcFunDanmu.Im.Basic.RegisterResponse.accessPointsCOnfigIpv6: object expected");
                        message.accessPointsCOnfigIpv6 = $root.AcFunDanmu.Im.Basic.AccessPointsConfig.fromObject(object.accessPointsCOnfigIpv6);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a RegisterResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Basic.RegisterResponse
                 * @static
                 * @param {AcFunDanmu.Im.Basic.RegisterResponse} message RegisterResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RegisterResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.accessPointsConfig = null;
                        if (options.bytes === String)
                            object.sessKey = "";
                        else {
                            object.sessKey = [];
                            if (options.bytes !== Array)
                                object.sessKey = $util.newBuffer(object.sessKey);
                        }
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.instanceId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.instanceId = options.longs === String ? "0" : 0;
                        object.sdkOption = null;
                        object.accessPointsCOnfigIpv6 = null;
                    }
                    if (message.accessPointsConfig != null && message.hasOwnProperty("accessPointsConfig"))
                        object.accessPointsConfig = $root.AcFunDanmu.Im.Basic.AccessPointsConfig.toObject(message.accessPointsConfig, options);
                    if (message.sessKey != null && message.hasOwnProperty("sessKey"))
                        object.sessKey = options.bytes === String ? $util.base64.encode(message.sessKey, 0, message.sessKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.sessKey) : message.sessKey;
                    if (message.instanceId != null && message.hasOwnProperty("instanceId"))
                        if (typeof message.instanceId === "number")
                            object.instanceId = options.longs === String ? String(message.instanceId) : message.instanceId;
                        else
                            object.instanceId = options.longs === String ? $util.Long.prototype.toString.call(message.instanceId) : options.longs === Number ? new $util.LongBits(message.instanceId.low >>> 0, message.instanceId.high >>> 0).toNumber() : message.instanceId;
                    if (message.sdkOption != null && message.hasOwnProperty("sdkOption"))
                        object.sdkOption = $root.AcFunDanmu.Im.Basic.SdkOption.toObject(message.sdkOption, options);
                    if (message.accessPointsCOnfigIpv6 != null && message.hasOwnProperty("accessPointsCOnfigIpv6"))
                        object.accessPointsCOnfigIpv6 = $root.AcFunDanmu.Im.Basic.AccessPointsConfig.toObject(message.accessPointsCOnfigIpv6, options);
                    return object;
                };

                /**
                 * Converts this RegisterResponse to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Basic.RegisterResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                RegisterResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return RegisterResponse;
            })();

            Basic.AccessPointsConfig = (function() {

                /**
                 * Properties of an AccessPointsConfig.
                 * @memberof AcFunDanmu.Im.Basic
                 * @interface IAccessPointsConfig
                 * @property {Array.<AcFunDanmu.Im.Basic.IAccessPoint>|null} [optimalAps] AccessPointsConfig optimalAps
                 * @property {Array.<AcFunDanmu.Im.Basic.IAccessPoint>|null} [backupAps] AccessPointsConfig backupAps
                 * @property {Array.<number>|null} [availablePorts] AccessPointsConfig availablePorts
                 * @property {AcFunDanmu.Im.Basic.IAccessPoint|null} [foreceLastConnectedAp] AccessPointsConfig foreceLastConnectedAp
                 */

                /**
                 * Constructs a new AccessPointsConfig.
                 * @memberof AcFunDanmu.Im.Basic
                 * @classdesc Represents an AccessPointsConfig.
                 * @implements IAccessPointsConfig
                 * @constructor
                 * @param {AcFunDanmu.Im.Basic.IAccessPointsConfig=} [properties] Properties to set
                 */
                function AccessPointsConfig(properties) {
                    this.optimalAps = [];
                    this.backupAps = [];
                    this.availablePorts = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * AccessPointsConfig optimalAps.
                 * @member {Array.<AcFunDanmu.Im.Basic.IAccessPoint>} optimalAps
                 * @memberof AcFunDanmu.Im.Basic.AccessPointsConfig
                 * @instance
                 */
                AccessPointsConfig.prototype.optimalAps = $util.emptyArray;

                /**
                 * AccessPointsConfig backupAps.
                 * @member {Array.<AcFunDanmu.Im.Basic.IAccessPoint>} backupAps
                 * @memberof AcFunDanmu.Im.Basic.AccessPointsConfig
                 * @instance
                 */
                AccessPointsConfig.prototype.backupAps = $util.emptyArray;

                /**
                 * AccessPointsConfig availablePorts.
                 * @member {Array.<number>} availablePorts
                 * @memberof AcFunDanmu.Im.Basic.AccessPointsConfig
                 * @instance
                 */
                AccessPointsConfig.prototype.availablePorts = $util.emptyArray;

                /**
                 * AccessPointsConfig foreceLastConnectedAp.
                 * @member {AcFunDanmu.Im.Basic.IAccessPoint|null|undefined} foreceLastConnectedAp
                 * @memberof AcFunDanmu.Im.Basic.AccessPointsConfig
                 * @instance
                 */
                AccessPointsConfig.prototype.foreceLastConnectedAp = null;

                /**
                 * Creates a new AccessPointsConfig instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Basic.AccessPointsConfig
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IAccessPointsConfig=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Basic.AccessPointsConfig} AccessPointsConfig instance
                 */
                AccessPointsConfig.create = function create(properties) {
                    return new AccessPointsConfig(properties);
                };

                /**
                 * Encodes the specified AccessPointsConfig message. Does not implicitly {@link AcFunDanmu.Im.Basic.AccessPointsConfig.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Basic.AccessPointsConfig
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IAccessPointsConfig} message AccessPointsConfig message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AccessPointsConfig.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.optimalAps != null && message.optimalAps.length)
                        for (let i = 0; i < message.optimalAps.length; ++i)
                            $root.AcFunDanmu.Im.Basic.AccessPoint.encode(message.optimalAps[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.backupAps != null && message.backupAps.length)
                        for (let i = 0; i < message.backupAps.length; ++i)
                            $root.AcFunDanmu.Im.Basic.AccessPoint.encode(message.backupAps[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.availablePorts != null && message.availablePorts.length) {
                        writer.uint32(/* id 3, wireType 2 =*/26).fork();
                        for (let i = 0; i < message.availablePorts.length; ++i)
                            writer.uint32(message.availablePorts[i]);
                        writer.ldelim();
                    }
                    if (message.foreceLastConnectedAp != null && Object.hasOwnProperty.call(message, "foreceLastConnectedAp"))
                        $root.AcFunDanmu.Im.Basic.AccessPoint.encode(message.foreceLastConnectedAp, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified AccessPointsConfig message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Basic.AccessPointsConfig.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Basic.AccessPointsConfig
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IAccessPointsConfig} message AccessPointsConfig message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AccessPointsConfig.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an AccessPointsConfig message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Basic.AccessPointsConfig
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Basic.AccessPointsConfig} AccessPointsConfig
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AccessPointsConfig.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Basic.AccessPointsConfig();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.optimalAps && message.optimalAps.length))
                                message.optimalAps = [];
                            message.optimalAps.push($root.AcFunDanmu.Im.Basic.AccessPoint.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            if (!(message.backupAps && message.backupAps.length))
                                message.backupAps = [];
                            message.backupAps.push($root.AcFunDanmu.Im.Basic.AccessPoint.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            if (!(message.availablePorts && message.availablePorts.length))
                                message.availablePorts = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.availablePorts.push(reader.uint32());
                            } else
                                message.availablePorts.push(reader.uint32());
                            break;
                        case 4:
                            message.foreceLastConnectedAp = $root.AcFunDanmu.Im.Basic.AccessPoint.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an AccessPointsConfig message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Basic.AccessPointsConfig
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Basic.AccessPointsConfig} AccessPointsConfig
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AccessPointsConfig.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an AccessPointsConfig message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Basic.AccessPointsConfig
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                AccessPointsConfig.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.optimalAps != null && message.hasOwnProperty("optimalAps")) {
                        if (!Array.isArray(message.optimalAps))
                            return "optimalAps: array expected";
                        for (let i = 0; i < message.optimalAps.length; ++i) {
                            let error = $root.AcFunDanmu.Im.Basic.AccessPoint.verify(message.optimalAps[i]);
                            if (error)
                                return "optimalAps." + error;
                        }
                    }
                    if (message.backupAps != null && message.hasOwnProperty("backupAps")) {
                        if (!Array.isArray(message.backupAps))
                            return "backupAps: array expected";
                        for (let i = 0; i < message.backupAps.length; ++i) {
                            let error = $root.AcFunDanmu.Im.Basic.AccessPoint.verify(message.backupAps[i]);
                            if (error)
                                return "backupAps." + error;
                        }
                    }
                    if (message.availablePorts != null && message.hasOwnProperty("availablePorts")) {
                        if (!Array.isArray(message.availablePorts))
                            return "availablePorts: array expected";
                        for (let i = 0; i < message.availablePorts.length; ++i)
                            if (!$util.isInteger(message.availablePorts[i]))
                                return "availablePorts: integer[] expected";
                    }
                    if (message.foreceLastConnectedAp != null && message.hasOwnProperty("foreceLastConnectedAp")) {
                        let error = $root.AcFunDanmu.Im.Basic.AccessPoint.verify(message.foreceLastConnectedAp);
                        if (error)
                            return "foreceLastConnectedAp." + error;
                    }
                    return null;
                };

                /**
                 * Creates an AccessPointsConfig message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Basic.AccessPointsConfig
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Basic.AccessPointsConfig} AccessPointsConfig
                 */
                AccessPointsConfig.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Basic.AccessPointsConfig)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Basic.AccessPointsConfig();
                    if (object.optimalAps) {
                        if (!Array.isArray(object.optimalAps))
                            throw TypeError(".AcFunDanmu.Im.Basic.AccessPointsConfig.optimalAps: array expected");
                        message.optimalAps = [];
                        for (let i = 0; i < object.optimalAps.length; ++i) {
                            if (typeof object.optimalAps[i] !== "object")
                                throw TypeError(".AcFunDanmu.Im.Basic.AccessPointsConfig.optimalAps: object expected");
                            message.optimalAps[i] = $root.AcFunDanmu.Im.Basic.AccessPoint.fromObject(object.optimalAps[i]);
                        }
                    }
                    if (object.backupAps) {
                        if (!Array.isArray(object.backupAps))
                            throw TypeError(".AcFunDanmu.Im.Basic.AccessPointsConfig.backupAps: array expected");
                        message.backupAps = [];
                        for (let i = 0; i < object.backupAps.length; ++i) {
                            if (typeof object.backupAps[i] !== "object")
                                throw TypeError(".AcFunDanmu.Im.Basic.AccessPointsConfig.backupAps: object expected");
                            message.backupAps[i] = $root.AcFunDanmu.Im.Basic.AccessPoint.fromObject(object.backupAps[i]);
                        }
                    }
                    if (object.availablePorts) {
                        if (!Array.isArray(object.availablePorts))
                            throw TypeError(".AcFunDanmu.Im.Basic.AccessPointsConfig.availablePorts: array expected");
                        message.availablePorts = [];
                        for (let i = 0; i < object.availablePorts.length; ++i)
                            message.availablePorts[i] = object.availablePorts[i] >>> 0;
                    }
                    if (object.foreceLastConnectedAp != null) {
                        if (typeof object.foreceLastConnectedAp !== "object")
                            throw TypeError(".AcFunDanmu.Im.Basic.AccessPointsConfig.foreceLastConnectedAp: object expected");
                        message.foreceLastConnectedAp = $root.AcFunDanmu.Im.Basic.AccessPoint.fromObject(object.foreceLastConnectedAp);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an AccessPointsConfig message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Basic.AccessPointsConfig
                 * @static
                 * @param {AcFunDanmu.Im.Basic.AccessPointsConfig} message AccessPointsConfig
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                AccessPointsConfig.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults) {
                        object.optimalAps = [];
                        object.backupAps = [];
                        object.availablePorts = [];
                    }
                    if (options.defaults)
                        object.foreceLastConnectedAp = null;
                    if (message.optimalAps && message.optimalAps.length) {
                        object.optimalAps = [];
                        for (let j = 0; j < message.optimalAps.length; ++j)
                            object.optimalAps[j] = $root.AcFunDanmu.Im.Basic.AccessPoint.toObject(message.optimalAps[j], options);
                    }
                    if (message.backupAps && message.backupAps.length) {
                        object.backupAps = [];
                        for (let j = 0; j < message.backupAps.length; ++j)
                            object.backupAps[j] = $root.AcFunDanmu.Im.Basic.AccessPoint.toObject(message.backupAps[j], options);
                    }
                    if (message.availablePorts && message.availablePorts.length) {
                        object.availablePorts = [];
                        for (let j = 0; j < message.availablePorts.length; ++j)
                            object.availablePorts[j] = message.availablePorts[j];
                    }
                    if (message.foreceLastConnectedAp != null && message.hasOwnProperty("foreceLastConnectedAp"))
                        object.foreceLastConnectedAp = $root.AcFunDanmu.Im.Basic.AccessPoint.toObject(message.foreceLastConnectedAp, options);
                    return object;
                };

                /**
                 * Converts this AccessPointsConfig to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Basic.AccessPointsConfig
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                AccessPointsConfig.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return AccessPointsConfig;
            })();

            Basic.UnregisterRequest = (function() {

                /**
                 * Properties of an UnregisterRequest.
                 * @memberof AcFunDanmu.Im.Basic
                 * @interface IUnregisterRequest
                 */

                /**
                 * Constructs a new UnregisterRequest.
                 * @memberof AcFunDanmu.Im.Basic
                 * @classdesc Represents an UnregisterRequest.
                 * @implements IUnregisterRequest
                 * @constructor
                 * @param {AcFunDanmu.Im.Basic.IUnregisterRequest=} [properties] Properties to set
                 */
                function UnregisterRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new UnregisterRequest instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Basic.UnregisterRequest
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IUnregisterRequest=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Basic.UnregisterRequest} UnregisterRequest instance
                 */
                UnregisterRequest.create = function create(properties) {
                    return new UnregisterRequest(properties);
                };

                /**
                 * Encodes the specified UnregisterRequest message. Does not implicitly {@link AcFunDanmu.Im.Basic.UnregisterRequest.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Basic.UnregisterRequest
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IUnregisterRequest} message UnregisterRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UnregisterRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified UnregisterRequest message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Basic.UnregisterRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Basic.UnregisterRequest
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IUnregisterRequest} message UnregisterRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UnregisterRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an UnregisterRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Basic.UnregisterRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Basic.UnregisterRequest} UnregisterRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UnregisterRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Basic.UnregisterRequest();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an UnregisterRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Basic.UnregisterRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Basic.UnregisterRequest} UnregisterRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UnregisterRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an UnregisterRequest message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Basic.UnregisterRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                UnregisterRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates an UnregisterRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Basic.UnregisterRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Basic.UnregisterRequest} UnregisterRequest
                 */
                UnregisterRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Basic.UnregisterRequest)
                        return object;
                    return new $root.AcFunDanmu.Im.Basic.UnregisterRequest();
                };

                /**
                 * Creates a plain object from an UnregisterRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Basic.UnregisterRequest
                 * @static
                 * @param {AcFunDanmu.Im.Basic.UnregisterRequest} message UnregisterRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                UnregisterRequest.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this UnregisterRequest to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Basic.UnregisterRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                UnregisterRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return UnregisterRequest;
            })();

            Basic.UnregisterResponse = (function() {

                /**
                 * Properties of an UnregisterResponse.
                 * @memberof AcFunDanmu.Im.Basic
                 * @interface IUnregisterResponse
                 */

                /**
                 * Constructs a new UnregisterResponse.
                 * @memberof AcFunDanmu.Im.Basic
                 * @classdesc Represents an UnregisterResponse.
                 * @implements IUnregisterResponse
                 * @constructor
                 * @param {AcFunDanmu.Im.Basic.IUnregisterResponse=} [properties] Properties to set
                 */
                function UnregisterResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new UnregisterResponse instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Basic.UnregisterResponse
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IUnregisterResponse=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Basic.UnregisterResponse} UnregisterResponse instance
                 */
                UnregisterResponse.create = function create(properties) {
                    return new UnregisterResponse(properties);
                };

                /**
                 * Encodes the specified UnregisterResponse message. Does not implicitly {@link AcFunDanmu.Im.Basic.UnregisterResponse.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Basic.UnregisterResponse
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IUnregisterResponse} message UnregisterResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UnregisterResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified UnregisterResponse message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Basic.UnregisterResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Basic.UnregisterResponse
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IUnregisterResponse} message UnregisterResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UnregisterResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an UnregisterResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Basic.UnregisterResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Basic.UnregisterResponse} UnregisterResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UnregisterResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Basic.UnregisterResponse();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an UnregisterResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Basic.UnregisterResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Basic.UnregisterResponse} UnregisterResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UnregisterResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an UnregisterResponse message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Basic.UnregisterResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                UnregisterResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates an UnregisterResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Basic.UnregisterResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Basic.UnregisterResponse} UnregisterResponse
                 */
                UnregisterResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Basic.UnregisterResponse)
                        return object;
                    return new $root.AcFunDanmu.Im.Basic.UnregisterResponse();
                };

                /**
                 * Creates a plain object from an UnregisterResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Basic.UnregisterResponse
                 * @static
                 * @param {AcFunDanmu.Im.Basic.UnregisterResponse} message UnregisterResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                UnregisterResponse.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this UnregisterResponse to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Basic.UnregisterResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                UnregisterResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return UnregisterResponse;
            })();

            Basic.KeepAliveRequest = (function() {

                /**
                 * Properties of a KeepAliveRequest.
                 * @memberof AcFunDanmu.Im.Basic
                 * @interface IKeepAliveRequest
                 * @property {AcFunDanmu.Im.Basic.RegisterRequest.PresenceStatus|null} [presenceStatus] KeepAliveRequest presenceStatus
                 * @property {AcFunDanmu.Im.Basic.RegisterRequest.ActiveStatus|null} [appActiveStatus] KeepAliveRequest appActiveStatus
                 * @property {AcFunDanmu.Im.Basic.IPushServiceToken|null} [pushServiceToken] KeepAliveRequest pushServiceToken
                 * @property {Array.<AcFunDanmu.Im.Basic.IPushServiceToken>|null} [pushServiceTokenList] KeepAliveRequest pushServiceTokenList
                 * @property {number|null} [keepaliveIntervalSec] KeepAliveRequest keepaliveIntervalSec
                 */

                /**
                 * Constructs a new KeepAliveRequest.
                 * @memberof AcFunDanmu.Im.Basic
                 * @classdesc Represents a KeepAliveRequest.
                 * @implements IKeepAliveRequest
                 * @constructor
                 * @param {AcFunDanmu.Im.Basic.IKeepAliveRequest=} [properties] Properties to set
                 */
                function KeepAliveRequest(properties) {
                    this.pushServiceTokenList = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * KeepAliveRequest presenceStatus.
                 * @member {AcFunDanmu.Im.Basic.RegisterRequest.PresenceStatus} presenceStatus
                 * @memberof AcFunDanmu.Im.Basic.KeepAliveRequest
                 * @instance
                 */
                KeepAliveRequest.prototype.presenceStatus = 0;

                /**
                 * KeepAliveRequest appActiveStatus.
                 * @member {AcFunDanmu.Im.Basic.RegisterRequest.ActiveStatus} appActiveStatus
                 * @memberof AcFunDanmu.Im.Basic.KeepAliveRequest
                 * @instance
                 */
                KeepAliveRequest.prototype.appActiveStatus = 0;

                /**
                 * KeepAliveRequest pushServiceToken.
                 * @member {AcFunDanmu.Im.Basic.IPushServiceToken|null|undefined} pushServiceToken
                 * @memberof AcFunDanmu.Im.Basic.KeepAliveRequest
                 * @instance
                 */
                KeepAliveRequest.prototype.pushServiceToken = null;

                /**
                 * KeepAliveRequest pushServiceTokenList.
                 * @member {Array.<AcFunDanmu.Im.Basic.IPushServiceToken>} pushServiceTokenList
                 * @memberof AcFunDanmu.Im.Basic.KeepAliveRequest
                 * @instance
                 */
                KeepAliveRequest.prototype.pushServiceTokenList = $util.emptyArray;

                /**
                 * KeepAliveRequest keepaliveIntervalSec.
                 * @member {number} keepaliveIntervalSec
                 * @memberof AcFunDanmu.Im.Basic.KeepAliveRequest
                 * @instance
                 */
                KeepAliveRequest.prototype.keepaliveIntervalSec = 0;

                /**
                 * Creates a new KeepAliveRequest instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Basic.KeepAliveRequest
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IKeepAliveRequest=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Basic.KeepAliveRequest} KeepAliveRequest instance
                 */
                KeepAliveRequest.create = function create(properties) {
                    return new KeepAliveRequest(properties);
                };

                /**
                 * Encodes the specified KeepAliveRequest message. Does not implicitly {@link AcFunDanmu.Im.Basic.KeepAliveRequest.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Basic.KeepAliveRequest
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IKeepAliveRequest} message KeepAliveRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                KeepAliveRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.presenceStatus != null && Object.hasOwnProperty.call(message, "presenceStatus"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.presenceStatus);
                    if (message.appActiveStatus != null && Object.hasOwnProperty.call(message, "appActiveStatus"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.appActiveStatus);
                    if (message.pushServiceToken != null && Object.hasOwnProperty.call(message, "pushServiceToken"))
                        $root.AcFunDanmu.Im.Basic.PushServiceToken.encode(message.pushServiceToken, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.pushServiceTokenList != null && message.pushServiceTokenList.length)
                        for (let i = 0; i < message.pushServiceTokenList.length; ++i)
                            $root.AcFunDanmu.Im.Basic.PushServiceToken.encode(message.pushServiceTokenList[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.keepaliveIntervalSec != null && Object.hasOwnProperty.call(message, "keepaliveIntervalSec"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.keepaliveIntervalSec);
                    return writer;
                };

                /**
                 * Encodes the specified KeepAliveRequest message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Basic.KeepAliveRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Basic.KeepAliveRequest
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IKeepAliveRequest} message KeepAliveRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                KeepAliveRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a KeepAliveRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Basic.KeepAliveRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Basic.KeepAliveRequest} KeepAliveRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                KeepAliveRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Basic.KeepAliveRequest();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.presenceStatus = reader.int32();
                            break;
                        case 2:
                            message.appActiveStatus = reader.int32();
                            break;
                        case 3:
                            message.pushServiceToken = $root.AcFunDanmu.Im.Basic.PushServiceToken.decode(reader, reader.uint32());
                            break;
                        case 4:
                            if (!(message.pushServiceTokenList && message.pushServiceTokenList.length))
                                message.pushServiceTokenList = [];
                            message.pushServiceTokenList.push($root.AcFunDanmu.Im.Basic.PushServiceToken.decode(reader, reader.uint32()));
                            break;
                        case 5:
                            message.keepaliveIntervalSec = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a KeepAliveRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Basic.KeepAliveRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Basic.KeepAliveRequest} KeepAliveRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                KeepAliveRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a KeepAliveRequest message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Basic.KeepAliveRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                KeepAliveRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.presenceStatus != null && message.hasOwnProperty("presenceStatus"))
                        switch (message.presenceStatus) {
                        default:
                            return "presenceStatus: enum value expected";
                        case 0:
                        case 1:
                            break;
                        }
                    if (message.appActiveStatus != null && message.hasOwnProperty("appActiveStatus"))
                        switch (message.appActiveStatus) {
                        default:
                            return "appActiveStatus: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (message.pushServiceToken != null && message.hasOwnProperty("pushServiceToken")) {
                        let error = $root.AcFunDanmu.Im.Basic.PushServiceToken.verify(message.pushServiceToken);
                        if (error)
                            return "pushServiceToken." + error;
                    }
                    if (message.pushServiceTokenList != null && message.hasOwnProperty("pushServiceTokenList")) {
                        if (!Array.isArray(message.pushServiceTokenList))
                            return "pushServiceTokenList: array expected";
                        for (let i = 0; i < message.pushServiceTokenList.length; ++i) {
                            let error = $root.AcFunDanmu.Im.Basic.PushServiceToken.verify(message.pushServiceTokenList[i]);
                            if (error)
                                return "pushServiceTokenList." + error;
                        }
                    }
                    if (message.keepaliveIntervalSec != null && message.hasOwnProperty("keepaliveIntervalSec"))
                        if (!$util.isInteger(message.keepaliveIntervalSec))
                            return "keepaliveIntervalSec: integer expected";
                    return null;
                };

                /**
                 * Creates a KeepAliveRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Basic.KeepAliveRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Basic.KeepAliveRequest} KeepAliveRequest
                 */
                KeepAliveRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Basic.KeepAliveRequest)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Basic.KeepAliveRequest();
                    switch (object.presenceStatus) {
                    case "kPresenceOffline":
                    case 0:
                        message.presenceStatus = 0;
                        break;
                    case "kPresenceOnline":
                    case 1:
                        message.presenceStatus = 1;
                        break;
                    }
                    switch (object.appActiveStatus) {
                    case "kInvalid":
                    case 0:
                        message.appActiveStatus = 0;
                        break;
                    case "kAppInForeground":
                    case 1:
                        message.appActiveStatus = 1;
                        break;
                    case "kAppinBackground":
                    case 2:
                        message.appActiveStatus = 2;
                        break;
                    }
                    if (object.pushServiceToken != null) {
                        if (typeof object.pushServiceToken !== "object")
                            throw TypeError(".AcFunDanmu.Im.Basic.KeepAliveRequest.pushServiceToken: object expected");
                        message.pushServiceToken = $root.AcFunDanmu.Im.Basic.PushServiceToken.fromObject(object.pushServiceToken);
                    }
                    if (object.pushServiceTokenList) {
                        if (!Array.isArray(object.pushServiceTokenList))
                            throw TypeError(".AcFunDanmu.Im.Basic.KeepAliveRequest.pushServiceTokenList: array expected");
                        message.pushServiceTokenList = [];
                        for (let i = 0; i < object.pushServiceTokenList.length; ++i) {
                            if (typeof object.pushServiceTokenList[i] !== "object")
                                throw TypeError(".AcFunDanmu.Im.Basic.KeepAliveRequest.pushServiceTokenList: object expected");
                            message.pushServiceTokenList[i] = $root.AcFunDanmu.Im.Basic.PushServiceToken.fromObject(object.pushServiceTokenList[i]);
                        }
                    }
                    if (object.keepaliveIntervalSec != null)
                        message.keepaliveIntervalSec = object.keepaliveIntervalSec | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a KeepAliveRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Basic.KeepAliveRequest
                 * @static
                 * @param {AcFunDanmu.Im.Basic.KeepAliveRequest} message KeepAliveRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                KeepAliveRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.pushServiceTokenList = [];
                    if (options.defaults) {
                        object.presenceStatus = options.enums === String ? "kPresenceOffline" : 0;
                        object.appActiveStatus = options.enums === String ? "kInvalid" : 0;
                        object.pushServiceToken = null;
                        object.keepaliveIntervalSec = 0;
                    }
                    if (message.presenceStatus != null && message.hasOwnProperty("presenceStatus"))
                        object.presenceStatus = options.enums === String ? $root.AcFunDanmu.Im.Basic.RegisterRequest.PresenceStatus[message.presenceStatus] : message.presenceStatus;
                    if (message.appActiveStatus != null && message.hasOwnProperty("appActiveStatus"))
                        object.appActiveStatus = options.enums === String ? $root.AcFunDanmu.Im.Basic.RegisterRequest.ActiveStatus[message.appActiveStatus] : message.appActiveStatus;
                    if (message.pushServiceToken != null && message.hasOwnProperty("pushServiceToken"))
                        object.pushServiceToken = $root.AcFunDanmu.Im.Basic.PushServiceToken.toObject(message.pushServiceToken, options);
                    if (message.pushServiceTokenList && message.pushServiceTokenList.length) {
                        object.pushServiceTokenList = [];
                        for (let j = 0; j < message.pushServiceTokenList.length; ++j)
                            object.pushServiceTokenList[j] = $root.AcFunDanmu.Im.Basic.PushServiceToken.toObject(message.pushServiceTokenList[j], options);
                    }
                    if (message.keepaliveIntervalSec != null && message.hasOwnProperty("keepaliveIntervalSec"))
                        object.keepaliveIntervalSec = message.keepaliveIntervalSec;
                    return object;
                };

                /**
                 * Converts this KeepAliveRequest to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Basic.KeepAliveRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                KeepAliveRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return KeepAliveRequest;
            })();

            Basic.KeepAliveResponse = (function() {

                /**
                 * Properties of a KeepAliveResponse.
                 * @memberof AcFunDanmu.Im.Basic
                 * @interface IKeepAliveResponse
                 * @property {AcFunDanmu.Im.Basic.IAccessPointsConfig|null} [accessPointsConfig] KeepAliveResponse accessPointsConfig
                 * @property {number|Long|null} [serverMsec] KeepAliveResponse serverMsec
                 * @property {AcFunDanmu.Im.Basic.IAccessPointsConfig|null} [accessPointsConfigIpv6] KeepAliveResponse accessPointsConfigIpv6
                 */

                /**
                 * Constructs a new KeepAliveResponse.
                 * @memberof AcFunDanmu.Im.Basic
                 * @classdesc Represents a KeepAliveResponse.
                 * @implements IKeepAliveResponse
                 * @constructor
                 * @param {AcFunDanmu.Im.Basic.IKeepAliveResponse=} [properties] Properties to set
                 */
                function KeepAliveResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * KeepAliveResponse accessPointsConfig.
                 * @member {AcFunDanmu.Im.Basic.IAccessPointsConfig|null|undefined} accessPointsConfig
                 * @memberof AcFunDanmu.Im.Basic.KeepAliveResponse
                 * @instance
                 */
                KeepAliveResponse.prototype.accessPointsConfig = null;

                /**
                 * KeepAliveResponse serverMsec.
                 * @member {number|Long} serverMsec
                 * @memberof AcFunDanmu.Im.Basic.KeepAliveResponse
                 * @instance
                 */
                KeepAliveResponse.prototype.serverMsec = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * KeepAliveResponse accessPointsConfigIpv6.
                 * @member {AcFunDanmu.Im.Basic.IAccessPointsConfig|null|undefined} accessPointsConfigIpv6
                 * @memberof AcFunDanmu.Im.Basic.KeepAliveResponse
                 * @instance
                 */
                KeepAliveResponse.prototype.accessPointsConfigIpv6 = null;

                /**
                 * Creates a new KeepAliveResponse instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Basic.KeepAliveResponse
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IKeepAliveResponse=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Basic.KeepAliveResponse} KeepAliveResponse instance
                 */
                KeepAliveResponse.create = function create(properties) {
                    return new KeepAliveResponse(properties);
                };

                /**
                 * Encodes the specified KeepAliveResponse message. Does not implicitly {@link AcFunDanmu.Im.Basic.KeepAliveResponse.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Basic.KeepAliveResponse
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IKeepAliveResponse} message KeepAliveResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                KeepAliveResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.accessPointsConfig != null && Object.hasOwnProperty.call(message, "accessPointsConfig"))
                        $root.AcFunDanmu.Im.Basic.AccessPointsConfig.encode(message.accessPointsConfig, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.serverMsec != null && Object.hasOwnProperty.call(message, "serverMsec"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int64(message.serverMsec);
                    if (message.accessPointsConfigIpv6 != null && Object.hasOwnProperty.call(message, "accessPointsConfigIpv6"))
                        $root.AcFunDanmu.Im.Basic.AccessPointsConfig.encode(message.accessPointsConfigIpv6, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified KeepAliveResponse message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Basic.KeepAliveResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Basic.KeepAliveResponse
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IKeepAliveResponse} message KeepAliveResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                KeepAliveResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a KeepAliveResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Basic.KeepAliveResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Basic.KeepAliveResponse} KeepAliveResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                KeepAliveResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Basic.KeepAliveResponse();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.accessPointsConfig = $root.AcFunDanmu.Im.Basic.AccessPointsConfig.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.serverMsec = reader.int64();
                            break;
                        case 3:
                            message.accessPointsConfigIpv6 = $root.AcFunDanmu.Im.Basic.AccessPointsConfig.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a KeepAliveResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Basic.KeepAliveResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Basic.KeepAliveResponse} KeepAliveResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                KeepAliveResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a KeepAliveResponse message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Basic.KeepAliveResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                KeepAliveResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.accessPointsConfig != null && message.hasOwnProperty("accessPointsConfig")) {
                        let error = $root.AcFunDanmu.Im.Basic.AccessPointsConfig.verify(message.accessPointsConfig);
                        if (error)
                            return "accessPointsConfig." + error;
                    }
                    if (message.serverMsec != null && message.hasOwnProperty("serverMsec"))
                        if (!$util.isInteger(message.serverMsec) && !(message.serverMsec && $util.isInteger(message.serverMsec.low) && $util.isInteger(message.serverMsec.high)))
                            return "serverMsec: integer|Long expected";
                    if (message.accessPointsConfigIpv6 != null && message.hasOwnProperty("accessPointsConfigIpv6")) {
                        let error = $root.AcFunDanmu.Im.Basic.AccessPointsConfig.verify(message.accessPointsConfigIpv6);
                        if (error)
                            return "accessPointsConfigIpv6." + error;
                    }
                    return null;
                };

                /**
                 * Creates a KeepAliveResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Basic.KeepAliveResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Basic.KeepAliveResponse} KeepAliveResponse
                 */
                KeepAliveResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Basic.KeepAliveResponse)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Basic.KeepAliveResponse();
                    if (object.accessPointsConfig != null) {
                        if (typeof object.accessPointsConfig !== "object")
                            throw TypeError(".AcFunDanmu.Im.Basic.KeepAliveResponse.accessPointsConfig: object expected");
                        message.accessPointsConfig = $root.AcFunDanmu.Im.Basic.AccessPointsConfig.fromObject(object.accessPointsConfig);
                    }
                    if (object.serverMsec != null)
                        if ($util.Long)
                            (message.serverMsec = $util.Long.fromValue(object.serverMsec)).unsigned = false;
                        else if (typeof object.serverMsec === "string")
                            message.serverMsec = parseInt(object.serverMsec, 10);
                        else if (typeof object.serverMsec === "number")
                            message.serverMsec = object.serverMsec;
                        else if (typeof object.serverMsec === "object")
                            message.serverMsec = new $util.LongBits(object.serverMsec.low >>> 0, object.serverMsec.high >>> 0).toNumber();
                    if (object.accessPointsConfigIpv6 != null) {
                        if (typeof object.accessPointsConfigIpv6 !== "object")
                            throw TypeError(".AcFunDanmu.Im.Basic.KeepAliveResponse.accessPointsConfigIpv6: object expected");
                        message.accessPointsConfigIpv6 = $root.AcFunDanmu.Im.Basic.AccessPointsConfig.fromObject(object.accessPointsConfigIpv6);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a KeepAliveResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Basic.KeepAliveResponse
                 * @static
                 * @param {AcFunDanmu.Im.Basic.KeepAliveResponse} message KeepAliveResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                KeepAliveResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.accessPointsConfig = null;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.serverMsec = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.serverMsec = options.longs === String ? "0" : 0;
                        object.accessPointsConfigIpv6 = null;
                    }
                    if (message.accessPointsConfig != null && message.hasOwnProperty("accessPointsConfig"))
                        object.accessPointsConfig = $root.AcFunDanmu.Im.Basic.AccessPointsConfig.toObject(message.accessPointsConfig, options);
                    if (message.serverMsec != null && message.hasOwnProperty("serverMsec"))
                        if (typeof message.serverMsec === "number")
                            object.serverMsec = options.longs === String ? String(message.serverMsec) : message.serverMsec;
                        else
                            object.serverMsec = options.longs === String ? $util.Long.prototype.toString.call(message.serverMsec) : options.longs === Number ? new $util.LongBits(message.serverMsec.low >>> 0, message.serverMsec.high >>> 0).toNumber() : message.serverMsec;
                    if (message.accessPointsConfigIpv6 != null && message.hasOwnProperty("accessPointsConfigIpv6"))
                        object.accessPointsConfigIpv6 = $root.AcFunDanmu.Im.Basic.AccessPointsConfig.toObject(message.accessPointsConfigIpv6, options);
                    return object;
                };

                /**
                 * Converts this KeepAliveResponse to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Basic.KeepAliveResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                KeepAliveResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return KeepAliveResponse;
            })();

            Basic.AccessPoint = (function() {

                /**
                 * Properties of an AccessPoint.
                 * @memberof AcFunDanmu.Im.Basic
                 * @interface IAccessPoint
                 * @property {AcFunDanmu.Im.Basic.AccessPoint.AddressType|null} [addressType] AccessPoint addressType
                 * @property {number|null} [port] AccessPoint port
                 * @property {number|null} [ipV4] AccessPoint ipV4
                 * @property {Uint8Array|null} [ipV6] AccessPoint ipV6
                 * @property {string|null} [domain] AccessPoint domain
                 */

                /**
                 * Constructs a new AccessPoint.
                 * @memberof AcFunDanmu.Im.Basic
                 * @classdesc Represents an AccessPoint.
                 * @implements IAccessPoint
                 * @constructor
                 * @param {AcFunDanmu.Im.Basic.IAccessPoint=} [properties] Properties to set
                 */
                function AccessPoint(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * AccessPoint addressType.
                 * @member {AcFunDanmu.Im.Basic.AccessPoint.AddressType} addressType
                 * @memberof AcFunDanmu.Im.Basic.AccessPoint
                 * @instance
                 */
                AccessPoint.prototype.addressType = 0;

                /**
                 * AccessPoint port.
                 * @member {number} port
                 * @memberof AcFunDanmu.Im.Basic.AccessPoint
                 * @instance
                 */
                AccessPoint.prototype.port = 0;

                /**
                 * AccessPoint ipV4.
                 * @member {number} ipV4
                 * @memberof AcFunDanmu.Im.Basic.AccessPoint
                 * @instance
                 */
                AccessPoint.prototype.ipV4 = 0;

                /**
                 * AccessPoint ipV6.
                 * @member {Uint8Array} ipV6
                 * @memberof AcFunDanmu.Im.Basic.AccessPoint
                 * @instance
                 */
                AccessPoint.prototype.ipV6 = $util.newBuffer([]);

                /**
                 * AccessPoint domain.
                 * @member {string} domain
                 * @memberof AcFunDanmu.Im.Basic.AccessPoint
                 * @instance
                 */
                AccessPoint.prototype.domain = "";

                /**
                 * Creates a new AccessPoint instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Basic.AccessPoint
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IAccessPoint=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Basic.AccessPoint} AccessPoint instance
                 */
                AccessPoint.create = function create(properties) {
                    return new AccessPoint(properties);
                };

                /**
                 * Encodes the specified AccessPoint message. Does not implicitly {@link AcFunDanmu.Im.Basic.AccessPoint.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Basic.AccessPoint
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IAccessPoint} message AccessPoint message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AccessPoint.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.addressType != null && Object.hasOwnProperty.call(message, "addressType"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.addressType);
                    if (message.port != null && Object.hasOwnProperty.call(message, "port"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.port);
                    if (message.ipV4 != null && Object.hasOwnProperty.call(message, "ipV4"))
                        writer.uint32(/* id 3, wireType 5 =*/29).fixed32(message.ipV4);
                    if (message.ipV6 != null && Object.hasOwnProperty.call(message, "ipV6"))
                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.ipV6);
                    if (message.domain != null && Object.hasOwnProperty.call(message, "domain"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.domain);
                    return writer;
                };

                /**
                 * Encodes the specified AccessPoint message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Basic.AccessPoint.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Basic.AccessPoint
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IAccessPoint} message AccessPoint message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AccessPoint.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an AccessPoint message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Basic.AccessPoint
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Basic.AccessPoint} AccessPoint
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AccessPoint.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Basic.AccessPoint();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.addressType = reader.int32();
                            break;
                        case 2:
                            message.port = reader.uint32();
                            break;
                        case 3:
                            message.ipV4 = reader.fixed32();
                            break;
                        case 4:
                            message.ipV6 = reader.bytes();
                            break;
                        case 5:
                            message.domain = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an AccessPoint message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Basic.AccessPoint
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Basic.AccessPoint} AccessPoint
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AccessPoint.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an AccessPoint message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Basic.AccessPoint
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                AccessPoint.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.addressType != null && message.hasOwnProperty("addressType"))
                        switch (message.addressType) {
                        default:
                            return "addressType: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (message.port != null && message.hasOwnProperty("port"))
                        if (!$util.isInteger(message.port))
                            return "port: integer expected";
                    if (message.ipV4 != null && message.hasOwnProperty("ipV4"))
                        if (!$util.isInteger(message.ipV4))
                            return "ipV4: integer expected";
                    if (message.ipV6 != null && message.hasOwnProperty("ipV6"))
                        if (!(message.ipV6 && typeof message.ipV6.length === "number" || $util.isString(message.ipV6)))
                            return "ipV6: buffer expected";
                    if (message.domain != null && message.hasOwnProperty("domain"))
                        if (!$util.isString(message.domain))
                            return "domain: string expected";
                    return null;
                };

                /**
                 * Creates an AccessPoint message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Basic.AccessPoint
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Basic.AccessPoint} AccessPoint
                 */
                AccessPoint.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Basic.AccessPoint)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Basic.AccessPoint();
                    switch (object.addressType) {
                    case "kIPV4":
                    case 0:
                        message.addressType = 0;
                        break;
                    case "kIPV6":
                    case 1:
                        message.addressType = 1;
                        break;
                    case "kDomain":
                    case 2:
                        message.addressType = 2;
                        break;
                    }
                    if (object.port != null)
                        message.port = object.port >>> 0;
                    if (object.ipV4 != null)
                        message.ipV4 = object.ipV4 >>> 0;
                    if (object.ipV6 != null)
                        if (typeof object.ipV6 === "string")
                            $util.base64.decode(object.ipV6, message.ipV6 = $util.newBuffer($util.base64.length(object.ipV6)), 0);
                        else if (object.ipV6.length)
                            message.ipV6 = object.ipV6;
                    if (object.domain != null)
                        message.domain = String(object.domain);
                    return message;
                };

                /**
                 * Creates a plain object from an AccessPoint message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Basic.AccessPoint
                 * @static
                 * @param {AcFunDanmu.Im.Basic.AccessPoint} message AccessPoint
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                AccessPoint.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.addressType = options.enums === String ? "kIPV4" : 0;
                        object.port = 0;
                        object.ipV4 = 0;
                        if (options.bytes === String)
                            object.ipV6 = "";
                        else {
                            object.ipV6 = [];
                            if (options.bytes !== Array)
                                object.ipV6 = $util.newBuffer(object.ipV6);
                        }
                        object.domain = "";
                    }
                    if (message.addressType != null && message.hasOwnProperty("addressType"))
                        object.addressType = options.enums === String ? $root.AcFunDanmu.Im.Basic.AccessPoint.AddressType[message.addressType] : message.addressType;
                    if (message.port != null && message.hasOwnProperty("port"))
                        object.port = message.port;
                    if (message.ipV4 != null && message.hasOwnProperty("ipV4"))
                        object.ipV4 = message.ipV4;
                    if (message.ipV6 != null && message.hasOwnProperty("ipV6"))
                        object.ipV6 = options.bytes === String ? $util.base64.encode(message.ipV6, 0, message.ipV6.length) : options.bytes === Array ? Array.prototype.slice.call(message.ipV6) : message.ipV6;
                    if (message.domain != null && message.hasOwnProperty("domain"))
                        object.domain = message.domain;
                    return object;
                };

                /**
                 * Converts this AccessPoint to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Basic.AccessPoint
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                AccessPoint.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * AddressType enum.
                 * @name AcFunDanmu.Im.Basic.AccessPoint.AddressType
                 * @enum {number}
                 * @property {number} kIPV4=0 kIPV4 value
                 * @property {number} kIPV6=1 kIPV6 value
                 * @property {number} kDomain=2 kDomain value
                 */
                AccessPoint.AddressType = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "kIPV4"] = 0;
                    values[valuesById[1] = "kIPV6"] = 1;
                    values[valuesById[2] = "kDomain"] = 2;
                    return values;
                })();

                return AccessPoint;
            })();

            Basic.TokenInfo = (function() {

                /**
                 * Properties of a TokenInfo.
                 * @memberof AcFunDanmu.Im.Basic
                 * @interface ITokenInfo
                 * @property {AcFunDanmu.Im.Basic.TokenInfo.TokenType|null} [tokenType] TokenInfo tokenType
                 * @property {Uint8Array|null} [token] TokenInfo token
                 */

                /**
                 * Constructs a new TokenInfo.
                 * @memberof AcFunDanmu.Im.Basic
                 * @classdesc Represents a TokenInfo.
                 * @implements ITokenInfo
                 * @constructor
                 * @param {AcFunDanmu.Im.Basic.ITokenInfo=} [properties] Properties to set
                 */
                function TokenInfo(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TokenInfo tokenType.
                 * @member {AcFunDanmu.Im.Basic.TokenInfo.TokenType} tokenType
                 * @memberof AcFunDanmu.Im.Basic.TokenInfo
                 * @instance
                 */
                TokenInfo.prototype.tokenType = 0;

                /**
                 * TokenInfo token.
                 * @member {Uint8Array} token
                 * @memberof AcFunDanmu.Im.Basic.TokenInfo
                 * @instance
                 */
                TokenInfo.prototype.token = $util.newBuffer([]);

                /**
                 * Creates a new TokenInfo instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Basic.TokenInfo
                 * @static
                 * @param {AcFunDanmu.Im.Basic.ITokenInfo=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Basic.TokenInfo} TokenInfo instance
                 */
                TokenInfo.create = function create(properties) {
                    return new TokenInfo(properties);
                };

                /**
                 * Encodes the specified TokenInfo message. Does not implicitly {@link AcFunDanmu.Im.Basic.TokenInfo.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Basic.TokenInfo
                 * @static
                 * @param {AcFunDanmu.Im.Basic.ITokenInfo} message TokenInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TokenInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.tokenType != null && Object.hasOwnProperty.call(message, "tokenType"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tokenType);
                    if (message.token != null && Object.hasOwnProperty.call(message, "token"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.token);
                    return writer;
                };

                /**
                 * Encodes the specified TokenInfo message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Basic.TokenInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Basic.TokenInfo
                 * @static
                 * @param {AcFunDanmu.Im.Basic.ITokenInfo} message TokenInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TokenInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TokenInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Basic.TokenInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Basic.TokenInfo} TokenInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TokenInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Basic.TokenInfo();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.tokenType = reader.int32();
                            break;
                        case 2:
                            message.token = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TokenInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Basic.TokenInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Basic.TokenInfo} TokenInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TokenInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TokenInfo message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Basic.TokenInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TokenInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.tokenType != null && message.hasOwnProperty("tokenType"))
                        switch (message.tokenType) {
                        default:
                            return "tokenType: enum value expected";
                        case 0:
                        case 1:
                            break;
                        }
                    if (message.token != null && message.hasOwnProperty("token"))
                        if (!(message.token && typeof message.token.length === "number" || $util.isString(message.token)))
                            return "token: buffer expected";
                    return null;
                };

                /**
                 * Creates a TokenInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Basic.TokenInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Basic.TokenInfo} TokenInfo
                 */
                TokenInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Basic.TokenInfo)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Basic.TokenInfo();
                    switch (object.tokenType) {
                    case "kInvalid":
                    case 0:
                        message.tokenType = 0;
                        break;
                    case "kServiceToken":
                    case 1:
                        message.tokenType = 1;
                        break;
                    }
                    if (object.token != null)
                        if (typeof object.token === "string")
                            $util.base64.decode(object.token, message.token = $util.newBuffer($util.base64.length(object.token)), 0);
                        else if (object.token.length)
                            message.token = object.token;
                    return message;
                };

                /**
                 * Creates a plain object from a TokenInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Basic.TokenInfo
                 * @static
                 * @param {AcFunDanmu.Im.Basic.TokenInfo} message TokenInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TokenInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.tokenType = options.enums === String ? "kInvalid" : 0;
                        if (options.bytes === String)
                            object.token = "";
                        else {
                            object.token = [];
                            if (options.bytes !== Array)
                                object.token = $util.newBuffer(object.token);
                        }
                    }
                    if (message.tokenType != null && message.hasOwnProperty("tokenType"))
                        object.tokenType = options.enums === String ? $root.AcFunDanmu.Im.Basic.TokenInfo.TokenType[message.tokenType] : message.tokenType;
                    if (message.token != null && message.hasOwnProperty("token"))
                        object.token = options.bytes === String ? $util.base64.encode(message.token, 0, message.token.length) : options.bytes === Array ? Array.prototype.slice.call(message.token) : message.token;
                    return object;
                };

                /**
                 * Converts this TokenInfo to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Basic.TokenInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TokenInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * TokenType enum.
                 * @name AcFunDanmu.Im.Basic.TokenInfo.TokenType
                 * @enum {number}
                 * @property {number} kInvalid=0 kInvalid value
                 * @property {number} kServiceToken=1 kServiceToken value
                 */
                TokenInfo.TokenType = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "kInvalid"] = 0;
                    values[valuesById[1] = "kServiceToken"] = 1;
                    return values;
                })();

                return TokenInfo;
            })();

            Basic.PushServiceToken = (function() {

                /**
                 * Properties of a PushServiceToken.
                 * @memberof AcFunDanmu.Im.Basic
                 * @interface IPushServiceToken
                 * @property {AcFunDanmu.Im.Basic.PushServiceToken.PushType|null} [pushType] PushServiceToken pushType
                 * @property {Uint8Array|null} [token] PushServiceToken token
                 * @property {boolean|null} [isPassThrough] PushServiceToken isPassThrough
                 */

                /**
                 * Constructs a new PushServiceToken.
                 * @memberof AcFunDanmu.Im.Basic
                 * @classdesc Represents a PushServiceToken.
                 * @implements IPushServiceToken
                 * @constructor
                 * @param {AcFunDanmu.Im.Basic.IPushServiceToken=} [properties] Properties to set
                 */
                function PushServiceToken(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PushServiceToken pushType.
                 * @member {AcFunDanmu.Im.Basic.PushServiceToken.PushType} pushType
                 * @memberof AcFunDanmu.Im.Basic.PushServiceToken
                 * @instance
                 */
                PushServiceToken.prototype.pushType = 0;

                /**
                 * PushServiceToken token.
                 * @member {Uint8Array} token
                 * @memberof AcFunDanmu.Im.Basic.PushServiceToken
                 * @instance
                 */
                PushServiceToken.prototype.token = $util.newBuffer([]);

                /**
                 * PushServiceToken isPassThrough.
                 * @member {boolean} isPassThrough
                 * @memberof AcFunDanmu.Im.Basic.PushServiceToken
                 * @instance
                 */
                PushServiceToken.prototype.isPassThrough = false;

                /**
                 * Creates a new PushServiceToken instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Basic.PushServiceToken
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IPushServiceToken=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Basic.PushServiceToken} PushServiceToken instance
                 */
                PushServiceToken.create = function create(properties) {
                    return new PushServiceToken(properties);
                };

                /**
                 * Encodes the specified PushServiceToken message. Does not implicitly {@link AcFunDanmu.Im.Basic.PushServiceToken.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Basic.PushServiceToken
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IPushServiceToken} message PushServiceToken message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PushServiceToken.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.pushType != null && Object.hasOwnProperty.call(message, "pushType"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.pushType);
                    if (message.token != null && Object.hasOwnProperty.call(message, "token"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.token);
                    if (message.isPassThrough != null && Object.hasOwnProperty.call(message, "isPassThrough"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isPassThrough);
                    return writer;
                };

                /**
                 * Encodes the specified PushServiceToken message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Basic.PushServiceToken.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Basic.PushServiceToken
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IPushServiceToken} message PushServiceToken message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PushServiceToken.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a PushServiceToken message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Basic.PushServiceToken
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Basic.PushServiceToken} PushServiceToken
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PushServiceToken.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Basic.PushServiceToken();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.pushType = reader.int32();
                            break;
                        case 2:
                            message.token = reader.bytes();
                            break;
                        case 3:
                            message.isPassThrough = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a PushServiceToken message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Basic.PushServiceToken
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Basic.PushServiceToken} PushServiceToken
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PushServiceToken.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a PushServiceToken message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Basic.PushServiceToken
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PushServiceToken.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.pushType != null && message.hasOwnProperty("pushType"))
                        switch (message.pushType) {
                        default:
                            return "pushType: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                            break;
                        }
                    if (message.token != null && message.hasOwnProperty("token"))
                        if (!(message.token && typeof message.token.length === "number" || $util.isString(message.token)))
                            return "token: buffer expected";
                    if (message.isPassThrough != null && message.hasOwnProperty("isPassThrough"))
                        if (typeof message.isPassThrough !== "boolean")
                            return "isPassThrough: boolean expected";
                    return null;
                };

                /**
                 * Creates a PushServiceToken message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Basic.PushServiceToken
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Basic.PushServiceToken} PushServiceToken
                 */
                PushServiceToken.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Basic.PushServiceToken)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Basic.PushServiceToken();
                    switch (object.pushType) {
                    case "kPushTypeInvalid":
                    case 0:
                        message.pushType = 0;
                        break;
                    case "kPushTypeAPNS":
                    case 1:
                        message.pushType = 1;
                        break;
                    case "kPushTypeXmPush":
                    case 2:
                        message.pushType = 2;
                        break;
                    case "kPushTypeJgPush":
                    case 3:
                        message.pushType = 3;
                        break;
                    case "kPushTypeGtPUsh":
                    case 4:
                        message.pushType = 4;
                        break;
                    case "kPushTypeOpPush":
                    case 5:
                        message.pushType = 5;
                        break;
                    case "kPushTYpeVvPush":
                    case 6:
                        message.pushType = 6;
                        break;
                    case "kPushTypeHwPush":
                    case 7:
                        message.pushType = 7;
                        break;
                    case "kPushTYpeFcm":
                    case 8:
                        message.pushType = 8;
                        break;
                    }
                    if (object.token != null)
                        if (typeof object.token === "string")
                            $util.base64.decode(object.token, message.token = $util.newBuffer($util.base64.length(object.token)), 0);
                        else if (object.token.length)
                            message.token = object.token;
                    if (object.isPassThrough != null)
                        message.isPassThrough = Boolean(object.isPassThrough);
                    return message;
                };

                /**
                 * Creates a plain object from a PushServiceToken message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Basic.PushServiceToken
                 * @static
                 * @param {AcFunDanmu.Im.Basic.PushServiceToken} message PushServiceToken
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PushServiceToken.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.pushType = options.enums === String ? "kPushTypeInvalid" : 0;
                        if (options.bytes === String)
                            object.token = "";
                        else {
                            object.token = [];
                            if (options.bytes !== Array)
                                object.token = $util.newBuffer(object.token);
                        }
                        object.isPassThrough = false;
                    }
                    if (message.pushType != null && message.hasOwnProperty("pushType"))
                        object.pushType = options.enums === String ? $root.AcFunDanmu.Im.Basic.PushServiceToken.PushType[message.pushType] : message.pushType;
                    if (message.token != null && message.hasOwnProperty("token"))
                        object.token = options.bytes === String ? $util.base64.encode(message.token, 0, message.token.length) : options.bytes === Array ? Array.prototype.slice.call(message.token) : message.token;
                    if (message.isPassThrough != null && message.hasOwnProperty("isPassThrough"))
                        object.isPassThrough = message.isPassThrough;
                    return object;
                };

                /**
                 * Converts this PushServiceToken to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Basic.PushServiceToken
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PushServiceToken.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * PushType enum.
                 * @name AcFunDanmu.Im.Basic.PushServiceToken.PushType
                 * @enum {number}
                 * @property {number} kPushTypeInvalid=0 kPushTypeInvalid value
                 * @property {number} kPushTypeAPNS=1 kPushTypeAPNS value
                 * @property {number} kPushTypeXmPush=2 kPushTypeXmPush value
                 * @property {number} kPushTypeJgPush=3 kPushTypeJgPush value
                 * @property {number} kPushTypeGtPUsh=4 kPushTypeGtPUsh value
                 * @property {number} kPushTypeOpPush=5 kPushTypeOpPush value
                 * @property {number} kPushTYpeVvPush=6 kPushTYpeVvPush value
                 * @property {number} kPushTypeHwPush=7 kPushTypeHwPush value
                 * @property {number} kPushTYpeFcm=8 kPushTYpeFcm value
                 */
                PushServiceToken.PushType = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "kPushTypeInvalid"] = 0;
                    values[valuesById[1] = "kPushTypeAPNS"] = 1;
                    values[valuesById[2] = "kPushTypeXmPush"] = 2;
                    values[valuesById[3] = "kPushTypeJgPush"] = 3;
                    values[valuesById[4] = "kPushTypeGtPUsh"] = 4;
                    values[valuesById[5] = "kPushTypeOpPush"] = 5;
                    values[valuesById[6] = "kPushTYpeVvPush"] = 6;
                    values[valuesById[7] = "kPushTypeHwPush"] = 7;
                    values[valuesById[8] = "kPushTYpeFcm"] = 8;
                    return values;
                })();

                return PushServiceToken;
            })();

            Basic.SettingInfo = (function() {

                /**
                 * Properties of a SettingInfo.
                 * @memberof AcFunDanmu.Im.Basic
                 * @interface ISettingInfo
                 * @property {string|null} [locale] SettingInfo locale
                 * @property {number|null} [timezone] SettingInfo timezone
                 */

                /**
                 * Constructs a new SettingInfo.
                 * @memberof AcFunDanmu.Im.Basic
                 * @classdesc Represents a SettingInfo.
                 * @implements ISettingInfo
                 * @constructor
                 * @param {AcFunDanmu.Im.Basic.ISettingInfo=} [properties] Properties to set
                 */
                function SettingInfo(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SettingInfo locale.
                 * @member {string} locale
                 * @memberof AcFunDanmu.Im.Basic.SettingInfo
                 * @instance
                 */
                SettingInfo.prototype.locale = "";

                /**
                 * SettingInfo timezone.
                 * @member {number} timezone
                 * @memberof AcFunDanmu.Im.Basic.SettingInfo
                 * @instance
                 */
                SettingInfo.prototype.timezone = 0;

                /**
                 * Creates a new SettingInfo instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Basic.SettingInfo
                 * @static
                 * @param {AcFunDanmu.Im.Basic.ISettingInfo=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Basic.SettingInfo} SettingInfo instance
                 */
                SettingInfo.create = function create(properties) {
                    return new SettingInfo(properties);
                };

                /**
                 * Encodes the specified SettingInfo message. Does not implicitly {@link AcFunDanmu.Im.Basic.SettingInfo.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Basic.SettingInfo
                 * @static
                 * @param {AcFunDanmu.Im.Basic.ISettingInfo} message SettingInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SettingInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.locale != null && Object.hasOwnProperty.call(message, "locale"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.locale);
                    if (message.timezone != null && Object.hasOwnProperty.call(message, "timezone"))
                        writer.uint32(/* id 2, wireType 0 =*/16).sint32(message.timezone);
                    return writer;
                };

                /**
                 * Encodes the specified SettingInfo message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Basic.SettingInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Basic.SettingInfo
                 * @static
                 * @param {AcFunDanmu.Im.Basic.ISettingInfo} message SettingInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SettingInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SettingInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Basic.SettingInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Basic.SettingInfo} SettingInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SettingInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Basic.SettingInfo();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.locale = reader.string();
                            break;
                        case 2:
                            message.timezone = reader.sint32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SettingInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Basic.SettingInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Basic.SettingInfo} SettingInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SettingInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SettingInfo message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Basic.SettingInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SettingInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.locale != null && message.hasOwnProperty("locale"))
                        if (!$util.isString(message.locale))
                            return "locale: string expected";
                    if (message.timezone != null && message.hasOwnProperty("timezone"))
                        if (!$util.isInteger(message.timezone))
                            return "timezone: integer expected";
                    return null;
                };

                /**
                 * Creates a SettingInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Basic.SettingInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Basic.SettingInfo} SettingInfo
                 */
                SettingInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Basic.SettingInfo)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Basic.SettingInfo();
                    if (object.locale != null)
                        message.locale = String(object.locale);
                    if (object.timezone != null)
                        message.timezone = object.timezone | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a SettingInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Basic.SettingInfo
                 * @static
                 * @param {AcFunDanmu.Im.Basic.SettingInfo} message SettingInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SettingInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.locale = "";
                        object.timezone = 0;
                    }
                    if (message.locale != null && message.hasOwnProperty("locale"))
                        object.locale = message.locale;
                    if (message.timezone != null && message.hasOwnProperty("timezone"))
                        object.timezone = message.timezone;
                    return object;
                };

                /**
                 * Converts this SettingInfo to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Basic.SettingInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SettingInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SettingInfo;
            })();

            Basic.AppInfo = (function() {

                /**
                 * Properties of an AppInfo.
                 * @memberof AcFunDanmu.Im.Basic
                 * @interface IAppInfo
                 * @property {string|null} [appName] AppInfo appName
                 * @property {string|null} [appVersion] AppInfo appVersion
                 * @property {string|null} [appChannel] AppInfo appChannel
                 * @property {string|null} [sdkVersion] AppInfo sdkVersion
                 * @property {string|null} [extensionInfo] AppInfo extensionInfo
                 */

                /**
                 * Constructs a new AppInfo.
                 * @memberof AcFunDanmu.Im.Basic
                 * @classdesc Represents an AppInfo.
                 * @implements IAppInfo
                 * @constructor
                 * @param {AcFunDanmu.Im.Basic.IAppInfo=} [properties] Properties to set
                 */
                function AppInfo(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * AppInfo appName.
                 * @member {string} appName
                 * @memberof AcFunDanmu.Im.Basic.AppInfo
                 * @instance
                 */
                AppInfo.prototype.appName = "";

                /**
                 * AppInfo appVersion.
                 * @member {string} appVersion
                 * @memberof AcFunDanmu.Im.Basic.AppInfo
                 * @instance
                 */
                AppInfo.prototype.appVersion = "";

                /**
                 * AppInfo appChannel.
                 * @member {string} appChannel
                 * @memberof AcFunDanmu.Im.Basic.AppInfo
                 * @instance
                 */
                AppInfo.prototype.appChannel = "";

                /**
                 * AppInfo sdkVersion.
                 * @member {string} sdkVersion
                 * @memberof AcFunDanmu.Im.Basic.AppInfo
                 * @instance
                 */
                AppInfo.prototype.sdkVersion = "";

                /**
                 * AppInfo extensionInfo.
                 * @member {string} extensionInfo
                 * @memberof AcFunDanmu.Im.Basic.AppInfo
                 * @instance
                 */
                AppInfo.prototype.extensionInfo = "";

                /**
                 * Creates a new AppInfo instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Basic.AppInfo
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IAppInfo=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Basic.AppInfo} AppInfo instance
                 */
                AppInfo.create = function create(properties) {
                    return new AppInfo(properties);
                };

                /**
                 * Encodes the specified AppInfo message. Does not implicitly {@link AcFunDanmu.Im.Basic.AppInfo.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Basic.AppInfo
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IAppInfo} message AppInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AppInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.appName != null && Object.hasOwnProperty.call(message, "appName"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.appName);
                    if (message.appVersion != null && Object.hasOwnProperty.call(message, "appVersion"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.appVersion);
                    if (message.appChannel != null && Object.hasOwnProperty.call(message, "appChannel"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.appChannel);
                    if (message.sdkVersion != null && Object.hasOwnProperty.call(message, "sdkVersion"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.sdkVersion);
                    if (message.extensionInfo != null && Object.hasOwnProperty.call(message, "extensionInfo"))
                        writer.uint32(/* id 11, wireType 2 =*/90).string(message.extensionInfo);
                    return writer;
                };

                /**
                 * Encodes the specified AppInfo message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Basic.AppInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Basic.AppInfo
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IAppInfo} message AppInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AppInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an AppInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Basic.AppInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Basic.AppInfo} AppInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AppInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Basic.AppInfo();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.appName = reader.string();
                            break;
                        case 2:
                            message.appVersion = reader.string();
                            break;
                        case 3:
                            message.appChannel = reader.string();
                            break;
                        case 4:
                            message.sdkVersion = reader.string();
                            break;
                        case 11:
                            message.extensionInfo = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an AppInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Basic.AppInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Basic.AppInfo} AppInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AppInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an AppInfo message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Basic.AppInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                AppInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.appName != null && message.hasOwnProperty("appName"))
                        if (!$util.isString(message.appName))
                            return "appName: string expected";
                    if (message.appVersion != null && message.hasOwnProperty("appVersion"))
                        if (!$util.isString(message.appVersion))
                            return "appVersion: string expected";
                    if (message.appChannel != null && message.hasOwnProperty("appChannel"))
                        if (!$util.isString(message.appChannel))
                            return "appChannel: string expected";
                    if (message.sdkVersion != null && message.hasOwnProperty("sdkVersion"))
                        if (!$util.isString(message.sdkVersion))
                            return "sdkVersion: string expected";
                    if (message.extensionInfo != null && message.hasOwnProperty("extensionInfo"))
                        if (!$util.isString(message.extensionInfo))
                            return "extensionInfo: string expected";
                    return null;
                };

                /**
                 * Creates an AppInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Basic.AppInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Basic.AppInfo} AppInfo
                 */
                AppInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Basic.AppInfo)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Basic.AppInfo();
                    if (object.appName != null)
                        message.appName = String(object.appName);
                    if (object.appVersion != null)
                        message.appVersion = String(object.appVersion);
                    if (object.appChannel != null)
                        message.appChannel = String(object.appChannel);
                    if (object.sdkVersion != null)
                        message.sdkVersion = String(object.sdkVersion);
                    if (object.extensionInfo != null)
                        message.extensionInfo = String(object.extensionInfo);
                    return message;
                };

                /**
                 * Creates a plain object from an AppInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Basic.AppInfo
                 * @static
                 * @param {AcFunDanmu.Im.Basic.AppInfo} message AppInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                AppInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.appName = "";
                        object.appVersion = "";
                        object.appChannel = "";
                        object.sdkVersion = "";
                        object.extensionInfo = "";
                    }
                    if (message.appName != null && message.hasOwnProperty("appName"))
                        object.appName = message.appName;
                    if (message.appVersion != null && message.hasOwnProperty("appVersion"))
                        object.appVersion = message.appVersion;
                    if (message.appChannel != null && message.hasOwnProperty("appChannel"))
                        object.appChannel = message.appChannel;
                    if (message.sdkVersion != null && message.hasOwnProperty("sdkVersion"))
                        object.sdkVersion = message.sdkVersion;
                    if (message.extensionInfo != null && message.hasOwnProperty("extensionInfo"))
                        object.extensionInfo = message.extensionInfo;
                    return object;
                };

                /**
                 * Converts this AppInfo to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Basic.AppInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                AppInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return AppInfo;
            })();

            Basic.DeviceInfo = (function() {

                /**
                 * Properties of a DeviceInfo.
                 * @memberof AcFunDanmu.Im.Basic
                 * @interface IDeviceInfo
                 * @property {AcFunDanmu.Im.Basic.DeviceInfo.PlatformType|null} [platformType] DeviceInfo platformType
                 * @property {string|null} [osVersion] DeviceInfo osVersion
                 * @property {string|null} [deviceModel] DeviceInfo deviceModel
                 * @property {Uint8Array|null} [imeiMd5] DeviceInfo imeiMd5
                 * @property {string|null} [deviceId] DeviceInfo deviceId
                 * @property {string|null} [softDid] DeviceInfo softDid
                 * @property {string|null} [kwaiDid] DeviceInfo kwaiDid
                 * @property {string|null} [manufacturer] DeviceInfo manufacturer
                 * @property {string|null} [deviceName] DeviceInfo deviceName
                 */

                /**
                 * Constructs a new DeviceInfo.
                 * @memberof AcFunDanmu.Im.Basic
                 * @classdesc Represents a DeviceInfo.
                 * @implements IDeviceInfo
                 * @constructor
                 * @param {AcFunDanmu.Im.Basic.IDeviceInfo=} [properties] Properties to set
                 */
                function DeviceInfo(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DeviceInfo platformType.
                 * @member {AcFunDanmu.Im.Basic.DeviceInfo.PlatformType} platformType
                 * @memberof AcFunDanmu.Im.Basic.DeviceInfo
                 * @instance
                 */
                DeviceInfo.prototype.platformType = 0;

                /**
                 * DeviceInfo osVersion.
                 * @member {string} osVersion
                 * @memberof AcFunDanmu.Im.Basic.DeviceInfo
                 * @instance
                 */
                DeviceInfo.prototype.osVersion = "";

                /**
                 * DeviceInfo deviceModel.
                 * @member {string} deviceModel
                 * @memberof AcFunDanmu.Im.Basic.DeviceInfo
                 * @instance
                 */
                DeviceInfo.prototype.deviceModel = "";

                /**
                 * DeviceInfo imeiMd5.
                 * @member {Uint8Array} imeiMd5
                 * @memberof AcFunDanmu.Im.Basic.DeviceInfo
                 * @instance
                 */
                DeviceInfo.prototype.imeiMd5 = $util.newBuffer([]);

                /**
                 * DeviceInfo deviceId.
                 * @member {string} deviceId
                 * @memberof AcFunDanmu.Im.Basic.DeviceInfo
                 * @instance
                 */
                DeviceInfo.prototype.deviceId = "";

                /**
                 * DeviceInfo softDid.
                 * @member {string} softDid
                 * @memberof AcFunDanmu.Im.Basic.DeviceInfo
                 * @instance
                 */
                DeviceInfo.prototype.softDid = "";

                /**
                 * DeviceInfo kwaiDid.
                 * @member {string} kwaiDid
                 * @memberof AcFunDanmu.Im.Basic.DeviceInfo
                 * @instance
                 */
                DeviceInfo.prototype.kwaiDid = "";

                /**
                 * DeviceInfo manufacturer.
                 * @member {string} manufacturer
                 * @memberof AcFunDanmu.Im.Basic.DeviceInfo
                 * @instance
                 */
                DeviceInfo.prototype.manufacturer = "";

                /**
                 * DeviceInfo deviceName.
                 * @member {string} deviceName
                 * @memberof AcFunDanmu.Im.Basic.DeviceInfo
                 * @instance
                 */
                DeviceInfo.prototype.deviceName = "";

                /**
                 * Creates a new DeviceInfo instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Basic.DeviceInfo
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IDeviceInfo=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Basic.DeviceInfo} DeviceInfo instance
                 */
                DeviceInfo.create = function create(properties) {
                    return new DeviceInfo(properties);
                };

                /**
                 * Encodes the specified DeviceInfo message. Does not implicitly {@link AcFunDanmu.Im.Basic.DeviceInfo.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Basic.DeviceInfo
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IDeviceInfo} message DeviceInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DeviceInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.platformType != null && Object.hasOwnProperty.call(message, "platformType"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.platformType);
                    if (message.osVersion != null && Object.hasOwnProperty.call(message, "osVersion"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.osVersion);
                    if (message.deviceModel != null && Object.hasOwnProperty.call(message, "deviceModel"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.deviceModel);
                    if (message.imeiMd5 != null && Object.hasOwnProperty.call(message, "imeiMd5"))
                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.imeiMd5);
                    if (message.deviceId != null && Object.hasOwnProperty.call(message, "deviceId"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.deviceId);
                    if (message.softDid != null && Object.hasOwnProperty.call(message, "softDid"))
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.softDid);
                    if (message.kwaiDid != null && Object.hasOwnProperty.call(message, "kwaiDid"))
                        writer.uint32(/* id 7, wireType 2 =*/58).string(message.kwaiDid);
                    if (message.manufacturer != null && Object.hasOwnProperty.call(message, "manufacturer"))
                        writer.uint32(/* id 8, wireType 2 =*/66).string(message.manufacturer);
                    if (message.deviceName != null && Object.hasOwnProperty.call(message, "deviceName"))
                        writer.uint32(/* id 9, wireType 2 =*/74).string(message.deviceName);
                    return writer;
                };

                /**
                 * Encodes the specified DeviceInfo message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Basic.DeviceInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Basic.DeviceInfo
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IDeviceInfo} message DeviceInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DeviceInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a DeviceInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Basic.DeviceInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Basic.DeviceInfo} DeviceInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DeviceInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Basic.DeviceInfo();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.platformType = reader.int32();
                            break;
                        case 2:
                            message.osVersion = reader.string();
                            break;
                        case 3:
                            message.deviceModel = reader.string();
                            break;
                        case 4:
                            message.imeiMd5 = reader.bytes();
                            break;
                        case 5:
                            message.deviceId = reader.string();
                            break;
                        case 6:
                            message.softDid = reader.string();
                            break;
                        case 7:
                            message.kwaiDid = reader.string();
                            break;
                        case 8:
                            message.manufacturer = reader.string();
                            break;
                        case 9:
                            message.deviceName = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a DeviceInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Basic.DeviceInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Basic.DeviceInfo} DeviceInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DeviceInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a DeviceInfo message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Basic.DeviceInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DeviceInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.platformType != null && message.hasOwnProperty("platformType"))
                        switch (message.platformType) {
                        default:
                            return "platformType: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                            break;
                        }
                    if (message.osVersion != null && message.hasOwnProperty("osVersion"))
                        if (!$util.isString(message.osVersion))
                            return "osVersion: string expected";
                    if (message.deviceModel != null && message.hasOwnProperty("deviceModel"))
                        if (!$util.isString(message.deviceModel))
                            return "deviceModel: string expected";
                    if (message.imeiMd5 != null && message.hasOwnProperty("imeiMd5"))
                        if (!(message.imeiMd5 && typeof message.imeiMd5.length === "number" || $util.isString(message.imeiMd5)))
                            return "imeiMd5: buffer expected";
                    if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                        if (!$util.isString(message.deviceId))
                            return "deviceId: string expected";
                    if (message.softDid != null && message.hasOwnProperty("softDid"))
                        if (!$util.isString(message.softDid))
                            return "softDid: string expected";
                    if (message.kwaiDid != null && message.hasOwnProperty("kwaiDid"))
                        if (!$util.isString(message.kwaiDid))
                            return "kwaiDid: string expected";
                    if (message.manufacturer != null && message.hasOwnProperty("manufacturer"))
                        if (!$util.isString(message.manufacturer))
                            return "manufacturer: string expected";
                    if (message.deviceName != null && message.hasOwnProperty("deviceName"))
                        if (!$util.isString(message.deviceName))
                            return "deviceName: string expected";
                    return null;
                };

                /**
                 * Creates a DeviceInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Basic.DeviceInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Basic.DeviceInfo} DeviceInfo
                 */
                DeviceInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Basic.DeviceInfo)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Basic.DeviceInfo();
                    switch (object.platformType) {
                    case "kInvalid":
                    case 0:
                        message.platformType = 0;
                        break;
                    case "kAndroid":
                    case 1:
                        message.platformType = 1;
                        break;
                    case "kiOS":
                    case 2:
                        message.platformType = 2;
                        break;
                    case "kWindows":
                    case 3:
                        message.platformType = 3;
                        break;
                    case "WECHAT_ANDROID":
                    case 4:
                        message.platformType = 4;
                        break;
                    case "WECHAT_IOS":
                    case 5:
                        message.platformType = 5;
                        break;
                    case "H5":
                    case 6:
                        message.platformType = 6;
                        break;
                    case "kPlatformNum":
                    case 7:
                        message.platformType = 7;
                        break;
                    }
                    if (object.osVersion != null)
                        message.osVersion = String(object.osVersion);
                    if (object.deviceModel != null)
                        message.deviceModel = String(object.deviceModel);
                    if (object.imeiMd5 != null)
                        if (typeof object.imeiMd5 === "string")
                            $util.base64.decode(object.imeiMd5, message.imeiMd5 = $util.newBuffer($util.base64.length(object.imeiMd5)), 0);
                        else if (object.imeiMd5.length)
                            message.imeiMd5 = object.imeiMd5;
                    if (object.deviceId != null)
                        message.deviceId = String(object.deviceId);
                    if (object.softDid != null)
                        message.softDid = String(object.softDid);
                    if (object.kwaiDid != null)
                        message.kwaiDid = String(object.kwaiDid);
                    if (object.manufacturer != null)
                        message.manufacturer = String(object.manufacturer);
                    if (object.deviceName != null)
                        message.deviceName = String(object.deviceName);
                    return message;
                };

                /**
                 * Creates a plain object from a DeviceInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Basic.DeviceInfo
                 * @static
                 * @param {AcFunDanmu.Im.Basic.DeviceInfo} message DeviceInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DeviceInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.platformType = options.enums === String ? "kInvalid" : 0;
                        object.osVersion = "";
                        object.deviceModel = "";
                        if (options.bytes === String)
                            object.imeiMd5 = "";
                        else {
                            object.imeiMd5 = [];
                            if (options.bytes !== Array)
                                object.imeiMd5 = $util.newBuffer(object.imeiMd5);
                        }
                        object.deviceId = "";
                        object.softDid = "";
                        object.kwaiDid = "";
                        object.manufacturer = "";
                        object.deviceName = "";
                    }
                    if (message.platformType != null && message.hasOwnProperty("platformType"))
                        object.platformType = options.enums === String ? $root.AcFunDanmu.Im.Basic.DeviceInfo.PlatformType[message.platformType] : message.platformType;
                    if (message.osVersion != null && message.hasOwnProperty("osVersion"))
                        object.osVersion = message.osVersion;
                    if (message.deviceModel != null && message.hasOwnProperty("deviceModel"))
                        object.deviceModel = message.deviceModel;
                    if (message.imeiMd5 != null && message.hasOwnProperty("imeiMd5"))
                        object.imeiMd5 = options.bytes === String ? $util.base64.encode(message.imeiMd5, 0, message.imeiMd5.length) : options.bytes === Array ? Array.prototype.slice.call(message.imeiMd5) : message.imeiMd5;
                    if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                        object.deviceId = message.deviceId;
                    if (message.softDid != null && message.hasOwnProperty("softDid"))
                        object.softDid = message.softDid;
                    if (message.kwaiDid != null && message.hasOwnProperty("kwaiDid"))
                        object.kwaiDid = message.kwaiDid;
                    if (message.manufacturer != null && message.hasOwnProperty("manufacturer"))
                        object.manufacturer = message.manufacturer;
                    if (message.deviceName != null && message.hasOwnProperty("deviceName"))
                        object.deviceName = message.deviceName;
                    return object;
                };

                /**
                 * Converts this DeviceInfo to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Basic.DeviceInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DeviceInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * PlatformType enum.
                 * @name AcFunDanmu.Im.Basic.DeviceInfo.PlatformType
                 * @enum {number}
                 * @property {number} kInvalid=0 kInvalid value
                 * @property {number} kAndroid=1 kAndroid value
                 * @property {number} kiOS=2 kiOS value
                 * @property {number} kWindows=3 kWindows value
                 * @property {number} WECHAT_ANDROID=4 WECHAT_ANDROID value
                 * @property {number} WECHAT_IOS=5 WECHAT_IOS value
                 * @property {number} H5=6 H5 value
                 * @property {number} kPlatformNum=7 kPlatformNum value
                 */
                DeviceInfo.PlatformType = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "kInvalid"] = 0;
                    values[valuesById[1] = "kAndroid"] = 1;
                    values[valuesById[2] = "kiOS"] = 2;
                    values[valuesById[3] = "kWindows"] = 3;
                    values[valuesById[4] = "WECHAT_ANDROID"] = 4;
                    values[valuesById[5] = "WECHAT_IOS"] = 5;
                    values[valuesById[6] = "H5"] = 6;
                    values[valuesById[7] = "kPlatformNum"] = 7;
                    return values;
                })();

                return DeviceInfo;
            })();

            Basic.EnvInfo = (function() {

                /**
                 * Properties of an EnvInfo.
                 * @memberof AcFunDanmu.Im.Basic
                 * @interface IEnvInfo
                 * @property {AcFunDanmu.Im.Basic.EnvInfo.NetworkType|null} [networkType] EnvInfo networkType
                 * @property {Uint8Array|null} [appName] EnvInfo appName
                 */

                /**
                 * Constructs a new EnvInfo.
                 * @memberof AcFunDanmu.Im.Basic
                 * @classdesc Represents an EnvInfo.
                 * @implements IEnvInfo
                 * @constructor
                 * @param {AcFunDanmu.Im.Basic.IEnvInfo=} [properties] Properties to set
                 */
                function EnvInfo(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * EnvInfo networkType.
                 * @member {AcFunDanmu.Im.Basic.EnvInfo.NetworkType} networkType
                 * @memberof AcFunDanmu.Im.Basic.EnvInfo
                 * @instance
                 */
                EnvInfo.prototype.networkType = 0;

                /**
                 * EnvInfo appName.
                 * @member {Uint8Array} appName
                 * @memberof AcFunDanmu.Im.Basic.EnvInfo
                 * @instance
                 */
                EnvInfo.prototype.appName = $util.newBuffer([]);

                /**
                 * Creates a new EnvInfo instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Basic.EnvInfo
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IEnvInfo=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Basic.EnvInfo} EnvInfo instance
                 */
                EnvInfo.create = function create(properties) {
                    return new EnvInfo(properties);
                };

                /**
                 * Encodes the specified EnvInfo message. Does not implicitly {@link AcFunDanmu.Im.Basic.EnvInfo.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Basic.EnvInfo
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IEnvInfo} message EnvInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnvInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.networkType != null && Object.hasOwnProperty.call(message, "networkType"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.networkType);
                    if (message.appName != null && Object.hasOwnProperty.call(message, "appName"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.appName);
                    return writer;
                };

                /**
                 * Encodes the specified EnvInfo message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Basic.EnvInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Basic.EnvInfo
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IEnvInfo} message EnvInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnvInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an EnvInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Basic.EnvInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Basic.EnvInfo} EnvInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnvInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Basic.EnvInfo();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.networkType = reader.int32();
                            break;
                        case 2:
                            message.appName = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an EnvInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Basic.EnvInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Basic.EnvInfo} EnvInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnvInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an EnvInfo message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Basic.EnvInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EnvInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.networkType != null && message.hasOwnProperty("networkType"))
                        switch (message.networkType) {
                        default:
                            return "networkType: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (message.appName != null && message.hasOwnProperty("appName"))
                        if (!(message.appName && typeof message.appName.length === "number" || $util.isString(message.appName)))
                            return "appName: buffer expected";
                    return null;
                };

                /**
                 * Creates an EnvInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Basic.EnvInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Basic.EnvInfo} EnvInfo
                 */
                EnvInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Basic.EnvInfo)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Basic.EnvInfo();
                    switch (object.networkType) {
                    case "kInvalid":
                    case 0:
                        message.networkType = 0;
                        break;
                    case "kWIFI":
                    case 1:
                        message.networkType = 1;
                        break;
                    case "kCellular":
                    case 2:
                        message.networkType = 2;
                        break;
                    }
                    if (object.appName != null)
                        if (typeof object.appName === "string")
                            $util.base64.decode(object.appName, message.appName = $util.newBuffer($util.base64.length(object.appName)), 0);
                        else if (object.appName.length)
                            message.appName = object.appName;
                    return message;
                };

                /**
                 * Creates a plain object from an EnvInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Basic.EnvInfo
                 * @static
                 * @param {AcFunDanmu.Im.Basic.EnvInfo} message EnvInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EnvInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.networkType = options.enums === String ? "kInvalid" : 0;
                        if (options.bytes === String)
                            object.appName = "";
                        else {
                            object.appName = [];
                            if (options.bytes !== Array)
                                object.appName = $util.newBuffer(object.appName);
                        }
                    }
                    if (message.networkType != null && message.hasOwnProperty("networkType"))
                        object.networkType = options.enums === String ? $root.AcFunDanmu.Im.Basic.EnvInfo.NetworkType[message.networkType] : message.networkType;
                    if (message.appName != null && message.hasOwnProperty("appName"))
                        object.appName = options.bytes === String ? $util.base64.encode(message.appName, 0, message.appName.length) : options.bytes === Array ? Array.prototype.slice.call(message.appName) : message.appName;
                    return object;
                };

                /**
                 * Converts this EnvInfo to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Basic.EnvInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EnvInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * NetworkType enum.
                 * @name AcFunDanmu.Im.Basic.EnvInfo.NetworkType
                 * @enum {number}
                 * @property {number} kInvalid=0 kInvalid value
                 * @property {number} kWIFI=1 kWIFI value
                 * @property {number} kCellular=2 kCellular value
                 */
                EnvInfo.NetworkType = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "kInvalid"] = 0;
                    values[valuesById[1] = "kWIFI"] = 1;
                    values[valuesById[2] = "kCellular"] = 2;
                    return values;
                })();

                return EnvInfo;
            })();

            /**
             * SharePlatform enum.
             * @name AcFunDanmu.Im.Basic.SharePlatform
             * @enum {number}
             * @property {number} kSharePlatformInvalid=0 kSharePlatformInvalid value
             * @property {number} kSharePlatformWechat=1 kSharePlatformWechat value
             * @property {number} kSharePlatformWechatMoments=2 kSharePlatformWechatMoments value
             * @property {number} kSharePlatformQQ=3 kSharePlatformQQ value
             * @property {number} kSharePlatformQzone=4 kSharePlatformQzone value
             * @property {number} kSharePlatformWeibo=5 kSharePlatformWeibo value
             * @property {number} kSharePlatformKuaishou=6 kSharePlatformKuaishou value
             * @property {number} kSharePlatformFacebook=7 kSharePlatformFacebook value
             * @property {number} kSharePlatformTwitter=8 kSharePlatformTwitter value
             * @property {number} kSharePlatformGoogle=9 kSharePlatformGoogle value
             * @property {number} kSharePlatformKakao=10 kSharePlatformKakao value
             * @property {number} kSharePlatformZalo=11 kSharePlatformZalo value
             */
            Basic.SharePlatform = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "kSharePlatformInvalid"] = 0;
                values[valuesById[1] = "kSharePlatformWechat"] = 1;
                values[valuesById[2] = "kSharePlatformWechatMoments"] = 2;
                values[valuesById[3] = "kSharePlatformQQ"] = 3;
                values[valuesById[4] = "kSharePlatformQzone"] = 4;
                values[valuesById[5] = "kSharePlatformWeibo"] = 5;
                values[valuesById[6] = "kSharePlatformKuaishou"] = 6;
                values[valuesById[7] = "kSharePlatformFacebook"] = 7;
                values[valuesById[8] = "kSharePlatformTwitter"] = 8;
                values[valuesById[9] = "kSharePlatformGoogle"] = 9;
                values[valuesById[10] = "kSharePlatformKakao"] = 10;
                values[valuesById[11] = "kSharePlatformZalo"] = 11;
                return values;
            })();

            Basic.RequestBasicInfo = (function() {

                /**
                 * Properties of a RequestBasicInfo.
                 * @memberof AcFunDanmu.Im.Basic
                 * @interface IRequestBasicInfo
                 * @property {AcFunDanmu.Im.Basic.DeviceInfo.PlatformType|null} [clientType] RequestBasicInfo clientType
                 * @property {string|null} [deviceId] RequestBasicInfo deviceId
                 * @property {string|null} [clientIp] RequestBasicInfo clientIp
                 * @property {string|null} [appVersion] RequestBasicInfo appVersion
                 * @property {string|null} [channel] RequestBasicInfo channel
                 * @property {AcFunDanmu.Im.Basic.IAppInfo|null} [appInfo] RequestBasicInfo appInfo
                 * @property {AcFunDanmu.Im.Basic.IDeviceInfo|null} [deviceInfo] RequestBasicInfo deviceInfo
                 * @property {AcFunDanmu.Im.Basic.IEnvInfo|null} [envInfo] RequestBasicInfo envInfo
                 * @property {number|null} [clientPort] RequestBasicInfo clientPort
                 * @property {string|null} [location] RequestBasicInfo location
                 * @property {string|null} [kpf] RequestBasicInfo kpf
                 */

                /**
                 * Constructs a new RequestBasicInfo.
                 * @memberof AcFunDanmu.Im.Basic
                 * @classdesc Represents a RequestBasicInfo.
                 * @implements IRequestBasicInfo
                 * @constructor
                 * @param {AcFunDanmu.Im.Basic.IRequestBasicInfo=} [properties] Properties to set
                 */
                function RequestBasicInfo(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * RequestBasicInfo clientType.
                 * @member {AcFunDanmu.Im.Basic.DeviceInfo.PlatformType} clientType
                 * @memberof AcFunDanmu.Im.Basic.RequestBasicInfo
                 * @instance
                 */
                RequestBasicInfo.prototype.clientType = 0;

                /**
                 * RequestBasicInfo deviceId.
                 * @member {string} deviceId
                 * @memberof AcFunDanmu.Im.Basic.RequestBasicInfo
                 * @instance
                 */
                RequestBasicInfo.prototype.deviceId = "";

                /**
                 * RequestBasicInfo clientIp.
                 * @member {string} clientIp
                 * @memberof AcFunDanmu.Im.Basic.RequestBasicInfo
                 * @instance
                 */
                RequestBasicInfo.prototype.clientIp = "";

                /**
                 * RequestBasicInfo appVersion.
                 * @member {string} appVersion
                 * @memberof AcFunDanmu.Im.Basic.RequestBasicInfo
                 * @instance
                 */
                RequestBasicInfo.prototype.appVersion = "";

                /**
                 * RequestBasicInfo channel.
                 * @member {string} channel
                 * @memberof AcFunDanmu.Im.Basic.RequestBasicInfo
                 * @instance
                 */
                RequestBasicInfo.prototype.channel = "";

                /**
                 * RequestBasicInfo appInfo.
                 * @member {AcFunDanmu.Im.Basic.IAppInfo|null|undefined} appInfo
                 * @memberof AcFunDanmu.Im.Basic.RequestBasicInfo
                 * @instance
                 */
                RequestBasicInfo.prototype.appInfo = null;

                /**
                 * RequestBasicInfo deviceInfo.
                 * @member {AcFunDanmu.Im.Basic.IDeviceInfo|null|undefined} deviceInfo
                 * @memberof AcFunDanmu.Im.Basic.RequestBasicInfo
                 * @instance
                 */
                RequestBasicInfo.prototype.deviceInfo = null;

                /**
                 * RequestBasicInfo envInfo.
                 * @member {AcFunDanmu.Im.Basic.IEnvInfo|null|undefined} envInfo
                 * @memberof AcFunDanmu.Im.Basic.RequestBasicInfo
                 * @instance
                 */
                RequestBasicInfo.prototype.envInfo = null;

                /**
                 * RequestBasicInfo clientPort.
                 * @member {number} clientPort
                 * @memberof AcFunDanmu.Im.Basic.RequestBasicInfo
                 * @instance
                 */
                RequestBasicInfo.prototype.clientPort = 0;

                /**
                 * RequestBasicInfo location.
                 * @member {string} location
                 * @memberof AcFunDanmu.Im.Basic.RequestBasicInfo
                 * @instance
                 */
                RequestBasicInfo.prototype.location = "";

                /**
                 * RequestBasicInfo kpf.
                 * @member {string} kpf
                 * @memberof AcFunDanmu.Im.Basic.RequestBasicInfo
                 * @instance
                 */
                RequestBasicInfo.prototype.kpf = "";

                /**
                 * Creates a new RequestBasicInfo instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Basic.RequestBasicInfo
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IRequestBasicInfo=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Basic.RequestBasicInfo} RequestBasicInfo instance
                 */
                RequestBasicInfo.create = function create(properties) {
                    return new RequestBasicInfo(properties);
                };

                /**
                 * Encodes the specified RequestBasicInfo message. Does not implicitly {@link AcFunDanmu.Im.Basic.RequestBasicInfo.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Basic.RequestBasicInfo
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IRequestBasicInfo} message RequestBasicInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RequestBasicInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.clientType != null && Object.hasOwnProperty.call(message, "clientType"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.clientType);
                    if (message.deviceId != null && Object.hasOwnProperty.call(message, "deviceId"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.deviceId);
                    if (message.clientIp != null && Object.hasOwnProperty.call(message, "clientIp"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.clientIp);
                    if (message.appVersion != null && Object.hasOwnProperty.call(message, "appVersion"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.appVersion);
                    if (message.channel != null && Object.hasOwnProperty.call(message, "channel"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.channel);
                    if (message.appInfo != null && Object.hasOwnProperty.call(message, "appInfo"))
                        $root.AcFunDanmu.Im.Basic.AppInfo.encode(message.appInfo, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.deviceInfo != null && Object.hasOwnProperty.call(message, "deviceInfo"))
                        $root.AcFunDanmu.Im.Basic.DeviceInfo.encode(message.deviceInfo, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.envInfo != null && Object.hasOwnProperty.call(message, "envInfo"))
                        $root.AcFunDanmu.Im.Basic.EnvInfo.encode(message.envInfo, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.clientPort != null && Object.hasOwnProperty.call(message, "clientPort"))
                        writer.uint32(/* id 9, wireType 0 =*/72).int32(message.clientPort);
                    if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                        writer.uint32(/* id 10, wireType 2 =*/82).string(message.location);
                    if (message.kpf != null && Object.hasOwnProperty.call(message, "kpf"))
                        writer.uint32(/* id 11, wireType 2 =*/90).string(message.kpf);
                    return writer;
                };

                /**
                 * Encodes the specified RequestBasicInfo message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Basic.RequestBasicInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Basic.RequestBasicInfo
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IRequestBasicInfo} message RequestBasicInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RequestBasicInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a RequestBasicInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Basic.RequestBasicInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Basic.RequestBasicInfo} RequestBasicInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RequestBasicInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Basic.RequestBasicInfo();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.clientType = reader.int32();
                            break;
                        case 2:
                            message.deviceId = reader.string();
                            break;
                        case 3:
                            message.clientIp = reader.string();
                            break;
                        case 4:
                            message.appVersion = reader.string();
                            break;
                        case 5:
                            message.channel = reader.string();
                            break;
                        case 6:
                            message.appInfo = $root.AcFunDanmu.Im.Basic.AppInfo.decode(reader, reader.uint32());
                            break;
                        case 7:
                            message.deviceInfo = $root.AcFunDanmu.Im.Basic.DeviceInfo.decode(reader, reader.uint32());
                            break;
                        case 8:
                            message.envInfo = $root.AcFunDanmu.Im.Basic.EnvInfo.decode(reader, reader.uint32());
                            break;
                        case 9:
                            message.clientPort = reader.int32();
                            break;
                        case 10:
                            message.location = reader.string();
                            break;
                        case 11:
                            message.kpf = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a RequestBasicInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Basic.RequestBasicInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Basic.RequestBasicInfo} RequestBasicInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RequestBasicInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a RequestBasicInfo message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Basic.RequestBasicInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                RequestBasicInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.clientType != null && message.hasOwnProperty("clientType"))
                        switch (message.clientType) {
                        default:
                            return "clientType: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                            break;
                        }
                    if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                        if (!$util.isString(message.deviceId))
                            return "deviceId: string expected";
                    if (message.clientIp != null && message.hasOwnProperty("clientIp"))
                        if (!$util.isString(message.clientIp))
                            return "clientIp: string expected";
                    if (message.appVersion != null && message.hasOwnProperty("appVersion"))
                        if (!$util.isString(message.appVersion))
                            return "appVersion: string expected";
                    if (message.channel != null && message.hasOwnProperty("channel"))
                        if (!$util.isString(message.channel))
                            return "channel: string expected";
                    if (message.appInfo != null && message.hasOwnProperty("appInfo")) {
                        let error = $root.AcFunDanmu.Im.Basic.AppInfo.verify(message.appInfo);
                        if (error)
                            return "appInfo." + error;
                    }
                    if (message.deviceInfo != null && message.hasOwnProperty("deviceInfo")) {
                        let error = $root.AcFunDanmu.Im.Basic.DeviceInfo.verify(message.deviceInfo);
                        if (error)
                            return "deviceInfo." + error;
                    }
                    if (message.envInfo != null && message.hasOwnProperty("envInfo")) {
                        let error = $root.AcFunDanmu.Im.Basic.EnvInfo.verify(message.envInfo);
                        if (error)
                            return "envInfo." + error;
                    }
                    if (message.clientPort != null && message.hasOwnProperty("clientPort"))
                        if (!$util.isInteger(message.clientPort))
                            return "clientPort: integer expected";
                    if (message.location != null && message.hasOwnProperty("location"))
                        if (!$util.isString(message.location))
                            return "location: string expected";
                    if (message.kpf != null && message.hasOwnProperty("kpf"))
                        if (!$util.isString(message.kpf))
                            return "kpf: string expected";
                    return null;
                };

                /**
                 * Creates a RequestBasicInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Basic.RequestBasicInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Basic.RequestBasicInfo} RequestBasicInfo
                 */
                RequestBasicInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Basic.RequestBasicInfo)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Basic.RequestBasicInfo();
                    switch (object.clientType) {
                    case "kInvalid":
                    case 0:
                        message.clientType = 0;
                        break;
                    case "kAndroid":
                    case 1:
                        message.clientType = 1;
                        break;
                    case "kiOS":
                    case 2:
                        message.clientType = 2;
                        break;
                    case "kWindows":
                    case 3:
                        message.clientType = 3;
                        break;
                    case "WECHAT_ANDROID":
                    case 4:
                        message.clientType = 4;
                        break;
                    case "WECHAT_IOS":
                    case 5:
                        message.clientType = 5;
                        break;
                    case "H5":
                    case 6:
                        message.clientType = 6;
                        break;
                    case "kPlatformNum":
                    case 7:
                        message.clientType = 7;
                        break;
                    }
                    if (object.deviceId != null)
                        message.deviceId = String(object.deviceId);
                    if (object.clientIp != null)
                        message.clientIp = String(object.clientIp);
                    if (object.appVersion != null)
                        message.appVersion = String(object.appVersion);
                    if (object.channel != null)
                        message.channel = String(object.channel);
                    if (object.appInfo != null) {
                        if (typeof object.appInfo !== "object")
                            throw TypeError(".AcFunDanmu.Im.Basic.RequestBasicInfo.appInfo: object expected");
                        message.appInfo = $root.AcFunDanmu.Im.Basic.AppInfo.fromObject(object.appInfo);
                    }
                    if (object.deviceInfo != null) {
                        if (typeof object.deviceInfo !== "object")
                            throw TypeError(".AcFunDanmu.Im.Basic.RequestBasicInfo.deviceInfo: object expected");
                        message.deviceInfo = $root.AcFunDanmu.Im.Basic.DeviceInfo.fromObject(object.deviceInfo);
                    }
                    if (object.envInfo != null) {
                        if (typeof object.envInfo !== "object")
                            throw TypeError(".AcFunDanmu.Im.Basic.RequestBasicInfo.envInfo: object expected");
                        message.envInfo = $root.AcFunDanmu.Im.Basic.EnvInfo.fromObject(object.envInfo);
                    }
                    if (object.clientPort != null)
                        message.clientPort = object.clientPort | 0;
                    if (object.location != null)
                        message.location = String(object.location);
                    if (object.kpf != null)
                        message.kpf = String(object.kpf);
                    return message;
                };

                /**
                 * Creates a plain object from a RequestBasicInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Basic.RequestBasicInfo
                 * @static
                 * @param {AcFunDanmu.Im.Basic.RequestBasicInfo} message RequestBasicInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RequestBasicInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.clientType = options.enums === String ? "kInvalid" : 0;
                        object.deviceId = "";
                        object.clientIp = "";
                        object.appVersion = "";
                        object.channel = "";
                        object.appInfo = null;
                        object.deviceInfo = null;
                        object.envInfo = null;
                        object.clientPort = 0;
                        object.location = "";
                        object.kpf = "";
                    }
                    if (message.clientType != null && message.hasOwnProperty("clientType"))
                        object.clientType = options.enums === String ? $root.AcFunDanmu.Im.Basic.DeviceInfo.PlatformType[message.clientType] : message.clientType;
                    if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                        object.deviceId = message.deviceId;
                    if (message.clientIp != null && message.hasOwnProperty("clientIp"))
                        object.clientIp = message.clientIp;
                    if (message.appVersion != null && message.hasOwnProperty("appVersion"))
                        object.appVersion = message.appVersion;
                    if (message.channel != null && message.hasOwnProperty("channel"))
                        object.channel = message.channel;
                    if (message.appInfo != null && message.hasOwnProperty("appInfo"))
                        object.appInfo = $root.AcFunDanmu.Im.Basic.AppInfo.toObject(message.appInfo, options);
                    if (message.deviceInfo != null && message.hasOwnProperty("deviceInfo"))
                        object.deviceInfo = $root.AcFunDanmu.Im.Basic.DeviceInfo.toObject(message.deviceInfo, options);
                    if (message.envInfo != null && message.hasOwnProperty("envInfo"))
                        object.envInfo = $root.AcFunDanmu.Im.Basic.EnvInfo.toObject(message.envInfo, options);
                    if (message.clientPort != null && message.hasOwnProperty("clientPort"))
                        object.clientPort = message.clientPort;
                    if (message.location != null && message.hasOwnProperty("location"))
                        object.location = message.location;
                    if (message.kpf != null && message.hasOwnProperty("kpf"))
                        object.kpf = message.kpf;
                    return object;
                };

                /**
                 * Converts this RequestBasicInfo to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Basic.RequestBasicInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                RequestBasicInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return RequestBasicInfo;
            })();

            Basic.SyncCookie = (function() {

                /**
                 * Properties of a SyncCookie.
                 * @memberof AcFunDanmu.Im.Basic
                 * @interface ISyncCookie
                 * @property {number|Long|null} [syncOffset] SyncCookie syncOffset
                 */

                /**
                 * Constructs a new SyncCookie.
                 * @memberof AcFunDanmu.Im.Basic
                 * @classdesc Represents a SyncCookie.
                 * @implements ISyncCookie
                 * @constructor
                 * @param {AcFunDanmu.Im.Basic.ISyncCookie=} [properties] Properties to set
                 */
                function SyncCookie(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SyncCookie syncOffset.
                 * @member {number|Long} syncOffset
                 * @memberof AcFunDanmu.Im.Basic.SyncCookie
                 * @instance
                 */
                SyncCookie.prototype.syncOffset = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Creates a new SyncCookie instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Basic.SyncCookie
                 * @static
                 * @param {AcFunDanmu.Im.Basic.ISyncCookie=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Basic.SyncCookie} SyncCookie instance
                 */
                SyncCookie.create = function create(properties) {
                    return new SyncCookie(properties);
                };

                /**
                 * Encodes the specified SyncCookie message. Does not implicitly {@link AcFunDanmu.Im.Basic.SyncCookie.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Basic.SyncCookie
                 * @static
                 * @param {AcFunDanmu.Im.Basic.ISyncCookie} message SyncCookie message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SyncCookie.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.syncOffset != null && Object.hasOwnProperty.call(message, "syncOffset"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int64(message.syncOffset);
                    return writer;
                };

                /**
                 * Encodes the specified SyncCookie message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Basic.SyncCookie.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Basic.SyncCookie
                 * @static
                 * @param {AcFunDanmu.Im.Basic.ISyncCookie} message SyncCookie message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SyncCookie.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SyncCookie message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Basic.SyncCookie
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Basic.SyncCookie} SyncCookie
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SyncCookie.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Basic.SyncCookie();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.syncOffset = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SyncCookie message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Basic.SyncCookie
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Basic.SyncCookie} SyncCookie
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SyncCookie.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SyncCookie message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Basic.SyncCookie
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SyncCookie.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.syncOffset != null && message.hasOwnProperty("syncOffset"))
                        if (!$util.isInteger(message.syncOffset) && !(message.syncOffset && $util.isInteger(message.syncOffset.low) && $util.isInteger(message.syncOffset.high)))
                            return "syncOffset: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a SyncCookie message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Basic.SyncCookie
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Basic.SyncCookie} SyncCookie
                 */
                SyncCookie.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Basic.SyncCookie)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Basic.SyncCookie();
                    if (object.syncOffset != null)
                        if ($util.Long)
                            (message.syncOffset = $util.Long.fromValue(object.syncOffset)).unsigned = false;
                        else if (typeof object.syncOffset === "string")
                            message.syncOffset = parseInt(object.syncOffset, 10);
                        else if (typeof object.syncOffset === "number")
                            message.syncOffset = object.syncOffset;
                        else if (typeof object.syncOffset === "object")
                            message.syncOffset = new $util.LongBits(object.syncOffset.low >>> 0, object.syncOffset.high >>> 0).toNumber();
                    return message;
                };

                /**
                 * Creates a plain object from a SyncCookie message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Basic.SyncCookie
                 * @static
                 * @param {AcFunDanmu.Im.Basic.SyncCookie} message SyncCookie
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SyncCookie.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.syncOffset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.syncOffset = options.longs === String ? "0" : 0;
                    if (message.syncOffset != null && message.hasOwnProperty("syncOffset"))
                        if (typeof message.syncOffset === "number")
                            object.syncOffset = options.longs === String ? String(message.syncOffset) : message.syncOffset;
                        else
                            object.syncOffset = options.longs === String ? $util.Long.prototype.toString.call(message.syncOffset) : options.longs === Number ? new $util.LongBits(message.syncOffset.low >>> 0, message.syncOffset.high >>> 0).toNumber() : message.syncOffset;
                    return object;
                };

                /**
                 * Converts this SyncCookie to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Basic.SyncCookie
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SyncCookie.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SyncCookie;
            })();

            Basic.I18nCopyWriting = (function() {

                /**
                 * Properties of a I18nCopyWriting.
                 * @memberof AcFunDanmu.Im.Basic
                 * @interface II18nCopyWriting
                 * @property {string|null} [formatKey] I18nCopyWriting formatKey
                 * @property {Array.<string>|null} [formatParam] I18nCopyWriting formatParam
                 */

                /**
                 * Constructs a new I18nCopyWriting.
                 * @memberof AcFunDanmu.Im.Basic
                 * @classdesc Represents a I18nCopyWriting.
                 * @implements II18nCopyWriting
                 * @constructor
                 * @param {AcFunDanmu.Im.Basic.II18nCopyWriting=} [properties] Properties to set
                 */
                function I18nCopyWriting(properties) {
                    this.formatParam = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * I18nCopyWriting formatKey.
                 * @member {string} formatKey
                 * @memberof AcFunDanmu.Im.Basic.I18nCopyWriting
                 * @instance
                 */
                I18nCopyWriting.prototype.formatKey = "";

                /**
                 * I18nCopyWriting formatParam.
                 * @member {Array.<string>} formatParam
                 * @memberof AcFunDanmu.Im.Basic.I18nCopyWriting
                 * @instance
                 */
                I18nCopyWriting.prototype.formatParam = $util.emptyArray;

                /**
                 * Creates a new I18nCopyWriting instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Basic.I18nCopyWriting
                 * @static
                 * @param {AcFunDanmu.Im.Basic.II18nCopyWriting=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Basic.I18nCopyWriting} I18nCopyWriting instance
                 */
                I18nCopyWriting.create = function create(properties) {
                    return new I18nCopyWriting(properties);
                };

                /**
                 * Encodes the specified I18nCopyWriting message. Does not implicitly {@link AcFunDanmu.Im.Basic.I18nCopyWriting.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Basic.I18nCopyWriting
                 * @static
                 * @param {AcFunDanmu.Im.Basic.II18nCopyWriting} message I18nCopyWriting message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                I18nCopyWriting.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.formatKey != null && Object.hasOwnProperty.call(message, "formatKey"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.formatKey);
                    if (message.formatParam != null && message.formatParam.length)
                        for (let i = 0; i < message.formatParam.length; ++i)
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.formatParam[i]);
                    return writer;
                };

                /**
                 * Encodes the specified I18nCopyWriting message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Basic.I18nCopyWriting.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Basic.I18nCopyWriting
                 * @static
                 * @param {AcFunDanmu.Im.Basic.II18nCopyWriting} message I18nCopyWriting message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                I18nCopyWriting.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a I18nCopyWriting message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Basic.I18nCopyWriting
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Basic.I18nCopyWriting} I18nCopyWriting
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                I18nCopyWriting.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Basic.I18nCopyWriting();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.formatKey = reader.string();
                            break;
                        case 2:
                            if (!(message.formatParam && message.formatParam.length))
                                message.formatParam = [];
                            message.formatParam.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a I18nCopyWriting message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Basic.I18nCopyWriting
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Basic.I18nCopyWriting} I18nCopyWriting
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                I18nCopyWriting.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a I18nCopyWriting message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Basic.I18nCopyWriting
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                I18nCopyWriting.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.formatKey != null && message.hasOwnProperty("formatKey"))
                        if (!$util.isString(message.formatKey))
                            return "formatKey: string expected";
                    if (message.formatParam != null && message.hasOwnProperty("formatParam")) {
                        if (!Array.isArray(message.formatParam))
                            return "formatParam: array expected";
                        for (let i = 0; i < message.formatParam.length; ++i)
                            if (!$util.isString(message.formatParam[i]))
                                return "formatParam: string[] expected";
                    }
                    return null;
                };

                /**
                 * Creates a I18nCopyWriting message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Basic.I18nCopyWriting
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Basic.I18nCopyWriting} I18nCopyWriting
                 */
                I18nCopyWriting.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Basic.I18nCopyWriting)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Basic.I18nCopyWriting();
                    if (object.formatKey != null)
                        message.formatKey = String(object.formatKey);
                    if (object.formatParam) {
                        if (!Array.isArray(object.formatParam))
                            throw TypeError(".AcFunDanmu.Im.Basic.I18nCopyWriting.formatParam: array expected");
                        message.formatParam = [];
                        for (let i = 0; i < object.formatParam.length; ++i)
                            message.formatParam[i] = String(object.formatParam[i]);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a I18nCopyWriting message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Basic.I18nCopyWriting
                 * @static
                 * @param {AcFunDanmu.Im.Basic.I18nCopyWriting} message I18nCopyWriting
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                I18nCopyWriting.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.formatParam = [];
                    if (options.defaults)
                        object.formatKey = "";
                    if (message.formatKey != null && message.hasOwnProperty("formatKey"))
                        object.formatKey = message.formatKey;
                    if (message.formatParam && message.formatParam.length) {
                        object.formatParam = [];
                        for (let j = 0; j < message.formatParam.length; ++j)
                            object.formatParam[j] = message.formatParam[j];
                    }
                    return object;
                };

                /**
                 * Converts this I18nCopyWriting to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Basic.I18nCopyWriting
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                I18nCopyWriting.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return I18nCopyWriting;
            })();

            Basic.SdkOption = (function() {

                /**
                 * Properties of a SdkOption.
                 * @memberof AcFunDanmu.Im.Basic
                 * @interface ISdkOption
                 * @property {number|null} [reportIntervalSeconds] SdkOption reportIntervalSeconds
                 * @property {string|null} [reportSecurity] SdkOption reportSecurity
                 * @property {number|null} [lz4CompressionThresholdBytes] SdkOption lz4CompressionThresholdBytes
                 * @property {Array.<string>|null} [netCheckServers] SdkOption netCheckServers
                 */

                /**
                 * Constructs a new SdkOption.
                 * @memberof AcFunDanmu.Im.Basic
                 * @classdesc Represents a SdkOption.
                 * @implements ISdkOption
                 * @constructor
                 * @param {AcFunDanmu.Im.Basic.ISdkOption=} [properties] Properties to set
                 */
                function SdkOption(properties) {
                    this.netCheckServers = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SdkOption reportIntervalSeconds.
                 * @member {number} reportIntervalSeconds
                 * @memberof AcFunDanmu.Im.Basic.SdkOption
                 * @instance
                 */
                SdkOption.prototype.reportIntervalSeconds = 0;

                /**
                 * SdkOption reportSecurity.
                 * @member {string} reportSecurity
                 * @memberof AcFunDanmu.Im.Basic.SdkOption
                 * @instance
                 */
                SdkOption.prototype.reportSecurity = "";

                /**
                 * SdkOption lz4CompressionThresholdBytes.
                 * @member {number} lz4CompressionThresholdBytes
                 * @memberof AcFunDanmu.Im.Basic.SdkOption
                 * @instance
                 */
                SdkOption.prototype.lz4CompressionThresholdBytes = 0;

                /**
                 * SdkOption netCheckServers.
                 * @member {Array.<string>} netCheckServers
                 * @memberof AcFunDanmu.Im.Basic.SdkOption
                 * @instance
                 */
                SdkOption.prototype.netCheckServers = $util.emptyArray;

                /**
                 * Creates a new SdkOption instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Basic.SdkOption
                 * @static
                 * @param {AcFunDanmu.Im.Basic.ISdkOption=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Basic.SdkOption} SdkOption instance
                 */
                SdkOption.create = function create(properties) {
                    return new SdkOption(properties);
                };

                /**
                 * Encodes the specified SdkOption message. Does not implicitly {@link AcFunDanmu.Im.Basic.SdkOption.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Basic.SdkOption
                 * @static
                 * @param {AcFunDanmu.Im.Basic.ISdkOption} message SdkOption message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SdkOption.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.reportIntervalSeconds != null && Object.hasOwnProperty.call(message, "reportIntervalSeconds"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.reportIntervalSeconds);
                    if (message.reportSecurity != null && Object.hasOwnProperty.call(message, "reportSecurity"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.reportSecurity);
                    if (message.lz4CompressionThresholdBytes != null && Object.hasOwnProperty.call(message, "lz4CompressionThresholdBytes"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.lz4CompressionThresholdBytes);
                    if (message.netCheckServers != null && message.netCheckServers.length)
                        for (let i = 0; i < message.netCheckServers.length; ++i)
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.netCheckServers[i]);
                    return writer;
                };

                /**
                 * Encodes the specified SdkOption message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Basic.SdkOption.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Basic.SdkOption
                 * @static
                 * @param {AcFunDanmu.Im.Basic.ISdkOption} message SdkOption message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SdkOption.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SdkOption message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Basic.SdkOption
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Basic.SdkOption} SdkOption
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SdkOption.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Basic.SdkOption();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.reportIntervalSeconds = reader.int32();
                            break;
                        case 2:
                            message.reportSecurity = reader.string();
                            break;
                        case 3:
                            message.lz4CompressionThresholdBytes = reader.int32();
                            break;
                        case 4:
                            if (!(message.netCheckServers && message.netCheckServers.length))
                                message.netCheckServers = [];
                            message.netCheckServers.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SdkOption message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Basic.SdkOption
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Basic.SdkOption} SdkOption
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SdkOption.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SdkOption message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Basic.SdkOption
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SdkOption.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.reportIntervalSeconds != null && message.hasOwnProperty("reportIntervalSeconds"))
                        if (!$util.isInteger(message.reportIntervalSeconds))
                            return "reportIntervalSeconds: integer expected";
                    if (message.reportSecurity != null && message.hasOwnProperty("reportSecurity"))
                        if (!$util.isString(message.reportSecurity))
                            return "reportSecurity: string expected";
                    if (message.lz4CompressionThresholdBytes != null && message.hasOwnProperty("lz4CompressionThresholdBytes"))
                        if (!$util.isInteger(message.lz4CompressionThresholdBytes))
                            return "lz4CompressionThresholdBytes: integer expected";
                    if (message.netCheckServers != null && message.hasOwnProperty("netCheckServers")) {
                        if (!Array.isArray(message.netCheckServers))
                            return "netCheckServers: array expected";
                        for (let i = 0; i < message.netCheckServers.length; ++i)
                            if (!$util.isString(message.netCheckServers[i]))
                                return "netCheckServers: string[] expected";
                    }
                    return null;
                };

                /**
                 * Creates a SdkOption message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Basic.SdkOption
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Basic.SdkOption} SdkOption
                 */
                SdkOption.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Basic.SdkOption)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Basic.SdkOption();
                    if (object.reportIntervalSeconds != null)
                        message.reportIntervalSeconds = object.reportIntervalSeconds | 0;
                    if (object.reportSecurity != null)
                        message.reportSecurity = String(object.reportSecurity);
                    if (object.lz4CompressionThresholdBytes != null)
                        message.lz4CompressionThresholdBytes = object.lz4CompressionThresholdBytes | 0;
                    if (object.netCheckServers) {
                        if (!Array.isArray(object.netCheckServers))
                            throw TypeError(".AcFunDanmu.Im.Basic.SdkOption.netCheckServers: array expected");
                        message.netCheckServers = [];
                        for (let i = 0; i < object.netCheckServers.length; ++i)
                            message.netCheckServers[i] = String(object.netCheckServers[i]);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a SdkOption message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Basic.SdkOption
                 * @static
                 * @param {AcFunDanmu.Im.Basic.SdkOption} message SdkOption
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SdkOption.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.netCheckServers = [];
                    if (options.defaults) {
                        object.reportIntervalSeconds = 0;
                        object.reportSecurity = "";
                        object.lz4CompressionThresholdBytes = 0;
                    }
                    if (message.reportIntervalSeconds != null && message.hasOwnProperty("reportIntervalSeconds"))
                        object.reportIntervalSeconds = message.reportIntervalSeconds;
                    if (message.reportSecurity != null && message.hasOwnProperty("reportSecurity"))
                        object.reportSecurity = message.reportSecurity;
                    if (message.lz4CompressionThresholdBytes != null && message.hasOwnProperty("lz4CompressionThresholdBytes"))
                        object.lz4CompressionThresholdBytes = message.lz4CompressionThresholdBytes;
                    if (message.netCheckServers && message.netCheckServers.length) {
                        object.netCheckServers = [];
                        for (let j = 0; j < message.netCheckServers.length; ++j)
                            object.netCheckServers[j] = message.netCheckServers[j];
                    }
                    return object;
                };

                /**
                 * Converts this SdkOption to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Basic.SdkOption
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SdkOption.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SdkOption;
            })();

            Basic.ZtCommonInfo = (function() {

                /**
                 * Properties of a ZtCommonInfo.
                 * @memberof AcFunDanmu.Im.Basic
                 * @interface IZtCommonInfo
                 * @property {string|null} [kpn] ZtCommonInfo kpn
                 * @property {string|null} [kpf] ZtCommonInfo kpf
                 * @property {string|null} [subBiz] ZtCommonInfo subBiz
                 * @property {number|Long|null} [uid] ZtCommonInfo uid
                 * @property {string|null} [did] ZtCommonInfo did
                 * @property {number|Long|null} [clientIp] ZtCommonInfo clientIp
                 * @property {string|null} [appVer] ZtCommonInfo appVer
                 * @property {string|null} [ver] ZtCommonInfo ver
                 * @property {string|null} [lat] ZtCommonInfo lat
                 * @property {string|null} [lon] ZtCommonInfo lon
                 * @property {string|null} [mond] ZtCommonInfo mond
                 * @property {string|null} [net] ZtCommonInfo net
                 * @property {string|null} [sys] ZtCommonInfo sys
                 * @property {string|null} [c] ZtCommonInfo c
                 * @property {string|null} [language] ZtCommonInfo language
                 * @property {string|null} [countryCode] ZtCommonInfo countryCode
                 */

                /**
                 * Constructs a new ZtCommonInfo.
                 * @memberof AcFunDanmu.Im.Basic
                 * @classdesc Represents a ZtCommonInfo.
                 * @implements IZtCommonInfo
                 * @constructor
                 * @param {AcFunDanmu.Im.Basic.IZtCommonInfo=} [properties] Properties to set
                 */
                function ZtCommonInfo(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ZtCommonInfo kpn.
                 * @member {string} kpn
                 * @memberof AcFunDanmu.Im.Basic.ZtCommonInfo
                 * @instance
                 */
                ZtCommonInfo.prototype.kpn = "";

                /**
                 * ZtCommonInfo kpf.
                 * @member {string} kpf
                 * @memberof AcFunDanmu.Im.Basic.ZtCommonInfo
                 * @instance
                 */
                ZtCommonInfo.prototype.kpf = "";

                /**
                 * ZtCommonInfo subBiz.
                 * @member {string} subBiz
                 * @memberof AcFunDanmu.Im.Basic.ZtCommonInfo
                 * @instance
                 */
                ZtCommonInfo.prototype.subBiz = "";

                /**
                 * ZtCommonInfo uid.
                 * @member {number|Long} uid
                 * @memberof AcFunDanmu.Im.Basic.ZtCommonInfo
                 * @instance
                 */
                ZtCommonInfo.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * ZtCommonInfo did.
                 * @member {string} did
                 * @memberof AcFunDanmu.Im.Basic.ZtCommonInfo
                 * @instance
                 */
                ZtCommonInfo.prototype.did = "";

                /**
                 * ZtCommonInfo clientIp.
                 * @member {number|Long} clientIp
                 * @memberof AcFunDanmu.Im.Basic.ZtCommonInfo
                 * @instance
                 */
                ZtCommonInfo.prototype.clientIp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * ZtCommonInfo appVer.
                 * @member {string} appVer
                 * @memberof AcFunDanmu.Im.Basic.ZtCommonInfo
                 * @instance
                 */
                ZtCommonInfo.prototype.appVer = "";

                /**
                 * ZtCommonInfo ver.
                 * @member {string} ver
                 * @memberof AcFunDanmu.Im.Basic.ZtCommonInfo
                 * @instance
                 */
                ZtCommonInfo.prototype.ver = "";

                /**
                 * ZtCommonInfo lat.
                 * @member {string} lat
                 * @memberof AcFunDanmu.Im.Basic.ZtCommonInfo
                 * @instance
                 */
                ZtCommonInfo.prototype.lat = "";

                /**
                 * ZtCommonInfo lon.
                 * @member {string} lon
                 * @memberof AcFunDanmu.Im.Basic.ZtCommonInfo
                 * @instance
                 */
                ZtCommonInfo.prototype.lon = "";

                /**
                 * ZtCommonInfo mond.
                 * @member {string} mond
                 * @memberof AcFunDanmu.Im.Basic.ZtCommonInfo
                 * @instance
                 */
                ZtCommonInfo.prototype.mond = "";

                /**
                 * ZtCommonInfo net.
                 * @member {string} net
                 * @memberof AcFunDanmu.Im.Basic.ZtCommonInfo
                 * @instance
                 */
                ZtCommonInfo.prototype.net = "";

                /**
                 * ZtCommonInfo sys.
                 * @member {string} sys
                 * @memberof AcFunDanmu.Im.Basic.ZtCommonInfo
                 * @instance
                 */
                ZtCommonInfo.prototype.sys = "";

                /**
                 * ZtCommonInfo c.
                 * @member {string} c
                 * @memberof AcFunDanmu.Im.Basic.ZtCommonInfo
                 * @instance
                 */
                ZtCommonInfo.prototype.c = "";

                /**
                 * ZtCommonInfo language.
                 * @member {string} language
                 * @memberof AcFunDanmu.Im.Basic.ZtCommonInfo
                 * @instance
                 */
                ZtCommonInfo.prototype.language = "";

                /**
                 * ZtCommonInfo countryCode.
                 * @member {string} countryCode
                 * @memberof AcFunDanmu.Im.Basic.ZtCommonInfo
                 * @instance
                 */
                ZtCommonInfo.prototype.countryCode = "";

                /**
                 * Creates a new ZtCommonInfo instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Basic.ZtCommonInfo
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IZtCommonInfo=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Basic.ZtCommonInfo} ZtCommonInfo instance
                 */
                ZtCommonInfo.create = function create(properties) {
                    return new ZtCommonInfo(properties);
                };

                /**
                 * Encodes the specified ZtCommonInfo message. Does not implicitly {@link AcFunDanmu.Im.Basic.ZtCommonInfo.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Basic.ZtCommonInfo
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IZtCommonInfo} message ZtCommonInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ZtCommonInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.kpn != null && Object.hasOwnProperty.call(message, "kpn"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.kpn);
                    if (message.kpf != null && Object.hasOwnProperty.call(message, "kpf"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.kpf);
                    if (message.subBiz != null && Object.hasOwnProperty.call(message, "subBiz"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.subBiz);
                    if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int64(message.uid);
                    if (message.did != null && Object.hasOwnProperty.call(message, "did"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.did);
                    if (message.clientIp != null && Object.hasOwnProperty.call(message, "clientIp"))
                        writer.uint32(/* id 6, wireType 0 =*/48).int64(message.clientIp);
                    if (message.appVer != null && Object.hasOwnProperty.call(message, "appVer"))
                        writer.uint32(/* id 7, wireType 2 =*/58).string(message.appVer);
                    if (message.ver != null && Object.hasOwnProperty.call(message, "ver"))
                        writer.uint32(/* id 8, wireType 2 =*/66).string(message.ver);
                    if (message.lat != null && Object.hasOwnProperty.call(message, "lat"))
                        writer.uint32(/* id 9, wireType 2 =*/74).string(message.lat);
                    if (message.lon != null && Object.hasOwnProperty.call(message, "lon"))
                        writer.uint32(/* id 10, wireType 2 =*/82).string(message.lon);
                    if (message.mond != null && Object.hasOwnProperty.call(message, "mond"))
                        writer.uint32(/* id 11, wireType 2 =*/90).string(message.mond);
                    if (message.net != null && Object.hasOwnProperty.call(message, "net"))
                        writer.uint32(/* id 12, wireType 2 =*/98).string(message.net);
                    if (message.sys != null && Object.hasOwnProperty.call(message, "sys"))
                        writer.uint32(/* id 13, wireType 2 =*/106).string(message.sys);
                    if (message.c != null && Object.hasOwnProperty.call(message, "c"))
                        writer.uint32(/* id 14, wireType 2 =*/114).string(message.c);
                    if (message.language != null && Object.hasOwnProperty.call(message, "language"))
                        writer.uint32(/* id 15, wireType 2 =*/122).string(message.language);
                    if (message.countryCode != null && Object.hasOwnProperty.call(message, "countryCode"))
                        writer.uint32(/* id 16, wireType 2 =*/130).string(message.countryCode);
                    return writer;
                };

                /**
                 * Encodes the specified ZtCommonInfo message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Basic.ZtCommonInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Basic.ZtCommonInfo
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IZtCommonInfo} message ZtCommonInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ZtCommonInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ZtCommonInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Basic.ZtCommonInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Basic.ZtCommonInfo} ZtCommonInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ZtCommonInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Basic.ZtCommonInfo();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.kpn = reader.string();
                            break;
                        case 2:
                            message.kpf = reader.string();
                            break;
                        case 3:
                            message.subBiz = reader.string();
                            break;
                        case 4:
                            message.uid = reader.int64();
                            break;
                        case 5:
                            message.did = reader.string();
                            break;
                        case 6:
                            message.clientIp = reader.int64();
                            break;
                        case 7:
                            message.appVer = reader.string();
                            break;
                        case 8:
                            message.ver = reader.string();
                            break;
                        case 9:
                            message.lat = reader.string();
                            break;
                        case 10:
                            message.lon = reader.string();
                            break;
                        case 11:
                            message.mond = reader.string();
                            break;
                        case 12:
                            message.net = reader.string();
                            break;
                        case 13:
                            message.sys = reader.string();
                            break;
                        case 14:
                            message.c = reader.string();
                            break;
                        case 15:
                            message.language = reader.string();
                            break;
                        case 16:
                            message.countryCode = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ZtCommonInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Basic.ZtCommonInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Basic.ZtCommonInfo} ZtCommonInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ZtCommonInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ZtCommonInfo message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Basic.ZtCommonInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ZtCommonInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.kpn != null && message.hasOwnProperty("kpn"))
                        if (!$util.isString(message.kpn))
                            return "kpn: string expected";
                    if (message.kpf != null && message.hasOwnProperty("kpf"))
                        if (!$util.isString(message.kpf))
                            return "kpf: string expected";
                    if (message.subBiz != null && message.hasOwnProperty("subBiz"))
                        if (!$util.isString(message.subBiz))
                            return "subBiz: string expected";
                    if (message.uid != null && message.hasOwnProperty("uid"))
                        if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                            return "uid: integer|Long expected";
                    if (message.did != null && message.hasOwnProperty("did"))
                        if (!$util.isString(message.did))
                            return "did: string expected";
                    if (message.clientIp != null && message.hasOwnProperty("clientIp"))
                        if (!$util.isInteger(message.clientIp) && !(message.clientIp && $util.isInteger(message.clientIp.low) && $util.isInteger(message.clientIp.high)))
                            return "clientIp: integer|Long expected";
                    if (message.appVer != null && message.hasOwnProperty("appVer"))
                        if (!$util.isString(message.appVer))
                            return "appVer: string expected";
                    if (message.ver != null && message.hasOwnProperty("ver"))
                        if (!$util.isString(message.ver))
                            return "ver: string expected";
                    if (message.lat != null && message.hasOwnProperty("lat"))
                        if (!$util.isString(message.lat))
                            return "lat: string expected";
                    if (message.lon != null && message.hasOwnProperty("lon"))
                        if (!$util.isString(message.lon))
                            return "lon: string expected";
                    if (message.mond != null && message.hasOwnProperty("mond"))
                        if (!$util.isString(message.mond))
                            return "mond: string expected";
                    if (message.net != null && message.hasOwnProperty("net"))
                        if (!$util.isString(message.net))
                            return "net: string expected";
                    if (message.sys != null && message.hasOwnProperty("sys"))
                        if (!$util.isString(message.sys))
                            return "sys: string expected";
                    if (message.c != null && message.hasOwnProperty("c"))
                        if (!$util.isString(message.c))
                            return "c: string expected";
                    if (message.language != null && message.hasOwnProperty("language"))
                        if (!$util.isString(message.language))
                            return "language: string expected";
                    if (message.countryCode != null && message.hasOwnProperty("countryCode"))
                        if (!$util.isString(message.countryCode))
                            return "countryCode: string expected";
                    return null;
                };

                /**
                 * Creates a ZtCommonInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Basic.ZtCommonInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Basic.ZtCommonInfo} ZtCommonInfo
                 */
                ZtCommonInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Basic.ZtCommonInfo)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Basic.ZtCommonInfo();
                    if (object.kpn != null)
                        message.kpn = String(object.kpn);
                    if (object.kpf != null)
                        message.kpf = String(object.kpf);
                    if (object.subBiz != null)
                        message.subBiz = String(object.subBiz);
                    if (object.uid != null)
                        if ($util.Long)
                            (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                        else if (typeof object.uid === "string")
                            message.uid = parseInt(object.uid, 10);
                        else if (typeof object.uid === "number")
                            message.uid = object.uid;
                        else if (typeof object.uid === "object")
                            message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
                    if (object.did != null)
                        message.did = String(object.did);
                    if (object.clientIp != null)
                        if ($util.Long)
                            (message.clientIp = $util.Long.fromValue(object.clientIp)).unsigned = false;
                        else if (typeof object.clientIp === "string")
                            message.clientIp = parseInt(object.clientIp, 10);
                        else if (typeof object.clientIp === "number")
                            message.clientIp = object.clientIp;
                        else if (typeof object.clientIp === "object")
                            message.clientIp = new $util.LongBits(object.clientIp.low >>> 0, object.clientIp.high >>> 0).toNumber();
                    if (object.appVer != null)
                        message.appVer = String(object.appVer);
                    if (object.ver != null)
                        message.ver = String(object.ver);
                    if (object.lat != null)
                        message.lat = String(object.lat);
                    if (object.lon != null)
                        message.lon = String(object.lon);
                    if (object.mond != null)
                        message.mond = String(object.mond);
                    if (object.net != null)
                        message.net = String(object.net);
                    if (object.sys != null)
                        message.sys = String(object.sys);
                    if (object.c != null)
                        message.c = String(object.c);
                    if (object.language != null)
                        message.language = String(object.language);
                    if (object.countryCode != null)
                        message.countryCode = String(object.countryCode);
                    return message;
                };

                /**
                 * Creates a plain object from a ZtCommonInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Basic.ZtCommonInfo
                 * @static
                 * @param {AcFunDanmu.Im.Basic.ZtCommonInfo} message ZtCommonInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ZtCommonInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.kpn = "";
                        object.kpf = "";
                        object.subBiz = "";
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.uid = options.longs === String ? "0" : 0;
                        object.did = "";
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.clientIp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.clientIp = options.longs === String ? "0" : 0;
                        object.appVer = "";
                        object.ver = "";
                        object.lat = "";
                        object.lon = "";
                        object.mond = "";
                        object.net = "";
                        object.sys = "";
                        object.c = "";
                        object.language = "";
                        object.countryCode = "";
                    }
                    if (message.kpn != null && message.hasOwnProperty("kpn"))
                        object.kpn = message.kpn;
                    if (message.kpf != null && message.hasOwnProperty("kpf"))
                        object.kpf = message.kpf;
                    if (message.subBiz != null && message.hasOwnProperty("subBiz"))
                        object.subBiz = message.subBiz;
                    if (message.uid != null && message.hasOwnProperty("uid"))
                        if (typeof message.uid === "number")
                            object.uid = options.longs === String ? String(message.uid) : message.uid;
                        else
                            object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
                    if (message.did != null && message.hasOwnProperty("did"))
                        object.did = message.did;
                    if (message.clientIp != null && message.hasOwnProperty("clientIp"))
                        if (typeof message.clientIp === "number")
                            object.clientIp = options.longs === String ? String(message.clientIp) : message.clientIp;
                        else
                            object.clientIp = options.longs === String ? $util.Long.prototype.toString.call(message.clientIp) : options.longs === Number ? new $util.LongBits(message.clientIp.low >>> 0, message.clientIp.high >>> 0).toNumber() : message.clientIp;
                    if (message.appVer != null && message.hasOwnProperty("appVer"))
                        object.appVer = message.appVer;
                    if (message.ver != null && message.hasOwnProperty("ver"))
                        object.ver = message.ver;
                    if (message.lat != null && message.hasOwnProperty("lat"))
                        object.lat = message.lat;
                    if (message.lon != null && message.hasOwnProperty("lon"))
                        object.lon = message.lon;
                    if (message.mond != null && message.hasOwnProperty("mond"))
                        object.mond = message.mond;
                    if (message.net != null && message.hasOwnProperty("net"))
                        object.net = message.net;
                    if (message.sys != null && message.hasOwnProperty("sys"))
                        object.sys = message.sys;
                    if (message.c != null && message.hasOwnProperty("c"))
                        object.c = message.c;
                    if (message.language != null && message.hasOwnProperty("language"))
                        object.language = message.language;
                    if (message.countryCode != null && message.hasOwnProperty("countryCode"))
                        object.countryCode = message.countryCode;
                    return object;
                };

                /**
                 * Converts this ZtCommonInfo to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Basic.ZtCommonInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ZtCommonInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ZtCommonInfo;
            })();

            Basic.FrontendInfo = (function() {

                /**
                 * Properties of a FrontendInfo.
                 * @memberof AcFunDanmu.Im.Basic
                 * @interface IFrontendInfo
                 * @property {string|null} [ip] FrontendInfo ip
                 * @property {number|null} [port] FrontendInfo port
                 */

                /**
                 * Constructs a new FrontendInfo.
                 * @memberof AcFunDanmu.Im.Basic
                 * @classdesc Represents a FrontendInfo.
                 * @implements IFrontendInfo
                 * @constructor
                 * @param {AcFunDanmu.Im.Basic.IFrontendInfo=} [properties] Properties to set
                 */
                function FrontendInfo(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * FrontendInfo ip.
                 * @member {string} ip
                 * @memberof AcFunDanmu.Im.Basic.FrontendInfo
                 * @instance
                 */
                FrontendInfo.prototype.ip = "";

                /**
                 * FrontendInfo port.
                 * @member {number} port
                 * @memberof AcFunDanmu.Im.Basic.FrontendInfo
                 * @instance
                 */
                FrontendInfo.prototype.port = 0;

                /**
                 * Creates a new FrontendInfo instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Basic.FrontendInfo
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IFrontendInfo=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Basic.FrontendInfo} FrontendInfo instance
                 */
                FrontendInfo.create = function create(properties) {
                    return new FrontendInfo(properties);
                };

                /**
                 * Encodes the specified FrontendInfo message. Does not implicitly {@link AcFunDanmu.Im.Basic.FrontendInfo.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Basic.FrontendInfo
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IFrontendInfo} message FrontendInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FrontendInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.ip != null && Object.hasOwnProperty.call(message, "ip"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.ip);
                    if (message.port != null && Object.hasOwnProperty.call(message, "port"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.port);
                    return writer;
                };

                /**
                 * Encodes the specified FrontendInfo message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Basic.FrontendInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Basic.FrontendInfo
                 * @static
                 * @param {AcFunDanmu.Im.Basic.IFrontendInfo} message FrontendInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FrontendInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a FrontendInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Basic.FrontendInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Basic.FrontendInfo} FrontendInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FrontendInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Basic.FrontendInfo();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.ip = reader.string();
                            break;
                        case 2:
                            message.port = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a FrontendInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Basic.FrontendInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Basic.FrontendInfo} FrontendInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FrontendInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a FrontendInfo message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Basic.FrontendInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FrontendInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.ip != null && message.hasOwnProperty("ip"))
                        if (!$util.isString(message.ip))
                            return "ip: string expected";
                    if (message.port != null && message.hasOwnProperty("port"))
                        if (!$util.isInteger(message.port))
                            return "port: integer expected";
                    return null;
                };

                /**
                 * Creates a FrontendInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Basic.FrontendInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Basic.FrontendInfo} FrontendInfo
                 */
                FrontendInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Basic.FrontendInfo)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Basic.FrontendInfo();
                    if (object.ip != null)
                        message.ip = String(object.ip);
                    if (object.port != null)
                        message.port = object.port | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a FrontendInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Basic.FrontendInfo
                 * @static
                 * @param {AcFunDanmu.Im.Basic.FrontendInfo} message FrontendInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FrontendInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.ip = "";
                        object.port = 0;
                    }
                    if (message.ip != null && message.hasOwnProperty("ip"))
                        object.ip = message.ip;
                    if (message.port != null && message.hasOwnProperty("port"))
                        object.port = message.port;
                    return object;
                };

                /**
                 * Converts this FrontendInfo to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Basic.FrontendInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FrontendInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return FrontendInfo;
            })();

            return Basic;
        })();

        Im.Message = (function() {

            /**
             * Properties of a Message.
             * @memberof AcFunDanmu.Im
             * @interface IMessage
             */

            /**
             * Constructs a new Message.
             * @memberof AcFunDanmu.Im
             * @classdesc Represents a Message.
             * @implements IMessage
             * @constructor
             * @param {AcFunDanmu.Im.IMessage=} [properties] Properties to set
             */
            function Message(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new Message instance using the specified properties.
             * @function create
             * @memberof AcFunDanmu.Im.Message
             * @static
             * @param {AcFunDanmu.Im.IMessage=} [properties] Properties to set
             * @returns {AcFunDanmu.Im.Message} Message instance
             */
            Message.create = function create(properties) {
                return new Message(properties);
            };

            /**
             * Encodes the specified Message message. Does not implicitly {@link AcFunDanmu.Im.Message.verify|verify} messages.
             * @function encode
             * @memberof AcFunDanmu.Im.Message
             * @static
             * @param {AcFunDanmu.Im.IMessage} message Message message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Message.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified Message message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Message.verify|verify} messages.
             * @function encodeDelimited
             * @memberof AcFunDanmu.Im.Message
             * @static
             * @param {AcFunDanmu.Im.IMessage} message Message message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Message.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Message message from the specified reader or buffer.
             * @function decode
             * @memberof AcFunDanmu.Im.Message
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {AcFunDanmu.Im.Message} Message
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Message.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Message();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Message message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof AcFunDanmu.Im.Message
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {AcFunDanmu.Im.Message} Message
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Message.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Message message.
             * @function verify
             * @memberof AcFunDanmu.Im.Message
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Message.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a Message message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof AcFunDanmu.Im.Message
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {AcFunDanmu.Im.Message} Message
             */
            Message.fromObject = function fromObject(object) {
                if (object instanceof $root.AcFunDanmu.Im.Message)
                    return object;
                return new $root.AcFunDanmu.Im.Message();
            };

            /**
             * Creates a plain object from a Message message. Also converts values to other types if specified.
             * @function toObject
             * @memberof AcFunDanmu.Im.Message
             * @static
             * @param {AcFunDanmu.Im.Message} message Message
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Message.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this Message to JSON.
             * @function toJSON
             * @memberof AcFunDanmu.Im.Message
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Message.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            Message.Message = (function() {

                /**
                 * Properties of a Message.
                 * @memberof AcFunDanmu.Im.Message
                 * @interface IMessage
                 * @property {number|Long|null} [seqId] Message seqId
                 * @property {number|Long|null} [clientSeqId] Message clientSeqId
                 * @property {number|Long|null} [timestampMs] Message timestampMs
                 * @property {AcFunDanmu.Im.Basic.IUser|null} [fromUser] Message fromUser
                 * @property {number|Long|null} [targetId] Message targetId
                 * @property {AcFunDanmu.Im.Basic.IUser|null} [toUser] Message toUser
                 * @property {string|null} [title] Message title
                 * @property {number|null} [contentType] Message contentType
                 * @property {Uint8Array|null} [content] Message content
                 * @property {string|null} [buckupTips] Message buckupTips
                 * @property {Array.<AcFunDanmu.Im.Basic.IUser>|null} [receivers] Message receivers
                 * @property {boolean|null} [notContentUnread] Message notContentUnread
                 * @property {number|null} [sessionPriority] Message sessionPriority
                 * @property {number|null} [sessionCategoryId] Message sessionCategoryId
                 * @property {number|null} [sessionAccountType] Message sessionAccountType
                 * @property {boolean|null} [notAutoCreateSession] Message notAutoCreateSession
                 * @property {number|null} [userRelationship] Message userRelationship
                 * @property {string|null} [strTargetId] Message strTargetId
                 * @property {Array.<AcFunDanmu.Im.Basic.IUser>|null} [excludeReceivers] Message excludeReceivers
                 * @property {boolean|null} [markDelte] Message markDelte
                 * @property {AcFunDanmu.Im.Message.IReminder|null} [reminder] Message reminder
                 * @property {Uint8Array|null} [extra] Message extra
                 * @property {boolean|null} [receiptRequired] Message receiptRequired
                 */

                /**
                 * Constructs a new Message.
                 * @memberof AcFunDanmu.Im.Message
                 * @classdesc Represents a Message.
                 * @implements IMessage
                 * @constructor
                 * @param {AcFunDanmu.Im.Message.IMessage=} [properties] Properties to set
                 */
                function Message(properties) {
                    this.receivers = [];
                    this.excludeReceivers = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Message seqId.
                 * @member {number|Long} seqId
                 * @memberof AcFunDanmu.Im.Message.Message
                 * @instance
                 */
                Message.prototype.seqId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Message clientSeqId.
                 * @member {number|Long} clientSeqId
                 * @memberof AcFunDanmu.Im.Message.Message
                 * @instance
                 */
                Message.prototype.clientSeqId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Message timestampMs.
                 * @member {number|Long} timestampMs
                 * @memberof AcFunDanmu.Im.Message.Message
                 * @instance
                 */
                Message.prototype.timestampMs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Message fromUser.
                 * @member {AcFunDanmu.Im.Basic.IUser|null|undefined} fromUser
                 * @memberof AcFunDanmu.Im.Message.Message
                 * @instance
                 */
                Message.prototype.fromUser = null;

                /**
                 * Message targetId.
                 * @member {number|Long} targetId
                 * @memberof AcFunDanmu.Im.Message.Message
                 * @instance
                 */
                Message.prototype.targetId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Message toUser.
                 * @member {AcFunDanmu.Im.Basic.IUser|null|undefined} toUser
                 * @memberof AcFunDanmu.Im.Message.Message
                 * @instance
                 */
                Message.prototype.toUser = null;

                /**
                 * Message title.
                 * @member {string} title
                 * @memberof AcFunDanmu.Im.Message.Message
                 * @instance
                 */
                Message.prototype.title = "";

                /**
                 * Message contentType.
                 * @member {number} contentType
                 * @memberof AcFunDanmu.Im.Message.Message
                 * @instance
                 */
                Message.prototype.contentType = 0;

                /**
                 * Message content.
                 * @member {Uint8Array} content
                 * @memberof AcFunDanmu.Im.Message.Message
                 * @instance
                 */
                Message.prototype.content = $util.newBuffer([]);

                /**
                 * Message buckupTips.
                 * @member {string} buckupTips
                 * @memberof AcFunDanmu.Im.Message.Message
                 * @instance
                 */
                Message.prototype.buckupTips = "";

                /**
                 * Message receivers.
                 * @member {Array.<AcFunDanmu.Im.Basic.IUser>} receivers
                 * @memberof AcFunDanmu.Im.Message.Message
                 * @instance
                 */
                Message.prototype.receivers = $util.emptyArray;

                /**
                 * Message notContentUnread.
                 * @member {boolean} notContentUnread
                 * @memberof AcFunDanmu.Im.Message.Message
                 * @instance
                 */
                Message.prototype.notContentUnread = false;

                /**
                 * Message sessionPriority.
                 * @member {number} sessionPriority
                 * @memberof AcFunDanmu.Im.Message.Message
                 * @instance
                 */
                Message.prototype.sessionPriority = 0;

                /**
                 * Message sessionCategoryId.
                 * @member {number} sessionCategoryId
                 * @memberof AcFunDanmu.Im.Message.Message
                 * @instance
                 */
                Message.prototype.sessionCategoryId = 0;

                /**
                 * Message sessionAccountType.
                 * @member {number} sessionAccountType
                 * @memberof AcFunDanmu.Im.Message.Message
                 * @instance
                 */
                Message.prototype.sessionAccountType = 0;

                /**
                 * Message notAutoCreateSession.
                 * @member {boolean} notAutoCreateSession
                 * @memberof AcFunDanmu.Im.Message.Message
                 * @instance
                 */
                Message.prototype.notAutoCreateSession = false;

                /**
                 * Message userRelationship.
                 * @member {number} userRelationship
                 * @memberof AcFunDanmu.Im.Message.Message
                 * @instance
                 */
                Message.prototype.userRelationship = 0;

                /**
                 * Message strTargetId.
                 * @member {string} strTargetId
                 * @memberof AcFunDanmu.Im.Message.Message
                 * @instance
                 */
                Message.prototype.strTargetId = "";

                /**
                 * Message excludeReceivers.
                 * @member {Array.<AcFunDanmu.Im.Basic.IUser>} excludeReceivers
                 * @memberof AcFunDanmu.Im.Message.Message
                 * @instance
                 */
                Message.prototype.excludeReceivers = $util.emptyArray;

                /**
                 * Message markDelte.
                 * @member {boolean} markDelte
                 * @memberof AcFunDanmu.Im.Message.Message
                 * @instance
                 */
                Message.prototype.markDelte = false;

                /**
                 * Message reminder.
                 * @member {AcFunDanmu.Im.Message.IReminder|null|undefined} reminder
                 * @memberof AcFunDanmu.Im.Message.Message
                 * @instance
                 */
                Message.prototype.reminder = null;

                /**
                 * Message extra.
                 * @member {Uint8Array} extra
                 * @memberof AcFunDanmu.Im.Message.Message
                 * @instance
                 */
                Message.prototype.extra = $util.newBuffer([]);

                /**
                 * Message receiptRequired.
                 * @member {boolean} receiptRequired
                 * @memberof AcFunDanmu.Im.Message.Message
                 * @instance
                 */
                Message.prototype.receiptRequired = false;

                /**
                 * Creates a new Message instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Message.Message
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessage=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Message.Message} Message instance
                 */
                Message.create = function create(properties) {
                    return new Message(properties);
                };

                /**
                 * Encodes the specified Message message. Does not implicitly {@link AcFunDanmu.Im.Message.Message.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Message.Message
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessage} message Message message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Message.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.seqId != null && Object.hasOwnProperty.call(message, "seqId"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int64(message.seqId);
                    if (message.clientSeqId != null && Object.hasOwnProperty.call(message, "clientSeqId"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int64(message.clientSeqId);
                    if (message.timestampMs != null && Object.hasOwnProperty.call(message, "timestampMs"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int64(message.timestampMs);
                    if (message.fromUser != null && Object.hasOwnProperty.call(message, "fromUser"))
                        $root.AcFunDanmu.Im.Basic.User.encode(message.fromUser, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.targetId != null && Object.hasOwnProperty.call(message, "targetId"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int64(message.targetId);
                    if (message.toUser != null && Object.hasOwnProperty.call(message, "toUser"))
                        $root.AcFunDanmu.Im.Basic.User.encode(message.toUser, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                        writer.uint32(/* id 7, wireType 2 =*/58).string(message.title);
                    if (message.contentType != null && Object.hasOwnProperty.call(message, "contentType"))
                        writer.uint32(/* id 8, wireType 0 =*/64).int32(message.contentType);
                    if (message.content != null && Object.hasOwnProperty.call(message, "content"))
                        writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.content);
                    if (message.buckupTips != null && Object.hasOwnProperty.call(message, "buckupTips"))
                        writer.uint32(/* id 10, wireType 2 =*/82).string(message.buckupTips);
                    if (message.receivers != null && message.receivers.length)
                        for (let i = 0; i < message.receivers.length; ++i)
                            $root.AcFunDanmu.Im.Basic.User.encode(message.receivers[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                    if (message.notContentUnread != null && Object.hasOwnProperty.call(message, "notContentUnread"))
                        writer.uint32(/* id 12, wireType 0 =*/96).bool(message.notContentUnread);
                    if (message.sessionPriority != null && Object.hasOwnProperty.call(message, "sessionPriority"))
                        writer.uint32(/* id 13, wireType 0 =*/104).int32(message.sessionPriority);
                    if (message.sessionCategoryId != null && Object.hasOwnProperty.call(message, "sessionCategoryId"))
                        writer.uint32(/* id 14, wireType 0 =*/112).int32(message.sessionCategoryId);
                    if (message.sessionAccountType != null && Object.hasOwnProperty.call(message, "sessionAccountType"))
                        writer.uint32(/* id 15, wireType 0 =*/120).int32(message.sessionAccountType);
                    if (message.notAutoCreateSession != null && Object.hasOwnProperty.call(message, "notAutoCreateSession"))
                        writer.uint32(/* id 16, wireType 0 =*/128).bool(message.notAutoCreateSession);
                    if (message.userRelationship != null && Object.hasOwnProperty.call(message, "userRelationship"))
                        writer.uint32(/* id 17, wireType 0 =*/136).int32(message.userRelationship);
                    if (message.strTargetId != null && Object.hasOwnProperty.call(message, "strTargetId"))
                        writer.uint32(/* id 18, wireType 2 =*/146).string(message.strTargetId);
                    if (message.excludeReceivers != null && message.excludeReceivers.length)
                        for (let i = 0; i < message.excludeReceivers.length; ++i)
                            $root.AcFunDanmu.Im.Basic.User.encode(message.excludeReceivers[i], writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
                    if (message.markDelte != null && Object.hasOwnProperty.call(message, "markDelte"))
                        writer.uint32(/* id 20, wireType 0 =*/160).bool(message.markDelte);
                    if (message.reminder != null && Object.hasOwnProperty.call(message, "reminder"))
                        $root.AcFunDanmu.Im.Message.Reminder.encode(message.reminder, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
                    if (message.extra != null && Object.hasOwnProperty.call(message, "extra"))
                        writer.uint32(/* id 22, wireType 2 =*/178).bytes(message.extra);
                    if (message.receiptRequired != null && Object.hasOwnProperty.call(message, "receiptRequired"))
                        writer.uint32(/* id 23, wireType 0 =*/184).bool(message.receiptRequired);
                    return writer;
                };

                /**
                 * Encodes the specified Message message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Message.Message.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Message.Message
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessage} message Message message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Message.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Message message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Message.Message
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Message.Message} Message
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Message.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Message.Message();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.seqId = reader.int64();
                            break;
                        case 2:
                            message.clientSeqId = reader.int64();
                            break;
                        case 3:
                            message.timestampMs = reader.int64();
                            break;
                        case 4:
                            message.fromUser = $root.AcFunDanmu.Im.Basic.User.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.targetId = reader.int64();
                            break;
                        case 6:
                            message.toUser = $root.AcFunDanmu.Im.Basic.User.decode(reader, reader.uint32());
                            break;
                        case 7:
                            message.title = reader.string();
                            break;
                        case 8:
                            message.contentType = reader.int32();
                            break;
                        case 9:
                            message.content = reader.bytes();
                            break;
                        case 10:
                            message.buckupTips = reader.string();
                            break;
                        case 11:
                            if (!(message.receivers && message.receivers.length))
                                message.receivers = [];
                            message.receivers.push($root.AcFunDanmu.Im.Basic.User.decode(reader, reader.uint32()));
                            break;
                        case 12:
                            message.notContentUnread = reader.bool();
                            break;
                        case 13:
                            message.sessionPriority = reader.int32();
                            break;
                        case 14:
                            message.sessionCategoryId = reader.int32();
                            break;
                        case 15:
                            message.sessionAccountType = reader.int32();
                            break;
                        case 16:
                            message.notAutoCreateSession = reader.bool();
                            break;
                        case 17:
                            message.userRelationship = reader.int32();
                            break;
                        case 18:
                            message.strTargetId = reader.string();
                            break;
                        case 19:
                            if (!(message.excludeReceivers && message.excludeReceivers.length))
                                message.excludeReceivers = [];
                            message.excludeReceivers.push($root.AcFunDanmu.Im.Basic.User.decode(reader, reader.uint32()));
                            break;
                        case 20:
                            message.markDelte = reader.bool();
                            break;
                        case 21:
                            message.reminder = $root.AcFunDanmu.Im.Message.Reminder.decode(reader, reader.uint32());
                            break;
                        case 22:
                            message.extra = reader.bytes();
                            break;
                        case 23:
                            message.receiptRequired = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Message message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Message.Message
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Message.Message} Message
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Message.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Message message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Message.Message
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Message.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.seqId != null && message.hasOwnProperty("seqId"))
                        if (!$util.isInteger(message.seqId) && !(message.seqId && $util.isInteger(message.seqId.low) && $util.isInteger(message.seqId.high)))
                            return "seqId: integer|Long expected";
                    if (message.clientSeqId != null && message.hasOwnProperty("clientSeqId"))
                        if (!$util.isInteger(message.clientSeqId) && !(message.clientSeqId && $util.isInteger(message.clientSeqId.low) && $util.isInteger(message.clientSeqId.high)))
                            return "clientSeqId: integer|Long expected";
                    if (message.timestampMs != null && message.hasOwnProperty("timestampMs"))
                        if (!$util.isInteger(message.timestampMs) && !(message.timestampMs && $util.isInteger(message.timestampMs.low) && $util.isInteger(message.timestampMs.high)))
                            return "timestampMs: integer|Long expected";
                    if (message.fromUser != null && message.hasOwnProperty("fromUser")) {
                        let error = $root.AcFunDanmu.Im.Basic.User.verify(message.fromUser);
                        if (error)
                            return "fromUser." + error;
                    }
                    if (message.targetId != null && message.hasOwnProperty("targetId"))
                        if (!$util.isInteger(message.targetId) && !(message.targetId && $util.isInteger(message.targetId.low) && $util.isInteger(message.targetId.high)))
                            return "targetId: integer|Long expected";
                    if (message.toUser != null && message.hasOwnProperty("toUser")) {
                        let error = $root.AcFunDanmu.Im.Basic.User.verify(message.toUser);
                        if (error)
                            return "toUser." + error;
                    }
                    if (message.title != null && message.hasOwnProperty("title"))
                        if (!$util.isString(message.title))
                            return "title: string expected";
                    if (message.contentType != null && message.hasOwnProperty("contentType"))
                        if (!$util.isInteger(message.contentType))
                            return "contentType: integer expected";
                    if (message.content != null && message.hasOwnProperty("content"))
                        if (!(message.content && typeof message.content.length === "number" || $util.isString(message.content)))
                            return "content: buffer expected";
                    if (message.buckupTips != null && message.hasOwnProperty("buckupTips"))
                        if (!$util.isString(message.buckupTips))
                            return "buckupTips: string expected";
                    if (message.receivers != null && message.hasOwnProperty("receivers")) {
                        if (!Array.isArray(message.receivers))
                            return "receivers: array expected";
                        for (let i = 0; i < message.receivers.length; ++i) {
                            let error = $root.AcFunDanmu.Im.Basic.User.verify(message.receivers[i]);
                            if (error)
                                return "receivers." + error;
                        }
                    }
                    if (message.notContentUnread != null && message.hasOwnProperty("notContentUnread"))
                        if (typeof message.notContentUnread !== "boolean")
                            return "notContentUnread: boolean expected";
                    if (message.sessionPriority != null && message.hasOwnProperty("sessionPriority"))
                        if (!$util.isInteger(message.sessionPriority))
                            return "sessionPriority: integer expected";
                    if (message.sessionCategoryId != null && message.hasOwnProperty("sessionCategoryId"))
                        if (!$util.isInteger(message.sessionCategoryId))
                            return "sessionCategoryId: integer expected";
                    if (message.sessionAccountType != null && message.hasOwnProperty("sessionAccountType"))
                        if (!$util.isInteger(message.sessionAccountType))
                            return "sessionAccountType: integer expected";
                    if (message.notAutoCreateSession != null && message.hasOwnProperty("notAutoCreateSession"))
                        if (typeof message.notAutoCreateSession !== "boolean")
                            return "notAutoCreateSession: boolean expected";
                    if (message.userRelationship != null && message.hasOwnProperty("userRelationship"))
                        if (!$util.isInteger(message.userRelationship))
                            return "userRelationship: integer expected";
                    if (message.strTargetId != null && message.hasOwnProperty("strTargetId"))
                        if (!$util.isString(message.strTargetId))
                            return "strTargetId: string expected";
                    if (message.excludeReceivers != null && message.hasOwnProperty("excludeReceivers")) {
                        if (!Array.isArray(message.excludeReceivers))
                            return "excludeReceivers: array expected";
                        for (let i = 0; i < message.excludeReceivers.length; ++i) {
                            let error = $root.AcFunDanmu.Im.Basic.User.verify(message.excludeReceivers[i]);
                            if (error)
                                return "excludeReceivers." + error;
                        }
                    }
                    if (message.markDelte != null && message.hasOwnProperty("markDelte"))
                        if (typeof message.markDelte !== "boolean")
                            return "markDelte: boolean expected";
                    if (message.reminder != null && message.hasOwnProperty("reminder")) {
                        let error = $root.AcFunDanmu.Im.Message.Reminder.verify(message.reminder);
                        if (error)
                            return "reminder." + error;
                    }
                    if (message.extra != null && message.hasOwnProperty("extra"))
                        if (!(message.extra && typeof message.extra.length === "number" || $util.isString(message.extra)))
                            return "extra: buffer expected";
                    if (message.receiptRequired != null && message.hasOwnProperty("receiptRequired"))
                        if (typeof message.receiptRequired !== "boolean")
                            return "receiptRequired: boolean expected";
                    return null;
                };

                /**
                 * Creates a Message message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Message.Message
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Message.Message} Message
                 */
                Message.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Message.Message)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Message.Message();
                    if (object.seqId != null)
                        if ($util.Long)
                            (message.seqId = $util.Long.fromValue(object.seqId)).unsigned = false;
                        else if (typeof object.seqId === "string")
                            message.seqId = parseInt(object.seqId, 10);
                        else if (typeof object.seqId === "number")
                            message.seqId = object.seqId;
                        else if (typeof object.seqId === "object")
                            message.seqId = new $util.LongBits(object.seqId.low >>> 0, object.seqId.high >>> 0).toNumber();
                    if (object.clientSeqId != null)
                        if ($util.Long)
                            (message.clientSeqId = $util.Long.fromValue(object.clientSeqId)).unsigned = false;
                        else if (typeof object.clientSeqId === "string")
                            message.clientSeqId = parseInt(object.clientSeqId, 10);
                        else if (typeof object.clientSeqId === "number")
                            message.clientSeqId = object.clientSeqId;
                        else if (typeof object.clientSeqId === "object")
                            message.clientSeqId = new $util.LongBits(object.clientSeqId.low >>> 0, object.clientSeqId.high >>> 0).toNumber();
                    if (object.timestampMs != null)
                        if ($util.Long)
                            (message.timestampMs = $util.Long.fromValue(object.timestampMs)).unsigned = false;
                        else if (typeof object.timestampMs === "string")
                            message.timestampMs = parseInt(object.timestampMs, 10);
                        else if (typeof object.timestampMs === "number")
                            message.timestampMs = object.timestampMs;
                        else if (typeof object.timestampMs === "object")
                            message.timestampMs = new $util.LongBits(object.timestampMs.low >>> 0, object.timestampMs.high >>> 0).toNumber();
                    if (object.fromUser != null) {
                        if (typeof object.fromUser !== "object")
                            throw TypeError(".AcFunDanmu.Im.Message.Message.fromUser: object expected");
                        message.fromUser = $root.AcFunDanmu.Im.Basic.User.fromObject(object.fromUser);
                    }
                    if (object.targetId != null)
                        if ($util.Long)
                            (message.targetId = $util.Long.fromValue(object.targetId)).unsigned = false;
                        else if (typeof object.targetId === "string")
                            message.targetId = parseInt(object.targetId, 10);
                        else if (typeof object.targetId === "number")
                            message.targetId = object.targetId;
                        else if (typeof object.targetId === "object")
                            message.targetId = new $util.LongBits(object.targetId.low >>> 0, object.targetId.high >>> 0).toNumber();
                    if (object.toUser != null) {
                        if (typeof object.toUser !== "object")
                            throw TypeError(".AcFunDanmu.Im.Message.Message.toUser: object expected");
                        message.toUser = $root.AcFunDanmu.Im.Basic.User.fromObject(object.toUser);
                    }
                    if (object.title != null)
                        message.title = String(object.title);
                    if (object.contentType != null)
                        message.contentType = object.contentType | 0;
                    if (object.content != null)
                        if (typeof object.content === "string")
                            $util.base64.decode(object.content, message.content = $util.newBuffer($util.base64.length(object.content)), 0);
                        else if (object.content.length)
                            message.content = object.content;
                    if (object.buckupTips != null)
                        message.buckupTips = String(object.buckupTips);
                    if (object.receivers) {
                        if (!Array.isArray(object.receivers))
                            throw TypeError(".AcFunDanmu.Im.Message.Message.receivers: array expected");
                        message.receivers = [];
                        for (let i = 0; i < object.receivers.length; ++i) {
                            if (typeof object.receivers[i] !== "object")
                                throw TypeError(".AcFunDanmu.Im.Message.Message.receivers: object expected");
                            message.receivers[i] = $root.AcFunDanmu.Im.Basic.User.fromObject(object.receivers[i]);
                        }
                    }
                    if (object.notContentUnread != null)
                        message.notContentUnread = Boolean(object.notContentUnread);
                    if (object.sessionPriority != null)
                        message.sessionPriority = object.sessionPriority | 0;
                    if (object.sessionCategoryId != null)
                        message.sessionCategoryId = object.sessionCategoryId | 0;
                    if (object.sessionAccountType != null)
                        message.sessionAccountType = object.sessionAccountType | 0;
                    if (object.notAutoCreateSession != null)
                        message.notAutoCreateSession = Boolean(object.notAutoCreateSession);
                    if (object.userRelationship != null)
                        message.userRelationship = object.userRelationship | 0;
                    if (object.strTargetId != null)
                        message.strTargetId = String(object.strTargetId);
                    if (object.excludeReceivers) {
                        if (!Array.isArray(object.excludeReceivers))
                            throw TypeError(".AcFunDanmu.Im.Message.Message.excludeReceivers: array expected");
                        message.excludeReceivers = [];
                        for (let i = 0; i < object.excludeReceivers.length; ++i) {
                            if (typeof object.excludeReceivers[i] !== "object")
                                throw TypeError(".AcFunDanmu.Im.Message.Message.excludeReceivers: object expected");
                            message.excludeReceivers[i] = $root.AcFunDanmu.Im.Basic.User.fromObject(object.excludeReceivers[i]);
                        }
                    }
                    if (object.markDelte != null)
                        message.markDelte = Boolean(object.markDelte);
                    if (object.reminder != null) {
                        if (typeof object.reminder !== "object")
                            throw TypeError(".AcFunDanmu.Im.Message.Message.reminder: object expected");
                        message.reminder = $root.AcFunDanmu.Im.Message.Reminder.fromObject(object.reminder);
                    }
                    if (object.extra != null)
                        if (typeof object.extra === "string")
                            $util.base64.decode(object.extra, message.extra = $util.newBuffer($util.base64.length(object.extra)), 0);
                        else if (object.extra.length)
                            message.extra = object.extra;
                    if (object.receiptRequired != null)
                        message.receiptRequired = Boolean(object.receiptRequired);
                    return message;
                };

                /**
                 * Creates a plain object from a Message message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Message.Message
                 * @static
                 * @param {AcFunDanmu.Im.Message.Message} message Message
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Message.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults) {
                        object.receivers = [];
                        object.excludeReceivers = [];
                    }
                    if (options.defaults) {
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.seqId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.seqId = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.clientSeqId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.clientSeqId = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.timestampMs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.timestampMs = options.longs === String ? "0" : 0;
                        object.fromUser = null;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.targetId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.targetId = options.longs === String ? "0" : 0;
                        object.toUser = null;
                        object.title = "";
                        object.contentType = 0;
                        if (options.bytes === String)
                            object.content = "";
                        else {
                            object.content = [];
                            if (options.bytes !== Array)
                                object.content = $util.newBuffer(object.content);
                        }
                        object.buckupTips = "";
                        object.notContentUnread = false;
                        object.sessionPriority = 0;
                        object.sessionCategoryId = 0;
                        object.sessionAccountType = 0;
                        object.notAutoCreateSession = false;
                        object.userRelationship = 0;
                        object.strTargetId = "";
                        object.markDelte = false;
                        object.reminder = null;
                        if (options.bytes === String)
                            object.extra = "";
                        else {
                            object.extra = [];
                            if (options.bytes !== Array)
                                object.extra = $util.newBuffer(object.extra);
                        }
                        object.receiptRequired = false;
                    }
                    if (message.seqId != null && message.hasOwnProperty("seqId"))
                        if (typeof message.seqId === "number")
                            object.seqId = options.longs === String ? String(message.seqId) : message.seqId;
                        else
                            object.seqId = options.longs === String ? $util.Long.prototype.toString.call(message.seqId) : options.longs === Number ? new $util.LongBits(message.seqId.low >>> 0, message.seqId.high >>> 0).toNumber() : message.seqId;
                    if (message.clientSeqId != null && message.hasOwnProperty("clientSeqId"))
                        if (typeof message.clientSeqId === "number")
                            object.clientSeqId = options.longs === String ? String(message.clientSeqId) : message.clientSeqId;
                        else
                            object.clientSeqId = options.longs === String ? $util.Long.prototype.toString.call(message.clientSeqId) : options.longs === Number ? new $util.LongBits(message.clientSeqId.low >>> 0, message.clientSeqId.high >>> 0).toNumber() : message.clientSeqId;
                    if (message.timestampMs != null && message.hasOwnProperty("timestampMs"))
                        if (typeof message.timestampMs === "number")
                            object.timestampMs = options.longs === String ? String(message.timestampMs) : message.timestampMs;
                        else
                            object.timestampMs = options.longs === String ? $util.Long.prototype.toString.call(message.timestampMs) : options.longs === Number ? new $util.LongBits(message.timestampMs.low >>> 0, message.timestampMs.high >>> 0).toNumber() : message.timestampMs;
                    if (message.fromUser != null && message.hasOwnProperty("fromUser"))
                        object.fromUser = $root.AcFunDanmu.Im.Basic.User.toObject(message.fromUser, options);
                    if (message.targetId != null && message.hasOwnProperty("targetId"))
                        if (typeof message.targetId === "number")
                            object.targetId = options.longs === String ? String(message.targetId) : message.targetId;
                        else
                            object.targetId = options.longs === String ? $util.Long.prototype.toString.call(message.targetId) : options.longs === Number ? new $util.LongBits(message.targetId.low >>> 0, message.targetId.high >>> 0).toNumber() : message.targetId;
                    if (message.toUser != null && message.hasOwnProperty("toUser"))
                        object.toUser = $root.AcFunDanmu.Im.Basic.User.toObject(message.toUser, options);
                    if (message.title != null && message.hasOwnProperty("title"))
                        object.title = message.title;
                    if (message.contentType != null && message.hasOwnProperty("contentType"))
                        object.contentType = message.contentType;
                    if (message.content != null && message.hasOwnProperty("content"))
                        object.content = options.bytes === String ? $util.base64.encode(message.content, 0, message.content.length) : options.bytes === Array ? Array.prototype.slice.call(message.content) : message.content;
                    if (message.buckupTips != null && message.hasOwnProperty("buckupTips"))
                        object.buckupTips = message.buckupTips;
                    if (message.receivers && message.receivers.length) {
                        object.receivers = [];
                        for (let j = 0; j < message.receivers.length; ++j)
                            object.receivers[j] = $root.AcFunDanmu.Im.Basic.User.toObject(message.receivers[j], options);
                    }
                    if (message.notContentUnread != null && message.hasOwnProperty("notContentUnread"))
                        object.notContentUnread = message.notContentUnread;
                    if (message.sessionPriority != null && message.hasOwnProperty("sessionPriority"))
                        object.sessionPriority = message.sessionPriority;
                    if (message.sessionCategoryId != null && message.hasOwnProperty("sessionCategoryId"))
                        object.sessionCategoryId = message.sessionCategoryId;
                    if (message.sessionAccountType != null && message.hasOwnProperty("sessionAccountType"))
                        object.sessionAccountType = message.sessionAccountType;
                    if (message.notAutoCreateSession != null && message.hasOwnProperty("notAutoCreateSession"))
                        object.notAutoCreateSession = message.notAutoCreateSession;
                    if (message.userRelationship != null && message.hasOwnProperty("userRelationship"))
                        object.userRelationship = message.userRelationship;
                    if (message.strTargetId != null && message.hasOwnProperty("strTargetId"))
                        object.strTargetId = message.strTargetId;
                    if (message.excludeReceivers && message.excludeReceivers.length) {
                        object.excludeReceivers = [];
                        for (let j = 0; j < message.excludeReceivers.length; ++j)
                            object.excludeReceivers[j] = $root.AcFunDanmu.Im.Basic.User.toObject(message.excludeReceivers[j], options);
                    }
                    if (message.markDelte != null && message.hasOwnProperty("markDelte"))
                        object.markDelte = message.markDelte;
                    if (message.reminder != null && message.hasOwnProperty("reminder"))
                        object.reminder = $root.AcFunDanmu.Im.Message.Reminder.toObject(message.reminder, options);
                    if (message.extra != null && message.hasOwnProperty("extra"))
                        object.extra = options.bytes === String ? $util.base64.encode(message.extra, 0, message.extra.length) : options.bytes === Array ? Array.prototype.slice.call(message.extra) : message.extra;
                    if (message.receiptRequired != null && message.hasOwnProperty("receiptRequired"))
                        object.receiptRequired = message.receiptRequired;
                    return object;
                };

                /**
                 * Converts this Message to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Message.Message
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Message.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Message;
            })();

            /**
             * KsUserRelationShip enum.
             * @name AcFunDanmu.Im.Message.KsUserRelationShip
             * @enum {number}
             * @property {number} kUNKNOW=0 kUNKNOW value
             * @property {number} FOLLOW_EACH_OTHER=1 FOLLOW_EACH_OTHER value
             * @property {number} TO_FOLLOW_FROM=2 TO_FOLLOW_FROM value
             * @property {number} FROM_FOLLOW_TO=3 FROM_FOLLOW_TO value
             */
            Message.KsUserRelationShip = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "kUNKNOW"] = 0;
                values[valuesById[1] = "FOLLOW_EACH_OTHER"] = 1;
                values[valuesById[2] = "TO_FOLLOW_FROM"] = 2;
                values[valuesById[3] = "FROM_FOLLOW_TO"] = 3;
                return values;
            })();

            Message.SendMessageResponse = (function() {

                /**
                 * Properties of a SendMessageResponse.
                 * @memberof AcFunDanmu.Im.Message
                 * @interface ISendMessageResponse
                 * @property {number|Long|null} [clientSeqId] SendMessageResponse clientSeqId
                 * @property {number|Long|null} [messageTimestamp] SendMessageResponse messageTimestamp
                 * @property {number|Long|null} [seqId] SendMessageResponse seqId
                 * @property {number|null} [sessionAccountType] SendMessageResponse sessionAccountType
                 * @property {number|null} [sessionPriority] SendMessageResponse sessionPriority
                 * @property {number|null} [sessionCategoryId] SendMessageResponse sessionCategoryId
                 */

                /**
                 * Constructs a new SendMessageResponse.
                 * @memberof AcFunDanmu.Im.Message
                 * @classdesc Represents a SendMessageResponse.
                 * @implements ISendMessageResponse
                 * @constructor
                 * @param {AcFunDanmu.Im.Message.ISendMessageResponse=} [properties] Properties to set
                 */
                function SendMessageResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SendMessageResponse clientSeqId.
                 * @member {number|Long} clientSeqId
                 * @memberof AcFunDanmu.Im.Message.SendMessageResponse
                 * @instance
                 */
                SendMessageResponse.prototype.clientSeqId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * SendMessageResponse messageTimestamp.
                 * @member {number|Long} messageTimestamp
                 * @memberof AcFunDanmu.Im.Message.SendMessageResponse
                 * @instance
                 */
                SendMessageResponse.prototype.messageTimestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * SendMessageResponse seqId.
                 * @member {number|Long} seqId
                 * @memberof AcFunDanmu.Im.Message.SendMessageResponse
                 * @instance
                 */
                SendMessageResponse.prototype.seqId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * SendMessageResponse sessionAccountType.
                 * @member {number} sessionAccountType
                 * @memberof AcFunDanmu.Im.Message.SendMessageResponse
                 * @instance
                 */
                SendMessageResponse.prototype.sessionAccountType = 0;

                /**
                 * SendMessageResponse sessionPriority.
                 * @member {number} sessionPriority
                 * @memberof AcFunDanmu.Im.Message.SendMessageResponse
                 * @instance
                 */
                SendMessageResponse.prototype.sessionPriority = 0;

                /**
                 * SendMessageResponse sessionCategoryId.
                 * @member {number} sessionCategoryId
                 * @memberof AcFunDanmu.Im.Message.SendMessageResponse
                 * @instance
                 */
                SendMessageResponse.prototype.sessionCategoryId = 0;

                /**
                 * Creates a new SendMessageResponse instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Message.SendMessageResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.ISendMessageResponse=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Message.SendMessageResponse} SendMessageResponse instance
                 */
                SendMessageResponse.create = function create(properties) {
                    return new SendMessageResponse(properties);
                };

                /**
                 * Encodes the specified SendMessageResponse message. Does not implicitly {@link AcFunDanmu.Im.Message.SendMessageResponse.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Message.SendMessageResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.ISendMessageResponse} message SendMessageResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SendMessageResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.clientSeqId != null && Object.hasOwnProperty.call(message, "clientSeqId"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int64(message.clientSeqId);
                    if (message.messageTimestamp != null && Object.hasOwnProperty.call(message, "messageTimestamp"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int64(message.messageTimestamp);
                    if (message.seqId != null && Object.hasOwnProperty.call(message, "seqId"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int64(message.seqId);
                    if (message.sessionAccountType != null && Object.hasOwnProperty.call(message, "sessionAccountType"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.sessionAccountType);
                    if (message.sessionPriority != null && Object.hasOwnProperty.call(message, "sessionPriority"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.sessionPriority);
                    if (message.sessionCategoryId != null && Object.hasOwnProperty.call(message, "sessionCategoryId"))
                        writer.uint32(/* id 6, wireType 0 =*/48).int32(message.sessionCategoryId);
                    return writer;
                };

                /**
                 * Encodes the specified SendMessageResponse message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Message.SendMessageResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Message.SendMessageResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.ISendMessageResponse} message SendMessageResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SendMessageResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SendMessageResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Message.SendMessageResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Message.SendMessageResponse} SendMessageResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SendMessageResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Message.SendMessageResponse();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.clientSeqId = reader.int64();
                            break;
                        case 2:
                            message.messageTimestamp = reader.int64();
                            break;
                        case 3:
                            message.seqId = reader.int64();
                            break;
                        case 4:
                            message.sessionAccountType = reader.int32();
                            break;
                        case 5:
                            message.sessionPriority = reader.int32();
                            break;
                        case 6:
                            message.sessionCategoryId = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SendMessageResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Message.SendMessageResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Message.SendMessageResponse} SendMessageResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SendMessageResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SendMessageResponse message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Message.SendMessageResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SendMessageResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.clientSeqId != null && message.hasOwnProperty("clientSeqId"))
                        if (!$util.isInteger(message.clientSeqId) && !(message.clientSeqId && $util.isInteger(message.clientSeqId.low) && $util.isInteger(message.clientSeqId.high)))
                            return "clientSeqId: integer|Long expected";
                    if (message.messageTimestamp != null && message.hasOwnProperty("messageTimestamp"))
                        if (!$util.isInteger(message.messageTimestamp) && !(message.messageTimestamp && $util.isInteger(message.messageTimestamp.low) && $util.isInteger(message.messageTimestamp.high)))
                            return "messageTimestamp: integer|Long expected";
                    if (message.seqId != null && message.hasOwnProperty("seqId"))
                        if (!$util.isInteger(message.seqId) && !(message.seqId && $util.isInteger(message.seqId.low) && $util.isInteger(message.seqId.high)))
                            return "seqId: integer|Long expected";
                    if (message.sessionAccountType != null && message.hasOwnProperty("sessionAccountType"))
                        if (!$util.isInteger(message.sessionAccountType))
                            return "sessionAccountType: integer expected";
                    if (message.sessionPriority != null && message.hasOwnProperty("sessionPriority"))
                        if (!$util.isInteger(message.sessionPriority))
                            return "sessionPriority: integer expected";
                    if (message.sessionCategoryId != null && message.hasOwnProperty("sessionCategoryId"))
                        if (!$util.isInteger(message.sessionCategoryId))
                            return "sessionCategoryId: integer expected";
                    return null;
                };

                /**
                 * Creates a SendMessageResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Message.SendMessageResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Message.SendMessageResponse} SendMessageResponse
                 */
                SendMessageResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Message.SendMessageResponse)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Message.SendMessageResponse();
                    if (object.clientSeqId != null)
                        if ($util.Long)
                            (message.clientSeqId = $util.Long.fromValue(object.clientSeqId)).unsigned = false;
                        else if (typeof object.clientSeqId === "string")
                            message.clientSeqId = parseInt(object.clientSeqId, 10);
                        else if (typeof object.clientSeqId === "number")
                            message.clientSeqId = object.clientSeqId;
                        else if (typeof object.clientSeqId === "object")
                            message.clientSeqId = new $util.LongBits(object.clientSeqId.low >>> 0, object.clientSeqId.high >>> 0).toNumber();
                    if (object.messageTimestamp != null)
                        if ($util.Long)
                            (message.messageTimestamp = $util.Long.fromValue(object.messageTimestamp)).unsigned = false;
                        else if (typeof object.messageTimestamp === "string")
                            message.messageTimestamp = parseInt(object.messageTimestamp, 10);
                        else if (typeof object.messageTimestamp === "number")
                            message.messageTimestamp = object.messageTimestamp;
                        else if (typeof object.messageTimestamp === "object")
                            message.messageTimestamp = new $util.LongBits(object.messageTimestamp.low >>> 0, object.messageTimestamp.high >>> 0).toNumber();
                    if (object.seqId != null)
                        if ($util.Long)
                            (message.seqId = $util.Long.fromValue(object.seqId)).unsigned = false;
                        else if (typeof object.seqId === "string")
                            message.seqId = parseInt(object.seqId, 10);
                        else if (typeof object.seqId === "number")
                            message.seqId = object.seqId;
                        else if (typeof object.seqId === "object")
                            message.seqId = new $util.LongBits(object.seqId.low >>> 0, object.seqId.high >>> 0).toNumber();
                    if (object.sessionAccountType != null)
                        message.sessionAccountType = object.sessionAccountType | 0;
                    if (object.sessionPriority != null)
                        message.sessionPriority = object.sessionPriority | 0;
                    if (object.sessionCategoryId != null)
                        message.sessionCategoryId = object.sessionCategoryId | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a SendMessageResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Message.SendMessageResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.SendMessageResponse} message SendMessageResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SendMessageResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.clientSeqId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.clientSeqId = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.messageTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.messageTimestamp = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.seqId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.seqId = options.longs === String ? "0" : 0;
                        object.sessionAccountType = 0;
                        object.sessionPriority = 0;
                        object.sessionCategoryId = 0;
                    }
                    if (message.clientSeqId != null && message.hasOwnProperty("clientSeqId"))
                        if (typeof message.clientSeqId === "number")
                            object.clientSeqId = options.longs === String ? String(message.clientSeqId) : message.clientSeqId;
                        else
                            object.clientSeqId = options.longs === String ? $util.Long.prototype.toString.call(message.clientSeqId) : options.longs === Number ? new $util.LongBits(message.clientSeqId.low >>> 0, message.clientSeqId.high >>> 0).toNumber() : message.clientSeqId;
                    if (message.messageTimestamp != null && message.hasOwnProperty("messageTimestamp"))
                        if (typeof message.messageTimestamp === "number")
                            object.messageTimestamp = options.longs === String ? String(message.messageTimestamp) : message.messageTimestamp;
                        else
                            object.messageTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.messageTimestamp) : options.longs === Number ? new $util.LongBits(message.messageTimestamp.low >>> 0, message.messageTimestamp.high >>> 0).toNumber() : message.messageTimestamp;
                    if (message.seqId != null && message.hasOwnProperty("seqId"))
                        if (typeof message.seqId === "number")
                            object.seqId = options.longs === String ? String(message.seqId) : message.seqId;
                        else
                            object.seqId = options.longs === String ? $util.Long.prototype.toString.call(message.seqId) : options.longs === Number ? new $util.LongBits(message.seqId.low >>> 0, message.seqId.high >>> 0).toNumber() : message.seqId;
                    if (message.sessionAccountType != null && message.hasOwnProperty("sessionAccountType"))
                        object.sessionAccountType = message.sessionAccountType;
                    if (message.sessionPriority != null && message.hasOwnProperty("sessionPriority"))
                        object.sessionPriority = message.sessionPriority;
                    if (message.sessionCategoryId != null && message.hasOwnProperty("sessionCategoryId"))
                        object.sessionCategoryId = message.sessionCategoryId;
                    return object;
                };

                /**
                 * Converts this SendMessageResponse to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Message.SendMessageResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SendMessageResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SendMessageResponse;
            })();

            Message.PullOldRequest = (function() {

                /**
                 * Properties of a PullOldRequest.
                 * @memberof AcFunDanmu.Im.Message
                 * @interface IPullOldRequest
                 * @property {AcFunDanmu.Im.Basic.IUser|null} [target] PullOldRequest target
                 * @property {number|Long|null} [minSeq] PullOldRequest minSeq
                 * @property {number|Long|null} [maxSeq] PullOldRequest maxSeq
                 * @property {number|null} [count] PullOldRequest count
                 * @property {number|Long|null} [targetId] PullOldRequest targetId
                 * @property {string|null} [strTargetId] PullOldRequest strTargetId
                 */

                /**
                 * Constructs a new PullOldRequest.
                 * @memberof AcFunDanmu.Im.Message
                 * @classdesc Represents a PullOldRequest.
                 * @implements IPullOldRequest
                 * @constructor
                 * @param {AcFunDanmu.Im.Message.IPullOldRequest=} [properties] Properties to set
                 */
                function PullOldRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PullOldRequest target.
                 * @member {AcFunDanmu.Im.Basic.IUser|null|undefined} target
                 * @memberof AcFunDanmu.Im.Message.PullOldRequest
                 * @instance
                 */
                PullOldRequest.prototype.target = null;

                /**
                 * PullOldRequest minSeq.
                 * @member {number|Long} minSeq
                 * @memberof AcFunDanmu.Im.Message.PullOldRequest
                 * @instance
                 */
                PullOldRequest.prototype.minSeq = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * PullOldRequest maxSeq.
                 * @member {number|Long} maxSeq
                 * @memberof AcFunDanmu.Im.Message.PullOldRequest
                 * @instance
                 */
                PullOldRequest.prototype.maxSeq = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * PullOldRequest count.
                 * @member {number} count
                 * @memberof AcFunDanmu.Im.Message.PullOldRequest
                 * @instance
                 */
                PullOldRequest.prototype.count = 0;

                /**
                 * PullOldRequest targetId.
                 * @member {number|Long} targetId
                 * @memberof AcFunDanmu.Im.Message.PullOldRequest
                 * @instance
                 */
                PullOldRequest.prototype.targetId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * PullOldRequest strTargetId.
                 * @member {string} strTargetId
                 * @memberof AcFunDanmu.Im.Message.PullOldRequest
                 * @instance
                 */
                PullOldRequest.prototype.strTargetId = "";

                /**
                 * Creates a new PullOldRequest instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Message.PullOldRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.IPullOldRequest=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Message.PullOldRequest} PullOldRequest instance
                 */
                PullOldRequest.create = function create(properties) {
                    return new PullOldRequest(properties);
                };

                /**
                 * Encodes the specified PullOldRequest message. Does not implicitly {@link AcFunDanmu.Im.Message.PullOldRequest.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Message.PullOldRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.IPullOldRequest} message PullOldRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PullOldRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                        $root.AcFunDanmu.Im.Basic.User.encode(message.target, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.minSeq != null && Object.hasOwnProperty.call(message, "minSeq"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int64(message.minSeq);
                    if (message.maxSeq != null && Object.hasOwnProperty.call(message, "maxSeq"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int64(message.maxSeq);
                    if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.count);
                    if (message.targetId != null && Object.hasOwnProperty.call(message, "targetId"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int64(message.targetId);
                    if (message.strTargetId != null && Object.hasOwnProperty.call(message, "strTargetId"))
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.strTargetId);
                    return writer;
                };

                /**
                 * Encodes the specified PullOldRequest message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Message.PullOldRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Message.PullOldRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.IPullOldRequest} message PullOldRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PullOldRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a PullOldRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Message.PullOldRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Message.PullOldRequest} PullOldRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PullOldRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Message.PullOldRequest();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.target = $root.AcFunDanmu.Im.Basic.User.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.minSeq = reader.int64();
                            break;
                        case 3:
                            message.maxSeq = reader.int64();
                            break;
                        case 4:
                            message.count = reader.int32();
                            break;
                        case 5:
                            message.targetId = reader.int64();
                            break;
                        case 6:
                            message.strTargetId = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a PullOldRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Message.PullOldRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Message.PullOldRequest} PullOldRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PullOldRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a PullOldRequest message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Message.PullOldRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PullOldRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.target != null && message.hasOwnProperty("target")) {
                        let error = $root.AcFunDanmu.Im.Basic.User.verify(message.target);
                        if (error)
                            return "target." + error;
                    }
                    if (message.minSeq != null && message.hasOwnProperty("minSeq"))
                        if (!$util.isInteger(message.minSeq) && !(message.minSeq && $util.isInteger(message.minSeq.low) && $util.isInteger(message.minSeq.high)))
                            return "minSeq: integer|Long expected";
                    if (message.maxSeq != null && message.hasOwnProperty("maxSeq"))
                        if (!$util.isInteger(message.maxSeq) && !(message.maxSeq && $util.isInteger(message.maxSeq.low) && $util.isInteger(message.maxSeq.high)))
                            return "maxSeq: integer|Long expected";
                    if (message.count != null && message.hasOwnProperty("count"))
                        if (!$util.isInteger(message.count))
                            return "count: integer expected";
                    if (message.targetId != null && message.hasOwnProperty("targetId"))
                        if (!$util.isInteger(message.targetId) && !(message.targetId && $util.isInteger(message.targetId.low) && $util.isInteger(message.targetId.high)))
                            return "targetId: integer|Long expected";
                    if (message.strTargetId != null && message.hasOwnProperty("strTargetId"))
                        if (!$util.isString(message.strTargetId))
                            return "strTargetId: string expected";
                    return null;
                };

                /**
                 * Creates a PullOldRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Message.PullOldRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Message.PullOldRequest} PullOldRequest
                 */
                PullOldRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Message.PullOldRequest)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Message.PullOldRequest();
                    if (object.target != null) {
                        if (typeof object.target !== "object")
                            throw TypeError(".AcFunDanmu.Im.Message.PullOldRequest.target: object expected");
                        message.target = $root.AcFunDanmu.Im.Basic.User.fromObject(object.target);
                    }
                    if (object.minSeq != null)
                        if ($util.Long)
                            (message.minSeq = $util.Long.fromValue(object.minSeq)).unsigned = false;
                        else if (typeof object.minSeq === "string")
                            message.minSeq = parseInt(object.minSeq, 10);
                        else if (typeof object.minSeq === "number")
                            message.minSeq = object.minSeq;
                        else if (typeof object.minSeq === "object")
                            message.minSeq = new $util.LongBits(object.minSeq.low >>> 0, object.minSeq.high >>> 0).toNumber();
                    if (object.maxSeq != null)
                        if ($util.Long)
                            (message.maxSeq = $util.Long.fromValue(object.maxSeq)).unsigned = false;
                        else if (typeof object.maxSeq === "string")
                            message.maxSeq = parseInt(object.maxSeq, 10);
                        else if (typeof object.maxSeq === "number")
                            message.maxSeq = object.maxSeq;
                        else if (typeof object.maxSeq === "object")
                            message.maxSeq = new $util.LongBits(object.maxSeq.low >>> 0, object.maxSeq.high >>> 0).toNumber();
                    if (object.count != null)
                        message.count = object.count | 0;
                    if (object.targetId != null)
                        if ($util.Long)
                            (message.targetId = $util.Long.fromValue(object.targetId)).unsigned = false;
                        else if (typeof object.targetId === "string")
                            message.targetId = parseInt(object.targetId, 10);
                        else if (typeof object.targetId === "number")
                            message.targetId = object.targetId;
                        else if (typeof object.targetId === "object")
                            message.targetId = new $util.LongBits(object.targetId.low >>> 0, object.targetId.high >>> 0).toNumber();
                    if (object.strTargetId != null)
                        message.strTargetId = String(object.strTargetId);
                    return message;
                };

                /**
                 * Creates a plain object from a PullOldRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Message.PullOldRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.PullOldRequest} message PullOldRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PullOldRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.target = null;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.minSeq = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.minSeq = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.maxSeq = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.maxSeq = options.longs === String ? "0" : 0;
                        object.count = 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.targetId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.targetId = options.longs === String ? "0" : 0;
                        object.strTargetId = "";
                    }
                    if (message.target != null && message.hasOwnProperty("target"))
                        object.target = $root.AcFunDanmu.Im.Basic.User.toObject(message.target, options);
                    if (message.minSeq != null && message.hasOwnProperty("minSeq"))
                        if (typeof message.minSeq === "number")
                            object.minSeq = options.longs === String ? String(message.minSeq) : message.minSeq;
                        else
                            object.minSeq = options.longs === String ? $util.Long.prototype.toString.call(message.minSeq) : options.longs === Number ? new $util.LongBits(message.minSeq.low >>> 0, message.minSeq.high >>> 0).toNumber() : message.minSeq;
                    if (message.maxSeq != null && message.hasOwnProperty("maxSeq"))
                        if (typeof message.maxSeq === "number")
                            object.maxSeq = options.longs === String ? String(message.maxSeq) : message.maxSeq;
                        else
                            object.maxSeq = options.longs === String ? $util.Long.prototype.toString.call(message.maxSeq) : options.longs === Number ? new $util.LongBits(message.maxSeq.low >>> 0, message.maxSeq.high >>> 0).toNumber() : message.maxSeq;
                    if (message.count != null && message.hasOwnProperty("count"))
                        object.count = message.count;
                    if (message.targetId != null && message.hasOwnProperty("targetId"))
                        if (typeof message.targetId === "number")
                            object.targetId = options.longs === String ? String(message.targetId) : message.targetId;
                        else
                            object.targetId = options.longs === String ? $util.Long.prototype.toString.call(message.targetId) : options.longs === Number ? new $util.LongBits(message.targetId.low >>> 0, message.targetId.high >>> 0).toNumber() : message.targetId;
                    if (message.strTargetId != null && message.hasOwnProperty("strTargetId"))
                        object.strTargetId = message.strTargetId;
                    return object;
                };

                /**
                 * Converts this PullOldRequest to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Message.PullOldRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PullOldRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return PullOldRequest;
            })();

            Message.PullOldResponse = (function() {

                /**
                 * Properties of a PullOldResponse.
                 * @memberof AcFunDanmu.Im.Message
                 * @interface IPullOldResponse
                 * @property {Array.<AcFunDanmu.Im.Message.IMessage>|null} [messages] PullOldResponse messages
                 * @property {number|Long|null} [serverTime] PullOldResponse serverTime
                 */

                /**
                 * Constructs a new PullOldResponse.
                 * @memberof AcFunDanmu.Im.Message
                 * @classdesc Represents a PullOldResponse.
                 * @implements IPullOldResponse
                 * @constructor
                 * @param {AcFunDanmu.Im.Message.IPullOldResponse=} [properties] Properties to set
                 */
                function PullOldResponse(properties) {
                    this.messages = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PullOldResponse messages.
                 * @member {Array.<AcFunDanmu.Im.Message.IMessage>} messages
                 * @memberof AcFunDanmu.Im.Message.PullOldResponse
                 * @instance
                 */
                PullOldResponse.prototype.messages = $util.emptyArray;

                /**
                 * PullOldResponse serverTime.
                 * @member {number|Long} serverTime
                 * @memberof AcFunDanmu.Im.Message.PullOldResponse
                 * @instance
                 */
                PullOldResponse.prototype.serverTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Creates a new PullOldResponse instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Message.PullOldResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.IPullOldResponse=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Message.PullOldResponse} PullOldResponse instance
                 */
                PullOldResponse.create = function create(properties) {
                    return new PullOldResponse(properties);
                };

                /**
                 * Encodes the specified PullOldResponse message. Does not implicitly {@link AcFunDanmu.Im.Message.PullOldResponse.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Message.PullOldResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.IPullOldResponse} message PullOldResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PullOldResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.messages != null && message.messages.length)
                        for (let i = 0; i < message.messages.length; ++i)
                            $root.AcFunDanmu.Im.Message.Message.encode(message.messages[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.serverTime != null && Object.hasOwnProperty.call(message, "serverTime"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int64(message.serverTime);
                    return writer;
                };

                /**
                 * Encodes the specified PullOldResponse message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Message.PullOldResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Message.PullOldResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.IPullOldResponse} message PullOldResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PullOldResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a PullOldResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Message.PullOldResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Message.PullOldResponse} PullOldResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PullOldResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Message.PullOldResponse();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.messages && message.messages.length))
                                message.messages = [];
                            message.messages.push($root.AcFunDanmu.Im.Message.Message.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            message.serverTime = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a PullOldResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Message.PullOldResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Message.PullOldResponse} PullOldResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PullOldResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a PullOldResponse message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Message.PullOldResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PullOldResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.messages != null && message.hasOwnProperty("messages")) {
                        if (!Array.isArray(message.messages))
                            return "messages: array expected";
                        for (let i = 0; i < message.messages.length; ++i) {
                            let error = $root.AcFunDanmu.Im.Message.Message.verify(message.messages[i]);
                            if (error)
                                return "messages." + error;
                        }
                    }
                    if (message.serverTime != null && message.hasOwnProperty("serverTime"))
                        if (!$util.isInteger(message.serverTime) && !(message.serverTime && $util.isInteger(message.serverTime.low) && $util.isInteger(message.serverTime.high)))
                            return "serverTime: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a PullOldResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Message.PullOldResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Message.PullOldResponse} PullOldResponse
                 */
                PullOldResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Message.PullOldResponse)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Message.PullOldResponse();
                    if (object.messages) {
                        if (!Array.isArray(object.messages))
                            throw TypeError(".AcFunDanmu.Im.Message.PullOldResponse.messages: array expected");
                        message.messages = [];
                        for (let i = 0; i < object.messages.length; ++i) {
                            if (typeof object.messages[i] !== "object")
                                throw TypeError(".AcFunDanmu.Im.Message.PullOldResponse.messages: object expected");
                            message.messages[i] = $root.AcFunDanmu.Im.Message.Message.fromObject(object.messages[i]);
                        }
                    }
                    if (object.serverTime != null)
                        if ($util.Long)
                            (message.serverTime = $util.Long.fromValue(object.serverTime)).unsigned = false;
                        else if (typeof object.serverTime === "string")
                            message.serverTime = parseInt(object.serverTime, 10);
                        else if (typeof object.serverTime === "number")
                            message.serverTime = object.serverTime;
                        else if (typeof object.serverTime === "object")
                            message.serverTime = new $util.LongBits(object.serverTime.low >>> 0, object.serverTime.high >>> 0).toNumber();
                    return message;
                };

                /**
                 * Creates a plain object from a PullOldResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Message.PullOldResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.PullOldResponse} message PullOldResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PullOldResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.messages = [];
                    if (options.defaults)
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.serverTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.serverTime = options.longs === String ? "0" : 0;
                    if (message.messages && message.messages.length) {
                        object.messages = [];
                        for (let j = 0; j < message.messages.length; ++j)
                            object.messages[j] = $root.AcFunDanmu.Im.Message.Message.toObject(message.messages[j], options);
                    }
                    if (message.serverTime != null && message.hasOwnProperty("serverTime"))
                        if (typeof message.serverTime === "number")
                            object.serverTime = options.longs === String ? String(message.serverTime) : message.serverTime;
                        else
                            object.serverTime = options.longs === String ? $util.Long.prototype.toString.call(message.serverTime) : options.longs === Number ? new $util.LongBits(message.serverTime.low >>> 0, message.serverTime.high >>> 0).toNumber() : message.serverTime;
                    return object;
                };

                /**
                 * Converts this PullOldResponse to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Message.PullOldResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PullOldResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return PullOldResponse;
            })();

            Message.PullNewRequest = (function() {

                /**
                 * Properties of a PullNewRequest.
                 * @memberof AcFunDanmu.Im.Message
                 * @interface IPullNewRequest
                 * @property {AcFunDanmu.Im.Basic.IUser|null} [target] PullNewRequest target
                 * @property {number|Long|null} [minSeq] PullNewRequest minSeq
                 * @property {number|null} [count] PullNewRequest count
                 * @property {number|Long|null} [targetId] PullNewRequest targetId
                 * @property {string|null} [strTargetId] PullNewRequest strTargetId
                 */

                /**
                 * Constructs a new PullNewRequest.
                 * @memberof AcFunDanmu.Im.Message
                 * @classdesc Represents a PullNewRequest.
                 * @implements IPullNewRequest
                 * @constructor
                 * @param {AcFunDanmu.Im.Message.IPullNewRequest=} [properties] Properties to set
                 */
                function PullNewRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PullNewRequest target.
                 * @member {AcFunDanmu.Im.Basic.IUser|null|undefined} target
                 * @memberof AcFunDanmu.Im.Message.PullNewRequest
                 * @instance
                 */
                PullNewRequest.prototype.target = null;

                /**
                 * PullNewRequest minSeq.
                 * @member {number|Long} minSeq
                 * @memberof AcFunDanmu.Im.Message.PullNewRequest
                 * @instance
                 */
                PullNewRequest.prototype.minSeq = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * PullNewRequest count.
                 * @member {number} count
                 * @memberof AcFunDanmu.Im.Message.PullNewRequest
                 * @instance
                 */
                PullNewRequest.prototype.count = 0;

                /**
                 * PullNewRequest targetId.
                 * @member {number|Long} targetId
                 * @memberof AcFunDanmu.Im.Message.PullNewRequest
                 * @instance
                 */
                PullNewRequest.prototype.targetId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * PullNewRequest strTargetId.
                 * @member {string} strTargetId
                 * @memberof AcFunDanmu.Im.Message.PullNewRequest
                 * @instance
                 */
                PullNewRequest.prototype.strTargetId = "";

                /**
                 * Creates a new PullNewRequest instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Message.PullNewRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.IPullNewRequest=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Message.PullNewRequest} PullNewRequest instance
                 */
                PullNewRequest.create = function create(properties) {
                    return new PullNewRequest(properties);
                };

                /**
                 * Encodes the specified PullNewRequest message. Does not implicitly {@link AcFunDanmu.Im.Message.PullNewRequest.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Message.PullNewRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.IPullNewRequest} message PullNewRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PullNewRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                        $root.AcFunDanmu.Im.Basic.User.encode(message.target, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.minSeq != null && Object.hasOwnProperty.call(message, "minSeq"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int64(message.minSeq);
                    if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.count);
                    if (message.targetId != null && Object.hasOwnProperty.call(message, "targetId"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int64(message.targetId);
                    if (message.strTargetId != null && Object.hasOwnProperty.call(message, "strTargetId"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.strTargetId);
                    return writer;
                };

                /**
                 * Encodes the specified PullNewRequest message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Message.PullNewRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Message.PullNewRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.IPullNewRequest} message PullNewRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PullNewRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a PullNewRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Message.PullNewRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Message.PullNewRequest} PullNewRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PullNewRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Message.PullNewRequest();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.target = $root.AcFunDanmu.Im.Basic.User.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.minSeq = reader.int64();
                            break;
                        case 3:
                            message.count = reader.int32();
                            break;
                        case 4:
                            message.targetId = reader.int64();
                            break;
                        case 5:
                            message.strTargetId = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a PullNewRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Message.PullNewRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Message.PullNewRequest} PullNewRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PullNewRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a PullNewRequest message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Message.PullNewRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PullNewRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.target != null && message.hasOwnProperty("target")) {
                        let error = $root.AcFunDanmu.Im.Basic.User.verify(message.target);
                        if (error)
                            return "target." + error;
                    }
                    if (message.minSeq != null && message.hasOwnProperty("minSeq"))
                        if (!$util.isInteger(message.minSeq) && !(message.minSeq && $util.isInteger(message.minSeq.low) && $util.isInteger(message.minSeq.high)))
                            return "minSeq: integer|Long expected";
                    if (message.count != null && message.hasOwnProperty("count"))
                        if (!$util.isInteger(message.count))
                            return "count: integer expected";
                    if (message.targetId != null && message.hasOwnProperty("targetId"))
                        if (!$util.isInteger(message.targetId) && !(message.targetId && $util.isInteger(message.targetId.low) && $util.isInteger(message.targetId.high)))
                            return "targetId: integer|Long expected";
                    if (message.strTargetId != null && message.hasOwnProperty("strTargetId"))
                        if (!$util.isString(message.strTargetId))
                            return "strTargetId: string expected";
                    return null;
                };

                /**
                 * Creates a PullNewRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Message.PullNewRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Message.PullNewRequest} PullNewRequest
                 */
                PullNewRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Message.PullNewRequest)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Message.PullNewRequest();
                    if (object.target != null) {
                        if (typeof object.target !== "object")
                            throw TypeError(".AcFunDanmu.Im.Message.PullNewRequest.target: object expected");
                        message.target = $root.AcFunDanmu.Im.Basic.User.fromObject(object.target);
                    }
                    if (object.minSeq != null)
                        if ($util.Long)
                            (message.minSeq = $util.Long.fromValue(object.minSeq)).unsigned = false;
                        else if (typeof object.minSeq === "string")
                            message.minSeq = parseInt(object.minSeq, 10);
                        else if (typeof object.minSeq === "number")
                            message.minSeq = object.minSeq;
                        else if (typeof object.minSeq === "object")
                            message.minSeq = new $util.LongBits(object.minSeq.low >>> 0, object.minSeq.high >>> 0).toNumber();
                    if (object.count != null)
                        message.count = object.count | 0;
                    if (object.targetId != null)
                        if ($util.Long)
                            (message.targetId = $util.Long.fromValue(object.targetId)).unsigned = false;
                        else if (typeof object.targetId === "string")
                            message.targetId = parseInt(object.targetId, 10);
                        else if (typeof object.targetId === "number")
                            message.targetId = object.targetId;
                        else if (typeof object.targetId === "object")
                            message.targetId = new $util.LongBits(object.targetId.low >>> 0, object.targetId.high >>> 0).toNumber();
                    if (object.strTargetId != null)
                        message.strTargetId = String(object.strTargetId);
                    return message;
                };

                /**
                 * Creates a plain object from a PullNewRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Message.PullNewRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.PullNewRequest} message PullNewRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PullNewRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.target = null;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.minSeq = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.minSeq = options.longs === String ? "0" : 0;
                        object.count = 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.targetId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.targetId = options.longs === String ? "0" : 0;
                        object.strTargetId = "";
                    }
                    if (message.target != null && message.hasOwnProperty("target"))
                        object.target = $root.AcFunDanmu.Im.Basic.User.toObject(message.target, options);
                    if (message.minSeq != null && message.hasOwnProperty("minSeq"))
                        if (typeof message.minSeq === "number")
                            object.minSeq = options.longs === String ? String(message.minSeq) : message.minSeq;
                        else
                            object.minSeq = options.longs === String ? $util.Long.prototype.toString.call(message.minSeq) : options.longs === Number ? new $util.LongBits(message.minSeq.low >>> 0, message.minSeq.high >>> 0).toNumber() : message.minSeq;
                    if (message.count != null && message.hasOwnProperty("count"))
                        object.count = message.count;
                    if (message.targetId != null && message.hasOwnProperty("targetId"))
                        if (typeof message.targetId === "number")
                            object.targetId = options.longs === String ? String(message.targetId) : message.targetId;
                        else
                            object.targetId = options.longs === String ? $util.Long.prototype.toString.call(message.targetId) : options.longs === Number ? new $util.LongBits(message.targetId.low >>> 0, message.targetId.high >>> 0).toNumber() : message.targetId;
                    if (message.strTargetId != null && message.hasOwnProperty("strTargetId"))
                        object.strTargetId = message.strTargetId;
                    return object;
                };

                /**
                 * Converts this PullNewRequest to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Message.PullNewRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PullNewRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return PullNewRequest;
            })();

            Message.PullNewResponse = (function() {

                /**
                 * Properties of a PullNewResponse.
                 * @memberof AcFunDanmu.Im.Message
                 * @interface IPullNewResponse
                 * @property {Array.<AcFunDanmu.Im.Message.IMessage>|null} [messages] PullNewResponse messages
                 */

                /**
                 * Constructs a new PullNewResponse.
                 * @memberof AcFunDanmu.Im.Message
                 * @classdesc Represents a PullNewResponse.
                 * @implements IPullNewResponse
                 * @constructor
                 * @param {AcFunDanmu.Im.Message.IPullNewResponse=} [properties] Properties to set
                 */
                function PullNewResponse(properties) {
                    this.messages = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PullNewResponse messages.
                 * @member {Array.<AcFunDanmu.Im.Message.IMessage>} messages
                 * @memberof AcFunDanmu.Im.Message.PullNewResponse
                 * @instance
                 */
                PullNewResponse.prototype.messages = $util.emptyArray;

                /**
                 * Creates a new PullNewResponse instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Message.PullNewResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.IPullNewResponse=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Message.PullNewResponse} PullNewResponse instance
                 */
                PullNewResponse.create = function create(properties) {
                    return new PullNewResponse(properties);
                };

                /**
                 * Encodes the specified PullNewResponse message. Does not implicitly {@link AcFunDanmu.Im.Message.PullNewResponse.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Message.PullNewResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.IPullNewResponse} message PullNewResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PullNewResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.messages != null && message.messages.length)
                        for (let i = 0; i < message.messages.length; ++i)
                            $root.AcFunDanmu.Im.Message.Message.encode(message.messages[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified PullNewResponse message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Message.PullNewResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Message.PullNewResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.IPullNewResponse} message PullNewResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PullNewResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a PullNewResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Message.PullNewResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Message.PullNewResponse} PullNewResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PullNewResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Message.PullNewResponse();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.messages && message.messages.length))
                                message.messages = [];
                            message.messages.push($root.AcFunDanmu.Im.Message.Message.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a PullNewResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Message.PullNewResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Message.PullNewResponse} PullNewResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PullNewResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a PullNewResponse message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Message.PullNewResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PullNewResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.messages != null && message.hasOwnProperty("messages")) {
                        if (!Array.isArray(message.messages))
                            return "messages: array expected";
                        for (let i = 0; i < message.messages.length; ++i) {
                            let error = $root.AcFunDanmu.Im.Message.Message.verify(message.messages[i]);
                            if (error)
                                return "messages." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a PullNewResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Message.PullNewResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Message.PullNewResponse} PullNewResponse
                 */
                PullNewResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Message.PullNewResponse)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Message.PullNewResponse();
                    if (object.messages) {
                        if (!Array.isArray(object.messages))
                            throw TypeError(".AcFunDanmu.Im.Message.PullNewResponse.messages: array expected");
                        message.messages = [];
                        for (let i = 0; i < object.messages.length; ++i) {
                            if (typeof object.messages[i] !== "object")
                                throw TypeError(".AcFunDanmu.Im.Message.PullNewResponse.messages: object expected");
                            message.messages[i] = $root.AcFunDanmu.Im.Message.Message.fromObject(object.messages[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a PullNewResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Message.PullNewResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.PullNewResponse} message PullNewResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PullNewResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.messages = [];
                    if (message.messages && message.messages.length) {
                        object.messages = [];
                        for (let j = 0; j < message.messages.length; ++j)
                            object.messages[j] = $root.AcFunDanmu.Im.Message.Message.toObject(message.messages[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this PullNewResponse to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Message.PullNewResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PullNewResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return PullNewResponse;
            })();

            Message.SessionListRequest = (function() {

                /**
                 * Properties of a SessionListRequest.
                 * @memberof AcFunDanmu.Im.Message
                 * @interface ISessionListRequest
                 * @property {AcFunDanmu.Im.Basic.ISyncCookie|null} [syncCookie] SessionListRequest syncCookie
                 * @property {number|null} [categoryId] SessionListRequest categoryId
                 * @property {number|null} [localDataStatus] SessionListRequest localDataStatus
                 */

                /**
                 * Constructs a new SessionListRequest.
                 * @memberof AcFunDanmu.Im.Message
                 * @classdesc Represents a SessionListRequest.
                 * @implements ISessionListRequest
                 * @constructor
                 * @param {AcFunDanmu.Im.Message.ISessionListRequest=} [properties] Properties to set
                 */
                function SessionListRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SessionListRequest syncCookie.
                 * @member {AcFunDanmu.Im.Basic.ISyncCookie|null|undefined} syncCookie
                 * @memberof AcFunDanmu.Im.Message.SessionListRequest
                 * @instance
                 */
                SessionListRequest.prototype.syncCookie = null;

                /**
                 * SessionListRequest categoryId.
                 * @member {number} categoryId
                 * @memberof AcFunDanmu.Im.Message.SessionListRequest
                 * @instance
                 */
                SessionListRequest.prototype.categoryId = 0;

                /**
                 * SessionListRequest localDataStatus.
                 * @member {number} localDataStatus
                 * @memberof AcFunDanmu.Im.Message.SessionListRequest
                 * @instance
                 */
                SessionListRequest.prototype.localDataStatus = 0;

                /**
                 * Creates a new SessionListRequest instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Message.SessionListRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.ISessionListRequest=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Message.SessionListRequest} SessionListRequest instance
                 */
                SessionListRequest.create = function create(properties) {
                    return new SessionListRequest(properties);
                };

                /**
                 * Encodes the specified SessionListRequest message. Does not implicitly {@link AcFunDanmu.Im.Message.SessionListRequest.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Message.SessionListRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.ISessionListRequest} message SessionListRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SessionListRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.syncCookie != null && Object.hasOwnProperty.call(message, "syncCookie"))
                        $root.AcFunDanmu.Im.Basic.SyncCookie.encode(message.syncCookie, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.categoryId != null && Object.hasOwnProperty.call(message, "categoryId"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.categoryId);
                    if (message.localDataStatus != null && Object.hasOwnProperty.call(message, "localDataStatus"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.localDataStatus);
                    return writer;
                };

                /**
                 * Encodes the specified SessionListRequest message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Message.SessionListRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Message.SessionListRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.ISessionListRequest} message SessionListRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SessionListRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SessionListRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Message.SessionListRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Message.SessionListRequest} SessionListRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SessionListRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Message.SessionListRequest();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.syncCookie = $root.AcFunDanmu.Im.Basic.SyncCookie.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.categoryId = reader.int32();
                            break;
                        case 3:
                            message.localDataStatus = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SessionListRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Message.SessionListRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Message.SessionListRequest} SessionListRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SessionListRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SessionListRequest message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Message.SessionListRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SessionListRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.syncCookie != null && message.hasOwnProperty("syncCookie")) {
                        let error = $root.AcFunDanmu.Im.Basic.SyncCookie.verify(message.syncCookie);
                        if (error)
                            return "syncCookie." + error;
                    }
                    if (message.categoryId != null && message.hasOwnProperty("categoryId"))
                        if (!$util.isInteger(message.categoryId))
                            return "categoryId: integer expected";
                    if (message.localDataStatus != null && message.hasOwnProperty("localDataStatus"))
                        if (!$util.isInteger(message.localDataStatus))
                            return "localDataStatus: integer expected";
                    return null;
                };

                /**
                 * Creates a SessionListRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Message.SessionListRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Message.SessionListRequest} SessionListRequest
                 */
                SessionListRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Message.SessionListRequest)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Message.SessionListRequest();
                    if (object.syncCookie != null) {
                        if (typeof object.syncCookie !== "object")
                            throw TypeError(".AcFunDanmu.Im.Message.SessionListRequest.syncCookie: object expected");
                        message.syncCookie = $root.AcFunDanmu.Im.Basic.SyncCookie.fromObject(object.syncCookie);
                    }
                    if (object.categoryId != null)
                        message.categoryId = object.categoryId | 0;
                    if (object.localDataStatus != null)
                        message.localDataStatus = object.localDataStatus | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a SessionListRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Message.SessionListRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.SessionListRequest} message SessionListRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SessionListRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.syncCookie = null;
                        object.categoryId = 0;
                        object.localDataStatus = 0;
                    }
                    if (message.syncCookie != null && message.hasOwnProperty("syncCookie"))
                        object.syncCookie = $root.AcFunDanmu.Im.Basic.SyncCookie.toObject(message.syncCookie, options);
                    if (message.categoryId != null && message.hasOwnProperty("categoryId"))
                        object.categoryId = message.categoryId;
                    if (message.localDataStatus != null && message.hasOwnProperty("localDataStatus"))
                        object.localDataStatus = message.localDataStatus;
                    return object;
                };

                /**
                 * Converts this SessionListRequest to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Message.SessionListRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SessionListRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SessionListRequest;
            })();

            Message.ChatSession = (function() {

                /**
                 * Properties of a ChatSession.
                 * @memberof AcFunDanmu.Im.Message
                 * @interface IChatSession
                 * @property {AcFunDanmu.Im.Basic.IUser|null} [target] ChatSession target
                 * @property {number|Long|null} [maxSeqId] ChatSession maxSeqId
                 * @property {number|Long|null} [readSeqId] ChatSession readSeqId
                 * @property {number|null} [unreadMsgCount] ChatSession unreadMsgCount
                 * @property {Array.<AcFunDanmu.Im.Message.IMessage>|null} [latestMessage] ChatSession latestMessage
                 * @property {AcFunDanmu.Im.Message.ChatTargetType|null} [chatTargetType] ChatSession chatTargetType
                 * @property {number|Long|null} [targetId] ChatSession targetId
                 * @property {number|Long|null} [activeTime] ChatSession activeTime
                 * @property {number|null} [priority] ChatSession priority
                 * @property {number|null} [categoryId] ChatSession categoryId
                 * @property {string|null} [cursor] ChatSession cursor
                 * @property {number|null} [accountType] ChatSession accountType
                 * @property {boolean|null} [aggregateSession] ChatSession aggregateSession
                 * @property {number|null} [jumpCategoryId] ChatSession jumpCategoryId
                 * @property {number|Long|null} [expireAt] ChatSession expireAt
                 * @property {number|Long|null} [effectiveFrom] ChatSession effectiveFrom
                 * @property {string|null} [strTargetId] ChatSession strTargetId
                 * @property {Array.<AcFunDanmu.Im.Message.IRemindBody>|null} [remindBody] ChatSession remindBody
                 * @property {number|Long|null} [targetReadSeqId] ChatSession targetReadSeqId
                 */

                /**
                 * Constructs a new ChatSession.
                 * @memberof AcFunDanmu.Im.Message
                 * @classdesc Represents a ChatSession.
                 * @implements IChatSession
                 * @constructor
                 * @param {AcFunDanmu.Im.Message.IChatSession=} [properties] Properties to set
                 */
                function ChatSession(properties) {
                    this.latestMessage = [];
                    this.remindBody = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ChatSession target.
                 * @member {AcFunDanmu.Im.Basic.IUser|null|undefined} target
                 * @memberof AcFunDanmu.Im.Message.ChatSession
                 * @instance
                 */
                ChatSession.prototype.target = null;

                /**
                 * ChatSession maxSeqId.
                 * @member {number|Long} maxSeqId
                 * @memberof AcFunDanmu.Im.Message.ChatSession
                 * @instance
                 */
                ChatSession.prototype.maxSeqId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * ChatSession readSeqId.
                 * @member {number|Long} readSeqId
                 * @memberof AcFunDanmu.Im.Message.ChatSession
                 * @instance
                 */
                ChatSession.prototype.readSeqId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * ChatSession unreadMsgCount.
                 * @member {number} unreadMsgCount
                 * @memberof AcFunDanmu.Im.Message.ChatSession
                 * @instance
                 */
                ChatSession.prototype.unreadMsgCount = 0;

                /**
                 * ChatSession latestMessage.
                 * @member {Array.<AcFunDanmu.Im.Message.IMessage>} latestMessage
                 * @memberof AcFunDanmu.Im.Message.ChatSession
                 * @instance
                 */
                ChatSession.prototype.latestMessage = $util.emptyArray;

                /**
                 * ChatSession chatTargetType.
                 * @member {AcFunDanmu.Im.Message.ChatTargetType} chatTargetType
                 * @memberof AcFunDanmu.Im.Message.ChatSession
                 * @instance
                 */
                ChatSession.prototype.chatTargetType = 0;

                /**
                 * ChatSession targetId.
                 * @member {number|Long} targetId
                 * @memberof AcFunDanmu.Im.Message.ChatSession
                 * @instance
                 */
                ChatSession.prototype.targetId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * ChatSession activeTime.
                 * @member {number|Long} activeTime
                 * @memberof AcFunDanmu.Im.Message.ChatSession
                 * @instance
                 */
                ChatSession.prototype.activeTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * ChatSession priority.
                 * @member {number} priority
                 * @memberof AcFunDanmu.Im.Message.ChatSession
                 * @instance
                 */
                ChatSession.prototype.priority = 0;

                /**
                 * ChatSession categoryId.
                 * @member {number} categoryId
                 * @memberof AcFunDanmu.Im.Message.ChatSession
                 * @instance
                 */
                ChatSession.prototype.categoryId = 0;

                /**
                 * ChatSession cursor.
                 * @member {string} cursor
                 * @memberof AcFunDanmu.Im.Message.ChatSession
                 * @instance
                 */
                ChatSession.prototype.cursor = "";

                /**
                 * ChatSession accountType.
                 * @member {number} accountType
                 * @memberof AcFunDanmu.Im.Message.ChatSession
                 * @instance
                 */
                ChatSession.prototype.accountType = 0;

                /**
                 * ChatSession aggregateSession.
                 * @member {boolean} aggregateSession
                 * @memberof AcFunDanmu.Im.Message.ChatSession
                 * @instance
                 */
                ChatSession.prototype.aggregateSession = false;

                /**
                 * ChatSession jumpCategoryId.
                 * @member {number} jumpCategoryId
                 * @memberof AcFunDanmu.Im.Message.ChatSession
                 * @instance
                 */
                ChatSession.prototype.jumpCategoryId = 0;

                /**
                 * ChatSession expireAt.
                 * @member {number|Long} expireAt
                 * @memberof AcFunDanmu.Im.Message.ChatSession
                 * @instance
                 */
                ChatSession.prototype.expireAt = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * ChatSession effectiveFrom.
                 * @member {number|Long} effectiveFrom
                 * @memberof AcFunDanmu.Im.Message.ChatSession
                 * @instance
                 */
                ChatSession.prototype.effectiveFrom = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * ChatSession strTargetId.
                 * @member {string} strTargetId
                 * @memberof AcFunDanmu.Im.Message.ChatSession
                 * @instance
                 */
                ChatSession.prototype.strTargetId = "";

                /**
                 * ChatSession remindBody.
                 * @member {Array.<AcFunDanmu.Im.Message.IRemindBody>} remindBody
                 * @memberof AcFunDanmu.Im.Message.ChatSession
                 * @instance
                 */
                ChatSession.prototype.remindBody = $util.emptyArray;

                /**
                 * ChatSession targetReadSeqId.
                 * @member {number|Long} targetReadSeqId
                 * @memberof AcFunDanmu.Im.Message.ChatSession
                 * @instance
                 */
                ChatSession.prototype.targetReadSeqId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Creates a new ChatSession instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Message.ChatSession
                 * @static
                 * @param {AcFunDanmu.Im.Message.IChatSession=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Message.ChatSession} ChatSession instance
                 */
                ChatSession.create = function create(properties) {
                    return new ChatSession(properties);
                };

                /**
                 * Encodes the specified ChatSession message. Does not implicitly {@link AcFunDanmu.Im.Message.ChatSession.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Message.ChatSession
                 * @static
                 * @param {AcFunDanmu.Im.Message.IChatSession} message ChatSession message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ChatSession.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                        $root.AcFunDanmu.Im.Basic.User.encode(message.target, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.maxSeqId != null && Object.hasOwnProperty.call(message, "maxSeqId"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int64(message.maxSeqId);
                    if (message.readSeqId != null && Object.hasOwnProperty.call(message, "readSeqId"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int64(message.readSeqId);
                    if (message.unreadMsgCount != null && Object.hasOwnProperty.call(message, "unreadMsgCount"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.unreadMsgCount);
                    if (message.latestMessage != null && message.latestMessage.length)
                        for (let i = 0; i < message.latestMessage.length; ++i)
                            $root.AcFunDanmu.Im.Message.Message.encode(message.latestMessage[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.chatTargetType != null && Object.hasOwnProperty.call(message, "chatTargetType"))
                        writer.uint32(/* id 8, wireType 0 =*/64).int32(message.chatTargetType);
                    if (message.targetId != null && Object.hasOwnProperty.call(message, "targetId"))
                        writer.uint32(/* id 9, wireType 0 =*/72).int64(message.targetId);
                    if (message.activeTime != null && Object.hasOwnProperty.call(message, "activeTime"))
                        writer.uint32(/* id 10, wireType 0 =*/80).int64(message.activeTime);
                    if (message.priority != null && Object.hasOwnProperty.call(message, "priority"))
                        writer.uint32(/* id 11, wireType 0 =*/88).int32(message.priority);
                    if (message.categoryId != null && Object.hasOwnProperty.call(message, "categoryId"))
                        writer.uint32(/* id 12, wireType 0 =*/96).int32(message.categoryId);
                    if (message.cursor != null && Object.hasOwnProperty.call(message, "cursor"))
                        writer.uint32(/* id 13, wireType 2 =*/106).string(message.cursor);
                    if (message.accountType != null && Object.hasOwnProperty.call(message, "accountType"))
                        writer.uint32(/* id 14, wireType 0 =*/112).int32(message.accountType);
                    if (message.aggregateSession != null && Object.hasOwnProperty.call(message, "aggregateSession"))
                        writer.uint32(/* id 15, wireType 0 =*/120).bool(message.aggregateSession);
                    if (message.jumpCategoryId != null && Object.hasOwnProperty.call(message, "jumpCategoryId"))
                        writer.uint32(/* id 16, wireType 0 =*/128).int32(message.jumpCategoryId);
                    if (message.expireAt != null && Object.hasOwnProperty.call(message, "expireAt"))
                        writer.uint32(/* id 17, wireType 0 =*/136).int64(message.expireAt);
                    if (message.effectiveFrom != null && Object.hasOwnProperty.call(message, "effectiveFrom"))
                        writer.uint32(/* id 18, wireType 0 =*/144).int64(message.effectiveFrom);
                    if (message.strTargetId != null && Object.hasOwnProperty.call(message, "strTargetId"))
                        writer.uint32(/* id 19, wireType 2 =*/154).string(message.strTargetId);
                    if (message.remindBody != null && message.remindBody.length)
                        for (let i = 0; i < message.remindBody.length; ++i)
                            $root.AcFunDanmu.Im.Message.RemindBody.encode(message.remindBody[i], writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
                    if (message.targetReadSeqId != null && Object.hasOwnProperty.call(message, "targetReadSeqId"))
                        writer.uint32(/* id 21, wireType 0 =*/168).int64(message.targetReadSeqId);
                    return writer;
                };

                /**
                 * Encodes the specified ChatSession message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Message.ChatSession.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Message.ChatSession
                 * @static
                 * @param {AcFunDanmu.Im.Message.IChatSession} message ChatSession message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ChatSession.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ChatSession message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Message.ChatSession
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Message.ChatSession} ChatSession
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ChatSession.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Message.ChatSession();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.target = $root.AcFunDanmu.Im.Basic.User.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.maxSeqId = reader.int64();
                            break;
                        case 3:
                            message.readSeqId = reader.int64();
                            break;
                        case 4:
                            message.unreadMsgCount = reader.int32();
                            break;
                        case 5:
                            if (!(message.latestMessage && message.latestMessage.length))
                                message.latestMessage = [];
                            message.latestMessage.push($root.AcFunDanmu.Im.Message.Message.decode(reader, reader.uint32()));
                            break;
                        case 8:
                            message.chatTargetType = reader.int32();
                            break;
                        case 9:
                            message.targetId = reader.int64();
                            break;
                        case 10:
                            message.activeTime = reader.int64();
                            break;
                        case 11:
                            message.priority = reader.int32();
                            break;
                        case 12:
                            message.categoryId = reader.int32();
                            break;
                        case 13:
                            message.cursor = reader.string();
                            break;
                        case 14:
                            message.accountType = reader.int32();
                            break;
                        case 15:
                            message.aggregateSession = reader.bool();
                            break;
                        case 16:
                            message.jumpCategoryId = reader.int32();
                            break;
                        case 17:
                            message.expireAt = reader.int64();
                            break;
                        case 18:
                            message.effectiveFrom = reader.int64();
                            break;
                        case 19:
                            message.strTargetId = reader.string();
                            break;
                        case 20:
                            if (!(message.remindBody && message.remindBody.length))
                                message.remindBody = [];
                            message.remindBody.push($root.AcFunDanmu.Im.Message.RemindBody.decode(reader, reader.uint32()));
                            break;
                        case 21:
                            message.targetReadSeqId = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ChatSession message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Message.ChatSession
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Message.ChatSession} ChatSession
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ChatSession.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ChatSession message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Message.ChatSession
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ChatSession.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.target != null && message.hasOwnProperty("target")) {
                        let error = $root.AcFunDanmu.Im.Basic.User.verify(message.target);
                        if (error)
                            return "target." + error;
                    }
                    if (message.maxSeqId != null && message.hasOwnProperty("maxSeqId"))
                        if (!$util.isInteger(message.maxSeqId) && !(message.maxSeqId && $util.isInteger(message.maxSeqId.low) && $util.isInteger(message.maxSeqId.high)))
                            return "maxSeqId: integer|Long expected";
                    if (message.readSeqId != null && message.hasOwnProperty("readSeqId"))
                        if (!$util.isInteger(message.readSeqId) && !(message.readSeqId && $util.isInteger(message.readSeqId.low) && $util.isInteger(message.readSeqId.high)))
                            return "readSeqId: integer|Long expected";
                    if (message.unreadMsgCount != null && message.hasOwnProperty("unreadMsgCount"))
                        if (!$util.isInteger(message.unreadMsgCount))
                            return "unreadMsgCount: integer expected";
                    if (message.latestMessage != null && message.hasOwnProperty("latestMessage")) {
                        if (!Array.isArray(message.latestMessage))
                            return "latestMessage: array expected";
                        for (let i = 0; i < message.latestMessage.length; ++i) {
                            let error = $root.AcFunDanmu.Im.Message.Message.verify(message.latestMessage[i]);
                            if (error)
                                return "latestMessage." + error;
                        }
                    }
                    if (message.chatTargetType != null && message.hasOwnProperty("chatTargetType"))
                        switch (message.chatTargetType) {
                        default:
                            return "chatTargetType: enum value expected";
                        case 0:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                            break;
                        }
                    if (message.targetId != null && message.hasOwnProperty("targetId"))
                        if (!$util.isInteger(message.targetId) && !(message.targetId && $util.isInteger(message.targetId.low) && $util.isInteger(message.targetId.high)))
                            return "targetId: integer|Long expected";
                    if (message.activeTime != null && message.hasOwnProperty("activeTime"))
                        if (!$util.isInteger(message.activeTime) && !(message.activeTime && $util.isInteger(message.activeTime.low) && $util.isInteger(message.activeTime.high)))
                            return "activeTime: integer|Long expected";
                    if (message.priority != null && message.hasOwnProperty("priority"))
                        if (!$util.isInteger(message.priority))
                            return "priority: integer expected";
                    if (message.categoryId != null && message.hasOwnProperty("categoryId"))
                        if (!$util.isInteger(message.categoryId))
                            return "categoryId: integer expected";
                    if (message.cursor != null && message.hasOwnProperty("cursor"))
                        if (!$util.isString(message.cursor))
                            return "cursor: string expected";
                    if (message.accountType != null && message.hasOwnProperty("accountType"))
                        if (!$util.isInteger(message.accountType))
                            return "accountType: integer expected";
                    if (message.aggregateSession != null && message.hasOwnProperty("aggregateSession"))
                        if (typeof message.aggregateSession !== "boolean")
                            return "aggregateSession: boolean expected";
                    if (message.jumpCategoryId != null && message.hasOwnProperty("jumpCategoryId"))
                        if (!$util.isInteger(message.jumpCategoryId))
                            return "jumpCategoryId: integer expected";
                    if (message.expireAt != null && message.hasOwnProperty("expireAt"))
                        if (!$util.isInteger(message.expireAt) && !(message.expireAt && $util.isInteger(message.expireAt.low) && $util.isInteger(message.expireAt.high)))
                            return "expireAt: integer|Long expected";
                    if (message.effectiveFrom != null && message.hasOwnProperty("effectiveFrom"))
                        if (!$util.isInteger(message.effectiveFrom) && !(message.effectiveFrom && $util.isInteger(message.effectiveFrom.low) && $util.isInteger(message.effectiveFrom.high)))
                            return "effectiveFrom: integer|Long expected";
                    if (message.strTargetId != null && message.hasOwnProperty("strTargetId"))
                        if (!$util.isString(message.strTargetId))
                            return "strTargetId: string expected";
                    if (message.remindBody != null && message.hasOwnProperty("remindBody")) {
                        if (!Array.isArray(message.remindBody))
                            return "remindBody: array expected";
                        for (let i = 0; i < message.remindBody.length; ++i) {
                            let error = $root.AcFunDanmu.Im.Message.RemindBody.verify(message.remindBody[i]);
                            if (error)
                                return "remindBody." + error;
                        }
                    }
                    if (message.targetReadSeqId != null && message.hasOwnProperty("targetReadSeqId"))
                        if (!$util.isInteger(message.targetReadSeqId) && !(message.targetReadSeqId && $util.isInteger(message.targetReadSeqId.low) && $util.isInteger(message.targetReadSeqId.high)))
                            return "targetReadSeqId: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a ChatSession message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Message.ChatSession
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Message.ChatSession} ChatSession
                 */
                ChatSession.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Message.ChatSession)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Message.ChatSession();
                    if (object.target != null) {
                        if (typeof object.target !== "object")
                            throw TypeError(".AcFunDanmu.Im.Message.ChatSession.target: object expected");
                        message.target = $root.AcFunDanmu.Im.Basic.User.fromObject(object.target);
                    }
                    if (object.maxSeqId != null)
                        if ($util.Long)
                            (message.maxSeqId = $util.Long.fromValue(object.maxSeqId)).unsigned = false;
                        else if (typeof object.maxSeqId === "string")
                            message.maxSeqId = parseInt(object.maxSeqId, 10);
                        else if (typeof object.maxSeqId === "number")
                            message.maxSeqId = object.maxSeqId;
                        else if (typeof object.maxSeqId === "object")
                            message.maxSeqId = new $util.LongBits(object.maxSeqId.low >>> 0, object.maxSeqId.high >>> 0).toNumber();
                    if (object.readSeqId != null)
                        if ($util.Long)
                            (message.readSeqId = $util.Long.fromValue(object.readSeqId)).unsigned = false;
                        else if (typeof object.readSeqId === "string")
                            message.readSeqId = parseInt(object.readSeqId, 10);
                        else if (typeof object.readSeqId === "number")
                            message.readSeqId = object.readSeqId;
                        else if (typeof object.readSeqId === "object")
                            message.readSeqId = new $util.LongBits(object.readSeqId.low >>> 0, object.readSeqId.high >>> 0).toNumber();
                    if (object.unreadMsgCount != null)
                        message.unreadMsgCount = object.unreadMsgCount | 0;
                    if (object.latestMessage) {
                        if (!Array.isArray(object.latestMessage))
                            throw TypeError(".AcFunDanmu.Im.Message.ChatSession.latestMessage: array expected");
                        message.latestMessage = [];
                        for (let i = 0; i < object.latestMessage.length; ++i) {
                            if (typeof object.latestMessage[i] !== "object")
                                throw TypeError(".AcFunDanmu.Im.Message.ChatSession.latestMessage: object expected");
                            message.latestMessage[i] = $root.AcFunDanmu.Im.Message.Message.fromObject(object.latestMessage[i]);
                        }
                    }
                    switch (object.chatTargetType) {
                    case "CTT_USER":
                    case 0:
                        message.chatTargetType = 0;
                        break;
                    case "CTT_CHAT_ROOM":
                    case 2:
                        message.chatTargetType = 2;
                        break;
                    case "CTT_MULTI_PLAYER_ROOM":
                    case 3:
                        message.chatTargetType = 3;
                        break;
                    case "CTT_GROUP":
                    case 4:
                        message.chatTargetType = 4;
                        break;
                    case "CTT_CHANNEL":
                    case 5:
                        message.chatTargetType = 5;
                        break;
                    case "CTT_AGGREGATE":
                    case 6:
                        message.chatTargetType = 6;
                        break;
                    }
                    if (object.targetId != null)
                        if ($util.Long)
                            (message.targetId = $util.Long.fromValue(object.targetId)).unsigned = false;
                        else if (typeof object.targetId === "string")
                            message.targetId = parseInt(object.targetId, 10);
                        else if (typeof object.targetId === "number")
                            message.targetId = object.targetId;
                        else if (typeof object.targetId === "object")
                            message.targetId = new $util.LongBits(object.targetId.low >>> 0, object.targetId.high >>> 0).toNumber();
                    if (object.activeTime != null)
                        if ($util.Long)
                            (message.activeTime = $util.Long.fromValue(object.activeTime)).unsigned = false;
                        else if (typeof object.activeTime === "string")
                            message.activeTime = parseInt(object.activeTime, 10);
                        else if (typeof object.activeTime === "number")
                            message.activeTime = object.activeTime;
                        else if (typeof object.activeTime === "object")
                            message.activeTime = new $util.LongBits(object.activeTime.low >>> 0, object.activeTime.high >>> 0).toNumber();
                    if (object.priority != null)
                        message.priority = object.priority | 0;
                    if (object.categoryId != null)
                        message.categoryId = object.categoryId | 0;
                    if (object.cursor != null)
                        message.cursor = String(object.cursor);
                    if (object.accountType != null)
                        message.accountType = object.accountType | 0;
                    if (object.aggregateSession != null)
                        message.aggregateSession = Boolean(object.aggregateSession);
                    if (object.jumpCategoryId != null)
                        message.jumpCategoryId = object.jumpCategoryId | 0;
                    if (object.expireAt != null)
                        if ($util.Long)
                            (message.expireAt = $util.Long.fromValue(object.expireAt)).unsigned = false;
                        else if (typeof object.expireAt === "string")
                            message.expireAt = parseInt(object.expireAt, 10);
                        else if (typeof object.expireAt === "number")
                            message.expireAt = object.expireAt;
                        else if (typeof object.expireAt === "object")
                            message.expireAt = new $util.LongBits(object.expireAt.low >>> 0, object.expireAt.high >>> 0).toNumber();
                    if (object.effectiveFrom != null)
                        if ($util.Long)
                            (message.effectiveFrom = $util.Long.fromValue(object.effectiveFrom)).unsigned = false;
                        else if (typeof object.effectiveFrom === "string")
                            message.effectiveFrom = parseInt(object.effectiveFrom, 10);
                        else if (typeof object.effectiveFrom === "number")
                            message.effectiveFrom = object.effectiveFrom;
                        else if (typeof object.effectiveFrom === "object")
                            message.effectiveFrom = new $util.LongBits(object.effectiveFrom.low >>> 0, object.effectiveFrom.high >>> 0).toNumber();
                    if (object.strTargetId != null)
                        message.strTargetId = String(object.strTargetId);
                    if (object.remindBody) {
                        if (!Array.isArray(object.remindBody))
                            throw TypeError(".AcFunDanmu.Im.Message.ChatSession.remindBody: array expected");
                        message.remindBody = [];
                        for (let i = 0; i < object.remindBody.length; ++i) {
                            if (typeof object.remindBody[i] !== "object")
                                throw TypeError(".AcFunDanmu.Im.Message.ChatSession.remindBody: object expected");
                            message.remindBody[i] = $root.AcFunDanmu.Im.Message.RemindBody.fromObject(object.remindBody[i]);
                        }
                    }
                    if (object.targetReadSeqId != null)
                        if ($util.Long)
                            (message.targetReadSeqId = $util.Long.fromValue(object.targetReadSeqId)).unsigned = false;
                        else if (typeof object.targetReadSeqId === "string")
                            message.targetReadSeqId = parseInt(object.targetReadSeqId, 10);
                        else if (typeof object.targetReadSeqId === "number")
                            message.targetReadSeqId = object.targetReadSeqId;
                        else if (typeof object.targetReadSeqId === "object")
                            message.targetReadSeqId = new $util.LongBits(object.targetReadSeqId.low >>> 0, object.targetReadSeqId.high >>> 0).toNumber();
                    return message;
                };

                /**
                 * Creates a plain object from a ChatSession message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Message.ChatSession
                 * @static
                 * @param {AcFunDanmu.Im.Message.ChatSession} message ChatSession
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ChatSession.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults) {
                        object.latestMessage = [];
                        object.remindBody = [];
                    }
                    if (options.defaults) {
                        object.target = null;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.maxSeqId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.maxSeqId = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.readSeqId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.readSeqId = options.longs === String ? "0" : 0;
                        object.unreadMsgCount = 0;
                        object.chatTargetType = options.enums === String ? "CTT_USER" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.targetId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.targetId = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.activeTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.activeTime = options.longs === String ? "0" : 0;
                        object.priority = 0;
                        object.categoryId = 0;
                        object.cursor = "";
                        object.accountType = 0;
                        object.aggregateSession = false;
                        object.jumpCategoryId = 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.expireAt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.expireAt = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.effectiveFrom = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.effectiveFrom = options.longs === String ? "0" : 0;
                        object.strTargetId = "";
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.targetReadSeqId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.targetReadSeqId = options.longs === String ? "0" : 0;
                    }
                    if (message.target != null && message.hasOwnProperty("target"))
                        object.target = $root.AcFunDanmu.Im.Basic.User.toObject(message.target, options);
                    if (message.maxSeqId != null && message.hasOwnProperty("maxSeqId"))
                        if (typeof message.maxSeqId === "number")
                            object.maxSeqId = options.longs === String ? String(message.maxSeqId) : message.maxSeqId;
                        else
                            object.maxSeqId = options.longs === String ? $util.Long.prototype.toString.call(message.maxSeqId) : options.longs === Number ? new $util.LongBits(message.maxSeqId.low >>> 0, message.maxSeqId.high >>> 0).toNumber() : message.maxSeqId;
                    if (message.readSeqId != null && message.hasOwnProperty("readSeqId"))
                        if (typeof message.readSeqId === "number")
                            object.readSeqId = options.longs === String ? String(message.readSeqId) : message.readSeqId;
                        else
                            object.readSeqId = options.longs === String ? $util.Long.prototype.toString.call(message.readSeqId) : options.longs === Number ? new $util.LongBits(message.readSeqId.low >>> 0, message.readSeqId.high >>> 0).toNumber() : message.readSeqId;
                    if (message.unreadMsgCount != null && message.hasOwnProperty("unreadMsgCount"))
                        object.unreadMsgCount = message.unreadMsgCount;
                    if (message.latestMessage && message.latestMessage.length) {
                        object.latestMessage = [];
                        for (let j = 0; j < message.latestMessage.length; ++j)
                            object.latestMessage[j] = $root.AcFunDanmu.Im.Message.Message.toObject(message.latestMessage[j], options);
                    }
                    if (message.chatTargetType != null && message.hasOwnProperty("chatTargetType"))
                        object.chatTargetType = options.enums === String ? $root.AcFunDanmu.Im.Message.ChatTargetType[message.chatTargetType] : message.chatTargetType;
                    if (message.targetId != null && message.hasOwnProperty("targetId"))
                        if (typeof message.targetId === "number")
                            object.targetId = options.longs === String ? String(message.targetId) : message.targetId;
                        else
                            object.targetId = options.longs === String ? $util.Long.prototype.toString.call(message.targetId) : options.longs === Number ? new $util.LongBits(message.targetId.low >>> 0, message.targetId.high >>> 0).toNumber() : message.targetId;
                    if (message.activeTime != null && message.hasOwnProperty("activeTime"))
                        if (typeof message.activeTime === "number")
                            object.activeTime = options.longs === String ? String(message.activeTime) : message.activeTime;
                        else
                            object.activeTime = options.longs === String ? $util.Long.prototype.toString.call(message.activeTime) : options.longs === Number ? new $util.LongBits(message.activeTime.low >>> 0, message.activeTime.high >>> 0).toNumber() : message.activeTime;
                    if (message.priority != null && message.hasOwnProperty("priority"))
                        object.priority = message.priority;
                    if (message.categoryId != null && message.hasOwnProperty("categoryId"))
                        object.categoryId = message.categoryId;
                    if (message.cursor != null && message.hasOwnProperty("cursor"))
                        object.cursor = message.cursor;
                    if (message.accountType != null && message.hasOwnProperty("accountType"))
                        object.accountType = message.accountType;
                    if (message.aggregateSession != null && message.hasOwnProperty("aggregateSession"))
                        object.aggregateSession = message.aggregateSession;
                    if (message.jumpCategoryId != null && message.hasOwnProperty("jumpCategoryId"))
                        object.jumpCategoryId = message.jumpCategoryId;
                    if (message.expireAt != null && message.hasOwnProperty("expireAt"))
                        if (typeof message.expireAt === "number")
                            object.expireAt = options.longs === String ? String(message.expireAt) : message.expireAt;
                        else
                            object.expireAt = options.longs === String ? $util.Long.prototype.toString.call(message.expireAt) : options.longs === Number ? new $util.LongBits(message.expireAt.low >>> 0, message.expireAt.high >>> 0).toNumber() : message.expireAt;
                    if (message.effectiveFrom != null && message.hasOwnProperty("effectiveFrom"))
                        if (typeof message.effectiveFrom === "number")
                            object.effectiveFrom = options.longs === String ? String(message.effectiveFrom) : message.effectiveFrom;
                        else
                            object.effectiveFrom = options.longs === String ? $util.Long.prototype.toString.call(message.effectiveFrom) : options.longs === Number ? new $util.LongBits(message.effectiveFrom.low >>> 0, message.effectiveFrom.high >>> 0).toNumber() : message.effectiveFrom;
                    if (message.strTargetId != null && message.hasOwnProperty("strTargetId"))
                        object.strTargetId = message.strTargetId;
                    if (message.remindBody && message.remindBody.length) {
                        object.remindBody = [];
                        for (let j = 0; j < message.remindBody.length; ++j)
                            object.remindBody[j] = $root.AcFunDanmu.Im.Message.RemindBody.toObject(message.remindBody[j], options);
                    }
                    if (message.targetReadSeqId != null && message.hasOwnProperty("targetReadSeqId"))
                        if (typeof message.targetReadSeqId === "number")
                            object.targetReadSeqId = options.longs === String ? String(message.targetReadSeqId) : message.targetReadSeqId;
                        else
                            object.targetReadSeqId = options.longs === String ? $util.Long.prototype.toString.call(message.targetReadSeqId) : options.longs === Number ? new $util.LongBits(message.targetReadSeqId.low >>> 0, message.targetReadSeqId.high >>> 0).toNumber() : message.targetReadSeqId;
                    return object;
                };

                /**
                 * Converts this ChatSession to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Message.ChatSession
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ChatSession.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ChatSession;
            })();

            Message.Reminder = (function() {

                /**
                 * Properties of a Reminder.
                 * @memberof AcFunDanmu.Im.Message
                 * @interface IReminder
                 * @property {string|null} [originText] Reminder originText
                 * @property {Array.<AcFunDanmu.Im.Message.IRemindBody>|null} [remindBody] Reminder remindBody
                 */

                /**
                 * Constructs a new Reminder.
                 * @memberof AcFunDanmu.Im.Message
                 * @classdesc Represents a Reminder.
                 * @implements IReminder
                 * @constructor
                 * @param {AcFunDanmu.Im.Message.IReminder=} [properties] Properties to set
                 */
                function Reminder(properties) {
                    this.remindBody = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Reminder originText.
                 * @member {string} originText
                 * @memberof AcFunDanmu.Im.Message.Reminder
                 * @instance
                 */
                Reminder.prototype.originText = "";

                /**
                 * Reminder remindBody.
                 * @member {Array.<AcFunDanmu.Im.Message.IRemindBody>} remindBody
                 * @memberof AcFunDanmu.Im.Message.Reminder
                 * @instance
                 */
                Reminder.prototype.remindBody = $util.emptyArray;

                /**
                 * Creates a new Reminder instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Message.Reminder
                 * @static
                 * @param {AcFunDanmu.Im.Message.IReminder=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Message.Reminder} Reminder instance
                 */
                Reminder.create = function create(properties) {
                    return new Reminder(properties);
                };

                /**
                 * Encodes the specified Reminder message. Does not implicitly {@link AcFunDanmu.Im.Message.Reminder.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Message.Reminder
                 * @static
                 * @param {AcFunDanmu.Im.Message.IReminder} message Reminder message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Reminder.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.originText != null && Object.hasOwnProperty.call(message, "originText"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.originText);
                    if (message.remindBody != null && message.remindBody.length)
                        for (let i = 0; i < message.remindBody.length; ++i)
                            $root.AcFunDanmu.Im.Message.RemindBody.encode(message.remindBody[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Reminder message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Message.Reminder.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Message.Reminder
                 * @static
                 * @param {AcFunDanmu.Im.Message.IReminder} message Reminder message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Reminder.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Reminder message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Message.Reminder
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Message.Reminder} Reminder
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Reminder.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Message.Reminder();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.originText = reader.string();
                            break;
                        case 2:
                            if (!(message.remindBody && message.remindBody.length))
                                message.remindBody = [];
                            message.remindBody.push($root.AcFunDanmu.Im.Message.RemindBody.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Reminder message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Message.Reminder
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Message.Reminder} Reminder
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Reminder.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Reminder message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Message.Reminder
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Reminder.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.originText != null && message.hasOwnProperty("originText"))
                        if (!$util.isString(message.originText))
                            return "originText: string expected";
                    if (message.remindBody != null && message.hasOwnProperty("remindBody")) {
                        if (!Array.isArray(message.remindBody))
                            return "remindBody: array expected";
                        for (let i = 0; i < message.remindBody.length; ++i) {
                            let error = $root.AcFunDanmu.Im.Message.RemindBody.verify(message.remindBody[i]);
                            if (error)
                                return "remindBody." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a Reminder message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Message.Reminder
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Message.Reminder} Reminder
                 */
                Reminder.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Message.Reminder)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Message.Reminder();
                    if (object.originText != null)
                        message.originText = String(object.originText);
                    if (object.remindBody) {
                        if (!Array.isArray(object.remindBody))
                            throw TypeError(".AcFunDanmu.Im.Message.Reminder.remindBody: array expected");
                        message.remindBody = [];
                        for (let i = 0; i < object.remindBody.length; ++i) {
                            if (typeof object.remindBody[i] !== "object")
                                throw TypeError(".AcFunDanmu.Im.Message.Reminder.remindBody: object expected");
                            message.remindBody[i] = $root.AcFunDanmu.Im.Message.RemindBody.fromObject(object.remindBody[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Reminder message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Message.Reminder
                 * @static
                 * @param {AcFunDanmu.Im.Message.Reminder} message Reminder
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Reminder.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.remindBody = [];
                    if (options.defaults)
                        object.originText = "";
                    if (message.originText != null && message.hasOwnProperty("originText"))
                        object.originText = message.originText;
                    if (message.remindBody && message.remindBody.length) {
                        object.remindBody = [];
                        for (let j = 0; j < message.remindBody.length; ++j)
                            object.remindBody[j] = $root.AcFunDanmu.Im.Message.RemindBody.toObject(message.remindBody[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this Reminder to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Message.Reminder
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Reminder.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Reminder;
            })();

            Message.RemindBody = (function() {

                /**
                 * Properties of a RemindBody.
                 * @memberof AcFunDanmu.Im.Message
                 * @interface IRemindBody
                 * @property {AcFunDanmu.Im.Message.RemindBody.RemindType|null} [remindType] RemindBody remindType
                 * @property {number|Long|null} [seqId] RemindBody seqId
                 * @property {number|Long|null} [targetId] RemindBody targetId
                 * @property {string|null} [userName] RemindBody userName
                 * @property {number|null} [startIndex] RemindBody startIndex
                 * @property {number|null} [length] RemindBody length
                 */

                /**
                 * Constructs a new RemindBody.
                 * @memberof AcFunDanmu.Im.Message
                 * @classdesc Represents a RemindBody.
                 * @implements IRemindBody
                 * @constructor
                 * @param {AcFunDanmu.Im.Message.IRemindBody=} [properties] Properties to set
                 */
                function RemindBody(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * RemindBody remindType.
                 * @member {AcFunDanmu.Im.Message.RemindBody.RemindType} remindType
                 * @memberof AcFunDanmu.Im.Message.RemindBody
                 * @instance
                 */
                RemindBody.prototype.remindType = 0;

                /**
                 * RemindBody seqId.
                 * @member {number|Long} seqId
                 * @memberof AcFunDanmu.Im.Message.RemindBody
                 * @instance
                 */
                RemindBody.prototype.seqId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * RemindBody targetId.
                 * @member {number|Long} targetId
                 * @memberof AcFunDanmu.Im.Message.RemindBody
                 * @instance
                 */
                RemindBody.prototype.targetId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * RemindBody userName.
                 * @member {string} userName
                 * @memberof AcFunDanmu.Im.Message.RemindBody
                 * @instance
                 */
                RemindBody.prototype.userName = "";

                /**
                 * RemindBody startIndex.
                 * @member {number} startIndex
                 * @memberof AcFunDanmu.Im.Message.RemindBody
                 * @instance
                 */
                RemindBody.prototype.startIndex = 0;

                /**
                 * RemindBody length.
                 * @member {number} length
                 * @memberof AcFunDanmu.Im.Message.RemindBody
                 * @instance
                 */
                RemindBody.prototype.length = 0;

                /**
                 * Creates a new RemindBody instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Message.RemindBody
                 * @static
                 * @param {AcFunDanmu.Im.Message.IRemindBody=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Message.RemindBody} RemindBody instance
                 */
                RemindBody.create = function create(properties) {
                    return new RemindBody(properties);
                };

                /**
                 * Encodes the specified RemindBody message. Does not implicitly {@link AcFunDanmu.Im.Message.RemindBody.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Message.RemindBody
                 * @static
                 * @param {AcFunDanmu.Im.Message.IRemindBody} message RemindBody message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RemindBody.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.remindType != null && Object.hasOwnProperty.call(message, "remindType"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.remindType);
                    if (message.seqId != null && Object.hasOwnProperty.call(message, "seqId"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int64(message.seqId);
                    if (message.targetId != null && Object.hasOwnProperty.call(message, "targetId"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int64(message.targetId);
                    if (message.userName != null && Object.hasOwnProperty.call(message, "userName"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.userName);
                    if (message.startIndex != null && Object.hasOwnProperty.call(message, "startIndex"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.startIndex);
                    if (message.length != null && Object.hasOwnProperty.call(message, "length"))
                        writer.uint32(/* id 6, wireType 0 =*/48).int32(message.length);
                    return writer;
                };

                /**
                 * Encodes the specified RemindBody message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Message.RemindBody.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Message.RemindBody
                 * @static
                 * @param {AcFunDanmu.Im.Message.IRemindBody} message RemindBody message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RemindBody.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a RemindBody message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Message.RemindBody
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Message.RemindBody} RemindBody
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RemindBody.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Message.RemindBody();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.remindType = reader.int32();
                            break;
                        case 2:
                            message.seqId = reader.int64();
                            break;
                        case 3:
                            message.targetId = reader.int64();
                            break;
                        case 4:
                            message.userName = reader.string();
                            break;
                        case 5:
                            message.startIndex = reader.int32();
                            break;
                        case 6:
                            message.length = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a RemindBody message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Message.RemindBody
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Message.RemindBody} RemindBody
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RemindBody.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a RemindBody message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Message.RemindBody
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                RemindBody.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.remindType != null && message.hasOwnProperty("remindType"))
                        switch (message.remindType) {
                        default:
                            return "remindType: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.seqId != null && message.hasOwnProperty("seqId"))
                        if (!$util.isInteger(message.seqId) && !(message.seqId && $util.isInteger(message.seqId.low) && $util.isInteger(message.seqId.high)))
                            return "seqId: integer|Long expected";
                    if (message.targetId != null && message.hasOwnProperty("targetId"))
                        if (!$util.isInteger(message.targetId) && !(message.targetId && $util.isInteger(message.targetId.low) && $util.isInteger(message.targetId.high)))
                            return "targetId: integer|Long expected";
                    if (message.userName != null && message.hasOwnProperty("userName"))
                        if (!$util.isString(message.userName))
                            return "userName: string expected";
                    if (message.startIndex != null && message.hasOwnProperty("startIndex"))
                        if (!$util.isInteger(message.startIndex))
                            return "startIndex: integer expected";
                    if (message.length != null && message.hasOwnProperty("length"))
                        if (!$util.isInteger(message.length))
                            return "length: integer expected";
                    return null;
                };

                /**
                 * Creates a RemindBody message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Message.RemindBody
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Message.RemindBody} RemindBody
                 */
                RemindBody.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Message.RemindBody)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Message.RemindBody();
                    switch (object.remindType) {
                    case "UNKNOWN":
                    case 0:
                        message.remindType = 0;
                        break;
                    case "AT_ALL":
                    case 1:
                        message.remindType = 1;
                        break;
                    case "AT_USER":
                    case 2:
                        message.remindType = 2;
                        break;
                    case "GROUP_BULLETIN":
                    case 3:
                        message.remindType = 3;
                        break;
                    case "RECEIPT_MESSAGE":
                    case 4:
                        message.remindType = 4;
                        break;
                    case "GROUP_JOIN_REQUEST":
                    case 5:
                        message.remindType = 5;
                        break;
                    }
                    if (object.seqId != null)
                        if ($util.Long)
                            (message.seqId = $util.Long.fromValue(object.seqId)).unsigned = false;
                        else if (typeof object.seqId === "string")
                            message.seqId = parseInt(object.seqId, 10);
                        else if (typeof object.seqId === "number")
                            message.seqId = object.seqId;
                        else if (typeof object.seqId === "object")
                            message.seqId = new $util.LongBits(object.seqId.low >>> 0, object.seqId.high >>> 0).toNumber();
                    if (object.targetId != null)
                        if ($util.Long)
                            (message.targetId = $util.Long.fromValue(object.targetId)).unsigned = false;
                        else if (typeof object.targetId === "string")
                            message.targetId = parseInt(object.targetId, 10);
                        else if (typeof object.targetId === "number")
                            message.targetId = object.targetId;
                        else if (typeof object.targetId === "object")
                            message.targetId = new $util.LongBits(object.targetId.low >>> 0, object.targetId.high >>> 0).toNumber();
                    if (object.userName != null)
                        message.userName = String(object.userName);
                    if (object.startIndex != null)
                        message.startIndex = object.startIndex | 0;
                    if (object.length != null)
                        message.length = object.length | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a RemindBody message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Message.RemindBody
                 * @static
                 * @param {AcFunDanmu.Im.Message.RemindBody} message RemindBody
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RemindBody.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.remindType = options.enums === String ? "UNKNOWN" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.seqId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.seqId = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.targetId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.targetId = options.longs === String ? "0" : 0;
                        object.userName = "";
                        object.startIndex = 0;
                        object.length = 0;
                    }
                    if (message.remindType != null && message.hasOwnProperty("remindType"))
                        object.remindType = options.enums === String ? $root.AcFunDanmu.Im.Message.RemindBody.RemindType[message.remindType] : message.remindType;
                    if (message.seqId != null && message.hasOwnProperty("seqId"))
                        if (typeof message.seqId === "number")
                            object.seqId = options.longs === String ? String(message.seqId) : message.seqId;
                        else
                            object.seqId = options.longs === String ? $util.Long.prototype.toString.call(message.seqId) : options.longs === Number ? new $util.LongBits(message.seqId.low >>> 0, message.seqId.high >>> 0).toNumber() : message.seqId;
                    if (message.targetId != null && message.hasOwnProperty("targetId"))
                        if (typeof message.targetId === "number")
                            object.targetId = options.longs === String ? String(message.targetId) : message.targetId;
                        else
                            object.targetId = options.longs === String ? $util.Long.prototype.toString.call(message.targetId) : options.longs === Number ? new $util.LongBits(message.targetId.low >>> 0, message.targetId.high >>> 0).toNumber() : message.targetId;
                    if (message.userName != null && message.hasOwnProperty("userName"))
                        object.userName = message.userName;
                    if (message.startIndex != null && message.hasOwnProperty("startIndex"))
                        object.startIndex = message.startIndex;
                    if (message.length != null && message.hasOwnProperty("length"))
                        object.length = message.length;
                    return object;
                };

                /**
                 * Converts this RemindBody to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Message.RemindBody
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                RemindBody.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * RemindType enum.
                 * @name AcFunDanmu.Im.Message.RemindBody.RemindType
                 * @enum {number}
                 * @property {number} UNKNOWN=0 UNKNOWN value
                 * @property {number} AT_ALL=1 AT_ALL value
                 * @property {number} AT_USER=2 AT_USER value
                 * @property {number} GROUP_BULLETIN=3 GROUP_BULLETIN value
                 * @property {number} RECEIPT_MESSAGE=4 RECEIPT_MESSAGE value
                 * @property {number} GROUP_JOIN_REQUEST=5 GROUP_JOIN_REQUEST value
                 */
                RemindBody.RemindType = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "UNKNOWN"] = 0;
                    values[valuesById[1] = "AT_ALL"] = 1;
                    values[valuesById[2] = "AT_USER"] = 2;
                    values[valuesById[3] = "GROUP_BULLETIN"] = 3;
                    values[valuesById[4] = "RECEIPT_MESSAGE"] = 4;
                    values[valuesById[5] = "GROUP_JOIN_REQUEST"] = 5;
                    return values;
                })();

                return RemindBody;
            })();

            /**
             * AccountType enum.
             * @name AcFunDanmu.Im.Message.AccountType
             * @enum {number}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} OFFICIAL=1 OFFICIAL value
             * @property {number} NORMAL=2 NORMAL value
             * @property {number} STRANGER=3 STRANGER value
             */
            Message.AccountType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[1] = "OFFICIAL"] = 1;
                values[valuesById[2] = "NORMAL"] = 2;
                values[valuesById[3] = "STRANGER"] = 3;
                return values;
            })();

            /**
             * ChatTargetType enum.
             * @name AcFunDanmu.Im.Message.ChatTargetType
             * @enum {number}
             * @property {number} CTT_USER=0 CTT_USER value
             * @property {number} CTT_CHAT_ROOM=2 CTT_CHAT_ROOM value
             * @property {number} CTT_MULTI_PLAYER_ROOM=3 CTT_MULTI_PLAYER_ROOM value
             * @property {number} CTT_GROUP=4 CTT_GROUP value
             * @property {number} CTT_CHANNEL=5 CTT_CHANNEL value
             * @property {number} CTT_AGGREGATE=6 CTT_AGGREGATE value
             */
            Message.ChatTargetType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "CTT_USER"] = 0;
                values[valuesById[2] = "CTT_CHAT_ROOM"] = 2;
                values[valuesById[3] = "CTT_MULTI_PLAYER_ROOM"] = 3;
                values[valuesById[4] = "CTT_GROUP"] = 4;
                values[valuesById[5] = "CTT_CHANNEL"] = 5;
                values[valuesById[6] = "CTT_AGGREGATE"] = 6;
                return values;
            })();

            Message.ChatTarget = (function() {

                /**
                 * Properties of a ChatTarget.
                 * @memberof AcFunDanmu.Im.Message
                 * @interface IChatTarget
                 * @property {string|null} [targetId] ChatTarget targetId
                 * @property {AcFunDanmu.Im.Message.ChatTargetType|null} [targetType] ChatTarget targetType
                 */

                /**
                 * Constructs a new ChatTarget.
                 * @memberof AcFunDanmu.Im.Message
                 * @classdesc Represents a ChatTarget.
                 * @implements IChatTarget
                 * @constructor
                 * @param {AcFunDanmu.Im.Message.IChatTarget=} [properties] Properties to set
                 */
                function ChatTarget(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ChatTarget targetId.
                 * @member {string} targetId
                 * @memberof AcFunDanmu.Im.Message.ChatTarget
                 * @instance
                 */
                ChatTarget.prototype.targetId = "";

                /**
                 * ChatTarget targetType.
                 * @member {AcFunDanmu.Im.Message.ChatTargetType} targetType
                 * @memberof AcFunDanmu.Im.Message.ChatTarget
                 * @instance
                 */
                ChatTarget.prototype.targetType = 0;

                /**
                 * Creates a new ChatTarget instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Message.ChatTarget
                 * @static
                 * @param {AcFunDanmu.Im.Message.IChatTarget=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Message.ChatTarget} ChatTarget instance
                 */
                ChatTarget.create = function create(properties) {
                    return new ChatTarget(properties);
                };

                /**
                 * Encodes the specified ChatTarget message. Does not implicitly {@link AcFunDanmu.Im.Message.ChatTarget.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Message.ChatTarget
                 * @static
                 * @param {AcFunDanmu.Im.Message.IChatTarget} message ChatTarget message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ChatTarget.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.targetId != null && Object.hasOwnProperty.call(message, "targetId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.targetId);
                    if (message.targetType != null && Object.hasOwnProperty.call(message, "targetType"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.targetType);
                    return writer;
                };

                /**
                 * Encodes the specified ChatTarget message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Message.ChatTarget.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Message.ChatTarget
                 * @static
                 * @param {AcFunDanmu.Im.Message.IChatTarget} message ChatTarget message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ChatTarget.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ChatTarget message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Message.ChatTarget
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Message.ChatTarget} ChatTarget
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ChatTarget.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Message.ChatTarget();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.targetId = reader.string();
                            break;
                        case 2:
                            message.targetType = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ChatTarget message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Message.ChatTarget
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Message.ChatTarget} ChatTarget
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ChatTarget.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ChatTarget message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Message.ChatTarget
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ChatTarget.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.targetId != null && message.hasOwnProperty("targetId"))
                        if (!$util.isString(message.targetId))
                            return "targetId: string expected";
                    if (message.targetType != null && message.hasOwnProperty("targetType"))
                        switch (message.targetType) {
                        default:
                            return "targetType: enum value expected";
                        case 0:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                            break;
                        }
                    return null;
                };

                /**
                 * Creates a ChatTarget message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Message.ChatTarget
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Message.ChatTarget} ChatTarget
                 */
                ChatTarget.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Message.ChatTarget)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Message.ChatTarget();
                    if (object.targetId != null)
                        message.targetId = String(object.targetId);
                    switch (object.targetType) {
                    case "CTT_USER":
                    case 0:
                        message.targetType = 0;
                        break;
                    case "CTT_CHAT_ROOM":
                    case 2:
                        message.targetType = 2;
                        break;
                    case "CTT_MULTI_PLAYER_ROOM":
                    case 3:
                        message.targetType = 3;
                        break;
                    case "CTT_GROUP":
                    case 4:
                        message.targetType = 4;
                        break;
                    case "CTT_CHANNEL":
                    case 5:
                        message.targetType = 5;
                        break;
                    case "CTT_AGGREGATE":
                    case 6:
                        message.targetType = 6;
                        break;
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ChatTarget message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Message.ChatTarget
                 * @static
                 * @param {AcFunDanmu.Im.Message.ChatTarget} message ChatTarget
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ChatTarget.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.targetId = "";
                        object.targetType = options.enums === String ? "CTT_USER" : 0;
                    }
                    if (message.targetId != null && message.hasOwnProperty("targetId"))
                        object.targetId = message.targetId;
                    if (message.targetType != null && message.hasOwnProperty("targetType"))
                        object.targetType = options.enums === String ? $root.AcFunDanmu.Im.Message.ChatTargetType[message.targetType] : message.targetType;
                    return object;
                };

                /**
                 * Converts this ChatTarget to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Message.ChatTarget
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ChatTarget.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ChatTarget;
            })();

            Message.SessionListResponse = (function() {

                /**
                 * Properties of a SessionListResponse.
                 * @memberof AcFunDanmu.Im.Message
                 * @interface ISessionListResponse
                 * @property {AcFunDanmu.Im.Basic.ISyncCookie|null} [syncCookie] SessionListResponse syncCookie
                 * @property {Array.<AcFunDanmu.Im.Message.IChatSession>|null} [sessions] SessionListResponse sessions
                 * @property {boolean|null} [notFullFetch] SessionListResponse notFullFetch
                 * @property {number|Long|null} [serverTime] SessionListResponse serverTime
                 * @property {boolean|null} [clearLocalData] SessionListResponse clearLocalData
                 * @property {number|null} [categoryId] SessionListResponse categoryId
                 * @property {number|null} [clientDataStatus] SessionListResponse clientDataStatus
                 */

                /**
                 * Constructs a new SessionListResponse.
                 * @memberof AcFunDanmu.Im.Message
                 * @classdesc Represents a SessionListResponse.
                 * @implements ISessionListResponse
                 * @constructor
                 * @param {AcFunDanmu.Im.Message.ISessionListResponse=} [properties] Properties to set
                 */
                function SessionListResponse(properties) {
                    this.sessions = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SessionListResponse syncCookie.
                 * @member {AcFunDanmu.Im.Basic.ISyncCookie|null|undefined} syncCookie
                 * @memberof AcFunDanmu.Im.Message.SessionListResponse
                 * @instance
                 */
                SessionListResponse.prototype.syncCookie = null;

                /**
                 * SessionListResponse sessions.
                 * @member {Array.<AcFunDanmu.Im.Message.IChatSession>} sessions
                 * @memberof AcFunDanmu.Im.Message.SessionListResponse
                 * @instance
                 */
                SessionListResponse.prototype.sessions = $util.emptyArray;

                /**
                 * SessionListResponse notFullFetch.
                 * @member {boolean} notFullFetch
                 * @memberof AcFunDanmu.Im.Message.SessionListResponse
                 * @instance
                 */
                SessionListResponse.prototype.notFullFetch = false;

                /**
                 * SessionListResponse serverTime.
                 * @member {number|Long} serverTime
                 * @memberof AcFunDanmu.Im.Message.SessionListResponse
                 * @instance
                 */
                SessionListResponse.prototype.serverTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * SessionListResponse clearLocalData.
                 * @member {boolean} clearLocalData
                 * @memberof AcFunDanmu.Im.Message.SessionListResponse
                 * @instance
                 */
                SessionListResponse.prototype.clearLocalData = false;

                /**
                 * SessionListResponse categoryId.
                 * @member {number} categoryId
                 * @memberof AcFunDanmu.Im.Message.SessionListResponse
                 * @instance
                 */
                SessionListResponse.prototype.categoryId = 0;

                /**
                 * SessionListResponse clientDataStatus.
                 * @member {number} clientDataStatus
                 * @memberof AcFunDanmu.Im.Message.SessionListResponse
                 * @instance
                 */
                SessionListResponse.prototype.clientDataStatus = 0;

                /**
                 * Creates a new SessionListResponse instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Message.SessionListResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.ISessionListResponse=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Message.SessionListResponse} SessionListResponse instance
                 */
                SessionListResponse.create = function create(properties) {
                    return new SessionListResponse(properties);
                };

                /**
                 * Encodes the specified SessionListResponse message. Does not implicitly {@link AcFunDanmu.Im.Message.SessionListResponse.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Message.SessionListResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.ISessionListResponse} message SessionListResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SessionListResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.syncCookie != null && Object.hasOwnProperty.call(message, "syncCookie"))
                        $root.AcFunDanmu.Im.Basic.SyncCookie.encode(message.syncCookie, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.sessions != null && message.sessions.length)
                        for (let i = 0; i < message.sessions.length; ++i)
                            $root.AcFunDanmu.Im.Message.ChatSession.encode(message.sessions[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.notFullFetch != null && Object.hasOwnProperty.call(message, "notFullFetch"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.notFullFetch);
                    if (message.serverTime != null && Object.hasOwnProperty.call(message, "serverTime"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int64(message.serverTime);
                    if (message.clearLocalData != null && Object.hasOwnProperty.call(message, "clearLocalData"))
                        writer.uint32(/* id 5, wireType 0 =*/40).bool(message.clearLocalData);
                    if (message.categoryId != null && Object.hasOwnProperty.call(message, "categoryId"))
                        writer.uint32(/* id 6, wireType 0 =*/48).int32(message.categoryId);
                    if (message.clientDataStatus != null && Object.hasOwnProperty.call(message, "clientDataStatus"))
                        writer.uint32(/* id 7, wireType 0 =*/56).int32(message.clientDataStatus);
                    return writer;
                };

                /**
                 * Encodes the specified SessionListResponse message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Message.SessionListResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Message.SessionListResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.ISessionListResponse} message SessionListResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SessionListResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SessionListResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Message.SessionListResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Message.SessionListResponse} SessionListResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SessionListResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Message.SessionListResponse();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.syncCookie = $root.AcFunDanmu.Im.Basic.SyncCookie.decode(reader, reader.uint32());
                            break;
                        case 2:
                            if (!(message.sessions && message.sessions.length))
                                message.sessions = [];
                            message.sessions.push($root.AcFunDanmu.Im.Message.ChatSession.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            message.notFullFetch = reader.bool();
                            break;
                        case 4:
                            message.serverTime = reader.int64();
                            break;
                        case 5:
                            message.clearLocalData = reader.bool();
                            break;
                        case 6:
                            message.categoryId = reader.int32();
                            break;
                        case 7:
                            message.clientDataStatus = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SessionListResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Message.SessionListResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Message.SessionListResponse} SessionListResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SessionListResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SessionListResponse message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Message.SessionListResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SessionListResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.syncCookie != null && message.hasOwnProperty("syncCookie")) {
                        let error = $root.AcFunDanmu.Im.Basic.SyncCookie.verify(message.syncCookie);
                        if (error)
                            return "syncCookie." + error;
                    }
                    if (message.sessions != null && message.hasOwnProperty("sessions")) {
                        if (!Array.isArray(message.sessions))
                            return "sessions: array expected";
                        for (let i = 0; i < message.sessions.length; ++i) {
                            let error = $root.AcFunDanmu.Im.Message.ChatSession.verify(message.sessions[i]);
                            if (error)
                                return "sessions." + error;
                        }
                    }
                    if (message.notFullFetch != null && message.hasOwnProperty("notFullFetch"))
                        if (typeof message.notFullFetch !== "boolean")
                            return "notFullFetch: boolean expected";
                    if (message.serverTime != null && message.hasOwnProperty("serverTime"))
                        if (!$util.isInteger(message.serverTime) && !(message.serverTime && $util.isInteger(message.serverTime.low) && $util.isInteger(message.serverTime.high)))
                            return "serverTime: integer|Long expected";
                    if (message.clearLocalData != null && message.hasOwnProperty("clearLocalData"))
                        if (typeof message.clearLocalData !== "boolean")
                            return "clearLocalData: boolean expected";
                    if (message.categoryId != null && message.hasOwnProperty("categoryId"))
                        if (!$util.isInteger(message.categoryId))
                            return "categoryId: integer expected";
                    if (message.clientDataStatus != null && message.hasOwnProperty("clientDataStatus"))
                        if (!$util.isInteger(message.clientDataStatus))
                            return "clientDataStatus: integer expected";
                    return null;
                };

                /**
                 * Creates a SessionListResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Message.SessionListResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Message.SessionListResponse} SessionListResponse
                 */
                SessionListResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Message.SessionListResponse)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Message.SessionListResponse();
                    if (object.syncCookie != null) {
                        if (typeof object.syncCookie !== "object")
                            throw TypeError(".AcFunDanmu.Im.Message.SessionListResponse.syncCookie: object expected");
                        message.syncCookie = $root.AcFunDanmu.Im.Basic.SyncCookie.fromObject(object.syncCookie);
                    }
                    if (object.sessions) {
                        if (!Array.isArray(object.sessions))
                            throw TypeError(".AcFunDanmu.Im.Message.SessionListResponse.sessions: array expected");
                        message.sessions = [];
                        for (let i = 0; i < object.sessions.length; ++i) {
                            if (typeof object.sessions[i] !== "object")
                                throw TypeError(".AcFunDanmu.Im.Message.SessionListResponse.sessions: object expected");
                            message.sessions[i] = $root.AcFunDanmu.Im.Message.ChatSession.fromObject(object.sessions[i]);
                        }
                    }
                    if (object.notFullFetch != null)
                        message.notFullFetch = Boolean(object.notFullFetch);
                    if (object.serverTime != null)
                        if ($util.Long)
                            (message.serverTime = $util.Long.fromValue(object.serverTime)).unsigned = false;
                        else if (typeof object.serverTime === "string")
                            message.serverTime = parseInt(object.serverTime, 10);
                        else if (typeof object.serverTime === "number")
                            message.serverTime = object.serverTime;
                        else if (typeof object.serverTime === "object")
                            message.serverTime = new $util.LongBits(object.serverTime.low >>> 0, object.serverTime.high >>> 0).toNumber();
                    if (object.clearLocalData != null)
                        message.clearLocalData = Boolean(object.clearLocalData);
                    if (object.categoryId != null)
                        message.categoryId = object.categoryId | 0;
                    if (object.clientDataStatus != null)
                        message.clientDataStatus = object.clientDataStatus | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a SessionListResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Message.SessionListResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.SessionListResponse} message SessionListResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SessionListResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.sessions = [];
                    if (options.defaults) {
                        object.syncCookie = null;
                        object.notFullFetch = false;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.serverTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.serverTime = options.longs === String ? "0" : 0;
                        object.clearLocalData = false;
                        object.categoryId = 0;
                        object.clientDataStatus = 0;
                    }
                    if (message.syncCookie != null && message.hasOwnProperty("syncCookie"))
                        object.syncCookie = $root.AcFunDanmu.Im.Basic.SyncCookie.toObject(message.syncCookie, options);
                    if (message.sessions && message.sessions.length) {
                        object.sessions = [];
                        for (let j = 0; j < message.sessions.length; ++j)
                            object.sessions[j] = $root.AcFunDanmu.Im.Message.ChatSession.toObject(message.sessions[j], options);
                    }
                    if (message.notFullFetch != null && message.hasOwnProperty("notFullFetch"))
                        object.notFullFetch = message.notFullFetch;
                    if (message.serverTime != null && message.hasOwnProperty("serverTime"))
                        if (typeof message.serverTime === "number")
                            object.serverTime = options.longs === String ? String(message.serverTime) : message.serverTime;
                        else
                            object.serverTime = options.longs === String ? $util.Long.prototype.toString.call(message.serverTime) : options.longs === Number ? new $util.LongBits(message.serverTime.low >>> 0, message.serverTime.high >>> 0).toNumber() : message.serverTime;
                    if (message.clearLocalData != null && message.hasOwnProperty("clearLocalData"))
                        object.clearLocalData = message.clearLocalData;
                    if (message.categoryId != null && message.hasOwnProperty("categoryId"))
                        object.categoryId = message.categoryId;
                    if (message.clientDataStatus != null && message.hasOwnProperty("clientDataStatus"))
                        object.clientDataStatus = message.clientDataStatus;
                    return object;
                };

                /**
                 * Converts this SessionListResponse to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Message.SessionListResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SessionListResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SessionListResponse;
            })();

            Message.SessionPageListRequest = (function() {

                /**
                 * Properties of a SessionPageListRequest.
                 * @memberof AcFunDanmu.Im.Message
                 * @interface ISessionPageListRequest
                 * @property {string|null} [cursor] SessionPageListRequest cursor
                 * @property {number|null} [count] SessionPageListRequest count
                 * @property {number|null} [categoryId] SessionPageListRequest categoryId
                 */

                /**
                 * Constructs a new SessionPageListRequest.
                 * @memberof AcFunDanmu.Im.Message
                 * @classdesc Represents a SessionPageListRequest.
                 * @implements ISessionPageListRequest
                 * @constructor
                 * @param {AcFunDanmu.Im.Message.ISessionPageListRequest=} [properties] Properties to set
                 */
                function SessionPageListRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SessionPageListRequest cursor.
                 * @member {string} cursor
                 * @memberof AcFunDanmu.Im.Message.SessionPageListRequest
                 * @instance
                 */
                SessionPageListRequest.prototype.cursor = "";

                /**
                 * SessionPageListRequest count.
                 * @member {number} count
                 * @memberof AcFunDanmu.Im.Message.SessionPageListRequest
                 * @instance
                 */
                SessionPageListRequest.prototype.count = 0;

                /**
                 * SessionPageListRequest categoryId.
                 * @member {number} categoryId
                 * @memberof AcFunDanmu.Im.Message.SessionPageListRequest
                 * @instance
                 */
                SessionPageListRequest.prototype.categoryId = 0;

                /**
                 * Creates a new SessionPageListRequest instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Message.SessionPageListRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.ISessionPageListRequest=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Message.SessionPageListRequest} SessionPageListRequest instance
                 */
                SessionPageListRequest.create = function create(properties) {
                    return new SessionPageListRequest(properties);
                };

                /**
                 * Encodes the specified SessionPageListRequest message. Does not implicitly {@link AcFunDanmu.Im.Message.SessionPageListRequest.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Message.SessionPageListRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.ISessionPageListRequest} message SessionPageListRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SessionPageListRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.cursor != null && Object.hasOwnProperty.call(message, "cursor"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.cursor);
                    if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.count);
                    if (message.categoryId != null && Object.hasOwnProperty.call(message, "categoryId"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.categoryId);
                    return writer;
                };

                /**
                 * Encodes the specified SessionPageListRequest message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Message.SessionPageListRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Message.SessionPageListRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.ISessionPageListRequest} message SessionPageListRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SessionPageListRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SessionPageListRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Message.SessionPageListRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Message.SessionPageListRequest} SessionPageListRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SessionPageListRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Message.SessionPageListRequest();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.cursor = reader.string();
                            break;
                        case 2:
                            message.count = reader.int32();
                            break;
                        case 3:
                            message.categoryId = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SessionPageListRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Message.SessionPageListRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Message.SessionPageListRequest} SessionPageListRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SessionPageListRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SessionPageListRequest message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Message.SessionPageListRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SessionPageListRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.cursor != null && message.hasOwnProperty("cursor"))
                        if (!$util.isString(message.cursor))
                            return "cursor: string expected";
                    if (message.count != null && message.hasOwnProperty("count"))
                        if (!$util.isInteger(message.count))
                            return "count: integer expected";
                    if (message.categoryId != null && message.hasOwnProperty("categoryId"))
                        if (!$util.isInteger(message.categoryId))
                            return "categoryId: integer expected";
                    return null;
                };

                /**
                 * Creates a SessionPageListRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Message.SessionPageListRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Message.SessionPageListRequest} SessionPageListRequest
                 */
                SessionPageListRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Message.SessionPageListRequest)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Message.SessionPageListRequest();
                    if (object.cursor != null)
                        message.cursor = String(object.cursor);
                    if (object.count != null)
                        message.count = object.count | 0;
                    if (object.categoryId != null)
                        message.categoryId = object.categoryId | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a SessionPageListRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Message.SessionPageListRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.SessionPageListRequest} message SessionPageListRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SessionPageListRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.cursor = "";
                        object.count = 0;
                        object.categoryId = 0;
                    }
                    if (message.cursor != null && message.hasOwnProperty("cursor"))
                        object.cursor = message.cursor;
                    if (message.count != null && message.hasOwnProperty("count"))
                        object.count = message.count;
                    if (message.categoryId != null && message.hasOwnProperty("categoryId"))
                        object.categoryId = message.categoryId;
                    return object;
                };

                /**
                 * Converts this SessionPageListRequest to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Message.SessionPageListRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SessionPageListRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SessionPageListRequest;
            })();

            Message.SessionPageListResponse = (function() {

                /**
                 * Properties of a SessionPageListResponse.
                 * @memberof AcFunDanmu.Im.Message
                 * @interface ISessionPageListResponse
                 * @property {boolean|null} [hasMore] SessionPageListResponse hasMore
                 * @property {Array.<AcFunDanmu.Im.Message.IChatSession>|null} [sessions] SessionPageListResponse sessions
                 */

                /**
                 * Constructs a new SessionPageListResponse.
                 * @memberof AcFunDanmu.Im.Message
                 * @classdesc Represents a SessionPageListResponse.
                 * @implements ISessionPageListResponse
                 * @constructor
                 * @param {AcFunDanmu.Im.Message.ISessionPageListResponse=} [properties] Properties to set
                 */
                function SessionPageListResponse(properties) {
                    this.sessions = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SessionPageListResponse hasMore.
                 * @member {boolean} hasMore
                 * @memberof AcFunDanmu.Im.Message.SessionPageListResponse
                 * @instance
                 */
                SessionPageListResponse.prototype.hasMore = false;

                /**
                 * SessionPageListResponse sessions.
                 * @member {Array.<AcFunDanmu.Im.Message.IChatSession>} sessions
                 * @memberof AcFunDanmu.Im.Message.SessionPageListResponse
                 * @instance
                 */
                SessionPageListResponse.prototype.sessions = $util.emptyArray;

                /**
                 * Creates a new SessionPageListResponse instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Message.SessionPageListResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.ISessionPageListResponse=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Message.SessionPageListResponse} SessionPageListResponse instance
                 */
                SessionPageListResponse.create = function create(properties) {
                    return new SessionPageListResponse(properties);
                };

                /**
                 * Encodes the specified SessionPageListResponse message. Does not implicitly {@link AcFunDanmu.Im.Message.SessionPageListResponse.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Message.SessionPageListResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.ISessionPageListResponse} message SessionPageListResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SessionPageListResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.hasMore != null && Object.hasOwnProperty.call(message, "hasMore"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.hasMore);
                    if (message.sessions != null && message.sessions.length)
                        for (let i = 0; i < message.sessions.length; ++i)
                            $root.AcFunDanmu.Im.Message.ChatSession.encode(message.sessions[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified SessionPageListResponse message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Message.SessionPageListResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Message.SessionPageListResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.ISessionPageListResponse} message SessionPageListResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SessionPageListResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SessionPageListResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Message.SessionPageListResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Message.SessionPageListResponse} SessionPageListResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SessionPageListResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Message.SessionPageListResponse();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.hasMore = reader.bool();
                            break;
                        case 2:
                            if (!(message.sessions && message.sessions.length))
                                message.sessions = [];
                            message.sessions.push($root.AcFunDanmu.Im.Message.ChatSession.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SessionPageListResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Message.SessionPageListResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Message.SessionPageListResponse} SessionPageListResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SessionPageListResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SessionPageListResponse message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Message.SessionPageListResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SessionPageListResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.hasMore != null && message.hasOwnProperty("hasMore"))
                        if (typeof message.hasMore !== "boolean")
                            return "hasMore: boolean expected";
                    if (message.sessions != null && message.hasOwnProperty("sessions")) {
                        if (!Array.isArray(message.sessions))
                            return "sessions: array expected";
                        for (let i = 0; i < message.sessions.length; ++i) {
                            let error = $root.AcFunDanmu.Im.Message.ChatSession.verify(message.sessions[i]);
                            if (error)
                                return "sessions." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a SessionPageListResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Message.SessionPageListResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Message.SessionPageListResponse} SessionPageListResponse
                 */
                SessionPageListResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Message.SessionPageListResponse)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Message.SessionPageListResponse();
                    if (object.hasMore != null)
                        message.hasMore = Boolean(object.hasMore);
                    if (object.sessions) {
                        if (!Array.isArray(object.sessions))
                            throw TypeError(".AcFunDanmu.Im.Message.SessionPageListResponse.sessions: array expected");
                        message.sessions = [];
                        for (let i = 0; i < object.sessions.length; ++i) {
                            if (typeof object.sessions[i] !== "object")
                                throw TypeError(".AcFunDanmu.Im.Message.SessionPageListResponse.sessions: object expected");
                            message.sessions[i] = $root.AcFunDanmu.Im.Message.ChatSession.fromObject(object.sessions[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a SessionPageListResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Message.SessionPageListResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.SessionPageListResponse} message SessionPageListResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SessionPageListResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.sessions = [];
                    if (options.defaults)
                        object.hasMore = false;
                    if (message.hasMore != null && message.hasOwnProperty("hasMore"))
                        object.hasMore = message.hasMore;
                    if (message.sessions && message.sessions.length) {
                        object.sessions = [];
                        for (let j = 0; j < message.sessions.length; ++j)
                            object.sessions[j] = $root.AcFunDanmu.Im.Message.ChatSession.toObject(message.sessions[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this SessionPageListResponse to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Message.SessionPageListResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SessionPageListResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SessionPageListResponse;
            })();

            Message.SessionRemoveRequest = (function() {

                /**
                 * Properties of a SessionRemoveRequest.
                 * @memberof AcFunDanmu.Im.Message
                 * @interface ISessionRemoveRequest
                 * @property {number|Long|null} [targetId] SessionRemoveRequest targetId
                 * @property {AcFunDanmu.Im.Message.ChatTargetType|null} [chatTargetType] SessionRemoveRequest chatTargetType
                 * @property {number|null} [categoryId] SessionRemoveRequest categoryId
                 * @property {string|null} [strTargetId] SessionRemoveRequest strTargetId
                 * @property {boolean|null} [notCleanAllMessages] SessionRemoveRequest notCleanAllMessages
                 */

                /**
                 * Constructs a new SessionRemoveRequest.
                 * @memberof AcFunDanmu.Im.Message
                 * @classdesc Represents a SessionRemoveRequest.
                 * @implements ISessionRemoveRequest
                 * @constructor
                 * @param {AcFunDanmu.Im.Message.ISessionRemoveRequest=} [properties] Properties to set
                 */
                function SessionRemoveRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SessionRemoveRequest targetId.
                 * @member {number|Long} targetId
                 * @memberof AcFunDanmu.Im.Message.SessionRemoveRequest
                 * @instance
                 */
                SessionRemoveRequest.prototype.targetId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * SessionRemoveRequest chatTargetType.
                 * @member {AcFunDanmu.Im.Message.ChatTargetType} chatTargetType
                 * @memberof AcFunDanmu.Im.Message.SessionRemoveRequest
                 * @instance
                 */
                SessionRemoveRequest.prototype.chatTargetType = 0;

                /**
                 * SessionRemoveRequest categoryId.
                 * @member {number} categoryId
                 * @memberof AcFunDanmu.Im.Message.SessionRemoveRequest
                 * @instance
                 */
                SessionRemoveRequest.prototype.categoryId = 0;

                /**
                 * SessionRemoveRequest strTargetId.
                 * @member {string} strTargetId
                 * @memberof AcFunDanmu.Im.Message.SessionRemoveRequest
                 * @instance
                 */
                SessionRemoveRequest.prototype.strTargetId = "";

                /**
                 * SessionRemoveRequest notCleanAllMessages.
                 * @member {boolean} notCleanAllMessages
                 * @memberof AcFunDanmu.Im.Message.SessionRemoveRequest
                 * @instance
                 */
                SessionRemoveRequest.prototype.notCleanAllMessages = false;

                /**
                 * Creates a new SessionRemoveRequest instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Message.SessionRemoveRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.ISessionRemoveRequest=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Message.SessionRemoveRequest} SessionRemoveRequest instance
                 */
                SessionRemoveRequest.create = function create(properties) {
                    return new SessionRemoveRequest(properties);
                };

                /**
                 * Encodes the specified SessionRemoveRequest message. Does not implicitly {@link AcFunDanmu.Im.Message.SessionRemoveRequest.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Message.SessionRemoveRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.ISessionRemoveRequest} message SessionRemoveRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SessionRemoveRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.targetId != null && Object.hasOwnProperty.call(message, "targetId"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int64(message.targetId);
                    if (message.chatTargetType != null && Object.hasOwnProperty.call(message, "chatTargetType"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.chatTargetType);
                    if (message.categoryId != null && Object.hasOwnProperty.call(message, "categoryId"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.categoryId);
                    if (message.strTargetId != null && Object.hasOwnProperty.call(message, "strTargetId"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.strTargetId);
                    if (message.notCleanAllMessages != null && Object.hasOwnProperty.call(message, "notCleanAllMessages"))
                        writer.uint32(/* id 5, wireType 0 =*/40).bool(message.notCleanAllMessages);
                    return writer;
                };

                /**
                 * Encodes the specified SessionRemoveRequest message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Message.SessionRemoveRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Message.SessionRemoveRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.ISessionRemoveRequest} message SessionRemoveRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SessionRemoveRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SessionRemoveRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Message.SessionRemoveRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Message.SessionRemoveRequest} SessionRemoveRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SessionRemoveRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Message.SessionRemoveRequest();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.targetId = reader.int64();
                            break;
                        case 2:
                            message.chatTargetType = reader.int32();
                            break;
                        case 3:
                            message.categoryId = reader.int32();
                            break;
                        case 4:
                            message.strTargetId = reader.string();
                            break;
                        case 5:
                            message.notCleanAllMessages = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SessionRemoveRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Message.SessionRemoveRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Message.SessionRemoveRequest} SessionRemoveRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SessionRemoveRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SessionRemoveRequest message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Message.SessionRemoveRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SessionRemoveRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.targetId != null && message.hasOwnProperty("targetId"))
                        if (!$util.isInteger(message.targetId) && !(message.targetId && $util.isInteger(message.targetId.low) && $util.isInteger(message.targetId.high)))
                            return "targetId: integer|Long expected";
                    if (message.chatTargetType != null && message.hasOwnProperty("chatTargetType"))
                        switch (message.chatTargetType) {
                        default:
                            return "chatTargetType: enum value expected";
                        case 0:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                            break;
                        }
                    if (message.categoryId != null && message.hasOwnProperty("categoryId"))
                        if (!$util.isInteger(message.categoryId))
                            return "categoryId: integer expected";
                    if (message.strTargetId != null && message.hasOwnProperty("strTargetId"))
                        if (!$util.isString(message.strTargetId))
                            return "strTargetId: string expected";
                    if (message.notCleanAllMessages != null && message.hasOwnProperty("notCleanAllMessages"))
                        if (typeof message.notCleanAllMessages !== "boolean")
                            return "notCleanAllMessages: boolean expected";
                    return null;
                };

                /**
                 * Creates a SessionRemoveRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Message.SessionRemoveRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Message.SessionRemoveRequest} SessionRemoveRequest
                 */
                SessionRemoveRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Message.SessionRemoveRequest)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Message.SessionRemoveRequest();
                    if (object.targetId != null)
                        if ($util.Long)
                            (message.targetId = $util.Long.fromValue(object.targetId)).unsigned = false;
                        else if (typeof object.targetId === "string")
                            message.targetId = parseInt(object.targetId, 10);
                        else if (typeof object.targetId === "number")
                            message.targetId = object.targetId;
                        else if (typeof object.targetId === "object")
                            message.targetId = new $util.LongBits(object.targetId.low >>> 0, object.targetId.high >>> 0).toNumber();
                    switch (object.chatTargetType) {
                    case "CTT_USER":
                    case 0:
                        message.chatTargetType = 0;
                        break;
                    case "CTT_CHAT_ROOM":
                    case 2:
                        message.chatTargetType = 2;
                        break;
                    case "CTT_MULTI_PLAYER_ROOM":
                    case 3:
                        message.chatTargetType = 3;
                        break;
                    case "CTT_GROUP":
                    case 4:
                        message.chatTargetType = 4;
                        break;
                    case "CTT_CHANNEL":
                    case 5:
                        message.chatTargetType = 5;
                        break;
                    case "CTT_AGGREGATE":
                    case 6:
                        message.chatTargetType = 6;
                        break;
                    }
                    if (object.categoryId != null)
                        message.categoryId = object.categoryId | 0;
                    if (object.strTargetId != null)
                        message.strTargetId = String(object.strTargetId);
                    if (object.notCleanAllMessages != null)
                        message.notCleanAllMessages = Boolean(object.notCleanAllMessages);
                    return message;
                };

                /**
                 * Creates a plain object from a SessionRemoveRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Message.SessionRemoveRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.SessionRemoveRequest} message SessionRemoveRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SessionRemoveRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.targetId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.targetId = options.longs === String ? "0" : 0;
                        object.chatTargetType = options.enums === String ? "CTT_USER" : 0;
                        object.categoryId = 0;
                        object.strTargetId = "";
                        object.notCleanAllMessages = false;
                    }
                    if (message.targetId != null && message.hasOwnProperty("targetId"))
                        if (typeof message.targetId === "number")
                            object.targetId = options.longs === String ? String(message.targetId) : message.targetId;
                        else
                            object.targetId = options.longs === String ? $util.Long.prototype.toString.call(message.targetId) : options.longs === Number ? new $util.LongBits(message.targetId.low >>> 0, message.targetId.high >>> 0).toNumber() : message.targetId;
                    if (message.chatTargetType != null && message.hasOwnProperty("chatTargetType"))
                        object.chatTargetType = options.enums === String ? $root.AcFunDanmu.Im.Message.ChatTargetType[message.chatTargetType] : message.chatTargetType;
                    if (message.categoryId != null && message.hasOwnProperty("categoryId"))
                        object.categoryId = message.categoryId;
                    if (message.strTargetId != null && message.hasOwnProperty("strTargetId"))
                        object.strTargetId = message.strTargetId;
                    if (message.notCleanAllMessages != null && message.hasOwnProperty("notCleanAllMessages"))
                        object.notCleanAllMessages = message.notCleanAllMessages;
                    return object;
                };

                /**
                 * Converts this SessionRemoveRequest to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Message.SessionRemoveRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SessionRemoveRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SessionRemoveRequest;
            })();

            Message.SessionRemoveResponse = (function() {

                /**
                 * Properties of a SessionRemoveResponse.
                 * @memberof AcFunDanmu.Im.Message
                 * @interface ISessionRemoveResponse
                 */

                /**
                 * Constructs a new SessionRemoveResponse.
                 * @memberof AcFunDanmu.Im.Message
                 * @classdesc Represents a SessionRemoveResponse.
                 * @implements ISessionRemoveResponse
                 * @constructor
                 * @param {AcFunDanmu.Im.Message.ISessionRemoveResponse=} [properties] Properties to set
                 */
                function SessionRemoveResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new SessionRemoveResponse instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Message.SessionRemoveResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.ISessionRemoveResponse=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Message.SessionRemoveResponse} SessionRemoveResponse instance
                 */
                SessionRemoveResponse.create = function create(properties) {
                    return new SessionRemoveResponse(properties);
                };

                /**
                 * Encodes the specified SessionRemoveResponse message. Does not implicitly {@link AcFunDanmu.Im.Message.SessionRemoveResponse.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Message.SessionRemoveResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.ISessionRemoveResponse} message SessionRemoveResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SessionRemoveResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified SessionRemoveResponse message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Message.SessionRemoveResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Message.SessionRemoveResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.ISessionRemoveResponse} message SessionRemoveResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SessionRemoveResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SessionRemoveResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Message.SessionRemoveResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Message.SessionRemoveResponse} SessionRemoveResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SessionRemoveResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Message.SessionRemoveResponse();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SessionRemoveResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Message.SessionRemoveResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Message.SessionRemoveResponse} SessionRemoveResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SessionRemoveResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SessionRemoveResponse message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Message.SessionRemoveResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SessionRemoveResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a SessionRemoveResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Message.SessionRemoveResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Message.SessionRemoveResponse} SessionRemoveResponse
                 */
                SessionRemoveResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Message.SessionRemoveResponse)
                        return object;
                    return new $root.AcFunDanmu.Im.Message.SessionRemoveResponse();
                };

                /**
                 * Creates a plain object from a SessionRemoveResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Message.SessionRemoveResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.SessionRemoveResponse} message SessionRemoveResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SessionRemoveResponse.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this SessionRemoveResponse to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Message.SessionRemoveResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SessionRemoveResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SessionRemoveResponse;
            })();

            Message.SessionCleanRequest = (function() {

                /**
                 * Properties of a SessionCleanRequest.
                 * @memberof AcFunDanmu.Im.Message
                 * @interface ISessionCleanRequest
                 * @property {AcFunDanmu.Im.Message.IChatTarget|null} [chatTarget] SessionCleanRequest chatTarget
                 */

                /**
                 * Constructs a new SessionCleanRequest.
                 * @memberof AcFunDanmu.Im.Message
                 * @classdesc Represents a SessionCleanRequest.
                 * @implements ISessionCleanRequest
                 * @constructor
                 * @param {AcFunDanmu.Im.Message.ISessionCleanRequest=} [properties] Properties to set
                 */
                function SessionCleanRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SessionCleanRequest chatTarget.
                 * @member {AcFunDanmu.Im.Message.IChatTarget|null|undefined} chatTarget
                 * @memberof AcFunDanmu.Im.Message.SessionCleanRequest
                 * @instance
                 */
                SessionCleanRequest.prototype.chatTarget = null;

                /**
                 * Creates a new SessionCleanRequest instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Message.SessionCleanRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.ISessionCleanRequest=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Message.SessionCleanRequest} SessionCleanRequest instance
                 */
                SessionCleanRequest.create = function create(properties) {
                    return new SessionCleanRequest(properties);
                };

                /**
                 * Encodes the specified SessionCleanRequest message. Does not implicitly {@link AcFunDanmu.Im.Message.SessionCleanRequest.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Message.SessionCleanRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.ISessionCleanRequest} message SessionCleanRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SessionCleanRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.chatTarget != null && Object.hasOwnProperty.call(message, "chatTarget"))
                        $root.AcFunDanmu.Im.Message.ChatTarget.encode(message.chatTarget, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified SessionCleanRequest message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Message.SessionCleanRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Message.SessionCleanRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.ISessionCleanRequest} message SessionCleanRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SessionCleanRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SessionCleanRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Message.SessionCleanRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Message.SessionCleanRequest} SessionCleanRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SessionCleanRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Message.SessionCleanRequest();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.chatTarget = $root.AcFunDanmu.Im.Message.ChatTarget.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SessionCleanRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Message.SessionCleanRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Message.SessionCleanRequest} SessionCleanRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SessionCleanRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SessionCleanRequest message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Message.SessionCleanRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SessionCleanRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.chatTarget != null && message.hasOwnProperty("chatTarget")) {
                        let error = $root.AcFunDanmu.Im.Message.ChatTarget.verify(message.chatTarget);
                        if (error)
                            return "chatTarget." + error;
                    }
                    return null;
                };

                /**
                 * Creates a SessionCleanRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Message.SessionCleanRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Message.SessionCleanRequest} SessionCleanRequest
                 */
                SessionCleanRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Message.SessionCleanRequest)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Message.SessionCleanRequest();
                    if (object.chatTarget != null) {
                        if (typeof object.chatTarget !== "object")
                            throw TypeError(".AcFunDanmu.Im.Message.SessionCleanRequest.chatTarget: object expected");
                        message.chatTarget = $root.AcFunDanmu.Im.Message.ChatTarget.fromObject(object.chatTarget);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a SessionCleanRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Message.SessionCleanRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.SessionCleanRequest} message SessionCleanRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SessionCleanRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.chatTarget = null;
                    if (message.chatTarget != null && message.hasOwnProperty("chatTarget"))
                        object.chatTarget = $root.AcFunDanmu.Im.Message.ChatTarget.toObject(message.chatTarget, options);
                    return object;
                };

                /**
                 * Converts this SessionCleanRequest to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Message.SessionCleanRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SessionCleanRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SessionCleanRequest;
            })();

            Message.SessionCleanResponse = (function() {

                /**
                 * Properties of a SessionCleanResponse.
                 * @memberof AcFunDanmu.Im.Message
                 * @interface ISessionCleanResponse
                 */

                /**
                 * Constructs a new SessionCleanResponse.
                 * @memberof AcFunDanmu.Im.Message
                 * @classdesc Represents a SessionCleanResponse.
                 * @implements ISessionCleanResponse
                 * @constructor
                 * @param {AcFunDanmu.Im.Message.ISessionCleanResponse=} [properties] Properties to set
                 */
                function SessionCleanResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new SessionCleanResponse instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Message.SessionCleanResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.ISessionCleanResponse=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Message.SessionCleanResponse} SessionCleanResponse instance
                 */
                SessionCleanResponse.create = function create(properties) {
                    return new SessionCleanResponse(properties);
                };

                /**
                 * Encodes the specified SessionCleanResponse message. Does not implicitly {@link AcFunDanmu.Im.Message.SessionCleanResponse.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Message.SessionCleanResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.ISessionCleanResponse} message SessionCleanResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SessionCleanResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified SessionCleanResponse message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Message.SessionCleanResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Message.SessionCleanResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.ISessionCleanResponse} message SessionCleanResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SessionCleanResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SessionCleanResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Message.SessionCleanResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Message.SessionCleanResponse} SessionCleanResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SessionCleanResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Message.SessionCleanResponse();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SessionCleanResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Message.SessionCleanResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Message.SessionCleanResponse} SessionCleanResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SessionCleanResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SessionCleanResponse message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Message.SessionCleanResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SessionCleanResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a SessionCleanResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Message.SessionCleanResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Message.SessionCleanResponse} SessionCleanResponse
                 */
                SessionCleanResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Message.SessionCleanResponse)
                        return object;
                    return new $root.AcFunDanmu.Im.Message.SessionCleanResponse();
                };

                /**
                 * Creates a plain object from a SessionCleanResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Message.SessionCleanResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.SessionCleanResponse} message SessionCleanResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SessionCleanResponse.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this SessionCleanResponse to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Message.SessionCleanResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SessionCleanResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SessionCleanResponse;
            })();

            Message.MessageDeleteRequest = (function() {

                /**
                 * Properties of a MessageDeleteRequest.
                 * @memberof AcFunDanmu.Im.Message
                 * @interface IMessageDeleteRequest
                 * @property {number|Long|null} [targetId] MessageDeleteRequest targetId
                 * @property {AcFunDanmu.Im.Message.ChatTargetType|null} [chatTargetType] MessageDeleteRequest chatTargetType
                 * @property {Array.<number|Long>|null} [seqId] MessageDeleteRequest seqId
                 * @property {string|null} [strTargetId] MessageDeleteRequest strTargetId
                 */

                /**
                 * Constructs a new MessageDeleteRequest.
                 * @memberof AcFunDanmu.Im.Message
                 * @classdesc Represents a MessageDeleteRequest.
                 * @implements IMessageDeleteRequest
                 * @constructor
                 * @param {AcFunDanmu.Im.Message.IMessageDeleteRequest=} [properties] Properties to set
                 */
                function MessageDeleteRequest(properties) {
                    this.seqId = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MessageDeleteRequest targetId.
                 * @member {number|Long} targetId
                 * @memberof AcFunDanmu.Im.Message.MessageDeleteRequest
                 * @instance
                 */
                MessageDeleteRequest.prototype.targetId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * MessageDeleteRequest chatTargetType.
                 * @member {AcFunDanmu.Im.Message.ChatTargetType} chatTargetType
                 * @memberof AcFunDanmu.Im.Message.MessageDeleteRequest
                 * @instance
                 */
                MessageDeleteRequest.prototype.chatTargetType = 0;

                /**
                 * MessageDeleteRequest seqId.
                 * @member {Array.<number|Long>} seqId
                 * @memberof AcFunDanmu.Im.Message.MessageDeleteRequest
                 * @instance
                 */
                MessageDeleteRequest.prototype.seqId = $util.emptyArray;

                /**
                 * MessageDeleteRequest strTargetId.
                 * @member {string} strTargetId
                 * @memberof AcFunDanmu.Im.Message.MessageDeleteRequest
                 * @instance
                 */
                MessageDeleteRequest.prototype.strTargetId = "";

                /**
                 * Creates a new MessageDeleteRequest instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Message.MessageDeleteRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageDeleteRequest=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Message.MessageDeleteRequest} MessageDeleteRequest instance
                 */
                MessageDeleteRequest.create = function create(properties) {
                    return new MessageDeleteRequest(properties);
                };

                /**
                 * Encodes the specified MessageDeleteRequest message. Does not implicitly {@link AcFunDanmu.Im.Message.MessageDeleteRequest.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Message.MessageDeleteRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageDeleteRequest} message MessageDeleteRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageDeleteRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.targetId != null && Object.hasOwnProperty.call(message, "targetId"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int64(message.targetId);
                    if (message.chatTargetType != null && Object.hasOwnProperty.call(message, "chatTargetType"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.chatTargetType);
                    if (message.seqId != null && message.seqId.length) {
                        writer.uint32(/* id 3, wireType 2 =*/26).fork();
                        for (let i = 0; i < message.seqId.length; ++i)
                            writer.int64(message.seqId[i]);
                        writer.ldelim();
                    }
                    if (message.strTargetId != null && Object.hasOwnProperty.call(message, "strTargetId"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.strTargetId);
                    return writer;
                };

                /**
                 * Encodes the specified MessageDeleteRequest message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Message.MessageDeleteRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Message.MessageDeleteRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageDeleteRequest} message MessageDeleteRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageDeleteRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MessageDeleteRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Message.MessageDeleteRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Message.MessageDeleteRequest} MessageDeleteRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageDeleteRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Message.MessageDeleteRequest();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.targetId = reader.int64();
                            break;
                        case 2:
                            message.chatTargetType = reader.int32();
                            break;
                        case 3:
                            if (!(message.seqId && message.seqId.length))
                                message.seqId = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.seqId.push(reader.int64());
                            } else
                                message.seqId.push(reader.int64());
                            break;
                        case 4:
                            message.strTargetId = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MessageDeleteRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Message.MessageDeleteRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Message.MessageDeleteRequest} MessageDeleteRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageDeleteRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MessageDeleteRequest message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Message.MessageDeleteRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageDeleteRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.targetId != null && message.hasOwnProperty("targetId"))
                        if (!$util.isInteger(message.targetId) && !(message.targetId && $util.isInteger(message.targetId.low) && $util.isInteger(message.targetId.high)))
                            return "targetId: integer|Long expected";
                    if (message.chatTargetType != null && message.hasOwnProperty("chatTargetType"))
                        switch (message.chatTargetType) {
                        default:
                            return "chatTargetType: enum value expected";
                        case 0:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                            break;
                        }
                    if (message.seqId != null && message.hasOwnProperty("seqId")) {
                        if (!Array.isArray(message.seqId))
                            return "seqId: array expected";
                        for (let i = 0; i < message.seqId.length; ++i)
                            if (!$util.isInteger(message.seqId[i]) && !(message.seqId[i] && $util.isInteger(message.seqId[i].low) && $util.isInteger(message.seqId[i].high)))
                                return "seqId: integer|Long[] expected";
                    }
                    if (message.strTargetId != null && message.hasOwnProperty("strTargetId"))
                        if (!$util.isString(message.strTargetId))
                            return "strTargetId: string expected";
                    return null;
                };

                /**
                 * Creates a MessageDeleteRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Message.MessageDeleteRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Message.MessageDeleteRequest} MessageDeleteRequest
                 */
                MessageDeleteRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Message.MessageDeleteRequest)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Message.MessageDeleteRequest();
                    if (object.targetId != null)
                        if ($util.Long)
                            (message.targetId = $util.Long.fromValue(object.targetId)).unsigned = false;
                        else if (typeof object.targetId === "string")
                            message.targetId = parseInt(object.targetId, 10);
                        else if (typeof object.targetId === "number")
                            message.targetId = object.targetId;
                        else if (typeof object.targetId === "object")
                            message.targetId = new $util.LongBits(object.targetId.low >>> 0, object.targetId.high >>> 0).toNumber();
                    switch (object.chatTargetType) {
                    case "CTT_USER":
                    case 0:
                        message.chatTargetType = 0;
                        break;
                    case "CTT_CHAT_ROOM":
                    case 2:
                        message.chatTargetType = 2;
                        break;
                    case "CTT_MULTI_PLAYER_ROOM":
                    case 3:
                        message.chatTargetType = 3;
                        break;
                    case "CTT_GROUP":
                    case 4:
                        message.chatTargetType = 4;
                        break;
                    case "CTT_CHANNEL":
                    case 5:
                        message.chatTargetType = 5;
                        break;
                    case "CTT_AGGREGATE":
                    case 6:
                        message.chatTargetType = 6;
                        break;
                    }
                    if (object.seqId) {
                        if (!Array.isArray(object.seqId))
                            throw TypeError(".AcFunDanmu.Im.Message.MessageDeleteRequest.seqId: array expected");
                        message.seqId = [];
                        for (let i = 0; i < object.seqId.length; ++i)
                            if ($util.Long)
                                (message.seqId[i] = $util.Long.fromValue(object.seqId[i])).unsigned = false;
                            else if (typeof object.seqId[i] === "string")
                                message.seqId[i] = parseInt(object.seqId[i], 10);
                            else if (typeof object.seqId[i] === "number")
                                message.seqId[i] = object.seqId[i];
                            else if (typeof object.seqId[i] === "object")
                                message.seqId[i] = new $util.LongBits(object.seqId[i].low >>> 0, object.seqId[i].high >>> 0).toNumber();
                    }
                    if (object.strTargetId != null)
                        message.strTargetId = String(object.strTargetId);
                    return message;
                };

                /**
                 * Creates a plain object from a MessageDeleteRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Message.MessageDeleteRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.MessageDeleteRequest} message MessageDeleteRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageDeleteRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.seqId = [];
                    if (options.defaults) {
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.targetId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.targetId = options.longs === String ? "0" : 0;
                        object.chatTargetType = options.enums === String ? "CTT_USER" : 0;
                        object.strTargetId = "";
                    }
                    if (message.targetId != null && message.hasOwnProperty("targetId"))
                        if (typeof message.targetId === "number")
                            object.targetId = options.longs === String ? String(message.targetId) : message.targetId;
                        else
                            object.targetId = options.longs === String ? $util.Long.prototype.toString.call(message.targetId) : options.longs === Number ? new $util.LongBits(message.targetId.low >>> 0, message.targetId.high >>> 0).toNumber() : message.targetId;
                    if (message.chatTargetType != null && message.hasOwnProperty("chatTargetType"))
                        object.chatTargetType = options.enums === String ? $root.AcFunDanmu.Im.Message.ChatTargetType[message.chatTargetType] : message.chatTargetType;
                    if (message.seqId && message.seqId.length) {
                        object.seqId = [];
                        for (let j = 0; j < message.seqId.length; ++j)
                            if (typeof message.seqId[j] === "number")
                                object.seqId[j] = options.longs === String ? String(message.seqId[j]) : message.seqId[j];
                            else
                                object.seqId[j] = options.longs === String ? $util.Long.prototype.toString.call(message.seqId[j]) : options.longs === Number ? new $util.LongBits(message.seqId[j].low >>> 0, message.seqId[j].high >>> 0).toNumber() : message.seqId[j];
                    }
                    if (message.strTargetId != null && message.hasOwnProperty("strTargetId"))
                        object.strTargetId = message.strTargetId;
                    return object;
                };

                /**
                 * Converts this MessageDeleteRequest to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Message.MessageDeleteRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageDeleteRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return MessageDeleteRequest;
            })();

            Message.MessageDeleteResponse = (function() {

                /**
                 * Properties of a MessageDeleteResponse.
                 * @memberof AcFunDanmu.Im.Message
                 * @interface IMessageDeleteResponse
                 */

                /**
                 * Constructs a new MessageDeleteResponse.
                 * @memberof AcFunDanmu.Im.Message
                 * @classdesc Represents a MessageDeleteResponse.
                 * @implements IMessageDeleteResponse
                 * @constructor
                 * @param {AcFunDanmu.Im.Message.IMessageDeleteResponse=} [properties] Properties to set
                 */
                function MessageDeleteResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new MessageDeleteResponse instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Message.MessageDeleteResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageDeleteResponse=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Message.MessageDeleteResponse} MessageDeleteResponse instance
                 */
                MessageDeleteResponse.create = function create(properties) {
                    return new MessageDeleteResponse(properties);
                };

                /**
                 * Encodes the specified MessageDeleteResponse message. Does not implicitly {@link AcFunDanmu.Im.Message.MessageDeleteResponse.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Message.MessageDeleteResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageDeleteResponse} message MessageDeleteResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageDeleteResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified MessageDeleteResponse message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Message.MessageDeleteResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Message.MessageDeleteResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageDeleteResponse} message MessageDeleteResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageDeleteResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MessageDeleteResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Message.MessageDeleteResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Message.MessageDeleteResponse} MessageDeleteResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageDeleteResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Message.MessageDeleteResponse();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MessageDeleteResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Message.MessageDeleteResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Message.MessageDeleteResponse} MessageDeleteResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageDeleteResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MessageDeleteResponse message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Message.MessageDeleteResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageDeleteResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a MessageDeleteResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Message.MessageDeleteResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Message.MessageDeleteResponse} MessageDeleteResponse
                 */
                MessageDeleteResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Message.MessageDeleteResponse)
                        return object;
                    return new $root.AcFunDanmu.Im.Message.MessageDeleteResponse();
                };

                /**
                 * Creates a plain object from a MessageDeleteResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Message.MessageDeleteResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.MessageDeleteResponse} message MessageDeleteResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageDeleteResponse.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this MessageDeleteResponse to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Message.MessageDeleteResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageDeleteResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return MessageDeleteResponse;
            })();

            Message.MessageCancelRequest = (function() {

                /**
                 * Properties of a MessageCancelRequest.
                 * @memberof AcFunDanmu.Im.Message
                 * @interface IMessageCancelRequest
                 * @property {AcFunDanmu.Im.Message.IChatTarget|null} [chatTarget] MessageCancelRequest chatTarget
                 * @property {Array.<number|Long>|null} [seqId] MessageCancelRequest seqId
                 */

                /**
                 * Constructs a new MessageCancelRequest.
                 * @memberof AcFunDanmu.Im.Message
                 * @classdesc Represents a MessageCancelRequest.
                 * @implements IMessageCancelRequest
                 * @constructor
                 * @param {AcFunDanmu.Im.Message.IMessageCancelRequest=} [properties] Properties to set
                 */
                function MessageCancelRequest(properties) {
                    this.seqId = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MessageCancelRequest chatTarget.
                 * @member {AcFunDanmu.Im.Message.IChatTarget|null|undefined} chatTarget
                 * @memberof AcFunDanmu.Im.Message.MessageCancelRequest
                 * @instance
                 */
                MessageCancelRequest.prototype.chatTarget = null;

                /**
                 * MessageCancelRequest seqId.
                 * @member {Array.<number|Long>} seqId
                 * @memberof AcFunDanmu.Im.Message.MessageCancelRequest
                 * @instance
                 */
                MessageCancelRequest.prototype.seqId = $util.emptyArray;

                /**
                 * Creates a new MessageCancelRequest instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Message.MessageCancelRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageCancelRequest=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Message.MessageCancelRequest} MessageCancelRequest instance
                 */
                MessageCancelRequest.create = function create(properties) {
                    return new MessageCancelRequest(properties);
                };

                /**
                 * Encodes the specified MessageCancelRequest message. Does not implicitly {@link AcFunDanmu.Im.Message.MessageCancelRequest.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Message.MessageCancelRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageCancelRequest} message MessageCancelRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageCancelRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.chatTarget != null && Object.hasOwnProperty.call(message, "chatTarget"))
                        $root.AcFunDanmu.Im.Message.ChatTarget.encode(message.chatTarget, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.seqId != null && message.seqId.length) {
                        writer.uint32(/* id 2, wireType 2 =*/18).fork();
                        for (let i = 0; i < message.seqId.length; ++i)
                            writer.int64(message.seqId[i]);
                        writer.ldelim();
                    }
                    return writer;
                };

                /**
                 * Encodes the specified MessageCancelRequest message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Message.MessageCancelRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Message.MessageCancelRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageCancelRequest} message MessageCancelRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageCancelRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MessageCancelRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Message.MessageCancelRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Message.MessageCancelRequest} MessageCancelRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageCancelRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Message.MessageCancelRequest();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.chatTarget = $root.AcFunDanmu.Im.Message.ChatTarget.decode(reader, reader.uint32());
                            break;
                        case 2:
                            if (!(message.seqId && message.seqId.length))
                                message.seqId = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.seqId.push(reader.int64());
                            } else
                                message.seqId.push(reader.int64());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MessageCancelRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Message.MessageCancelRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Message.MessageCancelRequest} MessageCancelRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageCancelRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MessageCancelRequest message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Message.MessageCancelRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageCancelRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.chatTarget != null && message.hasOwnProperty("chatTarget")) {
                        let error = $root.AcFunDanmu.Im.Message.ChatTarget.verify(message.chatTarget);
                        if (error)
                            return "chatTarget." + error;
                    }
                    if (message.seqId != null && message.hasOwnProperty("seqId")) {
                        if (!Array.isArray(message.seqId))
                            return "seqId: array expected";
                        for (let i = 0; i < message.seqId.length; ++i)
                            if (!$util.isInteger(message.seqId[i]) && !(message.seqId[i] && $util.isInteger(message.seqId[i].low) && $util.isInteger(message.seqId[i].high)))
                                return "seqId: integer|Long[] expected";
                    }
                    return null;
                };

                /**
                 * Creates a MessageCancelRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Message.MessageCancelRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Message.MessageCancelRequest} MessageCancelRequest
                 */
                MessageCancelRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Message.MessageCancelRequest)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Message.MessageCancelRequest();
                    if (object.chatTarget != null) {
                        if (typeof object.chatTarget !== "object")
                            throw TypeError(".AcFunDanmu.Im.Message.MessageCancelRequest.chatTarget: object expected");
                        message.chatTarget = $root.AcFunDanmu.Im.Message.ChatTarget.fromObject(object.chatTarget);
                    }
                    if (object.seqId) {
                        if (!Array.isArray(object.seqId))
                            throw TypeError(".AcFunDanmu.Im.Message.MessageCancelRequest.seqId: array expected");
                        message.seqId = [];
                        for (let i = 0; i < object.seqId.length; ++i)
                            if ($util.Long)
                                (message.seqId[i] = $util.Long.fromValue(object.seqId[i])).unsigned = false;
                            else if (typeof object.seqId[i] === "string")
                                message.seqId[i] = parseInt(object.seqId[i], 10);
                            else if (typeof object.seqId[i] === "number")
                                message.seqId[i] = object.seqId[i];
                            else if (typeof object.seqId[i] === "object")
                                message.seqId[i] = new $util.LongBits(object.seqId[i].low >>> 0, object.seqId[i].high >>> 0).toNumber();
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a MessageCancelRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Message.MessageCancelRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.MessageCancelRequest} message MessageCancelRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageCancelRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.seqId = [];
                    if (options.defaults)
                        object.chatTarget = null;
                    if (message.chatTarget != null && message.hasOwnProperty("chatTarget"))
                        object.chatTarget = $root.AcFunDanmu.Im.Message.ChatTarget.toObject(message.chatTarget, options);
                    if (message.seqId && message.seqId.length) {
                        object.seqId = [];
                        for (let j = 0; j < message.seqId.length; ++j)
                            if (typeof message.seqId[j] === "number")
                                object.seqId[j] = options.longs === String ? String(message.seqId[j]) : message.seqId[j];
                            else
                                object.seqId[j] = options.longs === String ? $util.Long.prototype.toString.call(message.seqId[j]) : options.longs === Number ? new $util.LongBits(message.seqId[j].low >>> 0, message.seqId[j].high >>> 0).toNumber() : message.seqId[j];
                    }
                    return object;
                };

                /**
                 * Converts this MessageCancelRequest to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Message.MessageCancelRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageCancelRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return MessageCancelRequest;
            })();

            Message.MessageCancelResponse = (function() {

                /**
                 * Properties of a MessageCancelResponse.
                 * @memberof AcFunDanmu.Im.Message
                 * @interface IMessageCancelResponse
                 */

                /**
                 * Constructs a new MessageCancelResponse.
                 * @memberof AcFunDanmu.Im.Message
                 * @classdesc Represents a MessageCancelResponse.
                 * @implements IMessageCancelResponse
                 * @constructor
                 * @param {AcFunDanmu.Im.Message.IMessageCancelResponse=} [properties] Properties to set
                 */
                function MessageCancelResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new MessageCancelResponse instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Message.MessageCancelResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageCancelResponse=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Message.MessageCancelResponse} MessageCancelResponse instance
                 */
                MessageCancelResponse.create = function create(properties) {
                    return new MessageCancelResponse(properties);
                };

                /**
                 * Encodes the specified MessageCancelResponse message. Does not implicitly {@link AcFunDanmu.Im.Message.MessageCancelResponse.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Message.MessageCancelResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageCancelResponse} message MessageCancelResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageCancelResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified MessageCancelResponse message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Message.MessageCancelResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Message.MessageCancelResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageCancelResponse} message MessageCancelResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageCancelResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MessageCancelResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Message.MessageCancelResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Message.MessageCancelResponse} MessageCancelResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageCancelResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Message.MessageCancelResponse();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MessageCancelResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Message.MessageCancelResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Message.MessageCancelResponse} MessageCancelResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageCancelResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MessageCancelResponse message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Message.MessageCancelResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageCancelResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a MessageCancelResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Message.MessageCancelResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Message.MessageCancelResponse} MessageCancelResponse
                 */
                MessageCancelResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Message.MessageCancelResponse)
                        return object;
                    return new $root.AcFunDanmu.Im.Message.MessageCancelResponse();
                };

                /**
                 * Creates a plain object from a MessageCancelResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Message.MessageCancelResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.MessageCancelResponse} message MessageCancelResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageCancelResponse.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this MessageCancelResponse to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Message.MessageCancelResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageCancelResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return MessageCancelResponse;
            })();

            Message.MessageClearRequest = (function() {

                /**
                 * Properties of a MessageClearRequest.
                 * @memberof AcFunDanmu.Im.Message
                 * @interface IMessageClearRequest
                 * @property {AcFunDanmu.Im.Message.IChatTarget|null} [chatTarget] MessageClearRequest chatTarget
                 */

                /**
                 * Constructs a new MessageClearRequest.
                 * @memberof AcFunDanmu.Im.Message
                 * @classdesc Represents a MessageClearRequest.
                 * @implements IMessageClearRequest
                 * @constructor
                 * @param {AcFunDanmu.Im.Message.IMessageClearRequest=} [properties] Properties to set
                 */
                function MessageClearRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MessageClearRequest chatTarget.
                 * @member {AcFunDanmu.Im.Message.IChatTarget|null|undefined} chatTarget
                 * @memberof AcFunDanmu.Im.Message.MessageClearRequest
                 * @instance
                 */
                MessageClearRequest.prototype.chatTarget = null;

                /**
                 * Creates a new MessageClearRequest instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Message.MessageClearRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageClearRequest=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Message.MessageClearRequest} MessageClearRequest instance
                 */
                MessageClearRequest.create = function create(properties) {
                    return new MessageClearRequest(properties);
                };

                /**
                 * Encodes the specified MessageClearRequest message. Does not implicitly {@link AcFunDanmu.Im.Message.MessageClearRequest.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Message.MessageClearRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageClearRequest} message MessageClearRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageClearRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.chatTarget != null && Object.hasOwnProperty.call(message, "chatTarget"))
                        $root.AcFunDanmu.Im.Message.ChatTarget.encode(message.chatTarget, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified MessageClearRequest message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Message.MessageClearRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Message.MessageClearRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageClearRequest} message MessageClearRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageClearRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MessageClearRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Message.MessageClearRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Message.MessageClearRequest} MessageClearRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageClearRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Message.MessageClearRequest();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.chatTarget = $root.AcFunDanmu.Im.Message.ChatTarget.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MessageClearRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Message.MessageClearRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Message.MessageClearRequest} MessageClearRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageClearRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MessageClearRequest message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Message.MessageClearRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageClearRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.chatTarget != null && message.hasOwnProperty("chatTarget")) {
                        let error = $root.AcFunDanmu.Im.Message.ChatTarget.verify(message.chatTarget);
                        if (error)
                            return "chatTarget." + error;
                    }
                    return null;
                };

                /**
                 * Creates a MessageClearRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Message.MessageClearRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Message.MessageClearRequest} MessageClearRequest
                 */
                MessageClearRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Message.MessageClearRequest)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Message.MessageClearRequest();
                    if (object.chatTarget != null) {
                        if (typeof object.chatTarget !== "object")
                            throw TypeError(".AcFunDanmu.Im.Message.MessageClearRequest.chatTarget: object expected");
                        message.chatTarget = $root.AcFunDanmu.Im.Message.ChatTarget.fromObject(object.chatTarget);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a MessageClearRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Message.MessageClearRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.MessageClearRequest} message MessageClearRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageClearRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.chatTarget = null;
                    if (message.chatTarget != null && message.hasOwnProperty("chatTarget"))
                        object.chatTarget = $root.AcFunDanmu.Im.Message.ChatTarget.toObject(message.chatTarget, options);
                    return object;
                };

                /**
                 * Converts this MessageClearRequest to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Message.MessageClearRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageClearRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return MessageClearRequest;
            })();

            Message.MessageClearResponse = (function() {

                /**
                 * Properties of a MessageClearResponse.
                 * @memberof AcFunDanmu.Im.Message
                 * @interface IMessageClearResponse
                 */

                /**
                 * Constructs a new MessageClearResponse.
                 * @memberof AcFunDanmu.Im.Message
                 * @classdesc Represents a MessageClearResponse.
                 * @implements IMessageClearResponse
                 * @constructor
                 * @param {AcFunDanmu.Im.Message.IMessageClearResponse=} [properties] Properties to set
                 */
                function MessageClearResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new MessageClearResponse instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Message.MessageClearResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageClearResponse=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Message.MessageClearResponse} MessageClearResponse instance
                 */
                MessageClearResponse.create = function create(properties) {
                    return new MessageClearResponse(properties);
                };

                /**
                 * Encodes the specified MessageClearResponse message. Does not implicitly {@link AcFunDanmu.Im.Message.MessageClearResponse.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Message.MessageClearResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageClearResponse} message MessageClearResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageClearResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified MessageClearResponse message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Message.MessageClearResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Message.MessageClearResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageClearResponse} message MessageClearResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageClearResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MessageClearResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Message.MessageClearResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Message.MessageClearResponse} MessageClearResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageClearResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Message.MessageClearResponse();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MessageClearResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Message.MessageClearResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Message.MessageClearResponse} MessageClearResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageClearResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MessageClearResponse message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Message.MessageClearResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageClearResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a MessageClearResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Message.MessageClearResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Message.MessageClearResponse} MessageClearResponse
                 */
                MessageClearResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Message.MessageClearResponse)
                        return object;
                    return new $root.AcFunDanmu.Im.Message.MessageClearResponse();
                };

                /**
                 * Creates a plain object from a MessageClearResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Message.MessageClearResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.MessageClearResponse} message MessageClearResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageClearResponse.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this MessageClearResponse to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Message.MessageClearResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageClearResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return MessageClearResponse;
            })();

            Message.ReadSeqInfo = (function() {

                /**
                 * Properties of a ReadSeqInfo.
                 * @memberof AcFunDanmu.Im.Message
                 * @interface IReadSeqInfo
                 * @property {AcFunDanmu.Im.Message.IChatTarget|null} [chatTarget] ReadSeqInfo chatTarget
                 * @property {number|Long|null} [readSeq] ReadSeqInfo readSeq
                 */

                /**
                 * Constructs a new ReadSeqInfo.
                 * @memberof AcFunDanmu.Im.Message
                 * @classdesc Represents a ReadSeqInfo.
                 * @implements IReadSeqInfo
                 * @constructor
                 * @param {AcFunDanmu.Im.Message.IReadSeqInfo=} [properties] Properties to set
                 */
                function ReadSeqInfo(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ReadSeqInfo chatTarget.
                 * @member {AcFunDanmu.Im.Message.IChatTarget|null|undefined} chatTarget
                 * @memberof AcFunDanmu.Im.Message.ReadSeqInfo
                 * @instance
                 */
                ReadSeqInfo.prototype.chatTarget = null;

                /**
                 * ReadSeqInfo readSeq.
                 * @member {number|Long} readSeq
                 * @memberof AcFunDanmu.Im.Message.ReadSeqInfo
                 * @instance
                 */
                ReadSeqInfo.prototype.readSeq = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Creates a new ReadSeqInfo instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Message.ReadSeqInfo
                 * @static
                 * @param {AcFunDanmu.Im.Message.IReadSeqInfo=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Message.ReadSeqInfo} ReadSeqInfo instance
                 */
                ReadSeqInfo.create = function create(properties) {
                    return new ReadSeqInfo(properties);
                };

                /**
                 * Encodes the specified ReadSeqInfo message. Does not implicitly {@link AcFunDanmu.Im.Message.ReadSeqInfo.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Message.ReadSeqInfo
                 * @static
                 * @param {AcFunDanmu.Im.Message.IReadSeqInfo} message ReadSeqInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReadSeqInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.chatTarget != null && Object.hasOwnProperty.call(message, "chatTarget"))
                        $root.AcFunDanmu.Im.Message.ChatTarget.encode(message.chatTarget, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.readSeq != null && Object.hasOwnProperty.call(message, "readSeq"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int64(message.readSeq);
                    return writer;
                };

                /**
                 * Encodes the specified ReadSeqInfo message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Message.ReadSeqInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Message.ReadSeqInfo
                 * @static
                 * @param {AcFunDanmu.Im.Message.IReadSeqInfo} message ReadSeqInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReadSeqInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ReadSeqInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Message.ReadSeqInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Message.ReadSeqInfo} ReadSeqInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReadSeqInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Message.ReadSeqInfo();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.chatTarget = $root.AcFunDanmu.Im.Message.ChatTarget.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.readSeq = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ReadSeqInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Message.ReadSeqInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Message.ReadSeqInfo} ReadSeqInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReadSeqInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ReadSeqInfo message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Message.ReadSeqInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ReadSeqInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.chatTarget != null && message.hasOwnProperty("chatTarget")) {
                        let error = $root.AcFunDanmu.Im.Message.ChatTarget.verify(message.chatTarget);
                        if (error)
                            return "chatTarget." + error;
                    }
                    if (message.readSeq != null && message.hasOwnProperty("readSeq"))
                        if (!$util.isInteger(message.readSeq) && !(message.readSeq && $util.isInteger(message.readSeq.low) && $util.isInteger(message.readSeq.high)))
                            return "readSeq: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a ReadSeqInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Message.ReadSeqInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Message.ReadSeqInfo} ReadSeqInfo
                 */
                ReadSeqInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Message.ReadSeqInfo)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Message.ReadSeqInfo();
                    if (object.chatTarget != null) {
                        if (typeof object.chatTarget !== "object")
                            throw TypeError(".AcFunDanmu.Im.Message.ReadSeqInfo.chatTarget: object expected");
                        message.chatTarget = $root.AcFunDanmu.Im.Message.ChatTarget.fromObject(object.chatTarget);
                    }
                    if (object.readSeq != null)
                        if ($util.Long)
                            (message.readSeq = $util.Long.fromValue(object.readSeq)).unsigned = false;
                        else if (typeof object.readSeq === "string")
                            message.readSeq = parseInt(object.readSeq, 10);
                        else if (typeof object.readSeq === "number")
                            message.readSeq = object.readSeq;
                        else if (typeof object.readSeq === "object")
                            message.readSeq = new $util.LongBits(object.readSeq.low >>> 0, object.readSeq.high >>> 0).toNumber();
                    return message;
                };

                /**
                 * Creates a plain object from a ReadSeqInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Message.ReadSeqInfo
                 * @static
                 * @param {AcFunDanmu.Im.Message.ReadSeqInfo} message ReadSeqInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ReadSeqInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.chatTarget = null;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.readSeq = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.readSeq = options.longs === String ? "0" : 0;
                    }
                    if (message.chatTarget != null && message.hasOwnProperty("chatTarget"))
                        object.chatTarget = $root.AcFunDanmu.Im.Message.ChatTarget.toObject(message.chatTarget, options);
                    if (message.readSeq != null && message.hasOwnProperty("readSeq"))
                        if (typeof message.readSeq === "number")
                            object.readSeq = options.longs === String ? String(message.readSeq) : message.readSeq;
                        else
                            object.readSeq = options.longs === String ? $util.Long.prototype.toString.call(message.readSeq) : options.longs === Number ? new $util.LongBits(message.readSeq.low >>> 0, message.readSeq.high >>> 0).toNumber() : message.readSeq;
                    return object;
                };

                /**
                 * Converts this ReadSeqInfo to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Message.ReadSeqInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ReadSeqInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ReadSeqInfo;
            })();

            Message.MessageReadSeqRequest = (function() {

                /**
                 * Properties of a MessageReadSeqRequest.
                 * @memberof AcFunDanmu.Im.Message
                 * @interface IMessageReadSeqRequest
                 * @property {Array.<AcFunDanmu.Im.Message.IChatTarget>|null} [chatTarget] MessageReadSeqRequest chatTarget
                 */

                /**
                 * Constructs a new MessageReadSeqRequest.
                 * @memberof AcFunDanmu.Im.Message
                 * @classdesc Represents a MessageReadSeqRequest.
                 * @implements IMessageReadSeqRequest
                 * @constructor
                 * @param {AcFunDanmu.Im.Message.IMessageReadSeqRequest=} [properties] Properties to set
                 */
                function MessageReadSeqRequest(properties) {
                    this.chatTarget = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MessageReadSeqRequest chatTarget.
                 * @member {Array.<AcFunDanmu.Im.Message.IChatTarget>} chatTarget
                 * @memberof AcFunDanmu.Im.Message.MessageReadSeqRequest
                 * @instance
                 */
                MessageReadSeqRequest.prototype.chatTarget = $util.emptyArray;

                /**
                 * Creates a new MessageReadSeqRequest instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Message.MessageReadSeqRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageReadSeqRequest=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Message.MessageReadSeqRequest} MessageReadSeqRequest instance
                 */
                MessageReadSeqRequest.create = function create(properties) {
                    return new MessageReadSeqRequest(properties);
                };

                /**
                 * Encodes the specified MessageReadSeqRequest message. Does not implicitly {@link AcFunDanmu.Im.Message.MessageReadSeqRequest.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Message.MessageReadSeqRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageReadSeqRequest} message MessageReadSeqRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageReadSeqRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.chatTarget != null && message.chatTarget.length)
                        for (let i = 0; i < message.chatTarget.length; ++i)
                            $root.AcFunDanmu.Im.Message.ChatTarget.encode(message.chatTarget[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified MessageReadSeqRequest message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Message.MessageReadSeqRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Message.MessageReadSeqRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageReadSeqRequest} message MessageReadSeqRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageReadSeqRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MessageReadSeqRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Message.MessageReadSeqRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Message.MessageReadSeqRequest} MessageReadSeqRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageReadSeqRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Message.MessageReadSeqRequest();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.chatTarget && message.chatTarget.length))
                                message.chatTarget = [];
                            message.chatTarget.push($root.AcFunDanmu.Im.Message.ChatTarget.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MessageReadSeqRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Message.MessageReadSeqRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Message.MessageReadSeqRequest} MessageReadSeqRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageReadSeqRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MessageReadSeqRequest message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Message.MessageReadSeqRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageReadSeqRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.chatTarget != null && message.hasOwnProperty("chatTarget")) {
                        if (!Array.isArray(message.chatTarget))
                            return "chatTarget: array expected";
                        for (let i = 0; i < message.chatTarget.length; ++i) {
                            let error = $root.AcFunDanmu.Im.Message.ChatTarget.verify(message.chatTarget[i]);
                            if (error)
                                return "chatTarget." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a MessageReadSeqRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Message.MessageReadSeqRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Message.MessageReadSeqRequest} MessageReadSeqRequest
                 */
                MessageReadSeqRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Message.MessageReadSeqRequest)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Message.MessageReadSeqRequest();
                    if (object.chatTarget) {
                        if (!Array.isArray(object.chatTarget))
                            throw TypeError(".AcFunDanmu.Im.Message.MessageReadSeqRequest.chatTarget: array expected");
                        message.chatTarget = [];
                        for (let i = 0; i < object.chatTarget.length; ++i) {
                            if (typeof object.chatTarget[i] !== "object")
                                throw TypeError(".AcFunDanmu.Im.Message.MessageReadSeqRequest.chatTarget: object expected");
                            message.chatTarget[i] = $root.AcFunDanmu.Im.Message.ChatTarget.fromObject(object.chatTarget[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a MessageReadSeqRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Message.MessageReadSeqRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.MessageReadSeqRequest} message MessageReadSeqRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageReadSeqRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.chatTarget = [];
                    if (message.chatTarget && message.chatTarget.length) {
                        object.chatTarget = [];
                        for (let j = 0; j < message.chatTarget.length; ++j)
                            object.chatTarget[j] = $root.AcFunDanmu.Im.Message.ChatTarget.toObject(message.chatTarget[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this MessageReadSeqRequest to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Message.MessageReadSeqRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageReadSeqRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return MessageReadSeqRequest;
            })();

            Message.MessageReadSeqResponse = (function() {

                /**
                 * Properties of a MessageReadSeqResponse.
                 * @memberof AcFunDanmu.Im.Message
                 * @interface IMessageReadSeqResponse
                 * @property {Array.<AcFunDanmu.Im.Message.IReadSeqInfo>|null} [readSeqInfo] MessageReadSeqResponse readSeqInfo
                 */

                /**
                 * Constructs a new MessageReadSeqResponse.
                 * @memberof AcFunDanmu.Im.Message
                 * @classdesc Represents a MessageReadSeqResponse.
                 * @implements IMessageReadSeqResponse
                 * @constructor
                 * @param {AcFunDanmu.Im.Message.IMessageReadSeqResponse=} [properties] Properties to set
                 */
                function MessageReadSeqResponse(properties) {
                    this.readSeqInfo = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MessageReadSeqResponse readSeqInfo.
                 * @member {Array.<AcFunDanmu.Im.Message.IReadSeqInfo>} readSeqInfo
                 * @memberof AcFunDanmu.Im.Message.MessageReadSeqResponse
                 * @instance
                 */
                MessageReadSeqResponse.prototype.readSeqInfo = $util.emptyArray;

                /**
                 * Creates a new MessageReadSeqResponse instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Message.MessageReadSeqResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageReadSeqResponse=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Message.MessageReadSeqResponse} MessageReadSeqResponse instance
                 */
                MessageReadSeqResponse.create = function create(properties) {
                    return new MessageReadSeqResponse(properties);
                };

                /**
                 * Encodes the specified MessageReadSeqResponse message. Does not implicitly {@link AcFunDanmu.Im.Message.MessageReadSeqResponse.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Message.MessageReadSeqResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageReadSeqResponse} message MessageReadSeqResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageReadSeqResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.readSeqInfo != null && message.readSeqInfo.length)
                        for (let i = 0; i < message.readSeqInfo.length; ++i)
                            $root.AcFunDanmu.Im.Message.ReadSeqInfo.encode(message.readSeqInfo[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified MessageReadSeqResponse message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Message.MessageReadSeqResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Message.MessageReadSeqResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageReadSeqResponse} message MessageReadSeqResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageReadSeqResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MessageReadSeqResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Message.MessageReadSeqResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Message.MessageReadSeqResponse} MessageReadSeqResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageReadSeqResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Message.MessageReadSeqResponse();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.readSeqInfo && message.readSeqInfo.length))
                                message.readSeqInfo = [];
                            message.readSeqInfo.push($root.AcFunDanmu.Im.Message.ReadSeqInfo.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MessageReadSeqResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Message.MessageReadSeqResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Message.MessageReadSeqResponse} MessageReadSeqResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageReadSeqResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MessageReadSeqResponse message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Message.MessageReadSeqResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageReadSeqResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.readSeqInfo != null && message.hasOwnProperty("readSeqInfo")) {
                        if (!Array.isArray(message.readSeqInfo))
                            return "readSeqInfo: array expected";
                        for (let i = 0; i < message.readSeqInfo.length; ++i) {
                            let error = $root.AcFunDanmu.Im.Message.ReadSeqInfo.verify(message.readSeqInfo[i]);
                            if (error)
                                return "readSeqInfo." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a MessageReadSeqResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Message.MessageReadSeqResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Message.MessageReadSeqResponse} MessageReadSeqResponse
                 */
                MessageReadSeqResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Message.MessageReadSeqResponse)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Message.MessageReadSeqResponse();
                    if (object.readSeqInfo) {
                        if (!Array.isArray(object.readSeqInfo))
                            throw TypeError(".AcFunDanmu.Im.Message.MessageReadSeqResponse.readSeqInfo: array expected");
                        message.readSeqInfo = [];
                        for (let i = 0; i < object.readSeqInfo.length; ++i) {
                            if (typeof object.readSeqInfo[i] !== "object")
                                throw TypeError(".AcFunDanmu.Im.Message.MessageReadSeqResponse.readSeqInfo: object expected");
                            message.readSeqInfo[i] = $root.AcFunDanmu.Im.Message.ReadSeqInfo.fromObject(object.readSeqInfo[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a MessageReadSeqResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Message.MessageReadSeqResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.MessageReadSeqResponse} message MessageReadSeqResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageReadSeqResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.readSeqInfo = [];
                    if (message.readSeqInfo && message.readSeqInfo.length) {
                        object.readSeqInfo = [];
                        for (let j = 0; j < message.readSeqInfo.length; ++j)
                            object.readSeqInfo[j] = $root.AcFunDanmu.Im.Message.ReadSeqInfo.toObject(message.readSeqInfo[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this MessageReadSeqResponse to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Message.MessageReadSeqResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageReadSeqResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return MessageReadSeqResponse;
            })();

            Message.MessageReadPush = (function() {

                /**
                 * Properties of a MessageReadPush.
                 * @memberof AcFunDanmu.Im.Message
                 * @interface IMessageReadPush
                 * @property {number|Long|null} [targetId] MessageReadPush targetId
                 * @property {number|Long|null} [readSeq] MessageReadPush readSeq
                 * @property {AcFunDanmu.Im.Message.ChatTargetType|null} [chatTargetType] MessageReadPush chatTargetType
                 * @property {string|null} [strTargetId] MessageReadPush strTargetId
                 */

                /**
                 * Constructs a new MessageReadPush.
                 * @memberof AcFunDanmu.Im.Message
                 * @classdesc Represents a MessageReadPush.
                 * @implements IMessageReadPush
                 * @constructor
                 * @param {AcFunDanmu.Im.Message.IMessageReadPush=} [properties] Properties to set
                 */
                function MessageReadPush(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MessageReadPush targetId.
                 * @member {number|Long} targetId
                 * @memberof AcFunDanmu.Im.Message.MessageReadPush
                 * @instance
                 */
                MessageReadPush.prototype.targetId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * MessageReadPush readSeq.
                 * @member {number|Long} readSeq
                 * @memberof AcFunDanmu.Im.Message.MessageReadPush
                 * @instance
                 */
                MessageReadPush.prototype.readSeq = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * MessageReadPush chatTargetType.
                 * @member {AcFunDanmu.Im.Message.ChatTargetType} chatTargetType
                 * @memberof AcFunDanmu.Im.Message.MessageReadPush
                 * @instance
                 */
                MessageReadPush.prototype.chatTargetType = 0;

                /**
                 * MessageReadPush strTargetId.
                 * @member {string} strTargetId
                 * @memberof AcFunDanmu.Im.Message.MessageReadPush
                 * @instance
                 */
                MessageReadPush.prototype.strTargetId = "";

                /**
                 * Creates a new MessageReadPush instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Message.MessageReadPush
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageReadPush=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Message.MessageReadPush} MessageReadPush instance
                 */
                MessageReadPush.create = function create(properties) {
                    return new MessageReadPush(properties);
                };

                /**
                 * Encodes the specified MessageReadPush message. Does not implicitly {@link AcFunDanmu.Im.Message.MessageReadPush.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Message.MessageReadPush
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageReadPush} message MessageReadPush message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageReadPush.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.targetId != null && Object.hasOwnProperty.call(message, "targetId"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int64(message.targetId);
                    if (message.readSeq != null && Object.hasOwnProperty.call(message, "readSeq"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int64(message.readSeq);
                    if (message.chatTargetType != null && Object.hasOwnProperty.call(message, "chatTargetType"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.chatTargetType);
                    if (message.strTargetId != null && Object.hasOwnProperty.call(message, "strTargetId"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.strTargetId);
                    return writer;
                };

                /**
                 * Encodes the specified MessageReadPush message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Message.MessageReadPush.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Message.MessageReadPush
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageReadPush} message MessageReadPush message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageReadPush.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MessageReadPush message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Message.MessageReadPush
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Message.MessageReadPush} MessageReadPush
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageReadPush.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Message.MessageReadPush();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.targetId = reader.int64();
                            break;
                        case 2:
                            message.readSeq = reader.int64();
                            break;
                        case 3:
                            message.chatTargetType = reader.int32();
                            break;
                        case 4:
                            message.strTargetId = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MessageReadPush message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Message.MessageReadPush
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Message.MessageReadPush} MessageReadPush
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageReadPush.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MessageReadPush message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Message.MessageReadPush
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageReadPush.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.targetId != null && message.hasOwnProperty("targetId"))
                        if (!$util.isInteger(message.targetId) && !(message.targetId && $util.isInteger(message.targetId.low) && $util.isInteger(message.targetId.high)))
                            return "targetId: integer|Long expected";
                    if (message.readSeq != null && message.hasOwnProperty("readSeq"))
                        if (!$util.isInteger(message.readSeq) && !(message.readSeq && $util.isInteger(message.readSeq.low) && $util.isInteger(message.readSeq.high)))
                            return "readSeq: integer|Long expected";
                    if (message.chatTargetType != null && message.hasOwnProperty("chatTargetType"))
                        switch (message.chatTargetType) {
                        default:
                            return "chatTargetType: enum value expected";
                        case 0:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                            break;
                        }
                    if (message.strTargetId != null && message.hasOwnProperty("strTargetId"))
                        if (!$util.isString(message.strTargetId))
                            return "strTargetId: string expected";
                    return null;
                };

                /**
                 * Creates a MessageReadPush message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Message.MessageReadPush
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Message.MessageReadPush} MessageReadPush
                 */
                MessageReadPush.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Message.MessageReadPush)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Message.MessageReadPush();
                    if (object.targetId != null)
                        if ($util.Long)
                            (message.targetId = $util.Long.fromValue(object.targetId)).unsigned = false;
                        else if (typeof object.targetId === "string")
                            message.targetId = parseInt(object.targetId, 10);
                        else if (typeof object.targetId === "number")
                            message.targetId = object.targetId;
                        else if (typeof object.targetId === "object")
                            message.targetId = new $util.LongBits(object.targetId.low >>> 0, object.targetId.high >>> 0).toNumber();
                    if (object.readSeq != null)
                        if ($util.Long)
                            (message.readSeq = $util.Long.fromValue(object.readSeq)).unsigned = false;
                        else if (typeof object.readSeq === "string")
                            message.readSeq = parseInt(object.readSeq, 10);
                        else if (typeof object.readSeq === "number")
                            message.readSeq = object.readSeq;
                        else if (typeof object.readSeq === "object")
                            message.readSeq = new $util.LongBits(object.readSeq.low >>> 0, object.readSeq.high >>> 0).toNumber();
                    switch (object.chatTargetType) {
                    case "CTT_USER":
                    case 0:
                        message.chatTargetType = 0;
                        break;
                    case "CTT_CHAT_ROOM":
                    case 2:
                        message.chatTargetType = 2;
                        break;
                    case "CTT_MULTI_PLAYER_ROOM":
                    case 3:
                        message.chatTargetType = 3;
                        break;
                    case "CTT_GROUP":
                    case 4:
                        message.chatTargetType = 4;
                        break;
                    case "CTT_CHANNEL":
                    case 5:
                        message.chatTargetType = 5;
                        break;
                    case "CTT_AGGREGATE":
                    case 6:
                        message.chatTargetType = 6;
                        break;
                    }
                    if (object.strTargetId != null)
                        message.strTargetId = String(object.strTargetId);
                    return message;
                };

                /**
                 * Creates a plain object from a MessageReadPush message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Message.MessageReadPush
                 * @static
                 * @param {AcFunDanmu.Im.Message.MessageReadPush} message MessageReadPush
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageReadPush.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.targetId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.targetId = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.readSeq = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.readSeq = options.longs === String ? "0" : 0;
                        object.chatTargetType = options.enums === String ? "CTT_USER" : 0;
                        object.strTargetId = "";
                    }
                    if (message.targetId != null && message.hasOwnProperty("targetId"))
                        if (typeof message.targetId === "number")
                            object.targetId = options.longs === String ? String(message.targetId) : message.targetId;
                        else
                            object.targetId = options.longs === String ? $util.Long.prototype.toString.call(message.targetId) : options.longs === Number ? new $util.LongBits(message.targetId.low >>> 0, message.targetId.high >>> 0).toNumber() : message.targetId;
                    if (message.readSeq != null && message.hasOwnProperty("readSeq"))
                        if (typeof message.readSeq === "number")
                            object.readSeq = options.longs === String ? String(message.readSeq) : message.readSeq;
                        else
                            object.readSeq = options.longs === String ? $util.Long.prototype.toString.call(message.readSeq) : options.longs === Number ? new $util.LongBits(message.readSeq.low >>> 0, message.readSeq.high >>> 0).toNumber() : message.readSeq;
                    if (message.chatTargetType != null && message.hasOwnProperty("chatTargetType"))
                        object.chatTargetType = options.enums === String ? $root.AcFunDanmu.Im.Message.ChatTargetType[message.chatTargetType] : message.chatTargetType;
                    if (message.strTargetId != null && message.hasOwnProperty("strTargetId"))
                        object.strTargetId = message.strTargetId;
                    return object;
                };

                /**
                 * Converts this MessageReadPush to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Message.MessageReadPush
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageReadPush.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return MessageReadPush;
            })();

            Message.AllUnreadCountRequest = (function() {

                /**
                 * Properties of an AllUnreadCountRequest.
                 * @memberof AcFunDanmu.Im.Message
                 * @interface IAllUnreadCountRequest
                 */

                /**
                 * Constructs a new AllUnreadCountRequest.
                 * @memberof AcFunDanmu.Im.Message
                 * @classdesc Represents an AllUnreadCountRequest.
                 * @implements IAllUnreadCountRequest
                 * @constructor
                 * @param {AcFunDanmu.Im.Message.IAllUnreadCountRequest=} [properties] Properties to set
                 */
                function AllUnreadCountRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new AllUnreadCountRequest instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Message.AllUnreadCountRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.IAllUnreadCountRequest=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Message.AllUnreadCountRequest} AllUnreadCountRequest instance
                 */
                AllUnreadCountRequest.create = function create(properties) {
                    return new AllUnreadCountRequest(properties);
                };

                /**
                 * Encodes the specified AllUnreadCountRequest message. Does not implicitly {@link AcFunDanmu.Im.Message.AllUnreadCountRequest.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Message.AllUnreadCountRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.IAllUnreadCountRequest} message AllUnreadCountRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AllUnreadCountRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified AllUnreadCountRequest message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Message.AllUnreadCountRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Message.AllUnreadCountRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.IAllUnreadCountRequest} message AllUnreadCountRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AllUnreadCountRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an AllUnreadCountRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Message.AllUnreadCountRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Message.AllUnreadCountRequest} AllUnreadCountRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AllUnreadCountRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Message.AllUnreadCountRequest();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an AllUnreadCountRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Message.AllUnreadCountRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Message.AllUnreadCountRequest} AllUnreadCountRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AllUnreadCountRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an AllUnreadCountRequest message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Message.AllUnreadCountRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                AllUnreadCountRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates an AllUnreadCountRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Message.AllUnreadCountRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Message.AllUnreadCountRequest} AllUnreadCountRequest
                 */
                AllUnreadCountRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Message.AllUnreadCountRequest)
                        return object;
                    return new $root.AcFunDanmu.Im.Message.AllUnreadCountRequest();
                };

                /**
                 * Creates a plain object from an AllUnreadCountRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Message.AllUnreadCountRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.AllUnreadCountRequest} message AllUnreadCountRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                AllUnreadCountRequest.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this AllUnreadCountRequest to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Message.AllUnreadCountRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                AllUnreadCountRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return AllUnreadCountRequest;
            })();

            Message.AllUnreadCountResponse = (function() {

                /**
                 * Properties of an AllUnreadCountResponse.
                 * @memberof AcFunDanmu.Im.Message
                 * @interface IAllUnreadCountResponse
                 * @property {number|null} [allUnreadCount] AllUnreadCountResponse allUnreadCount
                 */

                /**
                 * Constructs a new AllUnreadCountResponse.
                 * @memberof AcFunDanmu.Im.Message
                 * @classdesc Represents an AllUnreadCountResponse.
                 * @implements IAllUnreadCountResponse
                 * @constructor
                 * @param {AcFunDanmu.Im.Message.IAllUnreadCountResponse=} [properties] Properties to set
                 */
                function AllUnreadCountResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * AllUnreadCountResponse allUnreadCount.
                 * @member {number} allUnreadCount
                 * @memberof AcFunDanmu.Im.Message.AllUnreadCountResponse
                 * @instance
                 */
                AllUnreadCountResponse.prototype.allUnreadCount = 0;

                /**
                 * Creates a new AllUnreadCountResponse instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Message.AllUnreadCountResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.IAllUnreadCountResponse=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Message.AllUnreadCountResponse} AllUnreadCountResponse instance
                 */
                AllUnreadCountResponse.create = function create(properties) {
                    return new AllUnreadCountResponse(properties);
                };

                /**
                 * Encodes the specified AllUnreadCountResponse message. Does not implicitly {@link AcFunDanmu.Im.Message.AllUnreadCountResponse.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Message.AllUnreadCountResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.IAllUnreadCountResponse} message AllUnreadCountResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AllUnreadCountResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.allUnreadCount != null && Object.hasOwnProperty.call(message, "allUnreadCount"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.allUnreadCount);
                    return writer;
                };

                /**
                 * Encodes the specified AllUnreadCountResponse message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Message.AllUnreadCountResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Message.AllUnreadCountResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.IAllUnreadCountResponse} message AllUnreadCountResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AllUnreadCountResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an AllUnreadCountResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Message.AllUnreadCountResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Message.AllUnreadCountResponse} AllUnreadCountResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AllUnreadCountResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Message.AllUnreadCountResponse();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.allUnreadCount = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an AllUnreadCountResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Message.AllUnreadCountResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Message.AllUnreadCountResponse} AllUnreadCountResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AllUnreadCountResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an AllUnreadCountResponse message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Message.AllUnreadCountResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                AllUnreadCountResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.allUnreadCount != null && message.hasOwnProperty("allUnreadCount"))
                        if (!$util.isInteger(message.allUnreadCount))
                            return "allUnreadCount: integer expected";
                    return null;
                };

                /**
                 * Creates an AllUnreadCountResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Message.AllUnreadCountResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Message.AllUnreadCountResponse} AllUnreadCountResponse
                 */
                AllUnreadCountResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Message.AllUnreadCountResponse)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Message.AllUnreadCountResponse();
                    if (object.allUnreadCount != null)
                        message.allUnreadCount = object.allUnreadCount | 0;
                    return message;
                };

                /**
                 * Creates a plain object from an AllUnreadCountResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Message.AllUnreadCountResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.AllUnreadCountResponse} message AllUnreadCountResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                AllUnreadCountResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.allUnreadCount = 0;
                    if (message.allUnreadCount != null && message.hasOwnProperty("allUnreadCount"))
                        object.allUnreadCount = message.allUnreadCount;
                    return object;
                };

                /**
                 * Converts this AllUnreadCountResponse to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Message.AllUnreadCountResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                AllUnreadCountResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return AllUnreadCountResponse;
            })();

            Message.MessageReadAllRequest = (function() {

                /**
                 * Properties of a MessageReadAllRequest.
                 * @memberof AcFunDanmu.Im.Message
                 * @interface IMessageReadAllRequest
                 * @property {number|null} [sessionCategoryId] MessageReadAllRequest sessionCategoryId
                 */

                /**
                 * Constructs a new MessageReadAllRequest.
                 * @memberof AcFunDanmu.Im.Message
                 * @classdesc Represents a MessageReadAllRequest.
                 * @implements IMessageReadAllRequest
                 * @constructor
                 * @param {AcFunDanmu.Im.Message.IMessageReadAllRequest=} [properties] Properties to set
                 */
                function MessageReadAllRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MessageReadAllRequest sessionCategoryId.
                 * @member {number} sessionCategoryId
                 * @memberof AcFunDanmu.Im.Message.MessageReadAllRequest
                 * @instance
                 */
                MessageReadAllRequest.prototype.sessionCategoryId = 0;

                /**
                 * Creates a new MessageReadAllRequest instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Message.MessageReadAllRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageReadAllRequest=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Message.MessageReadAllRequest} MessageReadAllRequest instance
                 */
                MessageReadAllRequest.create = function create(properties) {
                    return new MessageReadAllRequest(properties);
                };

                /**
                 * Encodes the specified MessageReadAllRequest message. Does not implicitly {@link AcFunDanmu.Im.Message.MessageReadAllRequest.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Message.MessageReadAllRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageReadAllRequest} message MessageReadAllRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageReadAllRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.sessionCategoryId != null && Object.hasOwnProperty.call(message, "sessionCategoryId"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.sessionCategoryId);
                    return writer;
                };

                /**
                 * Encodes the specified MessageReadAllRequest message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Message.MessageReadAllRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Message.MessageReadAllRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageReadAllRequest} message MessageReadAllRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageReadAllRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MessageReadAllRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Message.MessageReadAllRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Message.MessageReadAllRequest} MessageReadAllRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageReadAllRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Message.MessageReadAllRequest();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.sessionCategoryId = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MessageReadAllRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Message.MessageReadAllRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Message.MessageReadAllRequest} MessageReadAllRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageReadAllRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MessageReadAllRequest message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Message.MessageReadAllRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageReadAllRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.sessionCategoryId != null && message.hasOwnProperty("sessionCategoryId"))
                        if (!$util.isInteger(message.sessionCategoryId))
                            return "sessionCategoryId: integer expected";
                    return null;
                };

                /**
                 * Creates a MessageReadAllRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Message.MessageReadAllRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Message.MessageReadAllRequest} MessageReadAllRequest
                 */
                MessageReadAllRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Message.MessageReadAllRequest)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Message.MessageReadAllRequest();
                    if (object.sessionCategoryId != null)
                        message.sessionCategoryId = object.sessionCategoryId | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a MessageReadAllRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Message.MessageReadAllRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.MessageReadAllRequest} message MessageReadAllRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageReadAllRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.sessionCategoryId = 0;
                    if (message.sessionCategoryId != null && message.hasOwnProperty("sessionCategoryId"))
                        object.sessionCategoryId = message.sessionCategoryId;
                    return object;
                };

                /**
                 * Converts this MessageReadAllRequest to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Message.MessageReadAllRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageReadAllRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return MessageReadAllRequest;
            })();

            Message.MessageReadAllResponse = (function() {

                /**
                 * Properties of a MessageReadAllResponse.
                 * @memberof AcFunDanmu.Im.Message
                 * @interface IMessageReadAllResponse
                 * @property {number|Long|null} [readAllTimestamp] MessageReadAllResponse readAllTimestamp
                 */

                /**
                 * Constructs a new MessageReadAllResponse.
                 * @memberof AcFunDanmu.Im.Message
                 * @classdesc Represents a MessageReadAllResponse.
                 * @implements IMessageReadAllResponse
                 * @constructor
                 * @param {AcFunDanmu.Im.Message.IMessageReadAllResponse=} [properties] Properties to set
                 */
                function MessageReadAllResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MessageReadAllResponse readAllTimestamp.
                 * @member {number|Long} readAllTimestamp
                 * @memberof AcFunDanmu.Im.Message.MessageReadAllResponse
                 * @instance
                 */
                MessageReadAllResponse.prototype.readAllTimestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Creates a new MessageReadAllResponse instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Message.MessageReadAllResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageReadAllResponse=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Message.MessageReadAllResponse} MessageReadAllResponse instance
                 */
                MessageReadAllResponse.create = function create(properties) {
                    return new MessageReadAllResponse(properties);
                };

                /**
                 * Encodes the specified MessageReadAllResponse message. Does not implicitly {@link AcFunDanmu.Im.Message.MessageReadAllResponse.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Message.MessageReadAllResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageReadAllResponse} message MessageReadAllResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageReadAllResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.readAllTimestamp != null && Object.hasOwnProperty.call(message, "readAllTimestamp"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int64(message.readAllTimestamp);
                    return writer;
                };

                /**
                 * Encodes the specified MessageReadAllResponse message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Message.MessageReadAllResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Message.MessageReadAllResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageReadAllResponse} message MessageReadAllResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageReadAllResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MessageReadAllResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Message.MessageReadAllResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Message.MessageReadAllResponse} MessageReadAllResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageReadAllResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Message.MessageReadAllResponse();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.readAllTimestamp = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MessageReadAllResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Message.MessageReadAllResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Message.MessageReadAllResponse} MessageReadAllResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageReadAllResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MessageReadAllResponse message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Message.MessageReadAllResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageReadAllResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.readAllTimestamp != null && message.hasOwnProperty("readAllTimestamp"))
                        if (!$util.isInteger(message.readAllTimestamp) && !(message.readAllTimestamp && $util.isInteger(message.readAllTimestamp.low) && $util.isInteger(message.readAllTimestamp.high)))
                            return "readAllTimestamp: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a MessageReadAllResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Message.MessageReadAllResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Message.MessageReadAllResponse} MessageReadAllResponse
                 */
                MessageReadAllResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Message.MessageReadAllResponse)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Message.MessageReadAllResponse();
                    if (object.readAllTimestamp != null)
                        if ($util.Long)
                            (message.readAllTimestamp = $util.Long.fromValue(object.readAllTimestamp)).unsigned = false;
                        else if (typeof object.readAllTimestamp === "string")
                            message.readAllTimestamp = parseInt(object.readAllTimestamp, 10);
                        else if (typeof object.readAllTimestamp === "number")
                            message.readAllTimestamp = object.readAllTimestamp;
                        else if (typeof object.readAllTimestamp === "object")
                            message.readAllTimestamp = new $util.LongBits(object.readAllTimestamp.low >>> 0, object.readAllTimestamp.high >>> 0).toNumber();
                    return message;
                };

                /**
                 * Creates a plain object from a MessageReadAllResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Message.MessageReadAllResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.MessageReadAllResponse} message MessageReadAllResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageReadAllResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.readAllTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.readAllTimestamp = options.longs === String ? "0" : 0;
                    if (message.readAllTimestamp != null && message.hasOwnProperty("readAllTimestamp"))
                        if (typeof message.readAllTimestamp === "number")
                            object.readAllTimestamp = options.longs === String ? String(message.readAllTimestamp) : message.readAllTimestamp;
                        else
                            object.readAllTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.readAllTimestamp) : options.longs === Number ? new $util.LongBits(message.readAllTimestamp.low >>> 0, message.readAllTimestamp.high >>> 0).toNumber() : message.readAllTimestamp;
                    return object;
                };

                /**
                 * Converts this MessageReadAllResponse to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Message.MessageReadAllResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageReadAllResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return MessageReadAllResponse;
            })();

            Message.SesionStickyOnTopRequest = (function() {

                /**
                 * Properties of a SesionStickyOnTopRequest.
                 * @memberof AcFunDanmu.Im.Message
                 * @interface ISesionStickyOnTopRequest
                 * @property {AcFunDanmu.Im.Message.IChatTarget|null} [chatTarget] SesionStickyOnTopRequest chatTarget
                 * @property {boolean|null} [stickyOnTop] SesionStickyOnTopRequest stickyOnTop
                 */

                /**
                 * Constructs a new SesionStickyOnTopRequest.
                 * @memberof AcFunDanmu.Im.Message
                 * @classdesc Represents a SesionStickyOnTopRequest.
                 * @implements ISesionStickyOnTopRequest
                 * @constructor
                 * @param {AcFunDanmu.Im.Message.ISesionStickyOnTopRequest=} [properties] Properties to set
                 */
                function SesionStickyOnTopRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SesionStickyOnTopRequest chatTarget.
                 * @member {AcFunDanmu.Im.Message.IChatTarget|null|undefined} chatTarget
                 * @memberof AcFunDanmu.Im.Message.SesionStickyOnTopRequest
                 * @instance
                 */
                SesionStickyOnTopRequest.prototype.chatTarget = null;

                /**
                 * SesionStickyOnTopRequest stickyOnTop.
                 * @member {boolean} stickyOnTop
                 * @memberof AcFunDanmu.Im.Message.SesionStickyOnTopRequest
                 * @instance
                 */
                SesionStickyOnTopRequest.prototype.stickyOnTop = false;

                /**
                 * Creates a new SesionStickyOnTopRequest instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Message.SesionStickyOnTopRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.ISesionStickyOnTopRequest=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Message.SesionStickyOnTopRequest} SesionStickyOnTopRequest instance
                 */
                SesionStickyOnTopRequest.create = function create(properties) {
                    return new SesionStickyOnTopRequest(properties);
                };

                /**
                 * Encodes the specified SesionStickyOnTopRequest message. Does not implicitly {@link AcFunDanmu.Im.Message.SesionStickyOnTopRequest.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Message.SesionStickyOnTopRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.ISesionStickyOnTopRequest} message SesionStickyOnTopRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SesionStickyOnTopRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.chatTarget != null && Object.hasOwnProperty.call(message, "chatTarget"))
                        $root.AcFunDanmu.Im.Message.ChatTarget.encode(message.chatTarget, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.stickyOnTop != null && Object.hasOwnProperty.call(message, "stickyOnTop"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.stickyOnTop);
                    return writer;
                };

                /**
                 * Encodes the specified SesionStickyOnTopRequest message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Message.SesionStickyOnTopRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Message.SesionStickyOnTopRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.ISesionStickyOnTopRequest} message SesionStickyOnTopRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SesionStickyOnTopRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SesionStickyOnTopRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Message.SesionStickyOnTopRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Message.SesionStickyOnTopRequest} SesionStickyOnTopRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SesionStickyOnTopRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Message.SesionStickyOnTopRequest();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.chatTarget = $root.AcFunDanmu.Im.Message.ChatTarget.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.stickyOnTop = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SesionStickyOnTopRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Message.SesionStickyOnTopRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Message.SesionStickyOnTopRequest} SesionStickyOnTopRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SesionStickyOnTopRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SesionStickyOnTopRequest message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Message.SesionStickyOnTopRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SesionStickyOnTopRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.chatTarget != null && message.hasOwnProperty("chatTarget")) {
                        let error = $root.AcFunDanmu.Im.Message.ChatTarget.verify(message.chatTarget);
                        if (error)
                            return "chatTarget." + error;
                    }
                    if (message.stickyOnTop != null && message.hasOwnProperty("stickyOnTop"))
                        if (typeof message.stickyOnTop !== "boolean")
                            return "stickyOnTop: boolean expected";
                    return null;
                };

                /**
                 * Creates a SesionStickyOnTopRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Message.SesionStickyOnTopRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Message.SesionStickyOnTopRequest} SesionStickyOnTopRequest
                 */
                SesionStickyOnTopRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Message.SesionStickyOnTopRequest)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Message.SesionStickyOnTopRequest();
                    if (object.chatTarget != null) {
                        if (typeof object.chatTarget !== "object")
                            throw TypeError(".AcFunDanmu.Im.Message.SesionStickyOnTopRequest.chatTarget: object expected");
                        message.chatTarget = $root.AcFunDanmu.Im.Message.ChatTarget.fromObject(object.chatTarget);
                    }
                    if (object.stickyOnTop != null)
                        message.stickyOnTop = Boolean(object.stickyOnTop);
                    return message;
                };

                /**
                 * Creates a plain object from a SesionStickyOnTopRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Message.SesionStickyOnTopRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.SesionStickyOnTopRequest} message SesionStickyOnTopRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SesionStickyOnTopRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.chatTarget = null;
                        object.stickyOnTop = false;
                    }
                    if (message.chatTarget != null && message.hasOwnProperty("chatTarget"))
                        object.chatTarget = $root.AcFunDanmu.Im.Message.ChatTarget.toObject(message.chatTarget, options);
                    if (message.stickyOnTop != null && message.hasOwnProperty("stickyOnTop"))
                        object.stickyOnTop = message.stickyOnTop;
                    return object;
                };

                /**
                 * Converts this SesionStickyOnTopRequest to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Message.SesionStickyOnTopRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SesionStickyOnTopRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SesionStickyOnTopRequest;
            })();

            Message.SessionStickyOnTopResponse = (function() {

                /**
                 * Properties of a SessionStickyOnTopResponse.
                 * @memberof AcFunDanmu.Im.Message
                 * @interface ISessionStickyOnTopResponse
                 * @property {AcFunDanmu.Im.Message.IChatSession|null} [session] SessionStickyOnTopResponse session
                 */

                /**
                 * Constructs a new SessionStickyOnTopResponse.
                 * @memberof AcFunDanmu.Im.Message
                 * @classdesc Represents a SessionStickyOnTopResponse.
                 * @implements ISessionStickyOnTopResponse
                 * @constructor
                 * @param {AcFunDanmu.Im.Message.ISessionStickyOnTopResponse=} [properties] Properties to set
                 */
                function SessionStickyOnTopResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SessionStickyOnTopResponse session.
                 * @member {AcFunDanmu.Im.Message.IChatSession|null|undefined} session
                 * @memberof AcFunDanmu.Im.Message.SessionStickyOnTopResponse
                 * @instance
                 */
                SessionStickyOnTopResponse.prototype.session = null;

                /**
                 * Creates a new SessionStickyOnTopResponse instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Message.SessionStickyOnTopResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.ISessionStickyOnTopResponse=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Message.SessionStickyOnTopResponse} SessionStickyOnTopResponse instance
                 */
                SessionStickyOnTopResponse.create = function create(properties) {
                    return new SessionStickyOnTopResponse(properties);
                };

                /**
                 * Encodes the specified SessionStickyOnTopResponse message. Does not implicitly {@link AcFunDanmu.Im.Message.SessionStickyOnTopResponse.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Message.SessionStickyOnTopResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.ISessionStickyOnTopResponse} message SessionStickyOnTopResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SessionStickyOnTopResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.session != null && Object.hasOwnProperty.call(message, "session"))
                        $root.AcFunDanmu.Im.Message.ChatSession.encode(message.session, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified SessionStickyOnTopResponse message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Message.SessionStickyOnTopResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Message.SessionStickyOnTopResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.ISessionStickyOnTopResponse} message SessionStickyOnTopResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SessionStickyOnTopResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SessionStickyOnTopResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Message.SessionStickyOnTopResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Message.SessionStickyOnTopResponse} SessionStickyOnTopResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SessionStickyOnTopResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Message.SessionStickyOnTopResponse();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.session = $root.AcFunDanmu.Im.Message.ChatSession.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SessionStickyOnTopResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Message.SessionStickyOnTopResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Message.SessionStickyOnTopResponse} SessionStickyOnTopResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SessionStickyOnTopResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SessionStickyOnTopResponse message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Message.SessionStickyOnTopResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SessionStickyOnTopResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.session != null && message.hasOwnProperty("session")) {
                        let error = $root.AcFunDanmu.Im.Message.ChatSession.verify(message.session);
                        if (error)
                            return "session." + error;
                    }
                    return null;
                };

                /**
                 * Creates a SessionStickyOnTopResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Message.SessionStickyOnTopResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Message.SessionStickyOnTopResponse} SessionStickyOnTopResponse
                 */
                SessionStickyOnTopResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Message.SessionStickyOnTopResponse)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Message.SessionStickyOnTopResponse();
                    if (object.session != null) {
                        if (typeof object.session !== "object")
                            throw TypeError(".AcFunDanmu.Im.Message.SessionStickyOnTopResponse.session: object expected");
                        message.session = $root.AcFunDanmu.Im.Message.ChatSession.fromObject(object.session);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a SessionStickyOnTopResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Message.SessionStickyOnTopResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.SessionStickyOnTopResponse} message SessionStickyOnTopResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SessionStickyOnTopResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.session = null;
                    if (message.session != null && message.hasOwnProperty("session"))
                        object.session = $root.AcFunDanmu.Im.Message.ChatSession.toObject(message.session, options);
                    return object;
                };

                /**
                 * Converts this SessionStickyOnTopResponse to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Message.SessionStickyOnTopResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SessionStickyOnTopResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SessionStickyOnTopResponse;
            })();

            Message.SessionRaw = (function() {

                /**
                 * Properties of a SessionRaw.
                 * @memberof AcFunDanmu.Im.Message
                 * @interface ISessionRaw
                 * @property {Object.<string,Uint8Array>|null} [raw] SessionRaw raw
                 */

                /**
                 * Constructs a new SessionRaw.
                 * @memberof AcFunDanmu.Im.Message
                 * @classdesc Represents a SessionRaw.
                 * @implements ISessionRaw
                 * @constructor
                 * @param {AcFunDanmu.Im.Message.ISessionRaw=} [properties] Properties to set
                 */
                function SessionRaw(properties) {
                    this.raw = {};
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SessionRaw raw.
                 * @member {Object.<string,Uint8Array>} raw
                 * @memberof AcFunDanmu.Im.Message.SessionRaw
                 * @instance
                 */
                SessionRaw.prototype.raw = $util.emptyObject;

                /**
                 * Creates a new SessionRaw instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Message.SessionRaw
                 * @static
                 * @param {AcFunDanmu.Im.Message.ISessionRaw=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Message.SessionRaw} SessionRaw instance
                 */
                SessionRaw.create = function create(properties) {
                    return new SessionRaw(properties);
                };

                /**
                 * Encodes the specified SessionRaw message. Does not implicitly {@link AcFunDanmu.Im.Message.SessionRaw.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Message.SessionRaw
                 * @static
                 * @param {AcFunDanmu.Im.Message.ISessionRaw} message SessionRaw message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SessionRaw.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.raw != null && Object.hasOwnProperty.call(message, "raw"))
                        for (let keys = Object.keys(message.raw), i = 0; i < keys.length; ++i)
                            writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).bytes(message.raw[keys[i]]).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified SessionRaw message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Message.SessionRaw.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Message.SessionRaw
                 * @static
                 * @param {AcFunDanmu.Im.Message.ISessionRaw} message SessionRaw message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SessionRaw.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SessionRaw message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Message.SessionRaw
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Message.SessionRaw} SessionRaw
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SessionRaw.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Message.SessionRaw(), key, value;
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (message.raw === $util.emptyObject)
                                message.raw = {};
                            let end2 = reader.uint32() + reader.pos;
                            key = "";
                            value = [];
                            while (reader.pos < end2) {
                                let tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.string();
                                    break;
                                case 2:
                                    value = reader.bytes();
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.raw[key] = value;
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SessionRaw message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Message.SessionRaw
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Message.SessionRaw} SessionRaw
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SessionRaw.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SessionRaw message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Message.SessionRaw
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SessionRaw.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.raw != null && message.hasOwnProperty("raw")) {
                        if (!$util.isObject(message.raw))
                            return "raw: object expected";
                        let key = Object.keys(message.raw);
                        for (let i = 0; i < key.length; ++i)
                            if (!(message.raw[key[i]] && typeof message.raw[key[i]].length === "number" || $util.isString(message.raw[key[i]])))
                                return "raw: buffer{k:string} expected";
                    }
                    return null;
                };

                /**
                 * Creates a SessionRaw message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Message.SessionRaw
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Message.SessionRaw} SessionRaw
                 */
                SessionRaw.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Message.SessionRaw)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Message.SessionRaw();
                    if (object.raw) {
                        if (typeof object.raw !== "object")
                            throw TypeError(".AcFunDanmu.Im.Message.SessionRaw.raw: object expected");
                        message.raw = {};
                        for (let keys = Object.keys(object.raw), i = 0; i < keys.length; ++i)
                            if (typeof object.raw[keys[i]] === "string")
                                $util.base64.decode(object.raw[keys[i]], message.raw[keys[i]] = $util.newBuffer($util.base64.length(object.raw[keys[i]])), 0);
                            else if (object.raw[keys[i]].length)
                                message.raw[keys[i]] = object.raw[keys[i]];
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a SessionRaw message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Message.SessionRaw
                 * @static
                 * @param {AcFunDanmu.Im.Message.SessionRaw} message SessionRaw
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SessionRaw.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.objects || options.defaults)
                        object.raw = {};
                    let keys2;
                    if (message.raw && (keys2 = Object.keys(message.raw)).length) {
                        object.raw = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.raw[keys2[j]] = options.bytes === String ? $util.base64.encode(message.raw[keys2[j]], 0, message.raw[keys2[j]].length) : options.bytes === Array ? Array.prototype.slice.call(message.raw[keys2[j]]) : message.raw[keys2[j]];
                    }
                    return object;
                };

                /**
                 * Converts this SessionRaw to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Message.SessionRaw
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SessionRaw.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SessionRaw;
            })();

            Message.MessageRecallRequest = (function() {

                /**
                 * Properties of a MessageRecallRequest.
                 * @memberof AcFunDanmu.Im.Message
                 * @interface IMessageRecallRequest
                 * @property {AcFunDanmu.Im.Message.IChatTarget|null} [chatTarget] MessageRecallRequest chatTarget
                 * @property {number|Long|null} [seqId] MessageRecallRequest seqId
                 */

                /**
                 * Constructs a new MessageRecallRequest.
                 * @memberof AcFunDanmu.Im.Message
                 * @classdesc Represents a MessageRecallRequest.
                 * @implements IMessageRecallRequest
                 * @constructor
                 * @param {AcFunDanmu.Im.Message.IMessageRecallRequest=} [properties] Properties to set
                 */
                function MessageRecallRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MessageRecallRequest chatTarget.
                 * @member {AcFunDanmu.Im.Message.IChatTarget|null|undefined} chatTarget
                 * @memberof AcFunDanmu.Im.Message.MessageRecallRequest
                 * @instance
                 */
                MessageRecallRequest.prototype.chatTarget = null;

                /**
                 * MessageRecallRequest seqId.
                 * @member {number|Long} seqId
                 * @memberof AcFunDanmu.Im.Message.MessageRecallRequest
                 * @instance
                 */
                MessageRecallRequest.prototype.seqId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Creates a new MessageRecallRequest instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Message.MessageRecallRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageRecallRequest=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Message.MessageRecallRequest} MessageRecallRequest instance
                 */
                MessageRecallRequest.create = function create(properties) {
                    return new MessageRecallRequest(properties);
                };

                /**
                 * Encodes the specified MessageRecallRequest message. Does not implicitly {@link AcFunDanmu.Im.Message.MessageRecallRequest.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Message.MessageRecallRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageRecallRequest} message MessageRecallRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageRecallRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.chatTarget != null && Object.hasOwnProperty.call(message, "chatTarget"))
                        $root.AcFunDanmu.Im.Message.ChatTarget.encode(message.chatTarget, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.seqId != null && Object.hasOwnProperty.call(message, "seqId"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int64(message.seqId);
                    return writer;
                };

                /**
                 * Encodes the specified MessageRecallRequest message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Message.MessageRecallRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Message.MessageRecallRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageRecallRequest} message MessageRecallRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageRecallRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MessageRecallRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Message.MessageRecallRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Message.MessageRecallRequest} MessageRecallRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageRecallRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Message.MessageRecallRequest();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.chatTarget = $root.AcFunDanmu.Im.Message.ChatTarget.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.seqId = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MessageRecallRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Message.MessageRecallRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Message.MessageRecallRequest} MessageRecallRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageRecallRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MessageRecallRequest message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Message.MessageRecallRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageRecallRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.chatTarget != null && message.hasOwnProperty("chatTarget")) {
                        let error = $root.AcFunDanmu.Im.Message.ChatTarget.verify(message.chatTarget);
                        if (error)
                            return "chatTarget." + error;
                    }
                    if (message.seqId != null && message.hasOwnProperty("seqId"))
                        if (!$util.isInteger(message.seqId) && !(message.seqId && $util.isInteger(message.seqId.low) && $util.isInteger(message.seqId.high)))
                            return "seqId: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a MessageRecallRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Message.MessageRecallRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Message.MessageRecallRequest} MessageRecallRequest
                 */
                MessageRecallRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Message.MessageRecallRequest)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Message.MessageRecallRequest();
                    if (object.chatTarget != null) {
                        if (typeof object.chatTarget !== "object")
                            throw TypeError(".AcFunDanmu.Im.Message.MessageRecallRequest.chatTarget: object expected");
                        message.chatTarget = $root.AcFunDanmu.Im.Message.ChatTarget.fromObject(object.chatTarget);
                    }
                    if (object.seqId != null)
                        if ($util.Long)
                            (message.seqId = $util.Long.fromValue(object.seqId)).unsigned = false;
                        else if (typeof object.seqId === "string")
                            message.seqId = parseInt(object.seqId, 10);
                        else if (typeof object.seqId === "number")
                            message.seqId = object.seqId;
                        else if (typeof object.seqId === "object")
                            message.seqId = new $util.LongBits(object.seqId.low >>> 0, object.seqId.high >>> 0).toNumber();
                    return message;
                };

                /**
                 * Creates a plain object from a MessageRecallRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Message.MessageRecallRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.MessageRecallRequest} message MessageRecallRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageRecallRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.chatTarget = null;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.seqId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.seqId = options.longs === String ? "0" : 0;
                    }
                    if (message.chatTarget != null && message.hasOwnProperty("chatTarget"))
                        object.chatTarget = $root.AcFunDanmu.Im.Message.ChatTarget.toObject(message.chatTarget, options);
                    if (message.seqId != null && message.hasOwnProperty("seqId"))
                        if (typeof message.seqId === "number")
                            object.seqId = options.longs === String ? String(message.seqId) : message.seqId;
                        else
                            object.seqId = options.longs === String ? $util.Long.prototype.toString.call(message.seqId) : options.longs === Number ? new $util.LongBits(message.seqId.low >>> 0, message.seqId.high >>> 0).toNumber() : message.seqId;
                    return object;
                };

                /**
                 * Converts this MessageRecallRequest to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Message.MessageRecallRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageRecallRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return MessageRecallRequest;
            })();

            Message.MessageRecallResponse = (function() {

                /**
                 * Properties of a MessageRecallResponse.
                 * @memberof AcFunDanmu.Im.Message
                 * @interface IMessageRecallResponse
                 */

                /**
                 * Constructs a new MessageRecallResponse.
                 * @memberof AcFunDanmu.Im.Message
                 * @classdesc Represents a MessageRecallResponse.
                 * @implements IMessageRecallResponse
                 * @constructor
                 * @param {AcFunDanmu.Im.Message.IMessageRecallResponse=} [properties] Properties to set
                 */
                function MessageRecallResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new MessageRecallResponse instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Message.MessageRecallResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageRecallResponse=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Message.MessageRecallResponse} MessageRecallResponse instance
                 */
                MessageRecallResponse.create = function create(properties) {
                    return new MessageRecallResponse(properties);
                };

                /**
                 * Encodes the specified MessageRecallResponse message. Does not implicitly {@link AcFunDanmu.Im.Message.MessageRecallResponse.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Message.MessageRecallResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageRecallResponse} message MessageRecallResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageRecallResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified MessageRecallResponse message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Message.MessageRecallResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Message.MessageRecallResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageRecallResponse} message MessageRecallResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageRecallResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MessageRecallResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Message.MessageRecallResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Message.MessageRecallResponse} MessageRecallResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageRecallResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Message.MessageRecallResponse();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MessageRecallResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Message.MessageRecallResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Message.MessageRecallResponse} MessageRecallResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageRecallResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MessageRecallResponse message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Message.MessageRecallResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageRecallResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a MessageRecallResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Message.MessageRecallResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Message.MessageRecallResponse} MessageRecallResponse
                 */
                MessageRecallResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Message.MessageRecallResponse)
                        return object;
                    return new $root.AcFunDanmu.Im.Message.MessageRecallResponse();
                };

                /**
                 * Creates a plain object from a MessageRecallResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Message.MessageRecallResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.MessageRecallResponse} message MessageRecallResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageRecallResponse.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this MessageRecallResponse to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Message.MessageRecallResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageRecallResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return MessageRecallResponse;
            })();

            Message.MessageReceiptRequest = (function() {

                /**
                 * Properties of a MessageReceiptRequest.
                 * @memberof AcFunDanmu.Im.Message
                 * @interface IMessageReceiptRequest
                 * @property {Array.<AcFunDanmu.Im.Message.IMessageReceiptInfo>|null} [messageReceiptInfo] MessageReceiptRequest messageReceiptInfo
                 * @property {AcFunDanmu.Im.Message.IChatTarget|null} [chatTarget] MessageReceiptRequest chatTarget
                 */

                /**
                 * Constructs a new MessageReceiptRequest.
                 * @memberof AcFunDanmu.Im.Message
                 * @classdesc Represents a MessageReceiptRequest.
                 * @implements IMessageReceiptRequest
                 * @constructor
                 * @param {AcFunDanmu.Im.Message.IMessageReceiptRequest=} [properties] Properties to set
                 */
                function MessageReceiptRequest(properties) {
                    this.messageReceiptInfo = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MessageReceiptRequest messageReceiptInfo.
                 * @member {Array.<AcFunDanmu.Im.Message.IMessageReceiptInfo>} messageReceiptInfo
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptRequest
                 * @instance
                 */
                MessageReceiptRequest.prototype.messageReceiptInfo = $util.emptyArray;

                /**
                 * MessageReceiptRequest chatTarget.
                 * @member {AcFunDanmu.Im.Message.IChatTarget|null|undefined} chatTarget
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptRequest
                 * @instance
                 */
                MessageReceiptRequest.prototype.chatTarget = null;

                /**
                 * Creates a new MessageReceiptRequest instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageReceiptRequest=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Message.MessageReceiptRequest} MessageReceiptRequest instance
                 */
                MessageReceiptRequest.create = function create(properties) {
                    return new MessageReceiptRequest(properties);
                };

                /**
                 * Encodes the specified MessageReceiptRequest message. Does not implicitly {@link AcFunDanmu.Im.Message.MessageReceiptRequest.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageReceiptRequest} message MessageReceiptRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageReceiptRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.messageReceiptInfo != null && message.messageReceiptInfo.length)
                        for (let i = 0; i < message.messageReceiptInfo.length; ++i)
                            $root.AcFunDanmu.Im.Message.MessageReceiptInfo.encode(message.messageReceiptInfo[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.chatTarget != null && Object.hasOwnProperty.call(message, "chatTarget"))
                        $root.AcFunDanmu.Im.Message.ChatTarget.encode(message.chatTarget, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified MessageReceiptRequest message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Message.MessageReceiptRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageReceiptRequest} message MessageReceiptRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageReceiptRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MessageReceiptRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Message.MessageReceiptRequest} MessageReceiptRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageReceiptRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Message.MessageReceiptRequest();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.messageReceiptInfo && message.messageReceiptInfo.length))
                                message.messageReceiptInfo = [];
                            message.messageReceiptInfo.push($root.AcFunDanmu.Im.Message.MessageReceiptInfo.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            message.chatTarget = $root.AcFunDanmu.Im.Message.ChatTarget.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MessageReceiptRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Message.MessageReceiptRequest} MessageReceiptRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageReceiptRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MessageReceiptRequest message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageReceiptRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.messageReceiptInfo != null && message.hasOwnProperty("messageReceiptInfo")) {
                        if (!Array.isArray(message.messageReceiptInfo))
                            return "messageReceiptInfo: array expected";
                        for (let i = 0; i < message.messageReceiptInfo.length; ++i) {
                            let error = $root.AcFunDanmu.Im.Message.MessageReceiptInfo.verify(message.messageReceiptInfo[i]);
                            if (error)
                                return "messageReceiptInfo." + error;
                        }
                    }
                    if (message.chatTarget != null && message.hasOwnProperty("chatTarget")) {
                        let error = $root.AcFunDanmu.Im.Message.ChatTarget.verify(message.chatTarget);
                        if (error)
                            return "chatTarget." + error;
                    }
                    return null;
                };

                /**
                 * Creates a MessageReceiptRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Message.MessageReceiptRequest} MessageReceiptRequest
                 */
                MessageReceiptRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Message.MessageReceiptRequest)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Message.MessageReceiptRequest();
                    if (object.messageReceiptInfo) {
                        if (!Array.isArray(object.messageReceiptInfo))
                            throw TypeError(".AcFunDanmu.Im.Message.MessageReceiptRequest.messageReceiptInfo: array expected");
                        message.messageReceiptInfo = [];
                        for (let i = 0; i < object.messageReceiptInfo.length; ++i) {
                            if (typeof object.messageReceiptInfo[i] !== "object")
                                throw TypeError(".AcFunDanmu.Im.Message.MessageReceiptRequest.messageReceiptInfo: object expected");
                            message.messageReceiptInfo[i] = $root.AcFunDanmu.Im.Message.MessageReceiptInfo.fromObject(object.messageReceiptInfo[i]);
                        }
                    }
                    if (object.chatTarget != null) {
                        if (typeof object.chatTarget !== "object")
                            throw TypeError(".AcFunDanmu.Im.Message.MessageReceiptRequest.chatTarget: object expected");
                        message.chatTarget = $root.AcFunDanmu.Im.Message.ChatTarget.fromObject(object.chatTarget);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a MessageReceiptRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.MessageReceiptRequest} message MessageReceiptRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageReceiptRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.messageReceiptInfo = [];
                    if (options.defaults)
                        object.chatTarget = null;
                    if (message.messageReceiptInfo && message.messageReceiptInfo.length) {
                        object.messageReceiptInfo = [];
                        for (let j = 0; j < message.messageReceiptInfo.length; ++j)
                            object.messageReceiptInfo[j] = $root.AcFunDanmu.Im.Message.MessageReceiptInfo.toObject(message.messageReceiptInfo[j], options);
                    }
                    if (message.chatTarget != null && message.hasOwnProperty("chatTarget"))
                        object.chatTarget = $root.AcFunDanmu.Im.Message.ChatTarget.toObject(message.chatTarget, options);
                    return object;
                };

                /**
                 * Converts this MessageReceiptRequest to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageReceiptRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return MessageReceiptRequest;
            })();

            Message.MessageReceiptResponse = (function() {

                /**
                 * Properties of a MessageReceiptResponse.
                 * @memberof AcFunDanmu.Im.Message
                 * @interface IMessageReceiptResponse
                 */

                /**
                 * Constructs a new MessageReceiptResponse.
                 * @memberof AcFunDanmu.Im.Message
                 * @classdesc Represents a MessageReceiptResponse.
                 * @implements IMessageReceiptResponse
                 * @constructor
                 * @param {AcFunDanmu.Im.Message.IMessageReceiptResponse=} [properties] Properties to set
                 */
                function MessageReceiptResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new MessageReceiptResponse instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageReceiptResponse=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Message.MessageReceiptResponse} MessageReceiptResponse instance
                 */
                MessageReceiptResponse.create = function create(properties) {
                    return new MessageReceiptResponse(properties);
                };

                /**
                 * Encodes the specified MessageReceiptResponse message. Does not implicitly {@link AcFunDanmu.Im.Message.MessageReceiptResponse.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageReceiptResponse} message MessageReceiptResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageReceiptResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified MessageReceiptResponse message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Message.MessageReceiptResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageReceiptResponse} message MessageReceiptResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageReceiptResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MessageReceiptResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Message.MessageReceiptResponse} MessageReceiptResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageReceiptResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Message.MessageReceiptResponse();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MessageReceiptResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Message.MessageReceiptResponse} MessageReceiptResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageReceiptResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MessageReceiptResponse message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageReceiptResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a MessageReceiptResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Message.MessageReceiptResponse} MessageReceiptResponse
                 */
                MessageReceiptResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Message.MessageReceiptResponse)
                        return object;
                    return new $root.AcFunDanmu.Im.Message.MessageReceiptResponse();
                };

                /**
                 * Creates a plain object from a MessageReceiptResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.MessageReceiptResponse} message MessageReceiptResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageReceiptResponse.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this MessageReceiptResponse to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageReceiptResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return MessageReceiptResponse;
            })();

            Message.MessageReceiptInfo = (function() {

                /**
                 * Properties of a MessageReceiptInfo.
                 * @memberof AcFunDanmu.Im.Message
                 * @interface IMessageReceiptInfo
                 * @property {number|Long|null} [readSeq] MessageReceiptInfo readSeq
                 */

                /**
                 * Constructs a new MessageReceiptInfo.
                 * @memberof AcFunDanmu.Im.Message
                 * @classdesc Represents a MessageReceiptInfo.
                 * @implements IMessageReceiptInfo
                 * @constructor
                 * @param {AcFunDanmu.Im.Message.IMessageReceiptInfo=} [properties] Properties to set
                 */
                function MessageReceiptInfo(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MessageReceiptInfo readSeq.
                 * @member {number|Long} readSeq
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptInfo
                 * @instance
                 */
                MessageReceiptInfo.prototype.readSeq = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Creates a new MessageReceiptInfo instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptInfo
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageReceiptInfo=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Message.MessageReceiptInfo} MessageReceiptInfo instance
                 */
                MessageReceiptInfo.create = function create(properties) {
                    return new MessageReceiptInfo(properties);
                };

                /**
                 * Encodes the specified MessageReceiptInfo message. Does not implicitly {@link AcFunDanmu.Im.Message.MessageReceiptInfo.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptInfo
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageReceiptInfo} message MessageReceiptInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageReceiptInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.readSeq != null && Object.hasOwnProperty.call(message, "readSeq"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int64(message.readSeq);
                    return writer;
                };

                /**
                 * Encodes the specified MessageReceiptInfo message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Message.MessageReceiptInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptInfo
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageReceiptInfo} message MessageReceiptInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageReceiptInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MessageReceiptInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Message.MessageReceiptInfo} MessageReceiptInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageReceiptInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Message.MessageReceiptInfo();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.readSeq = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MessageReceiptInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Message.MessageReceiptInfo} MessageReceiptInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageReceiptInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MessageReceiptInfo message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageReceiptInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.readSeq != null && message.hasOwnProperty("readSeq"))
                        if (!$util.isInteger(message.readSeq) && !(message.readSeq && $util.isInteger(message.readSeq.low) && $util.isInteger(message.readSeq.high)))
                            return "readSeq: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a MessageReceiptInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Message.MessageReceiptInfo} MessageReceiptInfo
                 */
                MessageReceiptInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Message.MessageReceiptInfo)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Message.MessageReceiptInfo();
                    if (object.readSeq != null)
                        if ($util.Long)
                            (message.readSeq = $util.Long.fromValue(object.readSeq)).unsigned = false;
                        else if (typeof object.readSeq === "string")
                            message.readSeq = parseInt(object.readSeq, 10);
                        else if (typeof object.readSeq === "number")
                            message.readSeq = object.readSeq;
                        else if (typeof object.readSeq === "object")
                            message.readSeq = new $util.LongBits(object.readSeq.low >>> 0, object.readSeq.high >>> 0).toNumber();
                    return message;
                };

                /**
                 * Creates a plain object from a MessageReceiptInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptInfo
                 * @static
                 * @param {AcFunDanmu.Im.Message.MessageReceiptInfo} message MessageReceiptInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageReceiptInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.readSeq = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.readSeq = options.longs === String ? "0" : 0;
                    if (message.readSeq != null && message.hasOwnProperty("readSeq"))
                        if (typeof message.readSeq === "number")
                            object.readSeq = options.longs === String ? String(message.readSeq) : message.readSeq;
                        else
                            object.readSeq = options.longs === String ? $util.Long.prototype.toString.call(message.readSeq) : options.longs === Number ? new $util.LongBits(message.readSeq.low >>> 0, message.readSeq.high >>> 0).toNumber() : message.readSeq;
                    return object;
                };

                /**
                 * Converts this MessageReceiptInfo to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageReceiptInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return MessageReceiptInfo;
            })();

            Message.MessageReceiptCountGetRequest = (function() {

                /**
                 * Properties of a MessageReceiptCountGetRequest.
                 * @memberof AcFunDanmu.Im.Message
                 * @interface IMessageReceiptCountGetRequest
                 * @property {Array.<number|Long>|null} [seqId] MessageReceiptCountGetRequest seqId
                 * @property {AcFunDanmu.Im.Message.IChatTarget|null} [chatTarget] MessageReceiptCountGetRequest chatTarget
                 */

                /**
                 * Constructs a new MessageReceiptCountGetRequest.
                 * @memberof AcFunDanmu.Im.Message
                 * @classdesc Represents a MessageReceiptCountGetRequest.
                 * @implements IMessageReceiptCountGetRequest
                 * @constructor
                 * @param {AcFunDanmu.Im.Message.IMessageReceiptCountGetRequest=} [properties] Properties to set
                 */
                function MessageReceiptCountGetRequest(properties) {
                    this.seqId = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MessageReceiptCountGetRequest seqId.
                 * @member {Array.<number|Long>} seqId
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptCountGetRequest
                 * @instance
                 */
                MessageReceiptCountGetRequest.prototype.seqId = $util.emptyArray;

                /**
                 * MessageReceiptCountGetRequest chatTarget.
                 * @member {AcFunDanmu.Im.Message.IChatTarget|null|undefined} chatTarget
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptCountGetRequest
                 * @instance
                 */
                MessageReceiptCountGetRequest.prototype.chatTarget = null;

                /**
                 * Creates a new MessageReceiptCountGetRequest instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptCountGetRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageReceiptCountGetRequest=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Message.MessageReceiptCountGetRequest} MessageReceiptCountGetRequest instance
                 */
                MessageReceiptCountGetRequest.create = function create(properties) {
                    return new MessageReceiptCountGetRequest(properties);
                };

                /**
                 * Encodes the specified MessageReceiptCountGetRequest message. Does not implicitly {@link AcFunDanmu.Im.Message.MessageReceiptCountGetRequest.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptCountGetRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageReceiptCountGetRequest} message MessageReceiptCountGetRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageReceiptCountGetRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.seqId != null && message.seqId.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (let i = 0; i < message.seqId.length; ++i)
                            writer.int64(message.seqId[i]);
                        writer.ldelim();
                    }
                    if (message.chatTarget != null && Object.hasOwnProperty.call(message, "chatTarget"))
                        $root.AcFunDanmu.Im.Message.ChatTarget.encode(message.chatTarget, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified MessageReceiptCountGetRequest message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Message.MessageReceiptCountGetRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptCountGetRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageReceiptCountGetRequest} message MessageReceiptCountGetRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageReceiptCountGetRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MessageReceiptCountGetRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptCountGetRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Message.MessageReceiptCountGetRequest} MessageReceiptCountGetRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageReceiptCountGetRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Message.MessageReceiptCountGetRequest();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.seqId && message.seqId.length))
                                message.seqId = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.seqId.push(reader.int64());
                            } else
                                message.seqId.push(reader.int64());
                            break;
                        case 2:
                            message.chatTarget = $root.AcFunDanmu.Im.Message.ChatTarget.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MessageReceiptCountGetRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptCountGetRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Message.MessageReceiptCountGetRequest} MessageReceiptCountGetRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageReceiptCountGetRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MessageReceiptCountGetRequest message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptCountGetRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageReceiptCountGetRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.seqId != null && message.hasOwnProperty("seqId")) {
                        if (!Array.isArray(message.seqId))
                            return "seqId: array expected";
                        for (let i = 0; i < message.seqId.length; ++i)
                            if (!$util.isInteger(message.seqId[i]) && !(message.seqId[i] && $util.isInteger(message.seqId[i].low) && $util.isInteger(message.seqId[i].high)))
                                return "seqId: integer|Long[] expected";
                    }
                    if (message.chatTarget != null && message.hasOwnProperty("chatTarget")) {
                        let error = $root.AcFunDanmu.Im.Message.ChatTarget.verify(message.chatTarget);
                        if (error)
                            return "chatTarget." + error;
                    }
                    return null;
                };

                /**
                 * Creates a MessageReceiptCountGetRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptCountGetRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Message.MessageReceiptCountGetRequest} MessageReceiptCountGetRequest
                 */
                MessageReceiptCountGetRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Message.MessageReceiptCountGetRequest)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Message.MessageReceiptCountGetRequest();
                    if (object.seqId) {
                        if (!Array.isArray(object.seqId))
                            throw TypeError(".AcFunDanmu.Im.Message.MessageReceiptCountGetRequest.seqId: array expected");
                        message.seqId = [];
                        for (let i = 0; i < object.seqId.length; ++i)
                            if ($util.Long)
                                (message.seqId[i] = $util.Long.fromValue(object.seqId[i])).unsigned = false;
                            else if (typeof object.seqId[i] === "string")
                                message.seqId[i] = parseInt(object.seqId[i], 10);
                            else if (typeof object.seqId[i] === "number")
                                message.seqId[i] = object.seqId[i];
                            else if (typeof object.seqId[i] === "object")
                                message.seqId[i] = new $util.LongBits(object.seqId[i].low >>> 0, object.seqId[i].high >>> 0).toNumber();
                    }
                    if (object.chatTarget != null) {
                        if (typeof object.chatTarget !== "object")
                            throw TypeError(".AcFunDanmu.Im.Message.MessageReceiptCountGetRequest.chatTarget: object expected");
                        message.chatTarget = $root.AcFunDanmu.Im.Message.ChatTarget.fromObject(object.chatTarget);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a MessageReceiptCountGetRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptCountGetRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.MessageReceiptCountGetRequest} message MessageReceiptCountGetRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageReceiptCountGetRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.seqId = [];
                    if (options.defaults)
                        object.chatTarget = null;
                    if (message.seqId && message.seqId.length) {
                        object.seqId = [];
                        for (let j = 0; j < message.seqId.length; ++j)
                            if (typeof message.seqId[j] === "number")
                                object.seqId[j] = options.longs === String ? String(message.seqId[j]) : message.seqId[j];
                            else
                                object.seqId[j] = options.longs === String ? $util.Long.prototype.toString.call(message.seqId[j]) : options.longs === Number ? new $util.LongBits(message.seqId[j].low >>> 0, message.seqId[j].high >>> 0).toNumber() : message.seqId[j];
                    }
                    if (message.chatTarget != null && message.hasOwnProperty("chatTarget"))
                        object.chatTarget = $root.AcFunDanmu.Im.Message.ChatTarget.toObject(message.chatTarget, options);
                    return object;
                };

                /**
                 * Converts this MessageReceiptCountGetRequest to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptCountGetRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageReceiptCountGetRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return MessageReceiptCountGetRequest;
            })();

            Message.MessageReceiptCountGetResponse = (function() {

                /**
                 * Properties of a MessageReceiptCountGetResponse.
                 * @memberof AcFunDanmu.Im.Message
                 * @interface IMessageReceiptCountGetResponse
                 * @property {Array.<AcFunDanmu.Im.Message.IMessageReceiptStatus>|null} [status] MessageReceiptCountGetResponse status
                 */

                /**
                 * Constructs a new MessageReceiptCountGetResponse.
                 * @memberof AcFunDanmu.Im.Message
                 * @classdesc Represents a MessageReceiptCountGetResponse.
                 * @implements IMessageReceiptCountGetResponse
                 * @constructor
                 * @param {AcFunDanmu.Im.Message.IMessageReceiptCountGetResponse=} [properties] Properties to set
                 */
                function MessageReceiptCountGetResponse(properties) {
                    this.status = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MessageReceiptCountGetResponse status.
                 * @member {Array.<AcFunDanmu.Im.Message.IMessageReceiptStatus>} status
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptCountGetResponse
                 * @instance
                 */
                MessageReceiptCountGetResponse.prototype.status = $util.emptyArray;

                /**
                 * Creates a new MessageReceiptCountGetResponse instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptCountGetResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageReceiptCountGetResponse=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Message.MessageReceiptCountGetResponse} MessageReceiptCountGetResponse instance
                 */
                MessageReceiptCountGetResponse.create = function create(properties) {
                    return new MessageReceiptCountGetResponse(properties);
                };

                /**
                 * Encodes the specified MessageReceiptCountGetResponse message. Does not implicitly {@link AcFunDanmu.Im.Message.MessageReceiptCountGetResponse.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptCountGetResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageReceiptCountGetResponse} message MessageReceiptCountGetResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageReceiptCountGetResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.status != null && message.status.length)
                        for (let i = 0; i < message.status.length; ++i)
                            $root.AcFunDanmu.Im.Message.MessageReceiptStatus.encode(message.status[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified MessageReceiptCountGetResponse message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Message.MessageReceiptCountGetResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptCountGetResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageReceiptCountGetResponse} message MessageReceiptCountGetResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageReceiptCountGetResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MessageReceiptCountGetResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptCountGetResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Message.MessageReceiptCountGetResponse} MessageReceiptCountGetResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageReceiptCountGetResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Message.MessageReceiptCountGetResponse();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.status && message.status.length))
                                message.status = [];
                            message.status.push($root.AcFunDanmu.Im.Message.MessageReceiptStatus.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MessageReceiptCountGetResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptCountGetResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Message.MessageReceiptCountGetResponse} MessageReceiptCountGetResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageReceiptCountGetResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MessageReceiptCountGetResponse message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptCountGetResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageReceiptCountGetResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.status != null && message.hasOwnProperty("status")) {
                        if (!Array.isArray(message.status))
                            return "status: array expected";
                        for (let i = 0; i < message.status.length; ++i) {
                            let error = $root.AcFunDanmu.Im.Message.MessageReceiptStatus.verify(message.status[i]);
                            if (error)
                                return "status." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a MessageReceiptCountGetResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptCountGetResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Message.MessageReceiptCountGetResponse} MessageReceiptCountGetResponse
                 */
                MessageReceiptCountGetResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Message.MessageReceiptCountGetResponse)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Message.MessageReceiptCountGetResponse();
                    if (object.status) {
                        if (!Array.isArray(object.status))
                            throw TypeError(".AcFunDanmu.Im.Message.MessageReceiptCountGetResponse.status: array expected");
                        message.status = [];
                        for (let i = 0; i < object.status.length; ++i) {
                            if (typeof object.status[i] !== "object")
                                throw TypeError(".AcFunDanmu.Im.Message.MessageReceiptCountGetResponse.status: object expected");
                            message.status[i] = $root.AcFunDanmu.Im.Message.MessageReceiptStatus.fromObject(object.status[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a MessageReceiptCountGetResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptCountGetResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.MessageReceiptCountGetResponse} message MessageReceiptCountGetResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageReceiptCountGetResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.status = [];
                    if (message.status && message.status.length) {
                        object.status = [];
                        for (let j = 0; j < message.status.length; ++j)
                            object.status[j] = $root.AcFunDanmu.Im.Message.MessageReceiptStatus.toObject(message.status[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this MessageReceiptCountGetResponse to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptCountGetResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageReceiptCountGetResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return MessageReceiptCountGetResponse;
            })();

            Message.MessageReceiptStatus = (function() {

                /**
                 * Properties of a MessageReceiptStatus.
                 * @memberof AcFunDanmu.Im.Message
                 * @interface IMessageReceiptStatus
                 * @property {number|null} [readCount] MessageReceiptStatus readCount
                 * @property {number|null} [unreadCount] MessageReceiptStatus unreadCount
                 * @property {number|Long|null} [seqId] MessageReceiptStatus seqId
                 * @property {number|Long|null} [serverTime] MessageReceiptStatus serverTime
                 */

                /**
                 * Constructs a new MessageReceiptStatus.
                 * @memberof AcFunDanmu.Im.Message
                 * @classdesc Represents a MessageReceiptStatus.
                 * @implements IMessageReceiptStatus
                 * @constructor
                 * @param {AcFunDanmu.Im.Message.IMessageReceiptStatus=} [properties] Properties to set
                 */
                function MessageReceiptStatus(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MessageReceiptStatus readCount.
                 * @member {number} readCount
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptStatus
                 * @instance
                 */
                MessageReceiptStatus.prototype.readCount = 0;

                /**
                 * MessageReceiptStatus unreadCount.
                 * @member {number} unreadCount
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptStatus
                 * @instance
                 */
                MessageReceiptStatus.prototype.unreadCount = 0;

                /**
                 * MessageReceiptStatus seqId.
                 * @member {number|Long} seqId
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptStatus
                 * @instance
                 */
                MessageReceiptStatus.prototype.seqId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * MessageReceiptStatus serverTime.
                 * @member {number|Long} serverTime
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptStatus
                 * @instance
                 */
                MessageReceiptStatus.prototype.serverTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Creates a new MessageReceiptStatus instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptStatus
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageReceiptStatus=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Message.MessageReceiptStatus} MessageReceiptStatus instance
                 */
                MessageReceiptStatus.create = function create(properties) {
                    return new MessageReceiptStatus(properties);
                };

                /**
                 * Encodes the specified MessageReceiptStatus message. Does not implicitly {@link AcFunDanmu.Im.Message.MessageReceiptStatus.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptStatus
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageReceiptStatus} message MessageReceiptStatus message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageReceiptStatus.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.readCount != null && Object.hasOwnProperty.call(message, "readCount"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.readCount);
                    if (message.unreadCount != null && Object.hasOwnProperty.call(message, "unreadCount"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.unreadCount);
                    if (message.seqId != null && Object.hasOwnProperty.call(message, "seqId"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int64(message.seqId);
                    if (message.serverTime != null && Object.hasOwnProperty.call(message, "serverTime"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int64(message.serverTime);
                    return writer;
                };

                /**
                 * Encodes the specified MessageReceiptStatus message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Message.MessageReceiptStatus.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptStatus
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageReceiptStatus} message MessageReceiptStatus message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageReceiptStatus.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MessageReceiptStatus message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptStatus
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Message.MessageReceiptStatus} MessageReceiptStatus
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageReceiptStatus.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Message.MessageReceiptStatus();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.readCount = reader.int32();
                            break;
                        case 2:
                            message.unreadCount = reader.int32();
                            break;
                        case 3:
                            message.seqId = reader.int64();
                            break;
                        case 4:
                            message.serverTime = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MessageReceiptStatus message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptStatus
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Message.MessageReceiptStatus} MessageReceiptStatus
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageReceiptStatus.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MessageReceiptStatus message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptStatus
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageReceiptStatus.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.readCount != null && message.hasOwnProperty("readCount"))
                        if (!$util.isInteger(message.readCount))
                            return "readCount: integer expected";
                    if (message.unreadCount != null && message.hasOwnProperty("unreadCount"))
                        if (!$util.isInteger(message.unreadCount))
                            return "unreadCount: integer expected";
                    if (message.seqId != null && message.hasOwnProperty("seqId"))
                        if (!$util.isInteger(message.seqId) && !(message.seqId && $util.isInteger(message.seqId.low) && $util.isInteger(message.seqId.high)))
                            return "seqId: integer|Long expected";
                    if (message.serverTime != null && message.hasOwnProperty("serverTime"))
                        if (!$util.isInteger(message.serverTime) && !(message.serverTime && $util.isInteger(message.serverTime.low) && $util.isInteger(message.serverTime.high)))
                            return "serverTime: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a MessageReceiptStatus message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptStatus
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Message.MessageReceiptStatus} MessageReceiptStatus
                 */
                MessageReceiptStatus.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Message.MessageReceiptStatus)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Message.MessageReceiptStatus();
                    if (object.readCount != null)
                        message.readCount = object.readCount | 0;
                    if (object.unreadCount != null)
                        message.unreadCount = object.unreadCount | 0;
                    if (object.seqId != null)
                        if ($util.Long)
                            (message.seqId = $util.Long.fromValue(object.seqId)).unsigned = false;
                        else if (typeof object.seqId === "string")
                            message.seqId = parseInt(object.seqId, 10);
                        else if (typeof object.seqId === "number")
                            message.seqId = object.seqId;
                        else if (typeof object.seqId === "object")
                            message.seqId = new $util.LongBits(object.seqId.low >>> 0, object.seqId.high >>> 0).toNumber();
                    if (object.serverTime != null)
                        if ($util.Long)
                            (message.serverTime = $util.Long.fromValue(object.serverTime)).unsigned = false;
                        else if (typeof object.serverTime === "string")
                            message.serverTime = parseInt(object.serverTime, 10);
                        else if (typeof object.serverTime === "number")
                            message.serverTime = object.serverTime;
                        else if (typeof object.serverTime === "object")
                            message.serverTime = new $util.LongBits(object.serverTime.low >>> 0, object.serverTime.high >>> 0).toNumber();
                    return message;
                };

                /**
                 * Creates a plain object from a MessageReceiptStatus message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptStatus
                 * @static
                 * @param {AcFunDanmu.Im.Message.MessageReceiptStatus} message MessageReceiptStatus
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageReceiptStatus.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.readCount = 0;
                        object.unreadCount = 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.seqId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.seqId = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.serverTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.serverTime = options.longs === String ? "0" : 0;
                    }
                    if (message.readCount != null && message.hasOwnProperty("readCount"))
                        object.readCount = message.readCount;
                    if (message.unreadCount != null && message.hasOwnProperty("unreadCount"))
                        object.unreadCount = message.unreadCount;
                    if (message.seqId != null && message.hasOwnProperty("seqId"))
                        if (typeof message.seqId === "number")
                            object.seqId = options.longs === String ? String(message.seqId) : message.seqId;
                        else
                            object.seqId = options.longs === String ? $util.Long.prototype.toString.call(message.seqId) : options.longs === Number ? new $util.LongBits(message.seqId.low >>> 0, message.seqId.high >>> 0).toNumber() : message.seqId;
                    if (message.serverTime != null && message.hasOwnProperty("serverTime"))
                        if (typeof message.serverTime === "number")
                            object.serverTime = options.longs === String ? String(message.serverTime) : message.serverTime;
                        else
                            object.serverTime = options.longs === String ? $util.Long.prototype.toString.call(message.serverTime) : options.longs === Number ? new $util.LongBits(message.serverTime.low >>> 0, message.serverTime.high >>> 0).toNumber() : message.serverTime;
                    return object;
                };

                /**
                 * Converts this MessageReceiptStatus to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptStatus
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageReceiptStatus.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return MessageReceiptStatus;
            })();

            Message.MessageReceiptDetailGetRequest = (function() {

                /**
                 * Properties of a MessageReceiptDetailGetRequest.
                 * @memberof AcFunDanmu.Im.Message
                 * @interface IMessageReceiptDetailGetRequest
                 * @property {number|Long|null} [seqId] MessageReceiptDetailGetRequest seqId
                 * @property {AcFunDanmu.Im.Message.IChatTarget|null} [chatTarget] MessageReceiptDetailGetRequest chatTarget
                 */

                /**
                 * Constructs a new MessageReceiptDetailGetRequest.
                 * @memberof AcFunDanmu.Im.Message
                 * @classdesc Represents a MessageReceiptDetailGetRequest.
                 * @implements IMessageReceiptDetailGetRequest
                 * @constructor
                 * @param {AcFunDanmu.Im.Message.IMessageReceiptDetailGetRequest=} [properties] Properties to set
                 */
                function MessageReceiptDetailGetRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MessageReceiptDetailGetRequest seqId.
                 * @member {number|Long} seqId
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptDetailGetRequest
                 * @instance
                 */
                MessageReceiptDetailGetRequest.prototype.seqId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * MessageReceiptDetailGetRequest chatTarget.
                 * @member {AcFunDanmu.Im.Message.IChatTarget|null|undefined} chatTarget
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptDetailGetRequest
                 * @instance
                 */
                MessageReceiptDetailGetRequest.prototype.chatTarget = null;

                /**
                 * Creates a new MessageReceiptDetailGetRequest instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptDetailGetRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageReceiptDetailGetRequest=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Message.MessageReceiptDetailGetRequest} MessageReceiptDetailGetRequest instance
                 */
                MessageReceiptDetailGetRequest.create = function create(properties) {
                    return new MessageReceiptDetailGetRequest(properties);
                };

                /**
                 * Encodes the specified MessageReceiptDetailGetRequest message. Does not implicitly {@link AcFunDanmu.Im.Message.MessageReceiptDetailGetRequest.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptDetailGetRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageReceiptDetailGetRequest} message MessageReceiptDetailGetRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageReceiptDetailGetRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.seqId != null && Object.hasOwnProperty.call(message, "seqId"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int64(message.seqId);
                    if (message.chatTarget != null && Object.hasOwnProperty.call(message, "chatTarget"))
                        $root.AcFunDanmu.Im.Message.ChatTarget.encode(message.chatTarget, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified MessageReceiptDetailGetRequest message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Message.MessageReceiptDetailGetRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptDetailGetRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageReceiptDetailGetRequest} message MessageReceiptDetailGetRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageReceiptDetailGetRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MessageReceiptDetailGetRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptDetailGetRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Message.MessageReceiptDetailGetRequest} MessageReceiptDetailGetRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageReceiptDetailGetRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Message.MessageReceiptDetailGetRequest();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.seqId = reader.int64();
                            break;
                        case 2:
                            message.chatTarget = $root.AcFunDanmu.Im.Message.ChatTarget.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MessageReceiptDetailGetRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptDetailGetRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Message.MessageReceiptDetailGetRequest} MessageReceiptDetailGetRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageReceiptDetailGetRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MessageReceiptDetailGetRequest message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptDetailGetRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageReceiptDetailGetRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.seqId != null && message.hasOwnProperty("seqId"))
                        if (!$util.isInteger(message.seqId) && !(message.seqId && $util.isInteger(message.seqId.low) && $util.isInteger(message.seqId.high)))
                            return "seqId: integer|Long expected";
                    if (message.chatTarget != null && message.hasOwnProperty("chatTarget")) {
                        let error = $root.AcFunDanmu.Im.Message.ChatTarget.verify(message.chatTarget);
                        if (error)
                            return "chatTarget." + error;
                    }
                    return null;
                };

                /**
                 * Creates a MessageReceiptDetailGetRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptDetailGetRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Message.MessageReceiptDetailGetRequest} MessageReceiptDetailGetRequest
                 */
                MessageReceiptDetailGetRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Message.MessageReceiptDetailGetRequest)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Message.MessageReceiptDetailGetRequest();
                    if (object.seqId != null)
                        if ($util.Long)
                            (message.seqId = $util.Long.fromValue(object.seqId)).unsigned = false;
                        else if (typeof object.seqId === "string")
                            message.seqId = parseInt(object.seqId, 10);
                        else if (typeof object.seqId === "number")
                            message.seqId = object.seqId;
                        else if (typeof object.seqId === "object")
                            message.seqId = new $util.LongBits(object.seqId.low >>> 0, object.seqId.high >>> 0).toNumber();
                    if (object.chatTarget != null) {
                        if (typeof object.chatTarget !== "object")
                            throw TypeError(".AcFunDanmu.Im.Message.MessageReceiptDetailGetRequest.chatTarget: object expected");
                        message.chatTarget = $root.AcFunDanmu.Im.Message.ChatTarget.fromObject(object.chatTarget);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a MessageReceiptDetailGetRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptDetailGetRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.MessageReceiptDetailGetRequest} message MessageReceiptDetailGetRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageReceiptDetailGetRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.seqId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.seqId = options.longs === String ? "0" : 0;
                        object.chatTarget = null;
                    }
                    if (message.seqId != null && message.hasOwnProperty("seqId"))
                        if (typeof message.seqId === "number")
                            object.seqId = options.longs === String ? String(message.seqId) : message.seqId;
                        else
                            object.seqId = options.longs === String ? $util.Long.prototype.toString.call(message.seqId) : options.longs === Number ? new $util.LongBits(message.seqId.low >>> 0, message.seqId.high >>> 0).toNumber() : message.seqId;
                    if (message.chatTarget != null && message.hasOwnProperty("chatTarget"))
                        object.chatTarget = $root.AcFunDanmu.Im.Message.ChatTarget.toObject(message.chatTarget, options);
                    return object;
                };

                /**
                 * Converts this MessageReceiptDetailGetRequest to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptDetailGetRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageReceiptDetailGetRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return MessageReceiptDetailGetRequest;
            })();

            Message.MessageReceiptDetailGetResponse = (function() {

                /**
                 * Properties of a MessageReceiptDetailGetResponse.
                 * @memberof AcFunDanmu.Im.Message
                 * @interface IMessageReceiptDetailGetResponse
                 * @property {Array.<AcFunDanmu.Im.Basic.IUser>|null} [readUser] MessageReceiptDetailGetResponse readUser
                 * @property {Array.<AcFunDanmu.Im.Basic.IUser>|null} [unreadUser] MessageReceiptDetailGetResponse unreadUser
                 */

                /**
                 * Constructs a new MessageReceiptDetailGetResponse.
                 * @memberof AcFunDanmu.Im.Message
                 * @classdesc Represents a MessageReceiptDetailGetResponse.
                 * @implements IMessageReceiptDetailGetResponse
                 * @constructor
                 * @param {AcFunDanmu.Im.Message.IMessageReceiptDetailGetResponse=} [properties] Properties to set
                 */
                function MessageReceiptDetailGetResponse(properties) {
                    this.readUser = [];
                    this.unreadUser = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MessageReceiptDetailGetResponse readUser.
                 * @member {Array.<AcFunDanmu.Im.Basic.IUser>} readUser
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptDetailGetResponse
                 * @instance
                 */
                MessageReceiptDetailGetResponse.prototype.readUser = $util.emptyArray;

                /**
                 * MessageReceiptDetailGetResponse unreadUser.
                 * @member {Array.<AcFunDanmu.Im.Basic.IUser>} unreadUser
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptDetailGetResponse
                 * @instance
                 */
                MessageReceiptDetailGetResponse.prototype.unreadUser = $util.emptyArray;

                /**
                 * Creates a new MessageReceiptDetailGetResponse instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptDetailGetResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageReceiptDetailGetResponse=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Message.MessageReceiptDetailGetResponse} MessageReceiptDetailGetResponse instance
                 */
                MessageReceiptDetailGetResponse.create = function create(properties) {
                    return new MessageReceiptDetailGetResponse(properties);
                };

                /**
                 * Encodes the specified MessageReceiptDetailGetResponse message. Does not implicitly {@link AcFunDanmu.Im.Message.MessageReceiptDetailGetResponse.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptDetailGetResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageReceiptDetailGetResponse} message MessageReceiptDetailGetResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageReceiptDetailGetResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.readUser != null && message.readUser.length)
                        for (let i = 0; i < message.readUser.length; ++i)
                            $root.AcFunDanmu.Im.Basic.User.encode(message.readUser[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.unreadUser != null && message.unreadUser.length)
                        for (let i = 0; i < message.unreadUser.length; ++i)
                            $root.AcFunDanmu.Im.Basic.User.encode(message.unreadUser[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified MessageReceiptDetailGetResponse message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Message.MessageReceiptDetailGetResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptDetailGetResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageReceiptDetailGetResponse} message MessageReceiptDetailGetResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageReceiptDetailGetResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MessageReceiptDetailGetResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptDetailGetResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Message.MessageReceiptDetailGetResponse} MessageReceiptDetailGetResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageReceiptDetailGetResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Message.MessageReceiptDetailGetResponse();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.readUser && message.readUser.length))
                                message.readUser = [];
                            message.readUser.push($root.AcFunDanmu.Im.Basic.User.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            if (!(message.unreadUser && message.unreadUser.length))
                                message.unreadUser = [];
                            message.unreadUser.push($root.AcFunDanmu.Im.Basic.User.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MessageReceiptDetailGetResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptDetailGetResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Message.MessageReceiptDetailGetResponse} MessageReceiptDetailGetResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageReceiptDetailGetResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MessageReceiptDetailGetResponse message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptDetailGetResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageReceiptDetailGetResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.readUser != null && message.hasOwnProperty("readUser")) {
                        if (!Array.isArray(message.readUser))
                            return "readUser: array expected";
                        for (let i = 0; i < message.readUser.length; ++i) {
                            let error = $root.AcFunDanmu.Im.Basic.User.verify(message.readUser[i]);
                            if (error)
                                return "readUser." + error;
                        }
                    }
                    if (message.unreadUser != null && message.hasOwnProperty("unreadUser")) {
                        if (!Array.isArray(message.unreadUser))
                            return "unreadUser: array expected";
                        for (let i = 0; i < message.unreadUser.length; ++i) {
                            let error = $root.AcFunDanmu.Im.Basic.User.verify(message.unreadUser[i]);
                            if (error)
                                return "unreadUser." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a MessageReceiptDetailGetResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptDetailGetResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Message.MessageReceiptDetailGetResponse} MessageReceiptDetailGetResponse
                 */
                MessageReceiptDetailGetResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Message.MessageReceiptDetailGetResponse)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Message.MessageReceiptDetailGetResponse();
                    if (object.readUser) {
                        if (!Array.isArray(object.readUser))
                            throw TypeError(".AcFunDanmu.Im.Message.MessageReceiptDetailGetResponse.readUser: array expected");
                        message.readUser = [];
                        for (let i = 0; i < object.readUser.length; ++i) {
                            if (typeof object.readUser[i] !== "object")
                                throw TypeError(".AcFunDanmu.Im.Message.MessageReceiptDetailGetResponse.readUser: object expected");
                            message.readUser[i] = $root.AcFunDanmu.Im.Basic.User.fromObject(object.readUser[i]);
                        }
                    }
                    if (object.unreadUser) {
                        if (!Array.isArray(object.unreadUser))
                            throw TypeError(".AcFunDanmu.Im.Message.MessageReceiptDetailGetResponse.unreadUser: array expected");
                        message.unreadUser = [];
                        for (let i = 0; i < object.unreadUser.length; ++i) {
                            if (typeof object.unreadUser[i] !== "object")
                                throw TypeError(".AcFunDanmu.Im.Message.MessageReceiptDetailGetResponse.unreadUser: object expected");
                            message.unreadUser[i] = $root.AcFunDanmu.Im.Basic.User.fromObject(object.unreadUser[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a MessageReceiptDetailGetResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptDetailGetResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.MessageReceiptDetailGetResponse} message MessageReceiptDetailGetResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageReceiptDetailGetResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults) {
                        object.readUser = [];
                        object.unreadUser = [];
                    }
                    if (message.readUser && message.readUser.length) {
                        object.readUser = [];
                        for (let j = 0; j < message.readUser.length; ++j)
                            object.readUser[j] = $root.AcFunDanmu.Im.Basic.User.toObject(message.readUser[j], options);
                    }
                    if (message.unreadUser && message.unreadUser.length) {
                        object.unreadUser = [];
                        for (let j = 0; j < message.unreadUser.length; ++j)
                            object.unreadUser[j] = $root.AcFunDanmu.Im.Basic.User.toObject(message.unreadUser[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this MessageReceiptDetailGetResponse to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Message.MessageReceiptDetailGetResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageReceiptDetailGetResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return MessageReceiptDetailGetResponse;
            })();

            Message.MessageBatchSendRequest = (function() {

                /**
                 * Properties of a MessageBatchSendRequest.
                 * @memberof AcFunDanmu.Im.Message
                 * @interface IMessageBatchSendRequest
                 * @property {Array.<AcFunDanmu.Im.Message.IMessage>|null} [message] MessageBatchSendRequest message
                 */

                /**
                 * Constructs a new MessageBatchSendRequest.
                 * @memberof AcFunDanmu.Im.Message
                 * @classdesc Represents a MessageBatchSendRequest.
                 * @implements IMessageBatchSendRequest
                 * @constructor
                 * @param {AcFunDanmu.Im.Message.IMessageBatchSendRequest=} [properties] Properties to set
                 */
                function MessageBatchSendRequest(properties) {
                    this.message = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MessageBatchSendRequest message.
                 * @member {Array.<AcFunDanmu.Im.Message.IMessage>} message
                 * @memberof AcFunDanmu.Im.Message.MessageBatchSendRequest
                 * @instance
                 */
                MessageBatchSendRequest.prototype.message = $util.emptyArray;

                /**
                 * Creates a new MessageBatchSendRequest instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Message.MessageBatchSendRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageBatchSendRequest=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Message.MessageBatchSendRequest} MessageBatchSendRequest instance
                 */
                MessageBatchSendRequest.create = function create(properties) {
                    return new MessageBatchSendRequest(properties);
                };

                /**
                 * Encodes the specified MessageBatchSendRequest message. Does not implicitly {@link AcFunDanmu.Im.Message.MessageBatchSendRequest.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Message.MessageBatchSendRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageBatchSendRequest} message MessageBatchSendRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageBatchSendRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.message != null && message.message.length)
                        for (let i = 0; i < message.message.length; ++i)
                            $root.AcFunDanmu.Im.Message.Message.encode(message.message[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified MessageBatchSendRequest message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Message.MessageBatchSendRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Message.MessageBatchSendRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageBatchSendRequest} message MessageBatchSendRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageBatchSendRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MessageBatchSendRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Message.MessageBatchSendRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Message.MessageBatchSendRequest} MessageBatchSendRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageBatchSendRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Message.MessageBatchSendRequest();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.message && message.message.length))
                                message.message = [];
                            message.message.push($root.AcFunDanmu.Im.Message.Message.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MessageBatchSendRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Message.MessageBatchSendRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Message.MessageBatchSendRequest} MessageBatchSendRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageBatchSendRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MessageBatchSendRequest message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Message.MessageBatchSendRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageBatchSendRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.message != null && message.hasOwnProperty("message")) {
                        if (!Array.isArray(message.message))
                            return "message: array expected";
                        for (let i = 0; i < message.message.length; ++i) {
                            let error = $root.AcFunDanmu.Im.Message.Message.verify(message.message[i]);
                            if (error)
                                return "message." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a MessageBatchSendRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Message.MessageBatchSendRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Message.MessageBatchSendRequest} MessageBatchSendRequest
                 */
                MessageBatchSendRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Message.MessageBatchSendRequest)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Message.MessageBatchSendRequest();
                    if (object.message) {
                        if (!Array.isArray(object.message))
                            throw TypeError(".AcFunDanmu.Im.Message.MessageBatchSendRequest.message: array expected");
                        message.message = [];
                        for (let i = 0; i < object.message.length; ++i) {
                            if (typeof object.message[i] !== "object")
                                throw TypeError(".AcFunDanmu.Im.Message.MessageBatchSendRequest.message: object expected");
                            message.message[i] = $root.AcFunDanmu.Im.Message.Message.fromObject(object.message[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a MessageBatchSendRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Message.MessageBatchSendRequest
                 * @static
                 * @param {AcFunDanmu.Im.Message.MessageBatchSendRequest} message MessageBatchSendRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageBatchSendRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.message = [];
                    if (message.message && message.message.length) {
                        object.message = [];
                        for (let j = 0; j < message.message.length; ++j)
                            object.message[j] = $root.AcFunDanmu.Im.Message.Message.toObject(message.message[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this MessageBatchSendRequest to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Message.MessageBatchSendRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageBatchSendRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return MessageBatchSendRequest;
            })();

            Message.MessageBatchSendResponse = (function() {

                /**
                 * Properties of a MessageBatchSendResponse.
                 * @memberof AcFunDanmu.Im.Message
                 * @interface IMessageBatchSendResponse
                 * @property {Array.<AcFunDanmu.Im.Message.ISendMessageResponse>|null} [response] MessageBatchSendResponse response
                 */

                /**
                 * Constructs a new MessageBatchSendResponse.
                 * @memberof AcFunDanmu.Im.Message
                 * @classdesc Represents a MessageBatchSendResponse.
                 * @implements IMessageBatchSendResponse
                 * @constructor
                 * @param {AcFunDanmu.Im.Message.IMessageBatchSendResponse=} [properties] Properties to set
                 */
                function MessageBatchSendResponse(properties) {
                    this.response = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MessageBatchSendResponse response.
                 * @member {Array.<AcFunDanmu.Im.Message.ISendMessageResponse>} response
                 * @memberof AcFunDanmu.Im.Message.MessageBatchSendResponse
                 * @instance
                 */
                MessageBatchSendResponse.prototype.response = $util.emptyArray;

                /**
                 * Creates a new MessageBatchSendResponse instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Message.MessageBatchSendResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageBatchSendResponse=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Message.MessageBatchSendResponse} MessageBatchSendResponse instance
                 */
                MessageBatchSendResponse.create = function create(properties) {
                    return new MessageBatchSendResponse(properties);
                };

                /**
                 * Encodes the specified MessageBatchSendResponse message. Does not implicitly {@link AcFunDanmu.Im.Message.MessageBatchSendResponse.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Message.MessageBatchSendResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageBatchSendResponse} message MessageBatchSendResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageBatchSendResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.response != null && message.response.length)
                        for (let i = 0; i < message.response.length; ++i)
                            $root.AcFunDanmu.Im.Message.SendMessageResponse.encode(message.response[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified MessageBatchSendResponse message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Message.MessageBatchSendResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Message.MessageBatchSendResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.IMessageBatchSendResponse} message MessageBatchSendResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageBatchSendResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MessageBatchSendResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Message.MessageBatchSendResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Message.MessageBatchSendResponse} MessageBatchSendResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageBatchSendResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Message.MessageBatchSendResponse();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.response && message.response.length))
                                message.response = [];
                            message.response.push($root.AcFunDanmu.Im.Message.SendMessageResponse.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MessageBatchSendResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Message.MessageBatchSendResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Message.MessageBatchSendResponse} MessageBatchSendResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageBatchSendResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MessageBatchSendResponse message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Message.MessageBatchSendResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageBatchSendResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.response != null && message.hasOwnProperty("response")) {
                        if (!Array.isArray(message.response))
                            return "response: array expected";
                        for (let i = 0; i < message.response.length; ++i) {
                            let error = $root.AcFunDanmu.Im.Message.SendMessageResponse.verify(message.response[i]);
                            if (error)
                                return "response." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a MessageBatchSendResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Message.MessageBatchSendResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Message.MessageBatchSendResponse} MessageBatchSendResponse
                 */
                MessageBatchSendResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Message.MessageBatchSendResponse)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Message.MessageBatchSendResponse();
                    if (object.response) {
                        if (!Array.isArray(object.response))
                            throw TypeError(".AcFunDanmu.Im.Message.MessageBatchSendResponse.response: array expected");
                        message.response = [];
                        for (let i = 0; i < object.response.length; ++i) {
                            if (typeof object.response[i] !== "object")
                                throw TypeError(".AcFunDanmu.Im.Message.MessageBatchSendResponse.response: object expected");
                            message.response[i] = $root.AcFunDanmu.Im.Message.SendMessageResponse.fromObject(object.response[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a MessageBatchSendResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Message.MessageBatchSendResponse
                 * @static
                 * @param {AcFunDanmu.Im.Message.MessageBatchSendResponse} message MessageBatchSendResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageBatchSendResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.response = [];
                    if (message.response && message.response.length) {
                        object.response = [];
                        for (let j = 0; j < message.response.length; ++j)
                            object.response[j] = $root.AcFunDanmu.Im.Message.SendMessageResponse.toObject(message.response[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this MessageBatchSendResponse to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Message.MessageBatchSendResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageBatchSendResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return MessageBatchSendResponse;
            })();

            Message.ImageAttachment = (function() {

                /**
                 * Properties of an ImageAttachment.
                 * @memberof AcFunDanmu.Im.Message
                 * @interface IImageAttachment
                 * @property {string|null} [mimeType] ImageAttachment mimeType
                 * @property {string|null} [url] ImageAttachment url
                 * @property {number|null} [width] ImageAttachment width
                 * @property {number|null} [height] ImageAttachment height
                 * @property {number|Long|null} [lengthInBytes] ImageAttachment lengthInBytes
                 */

                /**
                 * Constructs a new ImageAttachment.
                 * @memberof AcFunDanmu.Im.Message
                 * @classdesc Represents an ImageAttachment.
                 * @implements IImageAttachment
                 * @constructor
                 * @param {AcFunDanmu.Im.Message.IImageAttachment=} [properties] Properties to set
                 */
                function ImageAttachment(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ImageAttachment mimeType.
                 * @member {string} mimeType
                 * @memberof AcFunDanmu.Im.Message.ImageAttachment
                 * @instance
                 */
                ImageAttachment.prototype.mimeType = "";

                /**
                 * ImageAttachment url.
                 * @member {string} url
                 * @memberof AcFunDanmu.Im.Message.ImageAttachment
                 * @instance
                 */
                ImageAttachment.prototype.url = "";

                /**
                 * ImageAttachment width.
                 * @member {number} width
                 * @memberof AcFunDanmu.Im.Message.ImageAttachment
                 * @instance
                 */
                ImageAttachment.prototype.width = 0;

                /**
                 * ImageAttachment height.
                 * @member {number} height
                 * @memberof AcFunDanmu.Im.Message.ImageAttachment
                 * @instance
                 */
                ImageAttachment.prototype.height = 0;

                /**
                 * ImageAttachment lengthInBytes.
                 * @member {number|Long} lengthInBytes
                 * @memberof AcFunDanmu.Im.Message.ImageAttachment
                 * @instance
                 */
                ImageAttachment.prototype.lengthInBytes = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Creates a new ImageAttachment instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Message.ImageAttachment
                 * @static
                 * @param {AcFunDanmu.Im.Message.IImageAttachment=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Message.ImageAttachment} ImageAttachment instance
                 */
                ImageAttachment.create = function create(properties) {
                    return new ImageAttachment(properties);
                };

                /**
                 * Encodes the specified ImageAttachment message. Does not implicitly {@link AcFunDanmu.Im.Message.ImageAttachment.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Message.ImageAttachment
                 * @static
                 * @param {AcFunDanmu.Im.Message.IImageAttachment} message ImageAttachment message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ImageAttachment.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.mimeType != null && Object.hasOwnProperty.call(message, "mimeType"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.mimeType);
                    if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.url);
                    if (message.width != null && Object.hasOwnProperty.call(message, "width"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.width);
                    if (message.height != null && Object.hasOwnProperty.call(message, "height"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.height);
                    if (message.lengthInBytes != null && Object.hasOwnProperty.call(message, "lengthInBytes"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int64(message.lengthInBytes);
                    return writer;
                };

                /**
                 * Encodes the specified ImageAttachment message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Message.ImageAttachment.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Message.ImageAttachment
                 * @static
                 * @param {AcFunDanmu.Im.Message.IImageAttachment} message ImageAttachment message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ImageAttachment.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an ImageAttachment message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Message.ImageAttachment
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Message.ImageAttachment} ImageAttachment
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ImageAttachment.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Message.ImageAttachment();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.mimeType = reader.string();
                            break;
                        case 2:
                            message.url = reader.string();
                            break;
                        case 3:
                            message.width = reader.int32();
                            break;
                        case 4:
                            message.height = reader.int32();
                            break;
                        case 5:
                            message.lengthInBytes = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an ImageAttachment message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Message.ImageAttachment
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Message.ImageAttachment} ImageAttachment
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ImageAttachment.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an ImageAttachment message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Message.ImageAttachment
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ImageAttachment.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.mimeType != null && message.hasOwnProperty("mimeType"))
                        if (!$util.isString(message.mimeType))
                            return "mimeType: string expected";
                    if (message.url != null && message.hasOwnProperty("url"))
                        if (!$util.isString(message.url))
                            return "url: string expected";
                    if (message.width != null && message.hasOwnProperty("width"))
                        if (!$util.isInteger(message.width))
                            return "width: integer expected";
                    if (message.height != null && message.hasOwnProperty("height"))
                        if (!$util.isInteger(message.height))
                            return "height: integer expected";
                    if (message.lengthInBytes != null && message.hasOwnProperty("lengthInBytes"))
                        if (!$util.isInteger(message.lengthInBytes) && !(message.lengthInBytes && $util.isInteger(message.lengthInBytes.low) && $util.isInteger(message.lengthInBytes.high)))
                            return "lengthInBytes: integer|Long expected";
                    return null;
                };

                /**
                 * Creates an ImageAttachment message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Message.ImageAttachment
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Message.ImageAttachment} ImageAttachment
                 */
                ImageAttachment.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Message.ImageAttachment)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Message.ImageAttachment();
                    if (object.mimeType != null)
                        message.mimeType = String(object.mimeType);
                    if (object.url != null)
                        message.url = String(object.url);
                    if (object.width != null)
                        message.width = object.width | 0;
                    if (object.height != null)
                        message.height = object.height | 0;
                    if (object.lengthInBytes != null)
                        if ($util.Long)
                            (message.lengthInBytes = $util.Long.fromValue(object.lengthInBytes)).unsigned = false;
                        else if (typeof object.lengthInBytes === "string")
                            message.lengthInBytes = parseInt(object.lengthInBytes, 10);
                        else if (typeof object.lengthInBytes === "number")
                            message.lengthInBytes = object.lengthInBytes;
                        else if (typeof object.lengthInBytes === "object")
                            message.lengthInBytes = new $util.LongBits(object.lengthInBytes.low >>> 0, object.lengthInBytes.high >>> 0).toNumber();
                    return message;
                };

                /**
                 * Creates a plain object from an ImageAttachment message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Message.ImageAttachment
                 * @static
                 * @param {AcFunDanmu.Im.Message.ImageAttachment} message ImageAttachment
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ImageAttachment.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.mimeType = "";
                        object.url = "";
                        object.width = 0;
                        object.height = 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.lengthInBytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.lengthInBytes = options.longs === String ? "0" : 0;
                    }
                    if (message.mimeType != null && message.hasOwnProperty("mimeType"))
                        object.mimeType = message.mimeType;
                    if (message.url != null && message.hasOwnProperty("url"))
                        object.url = message.url;
                    if (message.width != null && message.hasOwnProperty("width"))
                        object.width = message.width;
                    if (message.height != null && message.hasOwnProperty("height"))
                        object.height = message.height;
                    if (message.lengthInBytes != null && message.hasOwnProperty("lengthInBytes"))
                        if (typeof message.lengthInBytes === "number")
                            object.lengthInBytes = options.longs === String ? String(message.lengthInBytes) : message.lengthInBytes;
                        else
                            object.lengthInBytes = options.longs === String ? $util.Long.prototype.toString.call(message.lengthInBytes) : options.longs === Number ? new $util.LongBits(message.lengthInBytes.low >>> 0, message.lengthInBytes.high >>> 0).toNumber() : message.lengthInBytes;
                    return object;
                };

                /**
                 * Converts this ImageAttachment to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Message.ImageAttachment
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ImageAttachment.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ImageAttachment;
            })();

            Message.AudioAttachment = (function() {

                /**
                 * Properties of an AudioAttachment.
                 * @memberof AcFunDanmu.Im.Message
                 * @interface IAudioAttachment
                 * @property {string|null} [mimeType] AudioAttachment mimeType
                 * @property {string|null} [url] AudioAttachment url
                 * @property {number|null} [width] AudioAttachment width
                 * @property {number|null} [height] AudioAttachment height
                 * @property {number|Long|null} [lengthInBytes] AudioAttachment lengthInBytes
                 */

                /**
                 * Constructs a new AudioAttachment.
                 * @memberof AcFunDanmu.Im.Message
                 * @classdesc Represents an AudioAttachment.
                 * @implements IAudioAttachment
                 * @constructor
                 * @param {AcFunDanmu.Im.Message.IAudioAttachment=} [properties] Properties to set
                 */
                function AudioAttachment(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * AudioAttachment mimeType.
                 * @member {string} mimeType
                 * @memberof AcFunDanmu.Im.Message.AudioAttachment
                 * @instance
                 */
                AudioAttachment.prototype.mimeType = "";

                /**
                 * AudioAttachment url.
                 * @member {string} url
                 * @memberof AcFunDanmu.Im.Message.AudioAttachment
                 * @instance
                 */
                AudioAttachment.prototype.url = "";

                /**
                 * AudioAttachment width.
                 * @member {number} width
                 * @memberof AcFunDanmu.Im.Message.AudioAttachment
                 * @instance
                 */
                AudioAttachment.prototype.width = 0;

                /**
                 * AudioAttachment height.
                 * @member {number} height
                 * @memberof AcFunDanmu.Im.Message.AudioAttachment
                 * @instance
                 */
                AudioAttachment.prototype.height = 0;

                /**
                 * AudioAttachment lengthInBytes.
                 * @member {number|Long} lengthInBytes
                 * @memberof AcFunDanmu.Im.Message.AudioAttachment
                 * @instance
                 */
                AudioAttachment.prototype.lengthInBytes = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Creates a new AudioAttachment instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Message.AudioAttachment
                 * @static
                 * @param {AcFunDanmu.Im.Message.IAudioAttachment=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Message.AudioAttachment} AudioAttachment instance
                 */
                AudioAttachment.create = function create(properties) {
                    return new AudioAttachment(properties);
                };

                /**
                 * Encodes the specified AudioAttachment message. Does not implicitly {@link AcFunDanmu.Im.Message.AudioAttachment.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Message.AudioAttachment
                 * @static
                 * @param {AcFunDanmu.Im.Message.IAudioAttachment} message AudioAttachment message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AudioAttachment.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.mimeType != null && Object.hasOwnProperty.call(message, "mimeType"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.mimeType);
                    if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.url);
                    if (message.width != null && Object.hasOwnProperty.call(message, "width"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.width);
                    if (message.height != null && Object.hasOwnProperty.call(message, "height"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.height);
                    if (message.lengthInBytes != null && Object.hasOwnProperty.call(message, "lengthInBytes"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int64(message.lengthInBytes);
                    return writer;
                };

                /**
                 * Encodes the specified AudioAttachment message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Message.AudioAttachment.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Message.AudioAttachment
                 * @static
                 * @param {AcFunDanmu.Im.Message.IAudioAttachment} message AudioAttachment message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AudioAttachment.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an AudioAttachment message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Message.AudioAttachment
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Message.AudioAttachment} AudioAttachment
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AudioAttachment.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Message.AudioAttachment();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.mimeType = reader.string();
                            break;
                        case 2:
                            message.url = reader.string();
                            break;
                        case 3:
                            message.width = reader.int32();
                            break;
                        case 4:
                            message.height = reader.int32();
                            break;
                        case 5:
                            message.lengthInBytes = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an AudioAttachment message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Message.AudioAttachment
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Message.AudioAttachment} AudioAttachment
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AudioAttachment.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an AudioAttachment message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Message.AudioAttachment
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                AudioAttachment.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.mimeType != null && message.hasOwnProperty("mimeType"))
                        if (!$util.isString(message.mimeType))
                            return "mimeType: string expected";
                    if (message.url != null && message.hasOwnProperty("url"))
                        if (!$util.isString(message.url))
                            return "url: string expected";
                    if (message.width != null && message.hasOwnProperty("width"))
                        if (!$util.isInteger(message.width))
                            return "width: integer expected";
                    if (message.height != null && message.hasOwnProperty("height"))
                        if (!$util.isInteger(message.height))
                            return "height: integer expected";
                    if (message.lengthInBytes != null && message.hasOwnProperty("lengthInBytes"))
                        if (!$util.isInteger(message.lengthInBytes) && !(message.lengthInBytes && $util.isInteger(message.lengthInBytes.low) && $util.isInteger(message.lengthInBytes.high)))
                            return "lengthInBytes: integer|Long expected";
                    return null;
                };

                /**
                 * Creates an AudioAttachment message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Message.AudioAttachment
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Message.AudioAttachment} AudioAttachment
                 */
                AudioAttachment.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Message.AudioAttachment)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Message.AudioAttachment();
                    if (object.mimeType != null)
                        message.mimeType = String(object.mimeType);
                    if (object.url != null)
                        message.url = String(object.url);
                    if (object.width != null)
                        message.width = object.width | 0;
                    if (object.height != null)
                        message.height = object.height | 0;
                    if (object.lengthInBytes != null)
                        if ($util.Long)
                            (message.lengthInBytes = $util.Long.fromValue(object.lengthInBytes)).unsigned = false;
                        else if (typeof object.lengthInBytes === "string")
                            message.lengthInBytes = parseInt(object.lengthInBytes, 10);
                        else if (typeof object.lengthInBytes === "number")
                            message.lengthInBytes = object.lengthInBytes;
                        else if (typeof object.lengthInBytes === "object")
                            message.lengthInBytes = new $util.LongBits(object.lengthInBytes.low >>> 0, object.lengthInBytes.high >>> 0).toNumber();
                    return message;
                };

                /**
                 * Creates a plain object from an AudioAttachment message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Message.AudioAttachment
                 * @static
                 * @param {AcFunDanmu.Im.Message.AudioAttachment} message AudioAttachment
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                AudioAttachment.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.mimeType = "";
                        object.url = "";
                        object.width = 0;
                        object.height = 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.lengthInBytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.lengthInBytes = options.longs === String ? "0" : 0;
                    }
                    if (message.mimeType != null && message.hasOwnProperty("mimeType"))
                        object.mimeType = message.mimeType;
                    if (message.url != null && message.hasOwnProperty("url"))
                        object.url = message.url;
                    if (message.width != null && message.hasOwnProperty("width"))
                        object.width = message.width;
                    if (message.height != null && message.hasOwnProperty("height"))
                        object.height = message.height;
                    if (message.lengthInBytes != null && message.hasOwnProperty("lengthInBytes"))
                        if (typeof message.lengthInBytes === "number")
                            object.lengthInBytes = options.longs === String ? String(message.lengthInBytes) : message.lengthInBytes;
                        else
                            object.lengthInBytes = options.longs === String ? $util.Long.prototype.toString.call(message.lengthInBytes) : options.longs === Number ? new $util.LongBits(message.lengthInBytes.low >>> 0, message.lengthInBytes.high >>> 0).toNumber() : message.lengthInBytes;
                    return object;
                };

                /**
                 * Converts this AudioAttachment to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Message.AudioAttachment
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                AudioAttachment.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return AudioAttachment;
            })();

            Message.GifAttachment = (function() {

                /**
                 * Properties of a GifAttachment.
                 * @memberof AcFunDanmu.Im.Message
                 * @interface IGifAttachment
                 * @property {string|null} [mimeType] GifAttachment mimeType
                 * @property {string|null} [url] GifAttachment url
                 * @property {number|null} [width] GifAttachment width
                 * @property {number|null} [height] GifAttachment height
                 * @property {string|null} [thumbaUrl] GifAttachment thumbaUrl
                 * @property {string|null} [text] GifAttachment text
                 */

                /**
                 * Constructs a new GifAttachment.
                 * @memberof AcFunDanmu.Im.Message
                 * @classdesc Represents a GifAttachment.
                 * @implements IGifAttachment
                 * @constructor
                 * @param {AcFunDanmu.Im.Message.IGifAttachment=} [properties] Properties to set
                 */
                function GifAttachment(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GifAttachment mimeType.
                 * @member {string} mimeType
                 * @memberof AcFunDanmu.Im.Message.GifAttachment
                 * @instance
                 */
                GifAttachment.prototype.mimeType = "";

                /**
                 * GifAttachment url.
                 * @member {string} url
                 * @memberof AcFunDanmu.Im.Message.GifAttachment
                 * @instance
                 */
                GifAttachment.prototype.url = "";

                /**
                 * GifAttachment width.
                 * @member {number} width
                 * @memberof AcFunDanmu.Im.Message.GifAttachment
                 * @instance
                 */
                GifAttachment.prototype.width = 0;

                /**
                 * GifAttachment height.
                 * @member {number} height
                 * @memberof AcFunDanmu.Im.Message.GifAttachment
                 * @instance
                 */
                GifAttachment.prototype.height = 0;

                /**
                 * GifAttachment thumbaUrl.
                 * @member {string} thumbaUrl
                 * @memberof AcFunDanmu.Im.Message.GifAttachment
                 * @instance
                 */
                GifAttachment.prototype.thumbaUrl = "";

                /**
                 * GifAttachment text.
                 * @member {string} text
                 * @memberof AcFunDanmu.Im.Message.GifAttachment
                 * @instance
                 */
                GifAttachment.prototype.text = "";

                /**
                 * Creates a new GifAttachment instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Message.GifAttachment
                 * @static
                 * @param {AcFunDanmu.Im.Message.IGifAttachment=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Message.GifAttachment} GifAttachment instance
                 */
                GifAttachment.create = function create(properties) {
                    return new GifAttachment(properties);
                };

                /**
                 * Encodes the specified GifAttachment message. Does not implicitly {@link AcFunDanmu.Im.Message.GifAttachment.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Message.GifAttachment
                 * @static
                 * @param {AcFunDanmu.Im.Message.IGifAttachment} message GifAttachment message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GifAttachment.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.mimeType != null && Object.hasOwnProperty.call(message, "mimeType"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.mimeType);
                    if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.url);
                    if (message.width != null && Object.hasOwnProperty.call(message, "width"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.width);
                    if (message.height != null && Object.hasOwnProperty.call(message, "height"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.height);
                    if (message.thumbaUrl != null && Object.hasOwnProperty.call(message, "thumbaUrl"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.thumbaUrl);
                    if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.text);
                    return writer;
                };

                /**
                 * Encodes the specified GifAttachment message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Message.GifAttachment.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Message.GifAttachment
                 * @static
                 * @param {AcFunDanmu.Im.Message.IGifAttachment} message GifAttachment message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GifAttachment.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a GifAttachment message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Message.GifAttachment
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Message.GifAttachment} GifAttachment
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GifAttachment.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Message.GifAttachment();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.mimeType = reader.string();
                            break;
                        case 2:
                            message.url = reader.string();
                            break;
                        case 3:
                            message.width = reader.int32();
                            break;
                        case 4:
                            message.height = reader.int32();
                            break;
                        case 5:
                            message.thumbaUrl = reader.string();
                            break;
                        case 6:
                            message.text = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a GifAttachment message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Message.GifAttachment
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Message.GifAttachment} GifAttachment
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GifAttachment.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a GifAttachment message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Message.GifAttachment
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GifAttachment.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.mimeType != null && message.hasOwnProperty("mimeType"))
                        if (!$util.isString(message.mimeType))
                            return "mimeType: string expected";
                    if (message.url != null && message.hasOwnProperty("url"))
                        if (!$util.isString(message.url))
                            return "url: string expected";
                    if (message.width != null && message.hasOwnProperty("width"))
                        if (!$util.isInteger(message.width))
                            return "width: integer expected";
                    if (message.height != null && message.hasOwnProperty("height"))
                        if (!$util.isInteger(message.height))
                            return "height: integer expected";
                    if (message.thumbaUrl != null && message.hasOwnProperty("thumbaUrl"))
                        if (!$util.isString(message.thumbaUrl))
                            return "thumbaUrl: string expected";
                    if (message.text != null && message.hasOwnProperty("text"))
                        if (!$util.isString(message.text))
                            return "text: string expected";
                    return null;
                };

                /**
                 * Creates a GifAttachment message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Message.GifAttachment
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Message.GifAttachment} GifAttachment
                 */
                GifAttachment.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Message.GifAttachment)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Message.GifAttachment();
                    if (object.mimeType != null)
                        message.mimeType = String(object.mimeType);
                    if (object.url != null)
                        message.url = String(object.url);
                    if (object.width != null)
                        message.width = object.width | 0;
                    if (object.height != null)
                        message.height = object.height | 0;
                    if (object.thumbaUrl != null)
                        message.thumbaUrl = String(object.thumbaUrl);
                    if (object.text != null)
                        message.text = String(object.text);
                    return message;
                };

                /**
                 * Creates a plain object from a GifAttachment message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Message.GifAttachment
                 * @static
                 * @param {AcFunDanmu.Im.Message.GifAttachment} message GifAttachment
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GifAttachment.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.mimeType = "";
                        object.url = "";
                        object.width = 0;
                        object.height = 0;
                        object.thumbaUrl = "";
                        object.text = "";
                    }
                    if (message.mimeType != null && message.hasOwnProperty("mimeType"))
                        object.mimeType = message.mimeType;
                    if (message.url != null && message.hasOwnProperty("url"))
                        object.url = message.url;
                    if (message.width != null && message.hasOwnProperty("width"))
                        object.width = message.width;
                    if (message.height != null && message.hasOwnProperty("height"))
                        object.height = message.height;
                    if (message.thumbaUrl != null && message.hasOwnProperty("thumbaUrl"))
                        object.thumbaUrl = message.thumbaUrl;
                    if (message.text != null && message.hasOwnProperty("text"))
                        object.text = message.text;
                    return object;
                };

                /**
                 * Converts this GifAttachment to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Message.GifAttachment
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GifAttachment.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return GifAttachment;
            })();

            Message.Attachment = (function() {

                /**
                 * Properties of an Attachment.
                 * @memberof AcFunDanmu.Im.Message
                 * @interface IAttachment
                 * @property {AcFunDanmu.Im.Message.IImageAttachment|null} [imageAttachment] Attachment imageAttachment
                 * @property {AcFunDanmu.Im.Message.IAudioAttachment|null} [audioAttachment] Attachment audioAttachment
                 */

                /**
                 * Constructs a new Attachment.
                 * @memberof AcFunDanmu.Im.Message
                 * @classdesc Represents an Attachment.
                 * @implements IAttachment
                 * @constructor
                 * @param {AcFunDanmu.Im.Message.IAttachment=} [properties] Properties to set
                 */
                function Attachment(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Attachment imageAttachment.
                 * @member {AcFunDanmu.Im.Message.IImageAttachment|null|undefined} imageAttachment
                 * @memberof AcFunDanmu.Im.Message.Attachment
                 * @instance
                 */
                Attachment.prototype.imageAttachment = null;

                /**
                 * Attachment audioAttachment.
                 * @member {AcFunDanmu.Im.Message.IAudioAttachment|null|undefined} audioAttachment
                 * @memberof AcFunDanmu.Im.Message.Attachment
                 * @instance
                 */
                Attachment.prototype.audioAttachment = null;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * Attachment attacmnent.
                 * @member {"imageAttachment"|"audioAttachment"|undefined} attacmnent
                 * @memberof AcFunDanmu.Im.Message.Attachment
                 * @instance
                 */
                Object.defineProperty(Attachment.prototype, "attacmnent", {
                    get: $util.oneOfGetter($oneOfFields = ["imageAttachment", "audioAttachment"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new Attachment instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Message.Attachment
                 * @static
                 * @param {AcFunDanmu.Im.Message.IAttachment=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Message.Attachment} Attachment instance
                 */
                Attachment.create = function create(properties) {
                    return new Attachment(properties);
                };

                /**
                 * Encodes the specified Attachment message. Does not implicitly {@link AcFunDanmu.Im.Message.Attachment.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Message.Attachment
                 * @static
                 * @param {AcFunDanmu.Im.Message.IAttachment} message Attachment message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Attachment.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.imageAttachment != null && Object.hasOwnProperty.call(message, "imageAttachment"))
                        $root.AcFunDanmu.Im.Message.ImageAttachment.encode(message.imageAttachment, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.audioAttachment != null && Object.hasOwnProperty.call(message, "audioAttachment"))
                        $root.AcFunDanmu.Im.Message.AudioAttachment.encode(message.audioAttachment, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Attachment message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Message.Attachment.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Message.Attachment
                 * @static
                 * @param {AcFunDanmu.Im.Message.IAttachment} message Attachment message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Attachment.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Attachment message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Message.Attachment
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Message.Attachment} Attachment
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Attachment.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Message.Attachment();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.imageAttachment = $root.AcFunDanmu.Im.Message.ImageAttachment.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.audioAttachment = $root.AcFunDanmu.Im.Message.AudioAttachment.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Attachment message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Message.Attachment
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Message.Attachment} Attachment
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Attachment.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Attachment message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Message.Attachment
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Attachment.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.imageAttachment != null && message.hasOwnProperty("imageAttachment")) {
                        properties.attacmnent = 1;
                        {
                            let error = $root.AcFunDanmu.Im.Message.ImageAttachment.verify(message.imageAttachment);
                            if (error)
                                return "imageAttachment." + error;
                        }
                    }
                    if (message.audioAttachment != null && message.hasOwnProperty("audioAttachment")) {
                        if (properties.attacmnent === 1)
                            return "attacmnent: multiple values";
                        properties.attacmnent = 1;
                        {
                            let error = $root.AcFunDanmu.Im.Message.AudioAttachment.verify(message.audioAttachment);
                            if (error)
                                return "audioAttachment." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates an Attachment message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Message.Attachment
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Message.Attachment} Attachment
                 */
                Attachment.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Message.Attachment)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Message.Attachment();
                    if (object.imageAttachment != null) {
                        if (typeof object.imageAttachment !== "object")
                            throw TypeError(".AcFunDanmu.Im.Message.Attachment.imageAttachment: object expected");
                        message.imageAttachment = $root.AcFunDanmu.Im.Message.ImageAttachment.fromObject(object.imageAttachment);
                    }
                    if (object.audioAttachment != null) {
                        if (typeof object.audioAttachment !== "object")
                            throw TypeError(".AcFunDanmu.Im.Message.Attachment.audioAttachment: object expected");
                        message.audioAttachment = $root.AcFunDanmu.Im.Message.AudioAttachment.fromObject(object.audioAttachment);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an Attachment message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Message.Attachment
                 * @static
                 * @param {AcFunDanmu.Im.Message.Attachment} message Attachment
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Attachment.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (message.imageAttachment != null && message.hasOwnProperty("imageAttachment")) {
                        object.imageAttachment = $root.AcFunDanmu.Im.Message.ImageAttachment.toObject(message.imageAttachment, options);
                        if (options.oneofs)
                            object.attacmnent = "imageAttachment";
                    }
                    if (message.audioAttachment != null && message.hasOwnProperty("audioAttachment")) {
                        object.audioAttachment = $root.AcFunDanmu.Im.Message.AudioAttachment.toObject(message.audioAttachment, options);
                        if (options.oneofs)
                            object.attacmnent = "audioAttachment";
                    }
                    return object;
                };

                /**
                 * Converts this Attachment to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Message.Attachment
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Attachment.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Attachment;
            })();

            Message.Attachments = (function() {

                /**
                 * Properties of an Attachments.
                 * @memberof AcFunDanmu.Im.Message
                 * @interface IAttachments
                 * @property {Array.<AcFunDanmu.Im.Message.IAttachment>|null} [attachments] Attachments attachments
                 */

                /**
                 * Constructs a new Attachments.
                 * @memberof AcFunDanmu.Im.Message
                 * @classdesc Represents an Attachments.
                 * @implements IAttachments
                 * @constructor
                 * @param {AcFunDanmu.Im.Message.IAttachments=} [properties] Properties to set
                 */
                function Attachments(properties) {
                    this.attachments = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Attachments attachments.
                 * @member {Array.<AcFunDanmu.Im.Message.IAttachment>} attachments
                 * @memberof AcFunDanmu.Im.Message.Attachments
                 * @instance
                 */
                Attachments.prototype.attachments = $util.emptyArray;

                /**
                 * Creates a new Attachments instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Message.Attachments
                 * @static
                 * @param {AcFunDanmu.Im.Message.IAttachments=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Message.Attachments} Attachments instance
                 */
                Attachments.create = function create(properties) {
                    return new Attachments(properties);
                };

                /**
                 * Encodes the specified Attachments message. Does not implicitly {@link AcFunDanmu.Im.Message.Attachments.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Message.Attachments
                 * @static
                 * @param {AcFunDanmu.Im.Message.IAttachments} message Attachments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Attachments.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.attachments != null && message.attachments.length)
                        for (let i = 0; i < message.attachments.length; ++i)
                            $root.AcFunDanmu.Im.Message.Attachment.encode(message.attachments[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Attachments message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Message.Attachments.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Message.Attachments
                 * @static
                 * @param {AcFunDanmu.Im.Message.IAttachments} message Attachments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Attachments.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Attachments message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Message.Attachments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Message.Attachments} Attachments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Attachments.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Message.Attachments();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.attachments && message.attachments.length))
                                message.attachments = [];
                            message.attachments.push($root.AcFunDanmu.Im.Message.Attachment.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Attachments message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Message.Attachments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Message.Attachments} Attachments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Attachments.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Attachments message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Message.Attachments
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Attachments.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.attachments != null && message.hasOwnProperty("attachments")) {
                        if (!Array.isArray(message.attachments))
                            return "attachments: array expected";
                        for (let i = 0; i < message.attachments.length; ++i) {
                            let error = $root.AcFunDanmu.Im.Message.Attachment.verify(message.attachments[i]);
                            if (error)
                                return "attachments." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates an Attachments message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Message.Attachments
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Message.Attachments} Attachments
                 */
                Attachments.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Message.Attachments)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Message.Attachments();
                    if (object.attachments) {
                        if (!Array.isArray(object.attachments))
                            throw TypeError(".AcFunDanmu.Im.Message.Attachments.attachments: array expected");
                        message.attachments = [];
                        for (let i = 0; i < object.attachments.length; ++i) {
                            if (typeof object.attachments[i] !== "object")
                                throw TypeError(".AcFunDanmu.Im.Message.Attachments.attachments: object expected");
                            message.attachments[i] = $root.AcFunDanmu.Im.Message.Attachment.fromObject(object.attachments[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an Attachments message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Message.Attachments
                 * @static
                 * @param {AcFunDanmu.Im.Message.Attachments} message Attachments
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Attachments.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.attachments = [];
                    if (message.attachments && message.attachments.length) {
                        object.attachments = [];
                        for (let j = 0; j < message.attachments.length; ++j)
                            object.attachments[j] = $root.AcFunDanmu.Im.Message.Attachment.toObject(message.attachments[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this Attachments to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Message.Attachments
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Attachments.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Attachments;
            })();

            Message.PlaceHolderMessage = (function() {

                /**
                 * Properties of a PlaceHolderMessage.
                 * @memberof AcFunDanmu.Im.Message
                 * @interface IPlaceHolderMessage
                 * @property {number|Long|null} [minSeq] PlaceHolderMessage minSeq
                 * @property {number|Long|null} [maxSeq] PlaceHolderMessage maxSeq
                 */

                /**
                 * Constructs a new PlaceHolderMessage.
                 * @memberof AcFunDanmu.Im.Message
                 * @classdesc Represents a PlaceHolderMessage.
                 * @implements IPlaceHolderMessage
                 * @constructor
                 * @param {AcFunDanmu.Im.Message.IPlaceHolderMessage=} [properties] Properties to set
                 */
                function PlaceHolderMessage(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PlaceHolderMessage minSeq.
                 * @member {number|Long} minSeq
                 * @memberof AcFunDanmu.Im.Message.PlaceHolderMessage
                 * @instance
                 */
                PlaceHolderMessage.prototype.minSeq = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * PlaceHolderMessage maxSeq.
                 * @member {number|Long} maxSeq
                 * @memberof AcFunDanmu.Im.Message.PlaceHolderMessage
                 * @instance
                 */
                PlaceHolderMessage.prototype.maxSeq = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Creates a new PlaceHolderMessage instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Message.PlaceHolderMessage
                 * @static
                 * @param {AcFunDanmu.Im.Message.IPlaceHolderMessage=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Message.PlaceHolderMessage} PlaceHolderMessage instance
                 */
                PlaceHolderMessage.create = function create(properties) {
                    return new PlaceHolderMessage(properties);
                };

                /**
                 * Encodes the specified PlaceHolderMessage message. Does not implicitly {@link AcFunDanmu.Im.Message.PlaceHolderMessage.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Message.PlaceHolderMessage
                 * @static
                 * @param {AcFunDanmu.Im.Message.IPlaceHolderMessage} message PlaceHolderMessage message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PlaceHolderMessage.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.minSeq != null && Object.hasOwnProperty.call(message, "minSeq"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int64(message.minSeq);
                    if (message.maxSeq != null && Object.hasOwnProperty.call(message, "maxSeq"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int64(message.maxSeq);
                    return writer;
                };

                /**
                 * Encodes the specified PlaceHolderMessage message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Message.PlaceHolderMessage.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Message.PlaceHolderMessage
                 * @static
                 * @param {AcFunDanmu.Im.Message.IPlaceHolderMessage} message PlaceHolderMessage message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PlaceHolderMessage.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a PlaceHolderMessage message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Message.PlaceHolderMessage
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Message.PlaceHolderMessage} PlaceHolderMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PlaceHolderMessage.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Message.PlaceHolderMessage();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.minSeq = reader.int64();
                            break;
                        case 2:
                            message.maxSeq = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a PlaceHolderMessage message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Message.PlaceHolderMessage
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Message.PlaceHolderMessage} PlaceHolderMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PlaceHolderMessage.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a PlaceHolderMessage message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Message.PlaceHolderMessage
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PlaceHolderMessage.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.minSeq != null && message.hasOwnProperty("minSeq"))
                        if (!$util.isInteger(message.minSeq) && !(message.minSeq && $util.isInteger(message.minSeq.low) && $util.isInteger(message.minSeq.high)))
                            return "minSeq: integer|Long expected";
                    if (message.maxSeq != null && message.hasOwnProperty("maxSeq"))
                        if (!$util.isInteger(message.maxSeq) && !(message.maxSeq && $util.isInteger(message.maxSeq.low) && $util.isInteger(message.maxSeq.high)))
                            return "maxSeq: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a PlaceHolderMessage message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Message.PlaceHolderMessage
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Message.PlaceHolderMessage} PlaceHolderMessage
                 */
                PlaceHolderMessage.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Message.PlaceHolderMessage)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Message.PlaceHolderMessage();
                    if (object.minSeq != null)
                        if ($util.Long)
                            (message.minSeq = $util.Long.fromValue(object.minSeq)).unsigned = false;
                        else if (typeof object.minSeq === "string")
                            message.minSeq = parseInt(object.minSeq, 10);
                        else if (typeof object.minSeq === "number")
                            message.minSeq = object.minSeq;
                        else if (typeof object.minSeq === "object")
                            message.minSeq = new $util.LongBits(object.minSeq.low >>> 0, object.minSeq.high >>> 0).toNumber();
                    if (object.maxSeq != null)
                        if ($util.Long)
                            (message.maxSeq = $util.Long.fromValue(object.maxSeq)).unsigned = false;
                        else if (typeof object.maxSeq === "string")
                            message.maxSeq = parseInt(object.maxSeq, 10);
                        else if (typeof object.maxSeq === "number")
                            message.maxSeq = object.maxSeq;
                        else if (typeof object.maxSeq === "object")
                            message.maxSeq = new $util.LongBits(object.maxSeq.low >>> 0, object.maxSeq.high >>> 0).toNumber();
                    return message;
                };

                /**
                 * Creates a plain object from a PlaceHolderMessage message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Message.PlaceHolderMessage
                 * @static
                 * @param {AcFunDanmu.Im.Message.PlaceHolderMessage} message PlaceHolderMessage
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PlaceHolderMessage.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.minSeq = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.minSeq = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.maxSeq = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.maxSeq = options.longs === String ? "0" : 0;
                    }
                    if (message.minSeq != null && message.hasOwnProperty("minSeq"))
                        if (typeof message.minSeq === "number")
                            object.minSeq = options.longs === String ? String(message.minSeq) : message.minSeq;
                        else
                            object.minSeq = options.longs === String ? $util.Long.prototype.toString.call(message.minSeq) : options.longs === Number ? new $util.LongBits(message.minSeq.low >>> 0, message.minSeq.high >>> 0).toNumber() : message.minSeq;
                    if (message.maxSeq != null && message.hasOwnProperty("maxSeq"))
                        if (typeof message.maxSeq === "number")
                            object.maxSeq = options.longs === String ? String(message.maxSeq) : message.maxSeq;
                        else
                            object.maxSeq = options.longs === String ? $util.Long.prototype.toString.call(message.maxSeq) : options.longs === Number ? new $util.LongBits(message.maxSeq.low >>> 0, message.maxSeq.high >>> 0).toNumber() : message.maxSeq;
                    return object;
                };

                /**
                 * Converts this PlaceHolderMessage to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Message.PlaceHolderMessage
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PlaceHolderMessage.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return PlaceHolderMessage;
            })();

            Message.ImageTextMessage = (function() {

                /**
                 * Properties of an ImageTextMessage.
                 * @memberof AcFunDanmu.Im.Message
                 * @interface IImageTextMessage
                 * @property {string|null} [title] ImageTextMessage title
                 * @property {string|null} [description] ImageTextMessage description
                 * @property {string|null} [imageUrl] ImageTextMessage imageUrl
                 * @property {string|null} [actionUrl] ImageTextMessage actionUrl
                 * @property {number|null} [width] ImageTextMessage width
                 * @property {number|null} [aspectRatio] ImageTextMessage aspectRatio
                 */

                /**
                 * Constructs a new ImageTextMessage.
                 * @memberof AcFunDanmu.Im.Message
                 * @classdesc Represents an ImageTextMessage.
                 * @implements IImageTextMessage
                 * @constructor
                 * @param {AcFunDanmu.Im.Message.IImageTextMessage=} [properties] Properties to set
                 */
                function ImageTextMessage(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ImageTextMessage title.
                 * @member {string} title
                 * @memberof AcFunDanmu.Im.Message.ImageTextMessage
                 * @instance
                 */
                ImageTextMessage.prototype.title = "";

                /**
                 * ImageTextMessage description.
                 * @member {string} description
                 * @memberof AcFunDanmu.Im.Message.ImageTextMessage
                 * @instance
                 */
                ImageTextMessage.prototype.description = "";

                /**
                 * ImageTextMessage imageUrl.
                 * @member {string} imageUrl
                 * @memberof AcFunDanmu.Im.Message.ImageTextMessage
                 * @instance
                 */
                ImageTextMessage.prototype.imageUrl = "";

                /**
                 * ImageTextMessage actionUrl.
                 * @member {string} actionUrl
                 * @memberof AcFunDanmu.Im.Message.ImageTextMessage
                 * @instance
                 */
                ImageTextMessage.prototype.actionUrl = "";

                /**
                 * ImageTextMessage width.
                 * @member {number} width
                 * @memberof AcFunDanmu.Im.Message.ImageTextMessage
                 * @instance
                 */
                ImageTextMessage.prototype.width = 0;

                /**
                 * ImageTextMessage aspectRatio.
                 * @member {number} aspectRatio
                 * @memberof AcFunDanmu.Im.Message.ImageTextMessage
                 * @instance
                 */
                ImageTextMessage.prototype.aspectRatio = 0;

                /**
                 * Creates a new ImageTextMessage instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Message.ImageTextMessage
                 * @static
                 * @param {AcFunDanmu.Im.Message.IImageTextMessage=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Message.ImageTextMessage} ImageTextMessage instance
                 */
                ImageTextMessage.create = function create(properties) {
                    return new ImageTextMessage(properties);
                };

                /**
                 * Encodes the specified ImageTextMessage message. Does not implicitly {@link AcFunDanmu.Im.Message.ImageTextMessage.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Message.ImageTextMessage
                 * @static
                 * @param {AcFunDanmu.Im.Message.IImageTextMessage} message ImageTextMessage message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ImageTextMessage.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.title);
                    if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                    if (message.imageUrl != null && Object.hasOwnProperty.call(message, "imageUrl"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.imageUrl);
                    if (message.actionUrl != null && Object.hasOwnProperty.call(message, "actionUrl"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.actionUrl);
                    if (message.width != null && Object.hasOwnProperty.call(message, "width"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.width);
                    if (message.aspectRatio != null && Object.hasOwnProperty.call(message, "aspectRatio"))
                        writer.uint32(/* id 6, wireType 5 =*/53).float(message.aspectRatio);
                    return writer;
                };

                /**
                 * Encodes the specified ImageTextMessage message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Message.ImageTextMessage.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Message.ImageTextMessage
                 * @static
                 * @param {AcFunDanmu.Im.Message.IImageTextMessage} message ImageTextMessage message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ImageTextMessage.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an ImageTextMessage message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Message.ImageTextMessage
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Message.ImageTextMessage} ImageTextMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ImageTextMessage.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Message.ImageTextMessage();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.title = reader.string();
                            break;
                        case 2:
                            message.description = reader.string();
                            break;
                        case 3:
                            message.imageUrl = reader.string();
                            break;
                        case 4:
                            message.actionUrl = reader.string();
                            break;
                        case 5:
                            message.width = reader.int32();
                            break;
                        case 6:
                            message.aspectRatio = reader.float();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an ImageTextMessage message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Message.ImageTextMessage
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Message.ImageTextMessage} ImageTextMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ImageTextMessage.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an ImageTextMessage message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Message.ImageTextMessage
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ImageTextMessage.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.title != null && message.hasOwnProperty("title"))
                        if (!$util.isString(message.title))
                            return "title: string expected";
                    if (message.description != null && message.hasOwnProperty("description"))
                        if (!$util.isString(message.description))
                            return "description: string expected";
                    if (message.imageUrl != null && message.hasOwnProperty("imageUrl"))
                        if (!$util.isString(message.imageUrl))
                            return "imageUrl: string expected";
                    if (message.actionUrl != null && message.hasOwnProperty("actionUrl"))
                        if (!$util.isString(message.actionUrl))
                            return "actionUrl: string expected";
                    if (message.width != null && message.hasOwnProperty("width"))
                        if (!$util.isInteger(message.width))
                            return "width: integer expected";
                    if (message.aspectRatio != null && message.hasOwnProperty("aspectRatio"))
                        if (typeof message.aspectRatio !== "number")
                            return "aspectRatio: number expected";
                    return null;
                };

                /**
                 * Creates an ImageTextMessage message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Message.ImageTextMessage
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Message.ImageTextMessage} ImageTextMessage
                 */
                ImageTextMessage.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Message.ImageTextMessage)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Message.ImageTextMessage();
                    if (object.title != null)
                        message.title = String(object.title);
                    if (object.description != null)
                        message.description = String(object.description);
                    if (object.imageUrl != null)
                        message.imageUrl = String(object.imageUrl);
                    if (object.actionUrl != null)
                        message.actionUrl = String(object.actionUrl);
                    if (object.width != null)
                        message.width = object.width | 0;
                    if (object.aspectRatio != null)
                        message.aspectRatio = Number(object.aspectRatio);
                    return message;
                };

                /**
                 * Creates a plain object from an ImageTextMessage message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Message.ImageTextMessage
                 * @static
                 * @param {AcFunDanmu.Im.Message.ImageTextMessage} message ImageTextMessage
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ImageTextMessage.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.title = "";
                        object.description = "";
                        object.imageUrl = "";
                        object.actionUrl = "";
                        object.width = 0;
                        object.aspectRatio = 0;
                    }
                    if (message.title != null && message.hasOwnProperty("title"))
                        object.title = message.title;
                    if (message.description != null && message.hasOwnProperty("description"))
                        object.description = message.description;
                    if (message.imageUrl != null && message.hasOwnProperty("imageUrl"))
                        object.imageUrl = message.imageUrl;
                    if (message.actionUrl != null && message.hasOwnProperty("actionUrl"))
                        object.actionUrl = message.actionUrl;
                    if (message.width != null && message.hasOwnProperty("width"))
                        object.width = message.width;
                    if (message.aspectRatio != null && message.hasOwnProperty("aspectRatio"))
                        object.aspectRatio = options.json && !isFinite(message.aspectRatio) ? String(message.aspectRatio) : message.aspectRatio;
                    return object;
                };

                /**
                 * Converts this ImageTextMessage to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Message.ImageTextMessage
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ImageTextMessage.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ImageTextMessage;
            })();

            Message.RichTextMessage = (function() {

                /**
                 * Properties of a RichTextMessage.
                 * @memberof AcFunDanmu.Im.Message
                 * @interface IRichTextMessage
                 * @property {AcFunDanmu.Im.Message.IRichTextNoticeMessage|null} [richTextMessage] RichTextMessage richTextMessage
                 */

                /**
                 * Constructs a new RichTextMessage.
                 * @memberof AcFunDanmu.Im.Message
                 * @classdesc Represents a RichTextMessage.
                 * @implements IRichTextMessage
                 * @constructor
                 * @param {AcFunDanmu.Im.Message.IRichTextMessage=} [properties] Properties to set
                 */
                function RichTextMessage(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * RichTextMessage richTextMessage.
                 * @member {AcFunDanmu.Im.Message.IRichTextNoticeMessage|null|undefined} richTextMessage
                 * @memberof AcFunDanmu.Im.Message.RichTextMessage
                 * @instance
                 */
                RichTextMessage.prototype.richTextMessage = null;

                /**
                 * Creates a new RichTextMessage instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Message.RichTextMessage
                 * @static
                 * @param {AcFunDanmu.Im.Message.IRichTextMessage=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Message.RichTextMessage} RichTextMessage instance
                 */
                RichTextMessage.create = function create(properties) {
                    return new RichTextMessage(properties);
                };

                /**
                 * Encodes the specified RichTextMessage message. Does not implicitly {@link AcFunDanmu.Im.Message.RichTextMessage.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Message.RichTextMessage
                 * @static
                 * @param {AcFunDanmu.Im.Message.IRichTextMessage} message RichTextMessage message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RichTextMessage.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.richTextMessage != null && Object.hasOwnProperty.call(message, "richTextMessage"))
                        $root.AcFunDanmu.Im.Message.RichTextNoticeMessage.encode(message.richTextMessage, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified RichTextMessage message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Message.RichTextMessage.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Message.RichTextMessage
                 * @static
                 * @param {AcFunDanmu.Im.Message.IRichTextMessage} message RichTextMessage message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RichTextMessage.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a RichTextMessage message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Message.RichTextMessage
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Message.RichTextMessage} RichTextMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RichTextMessage.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Message.RichTextMessage();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.richTextMessage = $root.AcFunDanmu.Im.Message.RichTextNoticeMessage.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a RichTextMessage message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Message.RichTextMessage
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Message.RichTextMessage} RichTextMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RichTextMessage.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a RichTextMessage message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Message.RichTextMessage
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                RichTextMessage.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.richTextMessage != null && message.hasOwnProperty("richTextMessage")) {
                        let error = $root.AcFunDanmu.Im.Message.RichTextNoticeMessage.verify(message.richTextMessage);
                        if (error)
                            return "richTextMessage." + error;
                    }
                    return null;
                };

                /**
                 * Creates a RichTextMessage message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Message.RichTextMessage
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Message.RichTextMessage} RichTextMessage
                 */
                RichTextMessage.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Message.RichTextMessage)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Message.RichTextMessage();
                    if (object.richTextMessage != null) {
                        if (typeof object.richTextMessage !== "object")
                            throw TypeError(".AcFunDanmu.Im.Message.RichTextMessage.richTextMessage: object expected");
                        message.richTextMessage = $root.AcFunDanmu.Im.Message.RichTextNoticeMessage.fromObject(object.richTextMessage);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a RichTextMessage message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Message.RichTextMessage
                 * @static
                 * @param {AcFunDanmu.Im.Message.RichTextMessage} message RichTextMessage
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RichTextMessage.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.richTextMessage = null;
                    if (message.richTextMessage != null && message.hasOwnProperty("richTextMessage"))
                        object.richTextMessage = $root.AcFunDanmu.Im.Message.RichTextNoticeMessage.toObject(message.richTextMessage, options);
                    return object;
                };

                /**
                 * Converts this RichTextMessage to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Message.RichTextMessage
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                RichTextMessage.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return RichTextMessage;
            })();

            /**
             * SystemUser enum.
             * @name AcFunDanmu.Im.Message.SystemUser
             * @enum {number}
             * @property {number} kSystemUserInvalid=0 kSystemUserInvalid value
             * @property {number} SYSTEM_USER_ID=10000 SYSTEM_USER_ID value
             */
            Message.SystemUser = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "kSystemUserInvalid"] = 0;
                values[valuesById[10000] = "SYSTEM_USER_ID"] = 10000;
                return values;
            })();

            Message.NoticeMessage = (function() {

                /**
                 * Properties of a NoticeMessage.
                 * @memberof AcFunDanmu.Im.Message
                 * @interface INoticeMessage
                 * @property {AcFunDanmu.Im.Message.IRichTextNoticeMessage|null} [richTextNotice] NoticeMessage richTextNotice
                 * @property {string|null} [msg] NoticeMessage msg
                 * @property {AcFunDanmu.Im.Basic.II18nCopyWriting|null} [i18nCopyWriting] NoticeMessage i18nCopyWriting
                 */

                /**
                 * Constructs a new NoticeMessage.
                 * @memberof AcFunDanmu.Im.Message
                 * @classdesc Represents a NoticeMessage.
                 * @implements INoticeMessage
                 * @constructor
                 * @param {AcFunDanmu.Im.Message.INoticeMessage=} [properties] Properties to set
                 */
                function NoticeMessage(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * NoticeMessage richTextNotice.
                 * @member {AcFunDanmu.Im.Message.IRichTextNoticeMessage|null|undefined} richTextNotice
                 * @memberof AcFunDanmu.Im.Message.NoticeMessage
                 * @instance
                 */
                NoticeMessage.prototype.richTextNotice = null;

                /**
                 * NoticeMessage msg.
                 * @member {string} msg
                 * @memberof AcFunDanmu.Im.Message.NoticeMessage
                 * @instance
                 */
                NoticeMessage.prototype.msg = "";

                /**
                 * NoticeMessage i18nCopyWriting.
                 * @member {AcFunDanmu.Im.Basic.II18nCopyWriting|null|undefined} i18nCopyWriting
                 * @memberof AcFunDanmu.Im.Message.NoticeMessage
                 * @instance
                 */
                NoticeMessage.prototype.i18nCopyWriting = null;

                /**
                 * Creates a new NoticeMessage instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Message.NoticeMessage
                 * @static
                 * @param {AcFunDanmu.Im.Message.INoticeMessage=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Message.NoticeMessage} NoticeMessage instance
                 */
                NoticeMessage.create = function create(properties) {
                    return new NoticeMessage(properties);
                };

                /**
                 * Encodes the specified NoticeMessage message. Does not implicitly {@link AcFunDanmu.Im.Message.NoticeMessage.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Message.NoticeMessage
                 * @static
                 * @param {AcFunDanmu.Im.Message.INoticeMessage} message NoticeMessage message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NoticeMessage.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.richTextNotice != null && Object.hasOwnProperty.call(message, "richTextNotice"))
                        $root.AcFunDanmu.Im.Message.RichTextNoticeMessage.encode(message.richTextNotice, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.msg);
                    if (message.i18nCopyWriting != null && Object.hasOwnProperty.call(message, "i18nCopyWriting"))
                        $root.AcFunDanmu.Im.Basic.I18nCopyWriting.encode(message.i18nCopyWriting, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified NoticeMessage message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Message.NoticeMessage.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Message.NoticeMessage
                 * @static
                 * @param {AcFunDanmu.Im.Message.INoticeMessage} message NoticeMessage message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NoticeMessage.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a NoticeMessage message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Message.NoticeMessage
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Message.NoticeMessage} NoticeMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NoticeMessage.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Message.NoticeMessage();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 2:
                            message.richTextNotice = $root.AcFunDanmu.Im.Message.RichTextNoticeMessage.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.msg = reader.string();
                            break;
                        case 10:
                            message.i18nCopyWriting = $root.AcFunDanmu.Im.Basic.I18nCopyWriting.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a NoticeMessage message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Message.NoticeMessage
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Message.NoticeMessage} NoticeMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NoticeMessage.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a NoticeMessage message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Message.NoticeMessage
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NoticeMessage.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.richTextNotice != null && message.hasOwnProperty("richTextNotice")) {
                        let error = $root.AcFunDanmu.Im.Message.RichTextNoticeMessage.verify(message.richTextNotice);
                        if (error)
                            return "richTextNotice." + error;
                    }
                    if (message.msg != null && message.hasOwnProperty("msg"))
                        if (!$util.isString(message.msg))
                            return "msg: string expected";
                    if (message.i18nCopyWriting != null && message.hasOwnProperty("i18nCopyWriting")) {
                        let error = $root.AcFunDanmu.Im.Basic.I18nCopyWriting.verify(message.i18nCopyWriting);
                        if (error)
                            return "i18nCopyWriting." + error;
                    }
                    return null;
                };

                /**
                 * Creates a NoticeMessage message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Message.NoticeMessage
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Message.NoticeMessage} NoticeMessage
                 */
                NoticeMessage.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Message.NoticeMessage)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Message.NoticeMessage();
                    if (object.richTextNotice != null) {
                        if (typeof object.richTextNotice !== "object")
                            throw TypeError(".AcFunDanmu.Im.Message.NoticeMessage.richTextNotice: object expected");
                        message.richTextNotice = $root.AcFunDanmu.Im.Message.RichTextNoticeMessage.fromObject(object.richTextNotice);
                    }
                    if (object.msg != null)
                        message.msg = String(object.msg);
                    if (object.i18nCopyWriting != null) {
                        if (typeof object.i18nCopyWriting !== "object")
                            throw TypeError(".AcFunDanmu.Im.Message.NoticeMessage.i18nCopyWriting: object expected");
                        message.i18nCopyWriting = $root.AcFunDanmu.Im.Basic.I18nCopyWriting.fromObject(object.i18nCopyWriting);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a NoticeMessage message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Message.NoticeMessage
                 * @static
                 * @param {AcFunDanmu.Im.Message.NoticeMessage} message NoticeMessage
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NoticeMessage.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.richTextNotice = null;
                        object.msg = "";
                        object.i18nCopyWriting = null;
                    }
                    if (message.richTextNotice != null && message.hasOwnProperty("richTextNotice"))
                        object.richTextNotice = $root.AcFunDanmu.Im.Message.RichTextNoticeMessage.toObject(message.richTextNotice, options);
                    if (message.msg != null && message.hasOwnProperty("msg"))
                        object.msg = message.msg;
                    if (message.i18nCopyWriting != null && message.hasOwnProperty("i18nCopyWriting"))
                        object.i18nCopyWriting = $root.AcFunDanmu.Im.Basic.I18nCopyWriting.toObject(message.i18nCopyWriting, options);
                    return object;
                };

                /**
                 * Converts this NoticeMessage to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Message.NoticeMessage
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                NoticeMessage.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return NoticeMessage;
            })();

            Message.RichTextNoticeMessage = (function() {

                /**
                 * Properties of a RichTextNoticeMessage.
                 * @memberof AcFunDanmu.Im.Message
                 * @interface IRichTextNoticeMessage
                 * @property {Array.<AcFunDanmu.Im.Message.RichTextNoticeMessage.IRichTextItem>|null} [items] RichTextNoticeMessage items
                 */

                /**
                 * Constructs a new RichTextNoticeMessage.
                 * @memberof AcFunDanmu.Im.Message
                 * @classdesc Represents a RichTextNoticeMessage.
                 * @implements IRichTextNoticeMessage
                 * @constructor
                 * @param {AcFunDanmu.Im.Message.IRichTextNoticeMessage=} [properties] Properties to set
                 */
                function RichTextNoticeMessage(properties) {
                    this.items = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * RichTextNoticeMessage items.
                 * @member {Array.<AcFunDanmu.Im.Message.RichTextNoticeMessage.IRichTextItem>} items
                 * @memberof AcFunDanmu.Im.Message.RichTextNoticeMessage
                 * @instance
                 */
                RichTextNoticeMessage.prototype.items = $util.emptyArray;

                /**
                 * Creates a new RichTextNoticeMessage instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Message.RichTextNoticeMessage
                 * @static
                 * @param {AcFunDanmu.Im.Message.IRichTextNoticeMessage=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Message.RichTextNoticeMessage} RichTextNoticeMessage instance
                 */
                RichTextNoticeMessage.create = function create(properties) {
                    return new RichTextNoticeMessage(properties);
                };

                /**
                 * Encodes the specified RichTextNoticeMessage message. Does not implicitly {@link AcFunDanmu.Im.Message.RichTextNoticeMessage.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Message.RichTextNoticeMessage
                 * @static
                 * @param {AcFunDanmu.Im.Message.IRichTextNoticeMessage} message RichTextNoticeMessage message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RichTextNoticeMessage.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.items != null && message.items.length)
                        for (let i = 0; i < message.items.length; ++i)
                            $root.AcFunDanmu.Im.Message.RichTextNoticeMessage.RichTextItem.encode(message.items[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified RichTextNoticeMessage message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Message.RichTextNoticeMessage.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Message.RichTextNoticeMessage
                 * @static
                 * @param {AcFunDanmu.Im.Message.IRichTextNoticeMessage} message RichTextNoticeMessage message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RichTextNoticeMessage.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a RichTextNoticeMessage message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Message.RichTextNoticeMessage
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Message.RichTextNoticeMessage} RichTextNoticeMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RichTextNoticeMessage.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Message.RichTextNoticeMessage();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.items && message.items.length))
                                message.items = [];
                            message.items.push($root.AcFunDanmu.Im.Message.RichTextNoticeMessage.RichTextItem.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a RichTextNoticeMessage message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Message.RichTextNoticeMessage
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Message.RichTextNoticeMessage} RichTextNoticeMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RichTextNoticeMessage.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a RichTextNoticeMessage message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Message.RichTextNoticeMessage
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                RichTextNoticeMessage.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.items != null && message.hasOwnProperty("items")) {
                        if (!Array.isArray(message.items))
                            return "items: array expected";
                        for (let i = 0; i < message.items.length; ++i) {
                            let error = $root.AcFunDanmu.Im.Message.RichTextNoticeMessage.RichTextItem.verify(message.items[i]);
                            if (error)
                                return "items." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a RichTextNoticeMessage message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Message.RichTextNoticeMessage
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Message.RichTextNoticeMessage} RichTextNoticeMessage
                 */
                RichTextNoticeMessage.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Message.RichTextNoticeMessage)
                        return object;
                    let message = new $root.AcFunDanmu.Im.Message.RichTextNoticeMessage();
                    if (object.items) {
                        if (!Array.isArray(object.items))
                            throw TypeError(".AcFunDanmu.Im.Message.RichTextNoticeMessage.items: array expected");
                        message.items = [];
                        for (let i = 0; i < object.items.length; ++i) {
                            if (typeof object.items[i] !== "object")
                                throw TypeError(".AcFunDanmu.Im.Message.RichTextNoticeMessage.items: object expected");
                            message.items[i] = $root.AcFunDanmu.Im.Message.RichTextNoticeMessage.RichTextItem.fromObject(object.items[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a RichTextNoticeMessage message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Message.RichTextNoticeMessage
                 * @static
                 * @param {AcFunDanmu.Im.Message.RichTextNoticeMessage} message RichTextNoticeMessage
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RichTextNoticeMessage.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.items = [];
                    if (message.items && message.items.length) {
                        object.items = [];
                        for (let j = 0; j < message.items.length; ++j)
                            object.items[j] = $root.AcFunDanmu.Im.Message.RichTextNoticeMessage.RichTextItem.toObject(message.items[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this RichTextNoticeMessage to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Message.RichTextNoticeMessage
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                RichTextNoticeMessage.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                RichTextNoticeMessage.RichTextItem = (function() {

                    /**
                     * Properties of a RichTextItem.
                     * @memberof AcFunDanmu.Im.Message.RichTextNoticeMessage
                     * @interface IRichTextItem
                     * @property {number|null} [color] RichTextItem color
                     * @property {number|null} [start] RichTextItem start
                     * @property {number|null} [len] RichTextItem len
                     * @property {string|null} [clickAction] RichTextItem clickAction
                     * @property {boolean|null} [underline] RichTextItem underline
                     */

                    /**
                     * Constructs a new RichTextItem.
                     * @memberof AcFunDanmu.Im.Message.RichTextNoticeMessage
                     * @classdesc Represents a RichTextItem.
                     * @implements IRichTextItem
                     * @constructor
                     * @param {AcFunDanmu.Im.Message.RichTextNoticeMessage.IRichTextItem=} [properties] Properties to set
                     */
                    function RichTextItem(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * RichTextItem color.
                     * @member {number} color
                     * @memberof AcFunDanmu.Im.Message.RichTextNoticeMessage.RichTextItem
                     * @instance
                     */
                    RichTextItem.prototype.color = 0;

                    /**
                     * RichTextItem start.
                     * @member {number} start
                     * @memberof AcFunDanmu.Im.Message.RichTextNoticeMessage.RichTextItem
                     * @instance
                     */
                    RichTextItem.prototype.start = 0;

                    /**
                     * RichTextItem len.
                     * @member {number} len
                     * @memberof AcFunDanmu.Im.Message.RichTextNoticeMessage.RichTextItem
                     * @instance
                     */
                    RichTextItem.prototype.len = 0;

                    /**
                     * RichTextItem clickAction.
                     * @member {string} clickAction
                     * @memberof AcFunDanmu.Im.Message.RichTextNoticeMessage.RichTextItem
                     * @instance
                     */
                    RichTextItem.prototype.clickAction = "";

                    /**
                     * RichTextItem underline.
                     * @member {boolean} underline
                     * @memberof AcFunDanmu.Im.Message.RichTextNoticeMessage.RichTextItem
                     * @instance
                     */
                    RichTextItem.prototype.underline = false;

                    /**
                     * Creates a new RichTextItem instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Message.RichTextNoticeMessage.RichTextItem
                     * @static
                     * @param {AcFunDanmu.Im.Message.RichTextNoticeMessage.IRichTextItem=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Message.RichTextNoticeMessage.RichTextItem} RichTextItem instance
                     */
                    RichTextItem.create = function create(properties) {
                        return new RichTextItem(properties);
                    };

                    /**
                     * Encodes the specified RichTextItem message. Does not implicitly {@link AcFunDanmu.Im.Message.RichTextNoticeMessage.RichTextItem.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Message.RichTextNoticeMessage.RichTextItem
                     * @static
                     * @param {AcFunDanmu.Im.Message.RichTextNoticeMessage.IRichTextItem} message RichTextItem message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    RichTextItem.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.color);
                        if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.start);
                        if (message.len != null && Object.hasOwnProperty.call(message, "len"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.len);
                        if (message.clickAction != null && Object.hasOwnProperty.call(message, "clickAction"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.clickAction);
                        if (message.underline != null && Object.hasOwnProperty.call(message, "underline"))
                            writer.uint32(/* id 5, wireType 0 =*/40).bool(message.underline);
                        return writer;
                    };

                    /**
                     * Encodes the specified RichTextItem message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Message.RichTextNoticeMessage.RichTextItem.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Message.RichTextNoticeMessage.RichTextItem
                     * @static
                     * @param {AcFunDanmu.Im.Message.RichTextNoticeMessage.IRichTextItem} message RichTextItem message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    RichTextItem.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a RichTextItem message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Message.RichTextNoticeMessage.RichTextItem
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Message.RichTextNoticeMessage.RichTextItem} RichTextItem
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    RichTextItem.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Message.RichTextNoticeMessage.RichTextItem();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.color = reader.int32();
                                break;
                            case 2:
                                message.start = reader.int32();
                                break;
                            case 3:
                                message.len = reader.int32();
                                break;
                            case 4:
                                message.clickAction = reader.string();
                                break;
                            case 5:
                                message.underline = reader.bool();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a RichTextItem message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Message.RichTextNoticeMessage.RichTextItem
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Message.RichTextNoticeMessage.RichTextItem} RichTextItem
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    RichTextItem.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a RichTextItem message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Message.RichTextNoticeMessage.RichTextItem
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    RichTextItem.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.color != null && message.hasOwnProperty("color"))
                            if (!$util.isInteger(message.color))
                                return "color: integer expected";
                        if (message.start != null && message.hasOwnProperty("start"))
                            if (!$util.isInteger(message.start))
                                return "start: integer expected";
                        if (message.len != null && message.hasOwnProperty("len"))
                            if (!$util.isInteger(message.len))
                                return "len: integer expected";
                        if (message.clickAction != null && message.hasOwnProperty("clickAction"))
                            if (!$util.isString(message.clickAction))
                                return "clickAction: string expected";
                        if (message.underline != null && message.hasOwnProperty("underline"))
                            if (typeof message.underline !== "boolean")
                                return "underline: boolean expected";
                        return null;
                    };

                    /**
                     * Creates a RichTextItem message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Message.RichTextNoticeMessage.RichTextItem
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Message.RichTextNoticeMessage.RichTextItem} RichTextItem
                     */
                    RichTextItem.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Message.RichTextNoticeMessage.RichTextItem)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Message.RichTextNoticeMessage.RichTextItem();
                        if (object.color != null)
                            message.color = object.color | 0;
                        if (object.start != null)
                            message.start = object.start | 0;
                        if (object.len != null)
                            message.len = object.len | 0;
                        if (object.clickAction != null)
                            message.clickAction = String(object.clickAction);
                        if (object.underline != null)
                            message.underline = Boolean(object.underline);
                        return message;
                    };

                    /**
                     * Creates a plain object from a RichTextItem message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Message.RichTextNoticeMessage.RichTextItem
                     * @static
                     * @param {AcFunDanmu.Im.Message.RichTextNoticeMessage.RichTextItem} message RichTextItem
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    RichTextItem.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.color = 0;
                            object.start = 0;
                            object.len = 0;
                            object.clickAction = "";
                            object.underline = false;
                        }
                        if (message.color != null && message.hasOwnProperty("color"))
                            object.color = message.color;
                        if (message.start != null && message.hasOwnProperty("start"))
                            object.start = message.start;
                        if (message.len != null && message.hasOwnProperty("len"))
                            object.len = message.len;
                        if (message.clickAction != null && message.hasOwnProperty("clickAction"))
                            object.clickAction = message.clickAction;
                        if (message.underline != null && message.hasOwnProperty("underline"))
                            object.underline = message.underline;
                        return object;
                    };

                    /**
                     * Converts this RichTextItem to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Message.RichTextNoticeMessage.RichTextItem
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    RichTextItem.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return RichTextItem;
                })();

                return RichTextNoticeMessage;
            })();

            return Message;
        })();

        Im.Cloud = (function() {

            /**
             * Properties of a Cloud.
             * @memberof AcFunDanmu.Im
             * @interface ICloud
             */

            /**
             * Constructs a new Cloud.
             * @memberof AcFunDanmu.Im
             * @classdesc Represents a Cloud.
             * @implements ICloud
             * @constructor
             * @param {AcFunDanmu.Im.ICloud=} [properties] Properties to set
             */
            function Cloud(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new Cloud instance using the specified properties.
             * @function create
             * @memberof AcFunDanmu.Im.Cloud
             * @static
             * @param {AcFunDanmu.Im.ICloud=} [properties] Properties to set
             * @returns {AcFunDanmu.Im.Cloud} Cloud instance
             */
            Cloud.create = function create(properties) {
                return new Cloud(properties);
            };

            /**
             * Encodes the specified Cloud message. Does not implicitly {@link AcFunDanmu.Im.Cloud.verify|verify} messages.
             * @function encode
             * @memberof AcFunDanmu.Im.Cloud
             * @static
             * @param {AcFunDanmu.Im.ICloud} message Cloud message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Cloud.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified Cloud message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.verify|verify} messages.
             * @function encodeDelimited
             * @memberof AcFunDanmu.Im.Cloud
             * @static
             * @param {AcFunDanmu.Im.ICloud} message Cloud message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Cloud.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Cloud message from the specified reader or buffer.
             * @function decode
             * @memberof AcFunDanmu.Im.Cloud
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {AcFunDanmu.Im.Cloud} Cloud
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Cloud.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Cloud message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof AcFunDanmu.Im.Cloud
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {AcFunDanmu.Im.Cloud} Cloud
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Cloud.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Cloud message.
             * @function verify
             * @memberof AcFunDanmu.Im.Cloud
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Cloud.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a Cloud message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof AcFunDanmu.Im.Cloud
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {AcFunDanmu.Im.Cloud} Cloud
             */
            Cloud.fromObject = function fromObject(object) {
                if (object instanceof $root.AcFunDanmu.Im.Cloud)
                    return object;
                return new $root.AcFunDanmu.Im.Cloud();
            };

            /**
             * Creates a plain object from a Cloud message. Also converts values to other types if specified.
             * @function toObject
             * @memberof AcFunDanmu.Im.Cloud
             * @static
             * @param {AcFunDanmu.Im.Cloud} message Cloud
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Cloud.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this Cloud to JSON.
             * @function toJSON
             * @memberof AcFunDanmu.Im.Cloud
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Cloud.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            Cloud.Channel = (function() {

                /**
                 * Properties of a Channel.
                 * @memberof AcFunDanmu.Im.Cloud
                 * @interface IChannel
                 */

                /**
                 * Constructs a new Channel.
                 * @memberof AcFunDanmu.Im.Cloud
                 * @classdesc Represents a Channel.
                 * @implements IChannel
                 * @constructor
                 * @param {AcFunDanmu.Im.Cloud.IChannel=} [properties] Properties to set
                 */
                function Channel(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new Channel instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Cloud.Channel
                 * @static
                 * @param {AcFunDanmu.Im.Cloud.IChannel=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Cloud.Channel} Channel instance
                 */
                Channel.create = function create(properties) {
                    return new Channel(properties);
                };

                /**
                 * Encodes the specified Channel message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Channel.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Cloud.Channel
                 * @static
                 * @param {AcFunDanmu.Im.Cloud.IChannel} message Channel message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Channel.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified Channel message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Channel.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Cloud.Channel
                 * @static
                 * @param {AcFunDanmu.Im.Cloud.IChannel} message Channel message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Channel.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Channel message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Cloud.Channel
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Cloud.Channel} Channel
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Channel.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Channel();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Channel message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Cloud.Channel
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Cloud.Channel} Channel
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Channel.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Channel message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Cloud.Channel
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Channel.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a Channel message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Cloud.Channel
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Cloud.Channel} Channel
                 */
                Channel.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Cloud.Channel)
                        return object;
                    return new $root.AcFunDanmu.Im.Cloud.Channel();
                };

                /**
                 * Creates a plain object from a Channel message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Cloud.Channel
                 * @static
                 * @param {AcFunDanmu.Im.Cloud.Channel} message Channel
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Channel.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this Channel to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Cloud.Channel
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Channel.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                Channel.ChannelSubscribeRequest = (function() {

                    /**
                     * Properties of a ChannelSubscribeRequest.
                     * @memberof AcFunDanmu.Im.Cloud.Channel
                     * @interface IChannelSubscribeRequest
                     * @property {string|null} [channelId] ChannelSubscribeRequest channelId
                     * @property {boolean|null} [setBarrier] ChannelSubscribeRequest setBarrier
                     */

                    /**
                     * Constructs a new ChannelSubscribeRequest.
                     * @memberof AcFunDanmu.Im.Cloud.Channel
                     * @classdesc Represents a ChannelSubscribeRequest.
                     * @implements IChannelSubscribeRequest
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Channel.IChannelSubscribeRequest=} [properties] Properties to set
                     */
                    function ChannelSubscribeRequest(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * ChannelSubscribeRequest channelId.
                     * @member {string} channelId
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelSubscribeRequest
                     * @instance
                     */
                    ChannelSubscribeRequest.prototype.channelId = "";

                    /**
                     * ChannelSubscribeRequest setBarrier.
                     * @member {boolean} setBarrier
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelSubscribeRequest
                     * @instance
                     */
                    ChannelSubscribeRequest.prototype.setBarrier = false;

                    /**
                     * Creates a new ChannelSubscribeRequest instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelSubscribeRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Channel.IChannelSubscribeRequest=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Channel.ChannelSubscribeRequest} ChannelSubscribeRequest instance
                     */
                    ChannelSubscribeRequest.create = function create(properties) {
                        return new ChannelSubscribeRequest(properties);
                    };

                    /**
                     * Encodes the specified ChannelSubscribeRequest message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Channel.ChannelSubscribeRequest.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelSubscribeRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Channel.IChannelSubscribeRequest} message ChannelSubscribeRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ChannelSubscribeRequest.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.channelId != null && Object.hasOwnProperty.call(message, "channelId"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.channelId);
                        if (message.setBarrier != null && Object.hasOwnProperty.call(message, "setBarrier"))
                            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.setBarrier);
                        return writer;
                    };

                    /**
                     * Encodes the specified ChannelSubscribeRequest message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Channel.ChannelSubscribeRequest.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelSubscribeRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Channel.IChannelSubscribeRequest} message ChannelSubscribeRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ChannelSubscribeRequest.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a ChannelSubscribeRequest message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelSubscribeRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Channel.ChannelSubscribeRequest} ChannelSubscribeRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ChannelSubscribeRequest.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Channel.ChannelSubscribeRequest();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.channelId = reader.string();
                                break;
                            case 2:
                                message.setBarrier = reader.bool();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a ChannelSubscribeRequest message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelSubscribeRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Channel.ChannelSubscribeRequest} ChannelSubscribeRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ChannelSubscribeRequest.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a ChannelSubscribeRequest message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelSubscribeRequest
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ChannelSubscribeRequest.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.channelId != null && message.hasOwnProperty("channelId"))
                            if (!$util.isString(message.channelId))
                                return "channelId: string expected";
                        if (message.setBarrier != null && message.hasOwnProperty("setBarrier"))
                            if (typeof message.setBarrier !== "boolean")
                                return "setBarrier: boolean expected";
                        return null;
                    };

                    /**
                     * Creates a ChannelSubscribeRequest message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelSubscribeRequest
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Channel.ChannelSubscribeRequest} ChannelSubscribeRequest
                     */
                    ChannelSubscribeRequest.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Channel.ChannelSubscribeRequest)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Channel.ChannelSubscribeRequest();
                        if (object.channelId != null)
                            message.channelId = String(object.channelId);
                        if (object.setBarrier != null)
                            message.setBarrier = Boolean(object.setBarrier);
                        return message;
                    };

                    /**
                     * Creates a plain object from a ChannelSubscribeRequest message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelSubscribeRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Channel.ChannelSubscribeRequest} message ChannelSubscribeRequest
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ChannelSubscribeRequest.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.channelId = "";
                            object.setBarrier = false;
                        }
                        if (message.channelId != null && message.hasOwnProperty("channelId"))
                            object.channelId = message.channelId;
                        if (message.setBarrier != null && message.hasOwnProperty("setBarrier"))
                            object.setBarrier = message.setBarrier;
                        return object;
                    };

                    /**
                     * Converts this ChannelSubscribeRequest to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelSubscribeRequest
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ChannelSubscribeRequest.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return ChannelSubscribeRequest;
                })();

                Channel.ChannelSubscribeResponse = (function() {

                    /**
                     * Properties of a ChannelSubscribeResponse.
                     * @memberof AcFunDanmu.Im.Cloud.Channel
                     * @interface IChannelSubscribeResponse
                     */

                    /**
                     * Constructs a new ChannelSubscribeResponse.
                     * @memberof AcFunDanmu.Im.Cloud.Channel
                     * @classdesc Represents a ChannelSubscribeResponse.
                     * @implements IChannelSubscribeResponse
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Channel.IChannelSubscribeResponse=} [properties] Properties to set
                     */
                    function ChannelSubscribeResponse(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Creates a new ChannelSubscribeResponse instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelSubscribeResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Channel.IChannelSubscribeResponse=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Channel.ChannelSubscribeResponse} ChannelSubscribeResponse instance
                     */
                    ChannelSubscribeResponse.create = function create(properties) {
                        return new ChannelSubscribeResponse(properties);
                    };

                    /**
                     * Encodes the specified ChannelSubscribeResponse message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Channel.ChannelSubscribeResponse.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelSubscribeResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Channel.IChannelSubscribeResponse} message ChannelSubscribeResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ChannelSubscribeResponse.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };

                    /**
                     * Encodes the specified ChannelSubscribeResponse message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Channel.ChannelSubscribeResponse.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelSubscribeResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Channel.IChannelSubscribeResponse} message ChannelSubscribeResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ChannelSubscribeResponse.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a ChannelSubscribeResponse message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelSubscribeResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Channel.ChannelSubscribeResponse} ChannelSubscribeResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ChannelSubscribeResponse.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Channel.ChannelSubscribeResponse();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a ChannelSubscribeResponse message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelSubscribeResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Channel.ChannelSubscribeResponse} ChannelSubscribeResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ChannelSubscribeResponse.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a ChannelSubscribeResponse message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelSubscribeResponse
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ChannelSubscribeResponse.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };

                    /**
                     * Creates a ChannelSubscribeResponse message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelSubscribeResponse
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Channel.ChannelSubscribeResponse} ChannelSubscribeResponse
                     */
                    ChannelSubscribeResponse.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Channel.ChannelSubscribeResponse)
                            return object;
                        return new $root.AcFunDanmu.Im.Cloud.Channel.ChannelSubscribeResponse();
                    };

                    /**
                     * Creates a plain object from a ChannelSubscribeResponse message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelSubscribeResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Channel.ChannelSubscribeResponse} message ChannelSubscribeResponse
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ChannelSubscribeResponse.toObject = function toObject() {
                        return {};
                    };

                    /**
                     * Converts this ChannelSubscribeResponse to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelSubscribeResponse
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ChannelSubscribeResponse.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return ChannelSubscribeResponse;
                })();

                Channel.ChannelUnsubscribeRequest = (function() {

                    /**
                     * Properties of a ChannelUnsubscribeRequest.
                     * @memberof AcFunDanmu.Im.Cloud.Channel
                     * @interface IChannelUnsubscribeRequest
                     * @property {string|null} [channelId] ChannelUnsubscribeRequest channelId
                     */

                    /**
                     * Constructs a new ChannelUnsubscribeRequest.
                     * @memberof AcFunDanmu.Im.Cloud.Channel
                     * @classdesc Represents a ChannelUnsubscribeRequest.
                     * @implements IChannelUnsubscribeRequest
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Channel.IChannelUnsubscribeRequest=} [properties] Properties to set
                     */
                    function ChannelUnsubscribeRequest(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * ChannelUnsubscribeRequest channelId.
                     * @member {string} channelId
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelUnsubscribeRequest
                     * @instance
                     */
                    ChannelUnsubscribeRequest.prototype.channelId = "";

                    /**
                     * Creates a new ChannelUnsubscribeRequest instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelUnsubscribeRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Channel.IChannelUnsubscribeRequest=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Channel.ChannelUnsubscribeRequest} ChannelUnsubscribeRequest instance
                     */
                    ChannelUnsubscribeRequest.create = function create(properties) {
                        return new ChannelUnsubscribeRequest(properties);
                    };

                    /**
                     * Encodes the specified ChannelUnsubscribeRequest message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Channel.ChannelUnsubscribeRequest.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelUnsubscribeRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Channel.IChannelUnsubscribeRequest} message ChannelUnsubscribeRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ChannelUnsubscribeRequest.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.channelId != null && Object.hasOwnProperty.call(message, "channelId"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.channelId);
                        return writer;
                    };

                    /**
                     * Encodes the specified ChannelUnsubscribeRequest message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Channel.ChannelUnsubscribeRequest.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelUnsubscribeRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Channel.IChannelUnsubscribeRequest} message ChannelUnsubscribeRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ChannelUnsubscribeRequest.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a ChannelUnsubscribeRequest message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelUnsubscribeRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Channel.ChannelUnsubscribeRequest} ChannelUnsubscribeRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ChannelUnsubscribeRequest.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Channel.ChannelUnsubscribeRequest();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.channelId = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a ChannelUnsubscribeRequest message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelUnsubscribeRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Channel.ChannelUnsubscribeRequest} ChannelUnsubscribeRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ChannelUnsubscribeRequest.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a ChannelUnsubscribeRequest message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelUnsubscribeRequest
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ChannelUnsubscribeRequest.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.channelId != null && message.hasOwnProperty("channelId"))
                            if (!$util.isString(message.channelId))
                                return "channelId: string expected";
                        return null;
                    };

                    /**
                     * Creates a ChannelUnsubscribeRequest message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelUnsubscribeRequest
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Channel.ChannelUnsubscribeRequest} ChannelUnsubscribeRequest
                     */
                    ChannelUnsubscribeRequest.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Channel.ChannelUnsubscribeRequest)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Channel.ChannelUnsubscribeRequest();
                        if (object.channelId != null)
                            message.channelId = String(object.channelId);
                        return message;
                    };

                    /**
                     * Creates a plain object from a ChannelUnsubscribeRequest message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelUnsubscribeRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Channel.ChannelUnsubscribeRequest} message ChannelUnsubscribeRequest
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ChannelUnsubscribeRequest.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.channelId = "";
                        if (message.channelId != null && message.hasOwnProperty("channelId"))
                            object.channelId = message.channelId;
                        return object;
                    };

                    /**
                     * Converts this ChannelUnsubscribeRequest to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelUnsubscribeRequest
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ChannelUnsubscribeRequest.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return ChannelUnsubscribeRequest;
                })();

                Channel.ChannelSubscribersGetRequest = (function() {

                    /**
                     * Properties of a ChannelSubscribersGetRequest.
                     * @memberof AcFunDanmu.Im.Cloud.Channel
                     * @interface IChannelSubscribersGetRequest
                     * @property {string|null} [channelId] ChannelSubscribersGetRequest channelId
                     */

                    /**
                     * Constructs a new ChannelSubscribersGetRequest.
                     * @memberof AcFunDanmu.Im.Cloud.Channel
                     * @classdesc Represents a ChannelSubscribersGetRequest.
                     * @implements IChannelSubscribersGetRequest
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Channel.IChannelSubscribersGetRequest=} [properties] Properties to set
                     */
                    function ChannelSubscribersGetRequest(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * ChannelSubscribersGetRequest channelId.
                     * @member {string} channelId
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelSubscribersGetRequest
                     * @instance
                     */
                    ChannelSubscribersGetRequest.prototype.channelId = "";

                    /**
                     * Creates a new ChannelSubscribersGetRequest instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelSubscribersGetRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Channel.IChannelSubscribersGetRequest=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Channel.ChannelSubscribersGetRequest} ChannelSubscribersGetRequest instance
                     */
                    ChannelSubscribersGetRequest.create = function create(properties) {
                        return new ChannelSubscribersGetRequest(properties);
                    };

                    /**
                     * Encodes the specified ChannelSubscribersGetRequest message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Channel.ChannelSubscribersGetRequest.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelSubscribersGetRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Channel.IChannelSubscribersGetRequest} message ChannelSubscribersGetRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ChannelSubscribersGetRequest.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.channelId != null && Object.hasOwnProperty.call(message, "channelId"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.channelId);
                        return writer;
                    };

                    /**
                     * Encodes the specified ChannelSubscribersGetRequest message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Channel.ChannelSubscribersGetRequest.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelSubscribersGetRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Channel.IChannelSubscribersGetRequest} message ChannelSubscribersGetRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ChannelSubscribersGetRequest.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a ChannelSubscribersGetRequest message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelSubscribersGetRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Channel.ChannelSubscribersGetRequest} ChannelSubscribersGetRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ChannelSubscribersGetRequest.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Channel.ChannelSubscribersGetRequest();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.channelId = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a ChannelSubscribersGetRequest message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelSubscribersGetRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Channel.ChannelSubscribersGetRequest} ChannelSubscribersGetRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ChannelSubscribersGetRequest.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a ChannelSubscribersGetRequest message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelSubscribersGetRequest
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ChannelSubscribersGetRequest.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.channelId != null && message.hasOwnProperty("channelId"))
                            if (!$util.isString(message.channelId))
                                return "channelId: string expected";
                        return null;
                    };

                    /**
                     * Creates a ChannelSubscribersGetRequest message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelSubscribersGetRequest
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Channel.ChannelSubscribersGetRequest} ChannelSubscribersGetRequest
                     */
                    ChannelSubscribersGetRequest.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Channel.ChannelSubscribersGetRequest)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Channel.ChannelSubscribersGetRequest();
                        if (object.channelId != null)
                            message.channelId = String(object.channelId);
                        return message;
                    };

                    /**
                     * Creates a plain object from a ChannelSubscribersGetRequest message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelSubscribersGetRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Channel.ChannelSubscribersGetRequest} message ChannelSubscribersGetRequest
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ChannelSubscribersGetRequest.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.channelId = "";
                        if (message.channelId != null && message.hasOwnProperty("channelId"))
                            object.channelId = message.channelId;
                        return object;
                    };

                    /**
                     * Converts this ChannelSubscribersGetRequest to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelSubscribersGetRequest
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ChannelSubscribersGetRequest.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return ChannelSubscribersGetRequest;
                })();

                Channel.ChannelSubscribersGetResposne = (function() {

                    /**
                     * Properties of a ChannelSubscribersGetResposne.
                     * @memberof AcFunDanmu.Im.Cloud.Channel
                     * @interface IChannelSubscribersGetResposne
                     * @property {Array.<AcFunDanmu.Im.Basic.IUser>|null} [subscriber] ChannelSubscribersGetResposne subscriber
                     */

                    /**
                     * Constructs a new ChannelSubscribersGetResposne.
                     * @memberof AcFunDanmu.Im.Cloud.Channel
                     * @classdesc Represents a ChannelSubscribersGetResposne.
                     * @implements IChannelSubscribersGetResposne
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Channel.IChannelSubscribersGetResposne=} [properties] Properties to set
                     */
                    function ChannelSubscribersGetResposne(properties) {
                        this.subscriber = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * ChannelSubscribersGetResposne subscriber.
                     * @member {Array.<AcFunDanmu.Im.Basic.IUser>} subscriber
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelSubscribersGetResposne
                     * @instance
                     */
                    ChannelSubscribersGetResposne.prototype.subscriber = $util.emptyArray;

                    /**
                     * Creates a new ChannelSubscribersGetResposne instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelSubscribersGetResposne
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Channel.IChannelSubscribersGetResposne=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Channel.ChannelSubscribersGetResposne} ChannelSubscribersGetResposne instance
                     */
                    ChannelSubscribersGetResposne.create = function create(properties) {
                        return new ChannelSubscribersGetResposne(properties);
                    };

                    /**
                     * Encodes the specified ChannelSubscribersGetResposne message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Channel.ChannelSubscribersGetResposne.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelSubscribersGetResposne
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Channel.IChannelSubscribersGetResposne} message ChannelSubscribersGetResposne message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ChannelSubscribersGetResposne.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.subscriber != null && message.subscriber.length)
                            for (let i = 0; i < message.subscriber.length; ++i)
                                $root.AcFunDanmu.Im.Basic.User.encode(message.subscriber[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified ChannelSubscribersGetResposne message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Channel.ChannelSubscribersGetResposne.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelSubscribersGetResposne
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Channel.IChannelSubscribersGetResposne} message ChannelSubscribersGetResposne message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ChannelSubscribersGetResposne.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a ChannelSubscribersGetResposne message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelSubscribersGetResposne
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Channel.ChannelSubscribersGetResposne} ChannelSubscribersGetResposne
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ChannelSubscribersGetResposne.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Channel.ChannelSubscribersGetResposne();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.subscriber && message.subscriber.length))
                                    message.subscriber = [];
                                message.subscriber.push($root.AcFunDanmu.Im.Basic.User.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a ChannelSubscribersGetResposne message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelSubscribersGetResposne
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Channel.ChannelSubscribersGetResposne} ChannelSubscribersGetResposne
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ChannelSubscribersGetResposne.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a ChannelSubscribersGetResposne message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelSubscribersGetResposne
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ChannelSubscribersGetResposne.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.subscriber != null && message.hasOwnProperty("subscriber")) {
                            if (!Array.isArray(message.subscriber))
                                return "subscriber: array expected";
                            for (let i = 0; i < message.subscriber.length; ++i) {
                                let error = $root.AcFunDanmu.Im.Basic.User.verify(message.subscriber[i]);
                                if (error)
                                    return "subscriber." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a ChannelSubscribersGetResposne message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelSubscribersGetResposne
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Channel.ChannelSubscribersGetResposne} ChannelSubscribersGetResposne
                     */
                    ChannelSubscribersGetResposne.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Channel.ChannelSubscribersGetResposne)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Channel.ChannelSubscribersGetResposne();
                        if (object.subscriber) {
                            if (!Array.isArray(object.subscriber))
                                throw TypeError(".AcFunDanmu.Im.Cloud.Channel.ChannelSubscribersGetResposne.subscriber: array expected");
                            message.subscriber = [];
                            for (let i = 0; i < object.subscriber.length; ++i) {
                                if (typeof object.subscriber[i] !== "object")
                                    throw TypeError(".AcFunDanmu.Im.Cloud.Channel.ChannelSubscribersGetResposne.subscriber: object expected");
                                message.subscriber[i] = $root.AcFunDanmu.Im.Basic.User.fromObject(object.subscriber[i]);
                            }
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a ChannelSubscribersGetResposne message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelSubscribersGetResposne
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Channel.ChannelSubscribersGetResposne} message ChannelSubscribersGetResposne
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ChannelSubscribersGetResposne.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.subscriber = [];
                        if (message.subscriber && message.subscriber.length) {
                            object.subscriber = [];
                            for (let j = 0; j < message.subscriber.length; ++j)
                                object.subscriber[j] = $root.AcFunDanmu.Im.Basic.User.toObject(message.subscriber[j], options);
                        }
                        return object;
                    };

                    /**
                     * Converts this ChannelSubscribersGetResposne to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelSubscribersGetResposne
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ChannelSubscribersGetResposne.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return ChannelSubscribersGetResposne;
                })();

                Channel.ChannelBasicInfo = (function() {

                    /**
                     * Properties of a ChannelBasicInfo.
                     * @memberof AcFunDanmu.Im.Cloud.Channel
                     * @interface IChannelBasicInfo
                     * @property {string|null} [channelId] ChannelBasicInfo channelId
                     * @property {number|null} [subscriberCount] ChannelBasicInfo subscriberCount
                     */

                    /**
                     * Constructs a new ChannelBasicInfo.
                     * @memberof AcFunDanmu.Im.Cloud.Channel
                     * @classdesc Represents a ChannelBasicInfo.
                     * @implements IChannelBasicInfo
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Channel.IChannelBasicInfo=} [properties] Properties to set
                     */
                    function ChannelBasicInfo(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * ChannelBasicInfo channelId.
                     * @member {string} channelId
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfo
                     * @instance
                     */
                    ChannelBasicInfo.prototype.channelId = "";

                    /**
                     * ChannelBasicInfo subscriberCount.
                     * @member {number} subscriberCount
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfo
                     * @instance
                     */
                    ChannelBasicInfo.prototype.subscriberCount = 0;

                    /**
                     * Creates a new ChannelBasicInfo instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfo
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Channel.IChannelBasicInfo=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfo} ChannelBasicInfo instance
                     */
                    ChannelBasicInfo.create = function create(properties) {
                        return new ChannelBasicInfo(properties);
                    };

                    /**
                     * Encodes the specified ChannelBasicInfo message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfo.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfo
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Channel.IChannelBasicInfo} message ChannelBasicInfo message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ChannelBasicInfo.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.channelId != null && Object.hasOwnProperty.call(message, "channelId"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.channelId);
                        if (message.subscriberCount != null && Object.hasOwnProperty.call(message, "subscriberCount"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.subscriberCount);
                        return writer;
                    };

                    /**
                     * Encodes the specified ChannelBasicInfo message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfo.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfo
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Channel.IChannelBasicInfo} message ChannelBasicInfo message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ChannelBasicInfo.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a ChannelBasicInfo message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfo
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfo} ChannelBasicInfo
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ChannelBasicInfo.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfo();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.channelId = reader.string();
                                break;
                            case 2:
                                message.subscriberCount = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a ChannelBasicInfo message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfo
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfo} ChannelBasicInfo
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ChannelBasicInfo.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a ChannelBasicInfo message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfo
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ChannelBasicInfo.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.channelId != null && message.hasOwnProperty("channelId"))
                            if (!$util.isString(message.channelId))
                                return "channelId: string expected";
                        if (message.subscriberCount != null && message.hasOwnProperty("subscriberCount"))
                            if (!$util.isInteger(message.subscriberCount))
                                return "subscriberCount: integer expected";
                        return null;
                    };

                    /**
                     * Creates a ChannelBasicInfo message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfo
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfo} ChannelBasicInfo
                     */
                    ChannelBasicInfo.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfo)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfo();
                        if (object.channelId != null)
                            message.channelId = String(object.channelId);
                        if (object.subscriberCount != null)
                            message.subscriberCount = object.subscriberCount | 0;
                        return message;
                    };

                    /**
                     * Creates a plain object from a ChannelBasicInfo message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfo
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfo} message ChannelBasicInfo
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ChannelBasicInfo.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.channelId = "";
                            object.subscriberCount = 0;
                        }
                        if (message.channelId != null && message.hasOwnProperty("channelId"))
                            object.channelId = message.channelId;
                        if (message.subscriberCount != null && message.hasOwnProperty("subscriberCount"))
                            object.subscriberCount = message.subscriberCount;
                        return object;
                    };

                    /**
                     * Converts this ChannelBasicInfo to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfo
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ChannelBasicInfo.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return ChannelBasicInfo;
                })();

                Channel.UserActionInfo = (function() {

                    /**
                     * Properties of a UserActionInfo.
                     * @memberof AcFunDanmu.Im.Cloud.Channel
                     * @interface IUserActionInfo
                     * @property {AcFunDanmu.Im.Basic.IUser|null} [user] UserActionInfo user
                     * @property {AcFunDanmu.Im.Cloud.Channel.UserAction|null} [action] UserActionInfo action
                     * @property {number|Long|null} [timestamp] UserActionInfo timestamp
                     */

                    /**
                     * Constructs a new UserActionInfo.
                     * @memberof AcFunDanmu.Im.Cloud.Channel
                     * @classdesc Represents a UserActionInfo.
                     * @implements IUserActionInfo
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Channel.IUserActionInfo=} [properties] Properties to set
                     */
                    function UserActionInfo(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * UserActionInfo user.
                     * @member {AcFunDanmu.Im.Basic.IUser|null|undefined} user
                     * @memberof AcFunDanmu.Im.Cloud.Channel.UserActionInfo
                     * @instance
                     */
                    UserActionInfo.prototype.user = null;

                    /**
                     * UserActionInfo action.
                     * @member {AcFunDanmu.Im.Cloud.Channel.UserAction} action
                     * @memberof AcFunDanmu.Im.Cloud.Channel.UserActionInfo
                     * @instance
                     */
                    UserActionInfo.prototype.action = 0;

                    /**
                     * UserActionInfo timestamp.
                     * @member {number|Long} timestamp
                     * @memberof AcFunDanmu.Im.Cloud.Channel.UserActionInfo
                     * @instance
                     */
                    UserActionInfo.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * Creates a new UserActionInfo instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Channel.UserActionInfo
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Channel.IUserActionInfo=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Channel.UserActionInfo} UserActionInfo instance
                     */
                    UserActionInfo.create = function create(properties) {
                        return new UserActionInfo(properties);
                    };

                    /**
                     * Encodes the specified UserActionInfo message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Channel.UserActionInfo.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Channel.UserActionInfo
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Channel.IUserActionInfo} message UserActionInfo message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    UserActionInfo.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.user != null && Object.hasOwnProperty.call(message, "user"))
                            $root.AcFunDanmu.Im.Basic.User.encode(message.user, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.action);
                        if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.timestamp);
                        return writer;
                    };

                    /**
                     * Encodes the specified UserActionInfo message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Channel.UserActionInfo.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Channel.UserActionInfo
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Channel.IUserActionInfo} message UserActionInfo message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    UserActionInfo.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a UserActionInfo message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Channel.UserActionInfo
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Channel.UserActionInfo} UserActionInfo
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    UserActionInfo.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Channel.UserActionInfo();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.user = $root.AcFunDanmu.Im.Basic.User.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.action = reader.int32();
                                break;
                            case 3:
                                message.timestamp = reader.int64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a UserActionInfo message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Channel.UserActionInfo
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Channel.UserActionInfo} UserActionInfo
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    UserActionInfo.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a UserActionInfo message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Channel.UserActionInfo
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    UserActionInfo.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.user != null && message.hasOwnProperty("user")) {
                            let error = $root.AcFunDanmu.Im.Basic.User.verify(message.user);
                            if (error)
                                return "user." + error;
                        }
                        if (message.action != null && message.hasOwnProperty("action"))
                            switch (message.action) {
                            default:
                                return "action: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                                break;
                            }
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                                return "timestamp: integer|Long expected";
                        return null;
                    };

                    /**
                     * Creates a UserActionInfo message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Channel.UserActionInfo
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Channel.UserActionInfo} UserActionInfo
                     */
                    UserActionInfo.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Channel.UserActionInfo)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Channel.UserActionInfo();
                        if (object.user != null) {
                            if (typeof object.user !== "object")
                                throw TypeError(".AcFunDanmu.Im.Cloud.Channel.UserActionInfo.user: object expected");
                            message.user = $root.AcFunDanmu.Im.Basic.User.fromObject(object.user);
                        }
                        switch (object.action) {
                        case "USER_ACTION_UNKNOWN":
                        case 0:
                            message.action = 0;
                            break;
                        case "USER_JOIN_CHANNEL":
                        case 1:
                            message.action = 1;
                            break;
                        case "USER_QUIT_CHANNEL":
                        case 2:
                            message.action = 2;
                            break;
                        case "USER_OFFLINE":
                        case 3:
                            message.action = 3;
                            break;
                        }
                        if (object.timestamp != null)
                            if ($util.Long)
                                (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                            else if (typeof object.timestamp === "string")
                                message.timestamp = parseInt(object.timestamp, 10);
                            else if (typeof object.timestamp === "number")
                                message.timestamp = object.timestamp;
                            else if (typeof object.timestamp === "object")
                                message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                        return message;
                    };

                    /**
                     * Creates a plain object from a UserActionInfo message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Channel.UserActionInfo
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Channel.UserActionInfo} message UserActionInfo
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    UserActionInfo.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.user = null;
                            object.action = options.enums === String ? "USER_ACTION_UNKNOWN" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, false);
                                object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.timestamp = options.longs === String ? "0" : 0;
                        }
                        if (message.user != null && message.hasOwnProperty("user"))
                            object.user = $root.AcFunDanmu.Im.Basic.User.toObject(message.user, options);
                        if (message.action != null && message.hasOwnProperty("action"))
                            object.action = options.enums === String ? $root.AcFunDanmu.Im.Cloud.Channel.UserAction[message.action] : message.action;
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            if (typeof message.timestamp === "number")
                                object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                            else
                                object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                        return object;
                    };

                    /**
                     * Converts this UserActionInfo to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Channel.UserActionInfo
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    UserActionInfo.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return UserActionInfo;
                })();

                /**
                 * UserAction enum.
                 * @name AcFunDanmu.Im.Cloud.Channel.UserAction
                 * @enum {number}
                 * @property {number} USER_ACTION_UNKNOWN=0 USER_ACTION_UNKNOWN value
                 * @property {number} USER_JOIN_CHANNEL=1 USER_JOIN_CHANNEL value
                 * @property {number} USER_QUIT_CHANNEL=2 USER_QUIT_CHANNEL value
                 * @property {number} USER_OFFLINE=3 USER_OFFLINE value
                 */
                Channel.UserAction = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "USER_ACTION_UNKNOWN"] = 0;
                    values[valuesById[1] = "USER_JOIN_CHANNEL"] = 1;
                    values[valuesById[2] = "USER_QUIT_CHANNEL"] = 2;
                    values[valuesById[3] = "USER_OFFLINE"] = 3;
                    return values;
                })();

                Channel.ChannelBasicInfoGetRequest = (function() {

                    /**
                     * Properties of a ChannelBasicInfoGetRequest.
                     * @memberof AcFunDanmu.Im.Cloud.Channel
                     * @interface IChannelBasicInfoGetRequest
                     * @property {Array.<string>|null} [channelId] ChannelBasicInfoGetRequest channelId
                     */

                    /**
                     * Constructs a new ChannelBasicInfoGetRequest.
                     * @memberof AcFunDanmu.Im.Cloud.Channel
                     * @classdesc Represents a ChannelBasicInfoGetRequest.
                     * @implements IChannelBasicInfoGetRequest
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Channel.IChannelBasicInfoGetRequest=} [properties] Properties to set
                     */
                    function ChannelBasicInfoGetRequest(properties) {
                        this.channelId = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * ChannelBasicInfoGetRequest channelId.
                     * @member {Array.<string>} channelId
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoGetRequest
                     * @instance
                     */
                    ChannelBasicInfoGetRequest.prototype.channelId = $util.emptyArray;

                    /**
                     * Creates a new ChannelBasicInfoGetRequest instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoGetRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Channel.IChannelBasicInfoGetRequest=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoGetRequest} ChannelBasicInfoGetRequest instance
                     */
                    ChannelBasicInfoGetRequest.create = function create(properties) {
                        return new ChannelBasicInfoGetRequest(properties);
                    };

                    /**
                     * Encodes the specified ChannelBasicInfoGetRequest message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoGetRequest.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoGetRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Channel.IChannelBasicInfoGetRequest} message ChannelBasicInfoGetRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ChannelBasicInfoGetRequest.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.channelId != null && message.channelId.length)
                            for (let i = 0; i < message.channelId.length; ++i)
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.channelId[i]);
                        return writer;
                    };

                    /**
                     * Encodes the specified ChannelBasicInfoGetRequest message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoGetRequest.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoGetRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Channel.IChannelBasicInfoGetRequest} message ChannelBasicInfoGetRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ChannelBasicInfoGetRequest.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a ChannelBasicInfoGetRequest message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoGetRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoGetRequest} ChannelBasicInfoGetRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ChannelBasicInfoGetRequest.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoGetRequest();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.channelId && message.channelId.length))
                                    message.channelId = [];
                                message.channelId.push(reader.string());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a ChannelBasicInfoGetRequest message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoGetRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoGetRequest} ChannelBasicInfoGetRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ChannelBasicInfoGetRequest.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a ChannelBasicInfoGetRequest message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoGetRequest
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ChannelBasicInfoGetRequest.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.channelId != null && message.hasOwnProperty("channelId")) {
                            if (!Array.isArray(message.channelId))
                                return "channelId: array expected";
                            for (let i = 0; i < message.channelId.length; ++i)
                                if (!$util.isString(message.channelId[i]))
                                    return "channelId: string[] expected";
                        }
                        return null;
                    };

                    /**
                     * Creates a ChannelBasicInfoGetRequest message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoGetRequest
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoGetRequest} ChannelBasicInfoGetRequest
                     */
                    ChannelBasicInfoGetRequest.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoGetRequest)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoGetRequest();
                        if (object.channelId) {
                            if (!Array.isArray(object.channelId))
                                throw TypeError(".AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoGetRequest.channelId: array expected");
                            message.channelId = [];
                            for (let i = 0; i < object.channelId.length; ++i)
                                message.channelId[i] = String(object.channelId[i]);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a ChannelBasicInfoGetRequest message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoGetRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoGetRequest} message ChannelBasicInfoGetRequest
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ChannelBasicInfoGetRequest.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.channelId = [];
                        if (message.channelId && message.channelId.length) {
                            object.channelId = [];
                            for (let j = 0; j < message.channelId.length; ++j)
                                object.channelId[j] = message.channelId[j];
                        }
                        return object;
                    };

                    /**
                     * Converts this ChannelBasicInfoGetRequest to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoGetRequest
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ChannelBasicInfoGetRequest.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return ChannelBasicInfoGetRequest;
                })();

                Channel.ChannelBasicInfoGetResponse = (function() {

                    /**
                     * Properties of a ChannelBasicInfoGetResponse.
                     * @memberof AcFunDanmu.Im.Cloud.Channel
                     * @interface IChannelBasicInfoGetResponse
                     * @property {Array.<AcFunDanmu.Im.Cloud.Channel.IChannelBasicInfo>|null} [basicInfo] ChannelBasicInfoGetResponse basicInfo
                     */

                    /**
                     * Constructs a new ChannelBasicInfoGetResponse.
                     * @memberof AcFunDanmu.Im.Cloud.Channel
                     * @classdesc Represents a ChannelBasicInfoGetResponse.
                     * @implements IChannelBasicInfoGetResponse
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Channel.IChannelBasicInfoGetResponse=} [properties] Properties to set
                     */
                    function ChannelBasicInfoGetResponse(properties) {
                        this.basicInfo = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * ChannelBasicInfoGetResponse basicInfo.
                     * @member {Array.<AcFunDanmu.Im.Cloud.Channel.IChannelBasicInfo>} basicInfo
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoGetResponse
                     * @instance
                     */
                    ChannelBasicInfoGetResponse.prototype.basicInfo = $util.emptyArray;

                    /**
                     * Creates a new ChannelBasicInfoGetResponse instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoGetResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Channel.IChannelBasicInfoGetResponse=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoGetResponse} ChannelBasicInfoGetResponse instance
                     */
                    ChannelBasicInfoGetResponse.create = function create(properties) {
                        return new ChannelBasicInfoGetResponse(properties);
                    };

                    /**
                     * Encodes the specified ChannelBasicInfoGetResponse message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoGetResponse.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoGetResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Channel.IChannelBasicInfoGetResponse} message ChannelBasicInfoGetResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ChannelBasicInfoGetResponse.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.basicInfo != null && message.basicInfo.length)
                            for (let i = 0; i < message.basicInfo.length; ++i)
                                $root.AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfo.encode(message.basicInfo[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified ChannelBasicInfoGetResponse message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoGetResponse.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoGetResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Channel.IChannelBasicInfoGetResponse} message ChannelBasicInfoGetResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ChannelBasicInfoGetResponse.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a ChannelBasicInfoGetResponse message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoGetResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoGetResponse} ChannelBasicInfoGetResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ChannelBasicInfoGetResponse.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoGetResponse();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.basicInfo && message.basicInfo.length))
                                    message.basicInfo = [];
                                message.basicInfo.push($root.AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfo.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a ChannelBasicInfoGetResponse message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoGetResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoGetResponse} ChannelBasicInfoGetResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ChannelBasicInfoGetResponse.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a ChannelBasicInfoGetResponse message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoGetResponse
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ChannelBasicInfoGetResponse.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.basicInfo != null && message.hasOwnProperty("basicInfo")) {
                            if (!Array.isArray(message.basicInfo))
                                return "basicInfo: array expected";
                            for (let i = 0; i < message.basicInfo.length; ++i) {
                                let error = $root.AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfo.verify(message.basicInfo[i]);
                                if (error)
                                    return "basicInfo." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a ChannelBasicInfoGetResponse message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoGetResponse
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoGetResponse} ChannelBasicInfoGetResponse
                     */
                    ChannelBasicInfoGetResponse.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoGetResponse)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoGetResponse();
                        if (object.basicInfo) {
                            if (!Array.isArray(object.basicInfo))
                                throw TypeError(".AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoGetResponse.basicInfo: array expected");
                            message.basicInfo = [];
                            for (let i = 0; i < object.basicInfo.length; ++i) {
                                if (typeof object.basicInfo[i] !== "object")
                                    throw TypeError(".AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoGetResponse.basicInfo: object expected");
                                message.basicInfo[i] = $root.AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfo.fromObject(object.basicInfo[i]);
                            }
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a ChannelBasicInfoGetResponse message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoGetResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoGetResponse} message ChannelBasicInfoGetResponse
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ChannelBasicInfoGetResponse.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.basicInfo = [];
                        if (message.basicInfo && message.basicInfo.length) {
                            object.basicInfo = [];
                            for (let j = 0; j < message.basicInfo.length; ++j)
                                object.basicInfo[j] = $root.AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfo.toObject(message.basicInfo[j], options);
                        }
                        return object;
                    };

                    /**
                     * Converts this ChannelBasicInfoGetResponse to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoGetResponse
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ChannelBasicInfoGetResponse.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return ChannelBasicInfoGetResponse;
                })();

                Channel.ChannelHeartbeatRequest = (function() {

                    /**
                     * Properties of a ChannelHeartbeatRequest.
                     * @memberof AcFunDanmu.Im.Cloud.Channel
                     * @interface IChannelHeartbeatRequest
                     * @property {Array.<string>|null} [channelId] ChannelHeartbeatRequest channelId
                     */

                    /**
                     * Constructs a new ChannelHeartbeatRequest.
                     * @memberof AcFunDanmu.Im.Cloud.Channel
                     * @classdesc Represents a ChannelHeartbeatRequest.
                     * @implements IChannelHeartbeatRequest
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Channel.IChannelHeartbeatRequest=} [properties] Properties to set
                     */
                    function ChannelHeartbeatRequest(properties) {
                        this.channelId = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * ChannelHeartbeatRequest channelId.
                     * @member {Array.<string>} channelId
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelHeartbeatRequest
                     * @instance
                     */
                    ChannelHeartbeatRequest.prototype.channelId = $util.emptyArray;

                    /**
                     * Creates a new ChannelHeartbeatRequest instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelHeartbeatRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Channel.IChannelHeartbeatRequest=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Channel.ChannelHeartbeatRequest} ChannelHeartbeatRequest instance
                     */
                    ChannelHeartbeatRequest.create = function create(properties) {
                        return new ChannelHeartbeatRequest(properties);
                    };

                    /**
                     * Encodes the specified ChannelHeartbeatRequest message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Channel.ChannelHeartbeatRequest.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelHeartbeatRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Channel.IChannelHeartbeatRequest} message ChannelHeartbeatRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ChannelHeartbeatRequest.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.channelId != null && message.channelId.length)
                            for (let i = 0; i < message.channelId.length; ++i)
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.channelId[i]);
                        return writer;
                    };

                    /**
                     * Encodes the specified ChannelHeartbeatRequest message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Channel.ChannelHeartbeatRequest.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelHeartbeatRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Channel.IChannelHeartbeatRequest} message ChannelHeartbeatRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ChannelHeartbeatRequest.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a ChannelHeartbeatRequest message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelHeartbeatRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Channel.ChannelHeartbeatRequest} ChannelHeartbeatRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ChannelHeartbeatRequest.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Channel.ChannelHeartbeatRequest();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.channelId && message.channelId.length))
                                    message.channelId = [];
                                message.channelId.push(reader.string());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a ChannelHeartbeatRequest message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelHeartbeatRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Channel.ChannelHeartbeatRequest} ChannelHeartbeatRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ChannelHeartbeatRequest.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a ChannelHeartbeatRequest message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelHeartbeatRequest
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ChannelHeartbeatRequest.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.channelId != null && message.hasOwnProperty("channelId")) {
                            if (!Array.isArray(message.channelId))
                                return "channelId: array expected";
                            for (let i = 0; i < message.channelId.length; ++i)
                                if (!$util.isString(message.channelId[i]))
                                    return "channelId: string[] expected";
                        }
                        return null;
                    };

                    /**
                     * Creates a ChannelHeartbeatRequest message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelHeartbeatRequest
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Channel.ChannelHeartbeatRequest} ChannelHeartbeatRequest
                     */
                    ChannelHeartbeatRequest.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Channel.ChannelHeartbeatRequest)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Channel.ChannelHeartbeatRequest();
                        if (object.channelId) {
                            if (!Array.isArray(object.channelId))
                                throw TypeError(".AcFunDanmu.Im.Cloud.Channel.ChannelHeartbeatRequest.channelId: array expected");
                            message.channelId = [];
                            for (let i = 0; i < object.channelId.length; ++i)
                                message.channelId[i] = String(object.channelId[i]);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a ChannelHeartbeatRequest message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelHeartbeatRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Channel.ChannelHeartbeatRequest} message ChannelHeartbeatRequest
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ChannelHeartbeatRequest.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.channelId = [];
                        if (message.channelId && message.channelId.length) {
                            object.channelId = [];
                            for (let j = 0; j < message.channelId.length; ++j)
                                object.channelId[j] = message.channelId[j];
                        }
                        return object;
                    };

                    /**
                     * Converts this ChannelHeartbeatRequest to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelHeartbeatRequest
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ChannelHeartbeatRequest.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return ChannelHeartbeatRequest;
                })();

                Channel.ChannelHeartbeatResponse = (function() {

                    /**
                     * Properties of a ChannelHeartbeatResponse.
                     * @memberof AcFunDanmu.Im.Cloud.Channel
                     * @interface IChannelHeartbeatResponse
                     * @property {Array.<string>|null} [notExistChannelId] ChannelHeartbeatResponse notExistChannelId
                     */

                    /**
                     * Constructs a new ChannelHeartbeatResponse.
                     * @memberof AcFunDanmu.Im.Cloud.Channel
                     * @classdesc Represents a ChannelHeartbeatResponse.
                     * @implements IChannelHeartbeatResponse
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Channel.IChannelHeartbeatResponse=} [properties] Properties to set
                     */
                    function ChannelHeartbeatResponse(properties) {
                        this.notExistChannelId = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * ChannelHeartbeatResponse notExistChannelId.
                     * @member {Array.<string>} notExistChannelId
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelHeartbeatResponse
                     * @instance
                     */
                    ChannelHeartbeatResponse.prototype.notExistChannelId = $util.emptyArray;

                    /**
                     * Creates a new ChannelHeartbeatResponse instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelHeartbeatResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Channel.IChannelHeartbeatResponse=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Channel.ChannelHeartbeatResponse} ChannelHeartbeatResponse instance
                     */
                    ChannelHeartbeatResponse.create = function create(properties) {
                        return new ChannelHeartbeatResponse(properties);
                    };

                    /**
                     * Encodes the specified ChannelHeartbeatResponse message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Channel.ChannelHeartbeatResponse.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelHeartbeatResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Channel.IChannelHeartbeatResponse} message ChannelHeartbeatResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ChannelHeartbeatResponse.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.notExistChannelId != null && message.notExistChannelId.length)
                            for (let i = 0; i < message.notExistChannelId.length; ++i)
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.notExistChannelId[i]);
                        return writer;
                    };

                    /**
                     * Encodes the specified ChannelHeartbeatResponse message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Channel.ChannelHeartbeatResponse.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelHeartbeatResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Channel.IChannelHeartbeatResponse} message ChannelHeartbeatResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ChannelHeartbeatResponse.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a ChannelHeartbeatResponse message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelHeartbeatResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Channel.ChannelHeartbeatResponse} ChannelHeartbeatResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ChannelHeartbeatResponse.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Channel.ChannelHeartbeatResponse();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.notExistChannelId && message.notExistChannelId.length))
                                    message.notExistChannelId = [];
                                message.notExistChannelId.push(reader.string());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a ChannelHeartbeatResponse message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelHeartbeatResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Channel.ChannelHeartbeatResponse} ChannelHeartbeatResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ChannelHeartbeatResponse.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a ChannelHeartbeatResponse message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelHeartbeatResponse
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ChannelHeartbeatResponse.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.notExistChannelId != null && message.hasOwnProperty("notExistChannelId")) {
                            if (!Array.isArray(message.notExistChannelId))
                                return "notExistChannelId: array expected";
                            for (let i = 0; i < message.notExistChannelId.length; ++i)
                                if (!$util.isString(message.notExistChannelId[i]))
                                    return "notExistChannelId: string[] expected";
                        }
                        return null;
                    };

                    /**
                     * Creates a ChannelHeartbeatResponse message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelHeartbeatResponse
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Channel.ChannelHeartbeatResponse} ChannelHeartbeatResponse
                     */
                    ChannelHeartbeatResponse.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Channel.ChannelHeartbeatResponse)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Channel.ChannelHeartbeatResponse();
                        if (object.notExistChannelId) {
                            if (!Array.isArray(object.notExistChannelId))
                                throw TypeError(".AcFunDanmu.Im.Cloud.Channel.ChannelHeartbeatResponse.notExistChannelId: array expected");
                            message.notExistChannelId = [];
                            for (let i = 0; i < object.notExistChannelId.length; ++i)
                                message.notExistChannelId[i] = String(object.notExistChannelId[i]);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a ChannelHeartbeatResponse message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelHeartbeatResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Channel.ChannelHeartbeatResponse} message ChannelHeartbeatResponse
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ChannelHeartbeatResponse.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.notExistChannelId = [];
                        if (message.notExistChannelId && message.notExistChannelId.length) {
                            object.notExistChannelId = [];
                            for (let j = 0; j < message.notExistChannelId.length; ++j)
                                object.notExistChannelId[j] = message.notExistChannelId[j];
                        }
                        return object;
                    };

                    /**
                     * Converts this ChannelHeartbeatResponse to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelHeartbeatResponse
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ChannelHeartbeatResponse.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return ChannelHeartbeatResponse;
                })();

                Channel.ChannelBasicInfoNotify = (function() {

                    /**
                     * Properties of a ChannelBasicInfoNotify.
                     * @memberof AcFunDanmu.Im.Cloud.Channel
                     * @interface IChannelBasicInfoNotify
                     * @property {AcFunDanmu.Im.Cloud.Channel.IUserActionInfo|null} [userActionInfo] ChannelBasicInfoNotify userActionInfo
                     * @property {AcFunDanmu.Im.Cloud.Channel.IChannelBasicInfo|null} [basicInfo] ChannelBasicInfoNotify basicInfo
                     */

                    /**
                     * Constructs a new ChannelBasicInfoNotify.
                     * @memberof AcFunDanmu.Im.Cloud.Channel
                     * @classdesc Represents a ChannelBasicInfoNotify.
                     * @implements IChannelBasicInfoNotify
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Channel.IChannelBasicInfoNotify=} [properties] Properties to set
                     */
                    function ChannelBasicInfoNotify(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * ChannelBasicInfoNotify userActionInfo.
                     * @member {AcFunDanmu.Im.Cloud.Channel.IUserActionInfo|null|undefined} userActionInfo
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoNotify
                     * @instance
                     */
                    ChannelBasicInfoNotify.prototype.userActionInfo = null;

                    /**
                     * ChannelBasicInfoNotify basicInfo.
                     * @member {AcFunDanmu.Im.Cloud.Channel.IChannelBasicInfo|null|undefined} basicInfo
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoNotify
                     * @instance
                     */
                    ChannelBasicInfoNotify.prototype.basicInfo = null;

                    /**
                     * Creates a new ChannelBasicInfoNotify instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoNotify
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Channel.IChannelBasicInfoNotify=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoNotify} ChannelBasicInfoNotify instance
                     */
                    ChannelBasicInfoNotify.create = function create(properties) {
                        return new ChannelBasicInfoNotify(properties);
                    };

                    /**
                     * Encodes the specified ChannelBasicInfoNotify message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoNotify.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoNotify
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Channel.IChannelBasicInfoNotify} message ChannelBasicInfoNotify message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ChannelBasicInfoNotify.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.userActionInfo != null && Object.hasOwnProperty.call(message, "userActionInfo"))
                            $root.AcFunDanmu.Im.Cloud.Channel.UserActionInfo.encode(message.userActionInfo, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.basicInfo != null && Object.hasOwnProperty.call(message, "basicInfo"))
                            $root.AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfo.encode(message.basicInfo, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified ChannelBasicInfoNotify message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoNotify.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoNotify
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Channel.IChannelBasicInfoNotify} message ChannelBasicInfoNotify message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ChannelBasicInfoNotify.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a ChannelBasicInfoNotify message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoNotify
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoNotify} ChannelBasicInfoNotify
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ChannelBasicInfoNotify.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoNotify();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.userActionInfo = $root.AcFunDanmu.Im.Cloud.Channel.UserActionInfo.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.basicInfo = $root.AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfo.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a ChannelBasicInfoNotify message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoNotify
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoNotify} ChannelBasicInfoNotify
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ChannelBasicInfoNotify.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a ChannelBasicInfoNotify message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoNotify
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ChannelBasicInfoNotify.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.userActionInfo != null && message.hasOwnProperty("userActionInfo")) {
                            let error = $root.AcFunDanmu.Im.Cloud.Channel.UserActionInfo.verify(message.userActionInfo);
                            if (error)
                                return "userActionInfo." + error;
                        }
                        if (message.basicInfo != null && message.hasOwnProperty("basicInfo")) {
                            let error = $root.AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfo.verify(message.basicInfo);
                            if (error)
                                return "basicInfo." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a ChannelBasicInfoNotify message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoNotify
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoNotify} ChannelBasicInfoNotify
                     */
                    ChannelBasicInfoNotify.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoNotify)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoNotify();
                        if (object.userActionInfo != null) {
                            if (typeof object.userActionInfo !== "object")
                                throw TypeError(".AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoNotify.userActionInfo: object expected");
                            message.userActionInfo = $root.AcFunDanmu.Im.Cloud.Channel.UserActionInfo.fromObject(object.userActionInfo);
                        }
                        if (object.basicInfo != null) {
                            if (typeof object.basicInfo !== "object")
                                throw TypeError(".AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoNotify.basicInfo: object expected");
                            message.basicInfo = $root.AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfo.fromObject(object.basicInfo);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a ChannelBasicInfoNotify message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoNotify
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoNotify} message ChannelBasicInfoNotify
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ChannelBasicInfoNotify.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.userActionInfo = null;
                            object.basicInfo = null;
                        }
                        if (message.userActionInfo != null && message.hasOwnProperty("userActionInfo"))
                            object.userActionInfo = $root.AcFunDanmu.Im.Cloud.Channel.UserActionInfo.toObject(message.userActionInfo, options);
                        if (message.basicInfo != null && message.hasOwnProperty("basicInfo"))
                            object.basicInfo = $root.AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfo.toObject(message.basicInfo, options);
                        return object;
                    };

                    /**
                     * Converts this ChannelBasicInfoNotify to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Channel.ChannelBasicInfoNotify
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ChannelBasicInfoNotify.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return ChannelBasicInfoNotify;
                })();

                return Channel;
            })();

            Cloud.Config = (function() {

                /**
                 * Properties of a Config.
                 * @memberof AcFunDanmu.Im.Cloud
                 * @interface IConfig
                 */

                /**
                 * Constructs a new Config.
                 * @memberof AcFunDanmu.Im.Cloud
                 * @classdesc Represents a Config.
                 * @implements IConfig
                 * @constructor
                 * @param {AcFunDanmu.Im.Cloud.IConfig=} [properties] Properties to set
                 */
                function Config(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new Config instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Cloud.Config
                 * @static
                 * @param {AcFunDanmu.Im.Cloud.IConfig=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Cloud.Config} Config instance
                 */
                Config.create = function create(properties) {
                    return new Config(properties);
                };

                /**
                 * Encodes the specified Config message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Config.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Cloud.Config
                 * @static
                 * @param {AcFunDanmu.Im.Cloud.IConfig} message Config message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Config.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified Config message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Config.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Cloud.Config
                 * @static
                 * @param {AcFunDanmu.Im.Cloud.IConfig} message Config message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Config.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Config message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Cloud.Config
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Cloud.Config} Config
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Config.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Config();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Config message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Cloud.Config
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Cloud.Config} Config
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Config.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Config message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Cloud.Config
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Config.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a Config message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Cloud.Config
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Cloud.Config} Config
                 */
                Config.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Cloud.Config)
                        return object;
                    return new $root.AcFunDanmu.Im.Cloud.Config();
                };

                /**
                 * Creates a plain object from a Config message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Cloud.Config
                 * @static
                 * @param {AcFunDanmu.Im.Cloud.Config} message Config
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Config.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this Config to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Cloud.Config
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Config.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                Config.ClientConfigGetRequest = (function() {

                    /**
                     * Properties of a ClientConfigGetRequest.
                     * @memberof AcFunDanmu.Im.Cloud.Config
                     * @interface IClientConfigGetRequest
                     * @property {number|null} [version] ClientConfigGetRequest version
                     */

                    /**
                     * Constructs a new ClientConfigGetRequest.
                     * @memberof AcFunDanmu.Im.Cloud.Config
                     * @classdesc Represents a ClientConfigGetRequest.
                     * @implements IClientConfigGetRequest
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Config.IClientConfigGetRequest=} [properties] Properties to set
                     */
                    function ClientConfigGetRequest(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * ClientConfigGetRequest version.
                     * @member {number} version
                     * @memberof AcFunDanmu.Im.Cloud.Config.ClientConfigGetRequest
                     * @instance
                     */
                    ClientConfigGetRequest.prototype.version = 0;

                    /**
                     * Creates a new ClientConfigGetRequest instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Config.ClientConfigGetRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Config.IClientConfigGetRequest=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Config.ClientConfigGetRequest} ClientConfigGetRequest instance
                     */
                    ClientConfigGetRequest.create = function create(properties) {
                        return new ClientConfigGetRequest(properties);
                    };

                    /**
                     * Encodes the specified ClientConfigGetRequest message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Config.ClientConfigGetRequest.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Config.ClientConfigGetRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Config.IClientConfigGetRequest} message ClientConfigGetRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ClientConfigGetRequest.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.version);
                        return writer;
                    };

                    /**
                     * Encodes the specified ClientConfigGetRequest message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Config.ClientConfigGetRequest.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Config.ClientConfigGetRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Config.IClientConfigGetRequest} message ClientConfigGetRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ClientConfigGetRequest.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a ClientConfigGetRequest message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Config.ClientConfigGetRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Config.ClientConfigGetRequest} ClientConfigGetRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ClientConfigGetRequest.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Config.ClientConfigGetRequest();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.version = reader.uint32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a ClientConfigGetRequest message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Config.ClientConfigGetRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Config.ClientConfigGetRequest} ClientConfigGetRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ClientConfigGetRequest.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a ClientConfigGetRequest message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Config.ClientConfigGetRequest
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ClientConfigGetRequest.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.version != null && message.hasOwnProperty("version"))
                            if (!$util.isInteger(message.version))
                                return "version: integer expected";
                        return null;
                    };

                    /**
                     * Creates a ClientConfigGetRequest message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Config.ClientConfigGetRequest
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Config.ClientConfigGetRequest} ClientConfigGetRequest
                     */
                    ClientConfigGetRequest.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Config.ClientConfigGetRequest)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Config.ClientConfigGetRequest();
                        if (object.version != null)
                            message.version = object.version >>> 0;
                        return message;
                    };

                    /**
                     * Creates a plain object from a ClientConfigGetRequest message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Config.ClientConfigGetRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Config.ClientConfigGetRequest} message ClientConfigGetRequest
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ClientConfigGetRequest.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.version = 0;
                        if (message.version != null && message.hasOwnProperty("version"))
                            object.version = message.version;
                        return object;
                    };

                    /**
                     * Converts this ClientConfigGetRequest to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Config.ClientConfigGetRequest
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ClientConfigGetRequest.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return ClientConfigGetRequest;
                })();

                Config.ClientConfigGetResponse = (function() {

                    /**
                     * Properties of a ClientConfigGetResponse.
                     * @memberof AcFunDanmu.Im.Cloud.Config
                     * @interface IClientConfigGetResponse
                     * @property {number|null} [version] ClientConfigGetResponse version
                     * @property {AcFunDanmu.Im.Cloud.Config.IClientConfig|null} [clientConfig] ClientConfigGetResponse clientConfig
                     */

                    /**
                     * Constructs a new ClientConfigGetResponse.
                     * @memberof AcFunDanmu.Im.Cloud.Config
                     * @classdesc Represents a ClientConfigGetResponse.
                     * @implements IClientConfigGetResponse
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Config.IClientConfigGetResponse=} [properties] Properties to set
                     */
                    function ClientConfigGetResponse(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * ClientConfigGetResponse version.
                     * @member {number} version
                     * @memberof AcFunDanmu.Im.Cloud.Config.ClientConfigGetResponse
                     * @instance
                     */
                    ClientConfigGetResponse.prototype.version = 0;

                    /**
                     * ClientConfigGetResponse clientConfig.
                     * @member {AcFunDanmu.Im.Cloud.Config.IClientConfig|null|undefined} clientConfig
                     * @memberof AcFunDanmu.Im.Cloud.Config.ClientConfigGetResponse
                     * @instance
                     */
                    ClientConfigGetResponse.prototype.clientConfig = null;

                    /**
                     * Creates a new ClientConfigGetResponse instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Config.ClientConfigGetResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Config.IClientConfigGetResponse=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Config.ClientConfigGetResponse} ClientConfigGetResponse instance
                     */
                    ClientConfigGetResponse.create = function create(properties) {
                        return new ClientConfigGetResponse(properties);
                    };

                    /**
                     * Encodes the specified ClientConfigGetResponse message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Config.ClientConfigGetResponse.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Config.ClientConfigGetResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Config.IClientConfigGetResponse} message ClientConfigGetResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ClientConfigGetResponse.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.version);
                        if (message.clientConfig != null && Object.hasOwnProperty.call(message, "clientConfig"))
                            $root.AcFunDanmu.Im.Cloud.Config.ClientConfig.encode(message.clientConfig, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified ClientConfigGetResponse message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Config.ClientConfigGetResponse.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Config.ClientConfigGetResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Config.IClientConfigGetResponse} message ClientConfigGetResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ClientConfigGetResponse.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a ClientConfigGetResponse message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Config.ClientConfigGetResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Config.ClientConfigGetResponse} ClientConfigGetResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ClientConfigGetResponse.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Config.ClientConfigGetResponse();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.version = reader.uint32();
                                break;
                            case 2:
                                message.clientConfig = $root.AcFunDanmu.Im.Cloud.Config.ClientConfig.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a ClientConfigGetResponse message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Config.ClientConfigGetResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Config.ClientConfigGetResponse} ClientConfigGetResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ClientConfigGetResponse.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a ClientConfigGetResponse message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Config.ClientConfigGetResponse
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ClientConfigGetResponse.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.version != null && message.hasOwnProperty("version"))
                            if (!$util.isInteger(message.version))
                                return "version: integer expected";
                        if (message.clientConfig != null && message.hasOwnProperty("clientConfig")) {
                            let error = $root.AcFunDanmu.Im.Cloud.Config.ClientConfig.verify(message.clientConfig);
                            if (error)
                                return "clientConfig." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a ClientConfigGetResponse message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Config.ClientConfigGetResponse
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Config.ClientConfigGetResponse} ClientConfigGetResponse
                     */
                    ClientConfigGetResponse.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Config.ClientConfigGetResponse)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Config.ClientConfigGetResponse();
                        if (object.version != null)
                            message.version = object.version >>> 0;
                        if (object.clientConfig != null) {
                            if (typeof object.clientConfig !== "object")
                                throw TypeError(".AcFunDanmu.Im.Cloud.Config.ClientConfigGetResponse.clientConfig: object expected");
                            message.clientConfig = $root.AcFunDanmu.Im.Cloud.Config.ClientConfig.fromObject(object.clientConfig);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a ClientConfigGetResponse message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Config.ClientConfigGetResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Config.ClientConfigGetResponse} message ClientConfigGetResponse
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ClientConfigGetResponse.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.version = 0;
                            object.clientConfig = null;
                        }
                        if (message.version != null && message.hasOwnProperty("version"))
                            object.version = message.version;
                        if (message.clientConfig != null && message.hasOwnProperty("clientConfig"))
                            object.clientConfig = $root.AcFunDanmu.Im.Cloud.Config.ClientConfig.toObject(message.clientConfig, options);
                        return object;
                    };

                    /**
                     * Converts this ClientConfigGetResponse to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Config.ClientConfigGetResponse
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ClientConfigGetResponse.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return ClientConfigGetResponse;
                })();

                Config.NetworkQualityDetectionConfig = (function() {

                    /**
                     * Properties of a NetworkQualityDetectionConfig.
                     * @memberof AcFunDanmu.Im.Cloud.Config
                     * @interface INetworkQualityDetectionConfig
                     * @property {string|null} [detectionDomain] NetworkQualityDetectionConfig detectionDomain
                     * @property {number|null} [detectionInvervalSec] NetworkQualityDetectionConfig detectionInvervalSec
                     */

                    /**
                     * Constructs a new NetworkQualityDetectionConfig.
                     * @memberof AcFunDanmu.Im.Cloud.Config
                     * @classdesc Represents a NetworkQualityDetectionConfig.
                     * @implements INetworkQualityDetectionConfig
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Config.INetworkQualityDetectionConfig=} [properties] Properties to set
                     */
                    function NetworkQualityDetectionConfig(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * NetworkQualityDetectionConfig detectionDomain.
                     * @member {string} detectionDomain
                     * @memberof AcFunDanmu.Im.Cloud.Config.NetworkQualityDetectionConfig
                     * @instance
                     */
                    NetworkQualityDetectionConfig.prototype.detectionDomain = "";

                    /**
                     * NetworkQualityDetectionConfig detectionInvervalSec.
                     * @member {number} detectionInvervalSec
                     * @memberof AcFunDanmu.Im.Cloud.Config.NetworkQualityDetectionConfig
                     * @instance
                     */
                    NetworkQualityDetectionConfig.prototype.detectionInvervalSec = 0;

                    /**
                     * Creates a new NetworkQualityDetectionConfig instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Config.NetworkQualityDetectionConfig
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Config.INetworkQualityDetectionConfig=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Config.NetworkQualityDetectionConfig} NetworkQualityDetectionConfig instance
                     */
                    NetworkQualityDetectionConfig.create = function create(properties) {
                        return new NetworkQualityDetectionConfig(properties);
                    };

                    /**
                     * Encodes the specified NetworkQualityDetectionConfig message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Config.NetworkQualityDetectionConfig.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Config.NetworkQualityDetectionConfig
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Config.INetworkQualityDetectionConfig} message NetworkQualityDetectionConfig message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    NetworkQualityDetectionConfig.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.detectionDomain != null && Object.hasOwnProperty.call(message, "detectionDomain"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.detectionDomain);
                        if (message.detectionInvervalSec != null && Object.hasOwnProperty.call(message, "detectionInvervalSec"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.detectionInvervalSec);
                        return writer;
                    };

                    /**
                     * Encodes the specified NetworkQualityDetectionConfig message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Config.NetworkQualityDetectionConfig.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Config.NetworkQualityDetectionConfig
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Config.INetworkQualityDetectionConfig} message NetworkQualityDetectionConfig message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    NetworkQualityDetectionConfig.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a NetworkQualityDetectionConfig message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Config.NetworkQualityDetectionConfig
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Config.NetworkQualityDetectionConfig} NetworkQualityDetectionConfig
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    NetworkQualityDetectionConfig.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Config.NetworkQualityDetectionConfig();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.detectionDomain = reader.string();
                                break;
                            case 2:
                                message.detectionInvervalSec = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a NetworkQualityDetectionConfig message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Config.NetworkQualityDetectionConfig
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Config.NetworkQualityDetectionConfig} NetworkQualityDetectionConfig
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    NetworkQualityDetectionConfig.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a NetworkQualityDetectionConfig message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Config.NetworkQualityDetectionConfig
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    NetworkQualityDetectionConfig.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.detectionDomain != null && message.hasOwnProperty("detectionDomain"))
                            if (!$util.isString(message.detectionDomain))
                                return "detectionDomain: string expected";
                        if (message.detectionInvervalSec != null && message.hasOwnProperty("detectionInvervalSec"))
                            if (!$util.isInteger(message.detectionInvervalSec))
                                return "detectionInvervalSec: integer expected";
                        return null;
                    };

                    /**
                     * Creates a NetworkQualityDetectionConfig message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Config.NetworkQualityDetectionConfig
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Config.NetworkQualityDetectionConfig} NetworkQualityDetectionConfig
                     */
                    NetworkQualityDetectionConfig.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Config.NetworkQualityDetectionConfig)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Config.NetworkQualityDetectionConfig();
                        if (object.detectionDomain != null)
                            message.detectionDomain = String(object.detectionDomain);
                        if (object.detectionInvervalSec != null)
                            message.detectionInvervalSec = object.detectionInvervalSec | 0;
                        return message;
                    };

                    /**
                     * Creates a plain object from a NetworkQualityDetectionConfig message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Config.NetworkQualityDetectionConfig
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Config.NetworkQualityDetectionConfig} message NetworkQualityDetectionConfig
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    NetworkQualityDetectionConfig.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.detectionDomain = "";
                            object.detectionInvervalSec = 0;
                        }
                        if (message.detectionDomain != null && message.hasOwnProperty("detectionDomain"))
                            object.detectionDomain = message.detectionDomain;
                        if (message.detectionInvervalSec != null && message.hasOwnProperty("detectionInvervalSec"))
                            object.detectionInvervalSec = message.detectionInvervalSec;
                        return object;
                    };

                    /**
                     * Converts this NetworkQualityDetectionConfig to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Config.NetworkQualityDetectionConfig
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    NetworkQualityDetectionConfig.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return NetworkQualityDetectionConfig;
                })();

                Config.ClientConfig = (function() {

                    /**
                     * Properties of a ClientConfig.
                     * @memberof AcFunDanmu.Im.Cloud.Config
                     * @interface IClientConfig
                     * @property {number|null} [fetchUserStatusInterval] ClientConfig fetchUserStatusInterval
                     * @property {number|null} [channelUserHeartbeatInterval] ClientConfig channelUserHeartbeatInterval
                     * @property {AcFunDanmu.Im.Cloud.Config.INetworkQualityDetectionConfig|null} [networkQualityDetectionConfig] ClientConfig networkQualityDetectionConfig
                     * @property {number|null} [inputtingTipDisplayInterval] ClientConfig inputtingTipDisplayInterval
                     * @property {number|null} [batchSendMessageMaxCount] ClientConfig batchSendMessageMaxCount
                     * @property {string|null} [resourceUploadingDomain] ClientConfig resourceUploadingDomain
                     */

                    /**
                     * Constructs a new ClientConfig.
                     * @memberof AcFunDanmu.Im.Cloud.Config
                     * @classdesc Represents a ClientConfig.
                     * @implements IClientConfig
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Config.IClientConfig=} [properties] Properties to set
                     */
                    function ClientConfig(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * ClientConfig fetchUserStatusInterval.
                     * @member {number} fetchUserStatusInterval
                     * @memberof AcFunDanmu.Im.Cloud.Config.ClientConfig
                     * @instance
                     */
                    ClientConfig.prototype.fetchUserStatusInterval = 0;

                    /**
                     * ClientConfig channelUserHeartbeatInterval.
                     * @member {number} channelUserHeartbeatInterval
                     * @memberof AcFunDanmu.Im.Cloud.Config.ClientConfig
                     * @instance
                     */
                    ClientConfig.prototype.channelUserHeartbeatInterval = 0;

                    /**
                     * ClientConfig networkQualityDetectionConfig.
                     * @member {AcFunDanmu.Im.Cloud.Config.INetworkQualityDetectionConfig|null|undefined} networkQualityDetectionConfig
                     * @memberof AcFunDanmu.Im.Cloud.Config.ClientConfig
                     * @instance
                     */
                    ClientConfig.prototype.networkQualityDetectionConfig = null;

                    /**
                     * ClientConfig inputtingTipDisplayInterval.
                     * @member {number} inputtingTipDisplayInterval
                     * @memberof AcFunDanmu.Im.Cloud.Config.ClientConfig
                     * @instance
                     */
                    ClientConfig.prototype.inputtingTipDisplayInterval = 0;

                    /**
                     * ClientConfig batchSendMessageMaxCount.
                     * @member {number} batchSendMessageMaxCount
                     * @memberof AcFunDanmu.Im.Cloud.Config.ClientConfig
                     * @instance
                     */
                    ClientConfig.prototype.batchSendMessageMaxCount = 0;

                    /**
                     * ClientConfig resourceUploadingDomain.
                     * @member {string} resourceUploadingDomain
                     * @memberof AcFunDanmu.Im.Cloud.Config.ClientConfig
                     * @instance
                     */
                    ClientConfig.prototype.resourceUploadingDomain = "";

                    /**
                     * Creates a new ClientConfig instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Config.ClientConfig
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Config.IClientConfig=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Config.ClientConfig} ClientConfig instance
                     */
                    ClientConfig.create = function create(properties) {
                        return new ClientConfig(properties);
                    };

                    /**
                     * Encodes the specified ClientConfig message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Config.ClientConfig.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Config.ClientConfig
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Config.IClientConfig} message ClientConfig message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ClientConfig.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.fetchUserStatusInterval != null && Object.hasOwnProperty.call(message, "fetchUserStatusInterval"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.fetchUserStatusInterval);
                        if (message.channelUserHeartbeatInterval != null && Object.hasOwnProperty.call(message, "channelUserHeartbeatInterval"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.channelUserHeartbeatInterval);
                        if (message.networkQualityDetectionConfig != null && Object.hasOwnProperty.call(message, "networkQualityDetectionConfig"))
                            $root.AcFunDanmu.Im.Cloud.Config.NetworkQualityDetectionConfig.encode(message.networkQualityDetectionConfig, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.inputtingTipDisplayInterval != null && Object.hasOwnProperty.call(message, "inputtingTipDisplayInterval"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.inputtingTipDisplayInterval);
                        if (message.batchSendMessageMaxCount != null && Object.hasOwnProperty.call(message, "batchSendMessageMaxCount"))
                            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.batchSendMessageMaxCount);
                        if (message.resourceUploadingDomain != null && Object.hasOwnProperty.call(message, "resourceUploadingDomain"))
                            writer.uint32(/* id 6, wireType 2 =*/50).string(message.resourceUploadingDomain);
                        return writer;
                    };

                    /**
                     * Encodes the specified ClientConfig message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Config.ClientConfig.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Config.ClientConfig
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Config.IClientConfig} message ClientConfig message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ClientConfig.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a ClientConfig message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Config.ClientConfig
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Config.ClientConfig} ClientConfig
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ClientConfig.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Config.ClientConfig();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.fetchUserStatusInterval = reader.int32();
                                break;
                            case 2:
                                message.channelUserHeartbeatInterval = reader.int32();
                                break;
                            case 3:
                                message.networkQualityDetectionConfig = $root.AcFunDanmu.Im.Cloud.Config.NetworkQualityDetectionConfig.decode(reader, reader.uint32());
                                break;
                            case 4:
                                message.inputtingTipDisplayInterval = reader.int32();
                                break;
                            case 5:
                                message.batchSendMessageMaxCount = reader.int32();
                                break;
                            case 6:
                                message.resourceUploadingDomain = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a ClientConfig message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Config.ClientConfig
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Config.ClientConfig} ClientConfig
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ClientConfig.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a ClientConfig message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Config.ClientConfig
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ClientConfig.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.fetchUserStatusInterval != null && message.hasOwnProperty("fetchUserStatusInterval"))
                            if (!$util.isInteger(message.fetchUserStatusInterval))
                                return "fetchUserStatusInterval: integer expected";
                        if (message.channelUserHeartbeatInterval != null && message.hasOwnProperty("channelUserHeartbeatInterval"))
                            if (!$util.isInteger(message.channelUserHeartbeatInterval))
                                return "channelUserHeartbeatInterval: integer expected";
                        if (message.networkQualityDetectionConfig != null && message.hasOwnProperty("networkQualityDetectionConfig")) {
                            let error = $root.AcFunDanmu.Im.Cloud.Config.NetworkQualityDetectionConfig.verify(message.networkQualityDetectionConfig);
                            if (error)
                                return "networkQualityDetectionConfig." + error;
                        }
                        if (message.inputtingTipDisplayInterval != null && message.hasOwnProperty("inputtingTipDisplayInterval"))
                            if (!$util.isInteger(message.inputtingTipDisplayInterval))
                                return "inputtingTipDisplayInterval: integer expected";
                        if (message.batchSendMessageMaxCount != null && message.hasOwnProperty("batchSendMessageMaxCount"))
                            if (!$util.isInteger(message.batchSendMessageMaxCount))
                                return "batchSendMessageMaxCount: integer expected";
                        if (message.resourceUploadingDomain != null && message.hasOwnProperty("resourceUploadingDomain"))
                            if (!$util.isString(message.resourceUploadingDomain))
                                return "resourceUploadingDomain: string expected";
                        return null;
                    };

                    /**
                     * Creates a ClientConfig message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Config.ClientConfig
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Config.ClientConfig} ClientConfig
                     */
                    ClientConfig.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Config.ClientConfig)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Config.ClientConfig();
                        if (object.fetchUserStatusInterval != null)
                            message.fetchUserStatusInterval = object.fetchUserStatusInterval | 0;
                        if (object.channelUserHeartbeatInterval != null)
                            message.channelUserHeartbeatInterval = object.channelUserHeartbeatInterval | 0;
                        if (object.networkQualityDetectionConfig != null) {
                            if (typeof object.networkQualityDetectionConfig !== "object")
                                throw TypeError(".AcFunDanmu.Im.Cloud.Config.ClientConfig.networkQualityDetectionConfig: object expected");
                            message.networkQualityDetectionConfig = $root.AcFunDanmu.Im.Cloud.Config.NetworkQualityDetectionConfig.fromObject(object.networkQualityDetectionConfig);
                        }
                        if (object.inputtingTipDisplayInterval != null)
                            message.inputtingTipDisplayInterval = object.inputtingTipDisplayInterval | 0;
                        if (object.batchSendMessageMaxCount != null)
                            message.batchSendMessageMaxCount = object.batchSendMessageMaxCount | 0;
                        if (object.resourceUploadingDomain != null)
                            message.resourceUploadingDomain = String(object.resourceUploadingDomain);
                        return message;
                    };

                    /**
                     * Creates a plain object from a ClientConfig message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Config.ClientConfig
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Config.ClientConfig} message ClientConfig
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ClientConfig.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.fetchUserStatusInterval = 0;
                            object.channelUserHeartbeatInterval = 0;
                            object.networkQualityDetectionConfig = null;
                            object.inputtingTipDisplayInterval = 0;
                            object.batchSendMessageMaxCount = 0;
                            object.resourceUploadingDomain = "";
                        }
                        if (message.fetchUserStatusInterval != null && message.hasOwnProperty("fetchUserStatusInterval"))
                            object.fetchUserStatusInterval = message.fetchUserStatusInterval;
                        if (message.channelUserHeartbeatInterval != null && message.hasOwnProperty("channelUserHeartbeatInterval"))
                            object.channelUserHeartbeatInterval = message.channelUserHeartbeatInterval;
                        if (message.networkQualityDetectionConfig != null && message.hasOwnProperty("networkQualityDetectionConfig"))
                            object.networkQualityDetectionConfig = $root.AcFunDanmu.Im.Cloud.Config.NetworkQualityDetectionConfig.toObject(message.networkQualityDetectionConfig, options);
                        if (message.inputtingTipDisplayInterval != null && message.hasOwnProperty("inputtingTipDisplayInterval"))
                            object.inputtingTipDisplayInterval = message.inputtingTipDisplayInterval;
                        if (message.batchSendMessageMaxCount != null && message.hasOwnProperty("batchSendMessageMaxCount"))
                            object.batchSendMessageMaxCount = message.batchSendMessageMaxCount;
                        if (message.resourceUploadingDomain != null && message.hasOwnProperty("resourceUploadingDomain"))
                            object.resourceUploadingDomain = message.resourceUploadingDomain;
                        return object;
                    };

                    /**
                     * Converts this ClientConfig to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Config.ClientConfig
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ClientConfig.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return ClientConfig;
                })();

                return Config;
            })();

            Cloud.Profile = (function() {

                /**
                 * Properties of a Profile.
                 * @memberof AcFunDanmu.Im.Cloud
                 * @interface IProfile
                 */

                /**
                 * Constructs a new Profile.
                 * @memberof AcFunDanmu.Im.Cloud
                 * @classdesc Represents a Profile.
                 * @implements IProfile
                 * @constructor
                 * @param {AcFunDanmu.Im.Cloud.IProfile=} [properties] Properties to set
                 */
                function Profile(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new Profile instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Cloud.Profile
                 * @static
                 * @param {AcFunDanmu.Im.Cloud.IProfile=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Cloud.Profile} Profile instance
                 */
                Profile.create = function create(properties) {
                    return new Profile(properties);
                };

                /**
                 * Encodes the specified Profile message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Profile.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Cloud.Profile
                 * @static
                 * @param {AcFunDanmu.Im.Cloud.IProfile} message Profile message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Profile.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified Profile message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Profile.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Cloud.Profile
                 * @static
                 * @param {AcFunDanmu.Im.Cloud.IProfile} message Profile message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Profile.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Profile message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Cloud.Profile
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Cloud.Profile} Profile
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Profile.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Profile();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Profile message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Cloud.Profile
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Cloud.Profile} Profile
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Profile.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Profile message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Cloud.Profile
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Profile.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a Profile message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Cloud.Profile
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Cloud.Profile} Profile
                 */
                Profile.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Cloud.Profile)
                        return object;
                    return new $root.AcFunDanmu.Im.Cloud.Profile();
                };

                /**
                 * Creates a plain object from a Profile message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Cloud.Profile
                 * @static
                 * @param {AcFunDanmu.Im.Cloud.Profile} message Profile
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Profile.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this Profile to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Cloud.Profile
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Profile.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                Profile.UserOnlineStatus = (function() {

                    /**
                     * Properties of a UserOnlineStatus.
                     * @memberof AcFunDanmu.Im.Cloud.Profile
                     * @interface IUserOnlineStatus
                     * @property {AcFunDanmu.Im.Basic.IUser|null} [user] UserOnlineStatus user
                     * @property {number|Long|null} [lastOfflineTime] UserOnlineStatus lastOfflineTime
                     * @property {AcFunDanmu.Im.Cloud.Profile.UserOnlineStatus.Status|null} [status] UserOnlineStatus status
                     */

                    /**
                     * Constructs a new UserOnlineStatus.
                     * @memberof AcFunDanmu.Im.Cloud.Profile
                     * @classdesc Represents a UserOnlineStatus.
                     * @implements IUserOnlineStatus
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Profile.IUserOnlineStatus=} [properties] Properties to set
                     */
                    function UserOnlineStatus(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * UserOnlineStatus user.
                     * @member {AcFunDanmu.Im.Basic.IUser|null|undefined} user
                     * @memberof AcFunDanmu.Im.Cloud.Profile.UserOnlineStatus
                     * @instance
                     */
                    UserOnlineStatus.prototype.user = null;

                    /**
                     * UserOnlineStatus lastOfflineTime.
                     * @member {number|Long} lastOfflineTime
                     * @memberof AcFunDanmu.Im.Cloud.Profile.UserOnlineStatus
                     * @instance
                     */
                    UserOnlineStatus.prototype.lastOfflineTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * UserOnlineStatus status.
                     * @member {AcFunDanmu.Im.Cloud.Profile.UserOnlineStatus.Status} status
                     * @memberof AcFunDanmu.Im.Cloud.Profile.UserOnlineStatus
                     * @instance
                     */
                    UserOnlineStatus.prototype.status = 0;

                    /**
                     * Creates a new UserOnlineStatus instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Profile.UserOnlineStatus
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Profile.IUserOnlineStatus=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Profile.UserOnlineStatus} UserOnlineStatus instance
                     */
                    UserOnlineStatus.create = function create(properties) {
                        return new UserOnlineStatus(properties);
                    };

                    /**
                     * Encodes the specified UserOnlineStatus message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Profile.UserOnlineStatus.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Profile.UserOnlineStatus
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Profile.IUserOnlineStatus} message UserOnlineStatus message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    UserOnlineStatus.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.user != null && Object.hasOwnProperty.call(message, "user"))
                            $root.AcFunDanmu.Im.Basic.User.encode(message.user, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.lastOfflineTime != null && Object.hasOwnProperty.call(message, "lastOfflineTime"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.lastOfflineTime);
                        if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.status);
                        return writer;
                    };

                    /**
                     * Encodes the specified UserOnlineStatus message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Profile.UserOnlineStatus.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Profile.UserOnlineStatus
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Profile.IUserOnlineStatus} message UserOnlineStatus message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    UserOnlineStatus.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a UserOnlineStatus message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Profile.UserOnlineStatus
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Profile.UserOnlineStatus} UserOnlineStatus
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    UserOnlineStatus.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Profile.UserOnlineStatus();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.user = $root.AcFunDanmu.Im.Basic.User.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.lastOfflineTime = reader.int64();
                                break;
                            case 3:
                                message.status = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a UserOnlineStatus message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Profile.UserOnlineStatus
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Profile.UserOnlineStatus} UserOnlineStatus
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    UserOnlineStatus.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a UserOnlineStatus message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Profile.UserOnlineStatus
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    UserOnlineStatus.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.user != null && message.hasOwnProperty("user")) {
                            let error = $root.AcFunDanmu.Im.Basic.User.verify(message.user);
                            if (error)
                                return "user." + error;
                        }
                        if (message.lastOfflineTime != null && message.hasOwnProperty("lastOfflineTime"))
                            if (!$util.isInteger(message.lastOfflineTime) && !(message.lastOfflineTime && $util.isInteger(message.lastOfflineTime.low) && $util.isInteger(message.lastOfflineTime.high)))
                                return "lastOfflineTime: integer|Long expected";
                        if (message.status != null && message.hasOwnProperty("status"))
                            switch (message.status) {
                            default:
                                return "status: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                                break;
                            }
                        return null;
                    };

                    /**
                     * Creates a UserOnlineStatus message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Profile.UserOnlineStatus
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Profile.UserOnlineStatus} UserOnlineStatus
                     */
                    UserOnlineStatus.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Profile.UserOnlineStatus)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Profile.UserOnlineStatus();
                        if (object.user != null) {
                            if (typeof object.user !== "object")
                                throw TypeError(".AcFunDanmu.Im.Cloud.Profile.UserOnlineStatus.user: object expected");
                            message.user = $root.AcFunDanmu.Im.Basic.User.fromObject(object.user);
                        }
                        if (object.lastOfflineTime != null)
                            if ($util.Long)
                                (message.lastOfflineTime = $util.Long.fromValue(object.lastOfflineTime)).unsigned = false;
                            else if (typeof object.lastOfflineTime === "string")
                                message.lastOfflineTime = parseInt(object.lastOfflineTime, 10);
                            else if (typeof object.lastOfflineTime === "number")
                                message.lastOfflineTime = object.lastOfflineTime;
                            else if (typeof object.lastOfflineTime === "object")
                                message.lastOfflineTime = new $util.LongBits(object.lastOfflineTime.low >>> 0, object.lastOfflineTime.high >>> 0).toNumber();
                        switch (object.status) {
                        case "UNKNOWN":
                        case 0:
                            message.status = 0;
                            break;
                        case "ONLINE":
                        case 1:
                            message.status = 1;
                            break;
                        case "OFFLINE":
                        case 2:
                            message.status = 2;
                            break;
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a UserOnlineStatus message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Profile.UserOnlineStatus
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Profile.UserOnlineStatus} message UserOnlineStatus
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    UserOnlineStatus.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.user = null;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, false);
                                object.lastOfflineTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.lastOfflineTime = options.longs === String ? "0" : 0;
                            object.status = options.enums === String ? "UNKNOWN" : 0;
                        }
                        if (message.user != null && message.hasOwnProperty("user"))
                            object.user = $root.AcFunDanmu.Im.Basic.User.toObject(message.user, options);
                        if (message.lastOfflineTime != null && message.hasOwnProperty("lastOfflineTime"))
                            if (typeof message.lastOfflineTime === "number")
                                object.lastOfflineTime = options.longs === String ? String(message.lastOfflineTime) : message.lastOfflineTime;
                            else
                                object.lastOfflineTime = options.longs === String ? $util.Long.prototype.toString.call(message.lastOfflineTime) : options.longs === Number ? new $util.LongBits(message.lastOfflineTime.low >>> 0, message.lastOfflineTime.high >>> 0).toNumber() : message.lastOfflineTime;
                        if (message.status != null && message.hasOwnProperty("status"))
                            object.status = options.enums === String ? $root.AcFunDanmu.Im.Cloud.Profile.UserOnlineStatus.Status[message.status] : message.status;
                        return object;
                    };

                    /**
                     * Converts this UserOnlineStatus to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Profile.UserOnlineStatus
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    UserOnlineStatus.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Status enum.
                     * @name AcFunDanmu.Im.Cloud.Profile.UserOnlineStatus.Status
                     * @enum {number}
                     * @property {number} UNKNOWN=0 UNKNOWN value
                     * @property {number} ONLINE=1 ONLINE value
                     * @property {number} OFFLINE=2 OFFLINE value
                     */
                    UserOnlineStatus.Status = (function() {
                        const valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "UNKNOWN"] = 0;
                        values[valuesById[1] = "ONLINE"] = 1;
                        values[valuesById[2] = "OFFLINE"] = 2;
                        return values;
                    })();

                    return UserOnlineStatus;
                })();

                Profile.ProfileBatchOnlineTimeRequest = (function() {

                    /**
                     * Properties of a ProfileBatchOnlineTimeRequest.
                     * @memberof AcFunDanmu.Im.Cloud.Profile
                     * @interface IProfileBatchOnlineTimeRequest
                     * @property {Array.<AcFunDanmu.Im.Basic.IUser>|null} [user] ProfileBatchOnlineTimeRequest user
                     */

                    /**
                     * Constructs a new ProfileBatchOnlineTimeRequest.
                     * @memberof AcFunDanmu.Im.Cloud.Profile
                     * @classdesc Represents a ProfileBatchOnlineTimeRequest.
                     * @implements IProfileBatchOnlineTimeRequest
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Profile.IProfileBatchOnlineTimeRequest=} [properties] Properties to set
                     */
                    function ProfileBatchOnlineTimeRequest(properties) {
                        this.user = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * ProfileBatchOnlineTimeRequest user.
                     * @member {Array.<AcFunDanmu.Im.Basic.IUser>} user
                     * @memberof AcFunDanmu.Im.Cloud.Profile.ProfileBatchOnlineTimeRequest
                     * @instance
                     */
                    ProfileBatchOnlineTimeRequest.prototype.user = $util.emptyArray;

                    /**
                     * Creates a new ProfileBatchOnlineTimeRequest instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Profile.ProfileBatchOnlineTimeRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Profile.IProfileBatchOnlineTimeRequest=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Profile.ProfileBatchOnlineTimeRequest} ProfileBatchOnlineTimeRequest instance
                     */
                    ProfileBatchOnlineTimeRequest.create = function create(properties) {
                        return new ProfileBatchOnlineTimeRequest(properties);
                    };

                    /**
                     * Encodes the specified ProfileBatchOnlineTimeRequest message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Profile.ProfileBatchOnlineTimeRequest.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Profile.ProfileBatchOnlineTimeRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Profile.IProfileBatchOnlineTimeRequest} message ProfileBatchOnlineTimeRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ProfileBatchOnlineTimeRequest.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.user != null && message.user.length)
                            for (let i = 0; i < message.user.length; ++i)
                                $root.AcFunDanmu.Im.Basic.User.encode(message.user[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified ProfileBatchOnlineTimeRequest message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Profile.ProfileBatchOnlineTimeRequest.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Profile.ProfileBatchOnlineTimeRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Profile.IProfileBatchOnlineTimeRequest} message ProfileBatchOnlineTimeRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ProfileBatchOnlineTimeRequest.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a ProfileBatchOnlineTimeRequest message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Profile.ProfileBatchOnlineTimeRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Profile.ProfileBatchOnlineTimeRequest} ProfileBatchOnlineTimeRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ProfileBatchOnlineTimeRequest.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Profile.ProfileBatchOnlineTimeRequest();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.user && message.user.length))
                                    message.user = [];
                                message.user.push($root.AcFunDanmu.Im.Basic.User.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a ProfileBatchOnlineTimeRequest message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Profile.ProfileBatchOnlineTimeRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Profile.ProfileBatchOnlineTimeRequest} ProfileBatchOnlineTimeRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ProfileBatchOnlineTimeRequest.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a ProfileBatchOnlineTimeRequest message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Profile.ProfileBatchOnlineTimeRequest
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ProfileBatchOnlineTimeRequest.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.user != null && message.hasOwnProperty("user")) {
                            if (!Array.isArray(message.user))
                                return "user: array expected";
                            for (let i = 0; i < message.user.length; ++i) {
                                let error = $root.AcFunDanmu.Im.Basic.User.verify(message.user[i]);
                                if (error)
                                    return "user." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a ProfileBatchOnlineTimeRequest message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Profile.ProfileBatchOnlineTimeRequest
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Profile.ProfileBatchOnlineTimeRequest} ProfileBatchOnlineTimeRequest
                     */
                    ProfileBatchOnlineTimeRequest.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Profile.ProfileBatchOnlineTimeRequest)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Profile.ProfileBatchOnlineTimeRequest();
                        if (object.user) {
                            if (!Array.isArray(object.user))
                                throw TypeError(".AcFunDanmu.Im.Cloud.Profile.ProfileBatchOnlineTimeRequest.user: array expected");
                            message.user = [];
                            for (let i = 0; i < object.user.length; ++i) {
                                if (typeof object.user[i] !== "object")
                                    throw TypeError(".AcFunDanmu.Im.Cloud.Profile.ProfileBatchOnlineTimeRequest.user: object expected");
                                message.user[i] = $root.AcFunDanmu.Im.Basic.User.fromObject(object.user[i]);
                            }
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a ProfileBatchOnlineTimeRequest message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Profile.ProfileBatchOnlineTimeRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Profile.ProfileBatchOnlineTimeRequest} message ProfileBatchOnlineTimeRequest
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ProfileBatchOnlineTimeRequest.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.user = [];
                        if (message.user && message.user.length) {
                            object.user = [];
                            for (let j = 0; j < message.user.length; ++j)
                                object.user[j] = $root.AcFunDanmu.Im.Basic.User.toObject(message.user[j], options);
                        }
                        return object;
                    };

                    /**
                     * Converts this ProfileBatchOnlineTimeRequest to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Profile.ProfileBatchOnlineTimeRequest
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ProfileBatchOnlineTimeRequest.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return ProfileBatchOnlineTimeRequest;
                })();

                Profile.ProfileBatchOnlineTimeResponse = (function() {

                    /**
                     * Properties of a ProfileBatchOnlineTimeResponse.
                     * @memberof AcFunDanmu.Im.Cloud.Profile
                     * @interface IProfileBatchOnlineTimeResponse
                     * @property {Array.<AcFunDanmu.Im.Cloud.Profile.IUserOnlineStatus>|null} [userOnlineStatus] ProfileBatchOnlineTimeResponse userOnlineStatus
                     */

                    /**
                     * Constructs a new ProfileBatchOnlineTimeResponse.
                     * @memberof AcFunDanmu.Im.Cloud.Profile
                     * @classdesc Represents a ProfileBatchOnlineTimeResponse.
                     * @implements IProfileBatchOnlineTimeResponse
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Profile.IProfileBatchOnlineTimeResponse=} [properties] Properties to set
                     */
                    function ProfileBatchOnlineTimeResponse(properties) {
                        this.userOnlineStatus = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * ProfileBatchOnlineTimeResponse userOnlineStatus.
                     * @member {Array.<AcFunDanmu.Im.Cloud.Profile.IUserOnlineStatus>} userOnlineStatus
                     * @memberof AcFunDanmu.Im.Cloud.Profile.ProfileBatchOnlineTimeResponse
                     * @instance
                     */
                    ProfileBatchOnlineTimeResponse.prototype.userOnlineStatus = $util.emptyArray;

                    /**
                     * Creates a new ProfileBatchOnlineTimeResponse instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Profile.ProfileBatchOnlineTimeResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Profile.IProfileBatchOnlineTimeResponse=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Profile.ProfileBatchOnlineTimeResponse} ProfileBatchOnlineTimeResponse instance
                     */
                    ProfileBatchOnlineTimeResponse.create = function create(properties) {
                        return new ProfileBatchOnlineTimeResponse(properties);
                    };

                    /**
                     * Encodes the specified ProfileBatchOnlineTimeResponse message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Profile.ProfileBatchOnlineTimeResponse.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Profile.ProfileBatchOnlineTimeResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Profile.IProfileBatchOnlineTimeResponse} message ProfileBatchOnlineTimeResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ProfileBatchOnlineTimeResponse.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.userOnlineStatus != null && message.userOnlineStatus.length)
                            for (let i = 0; i < message.userOnlineStatus.length; ++i)
                                $root.AcFunDanmu.Im.Cloud.Profile.UserOnlineStatus.encode(message.userOnlineStatus[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified ProfileBatchOnlineTimeResponse message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Profile.ProfileBatchOnlineTimeResponse.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Profile.ProfileBatchOnlineTimeResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Profile.IProfileBatchOnlineTimeResponse} message ProfileBatchOnlineTimeResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ProfileBatchOnlineTimeResponse.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a ProfileBatchOnlineTimeResponse message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Profile.ProfileBatchOnlineTimeResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Profile.ProfileBatchOnlineTimeResponse} ProfileBatchOnlineTimeResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ProfileBatchOnlineTimeResponse.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Profile.ProfileBatchOnlineTimeResponse();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.userOnlineStatus && message.userOnlineStatus.length))
                                    message.userOnlineStatus = [];
                                message.userOnlineStatus.push($root.AcFunDanmu.Im.Cloud.Profile.UserOnlineStatus.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a ProfileBatchOnlineTimeResponse message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Profile.ProfileBatchOnlineTimeResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Profile.ProfileBatchOnlineTimeResponse} ProfileBatchOnlineTimeResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ProfileBatchOnlineTimeResponse.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a ProfileBatchOnlineTimeResponse message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Profile.ProfileBatchOnlineTimeResponse
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ProfileBatchOnlineTimeResponse.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.userOnlineStatus != null && message.hasOwnProperty("userOnlineStatus")) {
                            if (!Array.isArray(message.userOnlineStatus))
                                return "userOnlineStatus: array expected";
                            for (let i = 0; i < message.userOnlineStatus.length; ++i) {
                                let error = $root.AcFunDanmu.Im.Cloud.Profile.UserOnlineStatus.verify(message.userOnlineStatus[i]);
                                if (error)
                                    return "userOnlineStatus." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a ProfileBatchOnlineTimeResponse message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Profile.ProfileBatchOnlineTimeResponse
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Profile.ProfileBatchOnlineTimeResponse} ProfileBatchOnlineTimeResponse
                     */
                    ProfileBatchOnlineTimeResponse.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Profile.ProfileBatchOnlineTimeResponse)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Profile.ProfileBatchOnlineTimeResponse();
                        if (object.userOnlineStatus) {
                            if (!Array.isArray(object.userOnlineStatus))
                                throw TypeError(".AcFunDanmu.Im.Cloud.Profile.ProfileBatchOnlineTimeResponse.userOnlineStatus: array expected");
                            message.userOnlineStatus = [];
                            for (let i = 0; i < object.userOnlineStatus.length; ++i) {
                                if (typeof object.userOnlineStatus[i] !== "object")
                                    throw TypeError(".AcFunDanmu.Im.Cloud.Profile.ProfileBatchOnlineTimeResponse.userOnlineStatus: object expected");
                                message.userOnlineStatus[i] = $root.AcFunDanmu.Im.Cloud.Profile.UserOnlineStatus.fromObject(object.userOnlineStatus[i]);
                            }
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a ProfileBatchOnlineTimeResponse message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Profile.ProfileBatchOnlineTimeResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Profile.ProfileBatchOnlineTimeResponse} message ProfileBatchOnlineTimeResponse
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ProfileBatchOnlineTimeResponse.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.userOnlineStatus = [];
                        if (message.userOnlineStatus && message.userOnlineStatus.length) {
                            object.userOnlineStatus = [];
                            for (let j = 0; j < message.userOnlineStatus.length; ++j)
                                object.userOnlineStatus[j] = $root.AcFunDanmu.Im.Cloud.Profile.UserOnlineStatus.toObject(message.userOnlineStatus[j], options);
                        }
                        return object;
                    };

                    /**
                     * Converts this ProfileBatchOnlineTimeResponse to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Profile.ProfileBatchOnlineTimeResponse
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ProfileBatchOnlineTimeResponse.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return ProfileBatchOnlineTimeResponse;
                })();

                return Profile;
            })();

            Cloud.Data = (function() {

                /**
                 * Properties of a Data.
                 * @memberof AcFunDanmu.Im.Cloud
                 * @interface IData
                 */

                /**
                 * Constructs a new Data.
                 * @memberof AcFunDanmu.Im.Cloud
                 * @classdesc Represents a Data.
                 * @implements IData
                 * @constructor
                 * @param {AcFunDanmu.Im.Cloud.IData=} [properties] Properties to set
                 */
                function Data(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new Data instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Cloud.Data
                 * @static
                 * @param {AcFunDanmu.Im.Cloud.IData=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Cloud.Data} Data instance
                 */
                Data.create = function create(properties) {
                    return new Data(properties);
                };

                /**
                 * Encodes the specified Data message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Data.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Cloud.Data
                 * @static
                 * @param {AcFunDanmu.Im.Cloud.IData} message Data message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Data.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified Data message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Data.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Cloud.Data
                 * @static
                 * @param {AcFunDanmu.Im.Cloud.IData} message Data message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Data.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Data message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Cloud.Data
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Cloud.Data} Data
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Data.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Data();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Data message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Cloud.Data
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Cloud.Data} Data
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Data.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Data message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Cloud.Data
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Data.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a Data message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Cloud.Data
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Cloud.Data} Data
                 */
                Data.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Cloud.Data)
                        return object;
                    return new $root.AcFunDanmu.Im.Cloud.Data();
                };

                /**
                 * Creates a plain object from a Data message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Cloud.Data
                 * @static
                 * @param {AcFunDanmu.Im.Cloud.Data} message Data
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Data.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this Data to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Cloud.Data
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Data.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                Data.Update = (function() {

                    /**
                     * Properties of an Update.
                     * @memberof AcFunDanmu.Im.Cloud.Data
                     * @interface IUpdate
                     */

                    /**
                     * Constructs a new Update.
                     * @memberof AcFunDanmu.Im.Cloud.Data
                     * @classdesc Represents an Update.
                     * @implements IUpdate
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Data.IUpdate=} [properties] Properties to set
                     */
                    function Update(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Creates a new Update instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Data.Update
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Data.IUpdate=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Data.Update} Update instance
                     */
                    Update.create = function create(properties) {
                        return new Update(properties);
                    };

                    /**
                     * Encodes the specified Update message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Data.Update.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Data.Update
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Data.IUpdate} message Update message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Update.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };

                    /**
                     * Encodes the specified Update message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Data.Update.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Data.Update
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Data.IUpdate} message Update message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Update.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes an Update message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Data.Update
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Data.Update} Update
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Update.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Data.Update();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes an Update message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Data.Update
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Data.Update} Update
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Update.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies an Update message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Data.Update
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Update.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };

                    /**
                     * Creates an Update message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Data.Update
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Data.Update} Update
                     */
                    Update.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Data.Update)
                            return object;
                        return new $root.AcFunDanmu.Im.Cloud.Data.Update();
                    };

                    /**
                     * Creates a plain object from an Update message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Data.Update
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Data.Update} message Update
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Update.toObject = function toObject() {
                        return {};
                    };

                    /**
                     * Converts this Update to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Data.Update
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Update.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * KsImDataUpdateType enum.
                     * @name AcFunDanmu.Im.Cloud.Data.Update.KsImDataUpdateType
                     * @enum {number}
                     * @property {number} INVALID=0 INVALID value
                     * @property {number} GROUP_INFO_UPDATE=1 GROUP_INFO_UPDATE value
                     * @property {number} GROUP_MEMBER_LIST_UPDATE=2 GROUP_MEMBER_LIST_UPDATE value
                     * @property {number} YOU_BE_KICKED=3 YOU_BE_KICKED value
                     * @property {number} MESSAGE_READ_EVENT=4 MESSAGE_READ_EVENT value
                     * @property {number} MESSAGE_RECEIPT_EVENT=5 MESSAGE_RECEIPT_EVENT value
                     * @property {number} FRIEND_LIST_UPDATE=6 FRIEND_LIST_UPDATE value
                     * @property {number} FRIEND_REQUEST_COUNT_UPDATE=7 FRIEND_REQUEST_COUNT_UPDATE value
                     * @property {number} BLACK_LIST_UPDATE=8 BLACK_LIST_UPDATE value
                     */
                    Update.KsImDataUpdateType = (function() {
                        const valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "INVALID"] = 0;
                        values[valuesById[1] = "GROUP_INFO_UPDATE"] = 1;
                        values[valuesById[2] = "GROUP_MEMBER_LIST_UPDATE"] = 2;
                        values[valuesById[3] = "YOU_BE_KICKED"] = 3;
                        values[valuesById[4] = "MESSAGE_READ_EVENT"] = 4;
                        values[valuesById[5] = "MESSAGE_RECEIPT_EVENT"] = 5;
                        values[valuesById[6] = "FRIEND_LIST_UPDATE"] = 6;
                        values[valuesById[7] = "FRIEND_REQUEST_COUNT_UPDATE"] = 7;
                        values[valuesById[8] = "BLACK_LIST_UPDATE"] = 8;
                        return values;
                    })();

                    Update.KsImDataUpdatePushPayload = (function() {

                        /**
                         * Properties of a KsImDataUpdatePushPayload.
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update
                         * @interface IKsImDataUpdatePushPayload
                         * @property {AcFunDanmu.Im.Cloud.Data.Update.IKsImDataUpdatePushPayload|null} [type] KsImDataUpdatePushPayload type
                         * @property {Uint8Array|null} [content] KsImDataUpdatePushPayload content
                         */

                        /**
                         * Constructs a new KsImDataUpdatePushPayload.
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update
                         * @classdesc Represents a KsImDataUpdatePushPayload.
                         * @implements IKsImDataUpdatePushPayload
                         * @constructor
                         * @param {AcFunDanmu.Im.Cloud.Data.Update.IKsImDataUpdatePushPayload=} [properties] Properties to set
                         */
                        function KsImDataUpdatePushPayload(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * KsImDataUpdatePushPayload type.
                         * @member {AcFunDanmu.Im.Cloud.Data.Update.IKsImDataUpdatePushPayload|null|undefined} type
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.KsImDataUpdatePushPayload
                         * @instance
                         */
                        KsImDataUpdatePushPayload.prototype.type = null;

                        /**
                         * KsImDataUpdatePushPayload content.
                         * @member {Uint8Array} content
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.KsImDataUpdatePushPayload
                         * @instance
                         */
                        KsImDataUpdatePushPayload.prototype.content = $util.newBuffer([]);

                        /**
                         * Creates a new KsImDataUpdatePushPayload instance using the specified properties.
                         * @function create
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.KsImDataUpdatePushPayload
                         * @static
                         * @param {AcFunDanmu.Im.Cloud.Data.Update.IKsImDataUpdatePushPayload=} [properties] Properties to set
                         * @returns {AcFunDanmu.Im.Cloud.Data.Update.KsImDataUpdatePushPayload} KsImDataUpdatePushPayload instance
                         */
                        KsImDataUpdatePushPayload.create = function create(properties) {
                            return new KsImDataUpdatePushPayload(properties);
                        };

                        /**
                         * Encodes the specified KsImDataUpdatePushPayload message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Data.Update.KsImDataUpdatePushPayload.verify|verify} messages.
                         * @function encode
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.KsImDataUpdatePushPayload
                         * @static
                         * @param {AcFunDanmu.Im.Cloud.Data.Update.IKsImDataUpdatePushPayload} message KsImDataUpdatePushPayload message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        KsImDataUpdatePushPayload.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                                $root.AcFunDanmu.Im.Cloud.Data.Update.KsImDataUpdatePushPayload.encode(message.type, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                            if (message.content != null && Object.hasOwnProperty.call(message, "content"))
                                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.content);
                            return writer;
                        };

                        /**
                         * Encodes the specified KsImDataUpdatePushPayload message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Data.Update.KsImDataUpdatePushPayload.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.KsImDataUpdatePushPayload
                         * @static
                         * @param {AcFunDanmu.Im.Cloud.Data.Update.IKsImDataUpdatePushPayload} message KsImDataUpdatePushPayload message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        KsImDataUpdatePushPayload.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a KsImDataUpdatePushPayload message from the specified reader or buffer.
                         * @function decode
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.KsImDataUpdatePushPayload
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {AcFunDanmu.Im.Cloud.Data.Update.KsImDataUpdatePushPayload} KsImDataUpdatePushPayload
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        KsImDataUpdatePushPayload.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Data.Update.KsImDataUpdatePushPayload();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.type = $root.AcFunDanmu.Im.Cloud.Data.Update.KsImDataUpdatePushPayload.decode(reader, reader.uint32());
                                    break;
                                case 2:
                                    message.content = reader.bytes();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a KsImDataUpdatePushPayload message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.KsImDataUpdatePushPayload
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {AcFunDanmu.Im.Cloud.Data.Update.KsImDataUpdatePushPayload} KsImDataUpdatePushPayload
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        KsImDataUpdatePushPayload.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a KsImDataUpdatePushPayload message.
                         * @function verify
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.KsImDataUpdatePushPayload
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        KsImDataUpdatePushPayload.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.type != null && message.hasOwnProperty("type")) {
                                let error = $root.AcFunDanmu.Im.Cloud.Data.Update.KsImDataUpdatePushPayload.verify(message.type);
                                if (error)
                                    return "type." + error;
                            }
                            if (message.content != null && message.hasOwnProperty("content"))
                                if (!(message.content && typeof message.content.length === "number" || $util.isString(message.content)))
                                    return "content: buffer expected";
                            return null;
                        };

                        /**
                         * Creates a KsImDataUpdatePushPayload message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.KsImDataUpdatePushPayload
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {AcFunDanmu.Im.Cloud.Data.Update.KsImDataUpdatePushPayload} KsImDataUpdatePushPayload
                         */
                        KsImDataUpdatePushPayload.fromObject = function fromObject(object) {
                            if (object instanceof $root.AcFunDanmu.Im.Cloud.Data.Update.KsImDataUpdatePushPayload)
                                return object;
                            let message = new $root.AcFunDanmu.Im.Cloud.Data.Update.KsImDataUpdatePushPayload();
                            if (object.type != null) {
                                if (typeof object.type !== "object")
                                    throw TypeError(".AcFunDanmu.Im.Cloud.Data.Update.KsImDataUpdatePushPayload.type: object expected");
                                message.type = $root.AcFunDanmu.Im.Cloud.Data.Update.KsImDataUpdatePushPayload.fromObject(object.type);
                            }
                            if (object.content != null)
                                if (typeof object.content === "string")
                                    $util.base64.decode(object.content, message.content = $util.newBuffer($util.base64.length(object.content)), 0);
                                else if (object.content.length)
                                    message.content = object.content;
                            return message;
                        };

                        /**
                         * Creates a plain object from a KsImDataUpdatePushPayload message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.KsImDataUpdatePushPayload
                         * @static
                         * @param {AcFunDanmu.Im.Cloud.Data.Update.KsImDataUpdatePushPayload} message KsImDataUpdatePushPayload
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        KsImDataUpdatePushPayload.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                object.type = null;
                                if (options.bytes === String)
                                    object.content = "";
                                else {
                                    object.content = [];
                                    if (options.bytes !== Array)
                                        object.content = $util.newBuffer(object.content);
                                }
                            }
                            if (message.type != null && message.hasOwnProperty("type"))
                                object.type = $root.AcFunDanmu.Im.Cloud.Data.Update.KsImDataUpdatePushPayload.toObject(message.type, options);
                            if (message.content != null && message.hasOwnProperty("content"))
                                object.content = options.bytes === String ? $util.base64.encode(message.content, 0, message.content.length) : options.bytes === Array ? Array.prototype.slice.call(message.content) : message.content;
                            return object;
                        };

                        /**
                         * Converts this KsImDataUpdatePushPayload to JSON.
                         * @function toJSON
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.KsImDataUpdatePushPayload
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        KsImDataUpdatePushPayload.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return KsImDataUpdatePushPayload;
                    })();

                    Update.GroupInfoDataUpdate = (function() {

                        /**
                         * Properties of a GroupInfoDataUpdate.
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update
                         * @interface IGroupInfoDataUpdate
                         * @property {string|null} [groupId] GroupInfoDataUpdate groupId
                         */

                        /**
                         * Constructs a new GroupInfoDataUpdate.
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update
                         * @classdesc Represents a GroupInfoDataUpdate.
                         * @implements IGroupInfoDataUpdate
                         * @constructor
                         * @param {AcFunDanmu.Im.Cloud.Data.Update.IGroupInfoDataUpdate=} [properties] Properties to set
                         */
                        function GroupInfoDataUpdate(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * GroupInfoDataUpdate groupId.
                         * @member {string} groupId
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.GroupInfoDataUpdate
                         * @instance
                         */
                        GroupInfoDataUpdate.prototype.groupId = "";

                        /**
                         * Creates a new GroupInfoDataUpdate instance using the specified properties.
                         * @function create
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.GroupInfoDataUpdate
                         * @static
                         * @param {AcFunDanmu.Im.Cloud.Data.Update.IGroupInfoDataUpdate=} [properties] Properties to set
                         * @returns {AcFunDanmu.Im.Cloud.Data.Update.GroupInfoDataUpdate} GroupInfoDataUpdate instance
                         */
                        GroupInfoDataUpdate.create = function create(properties) {
                            return new GroupInfoDataUpdate(properties);
                        };

                        /**
                         * Encodes the specified GroupInfoDataUpdate message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Data.Update.GroupInfoDataUpdate.verify|verify} messages.
                         * @function encode
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.GroupInfoDataUpdate
                         * @static
                         * @param {AcFunDanmu.Im.Cloud.Data.Update.IGroupInfoDataUpdate} message GroupInfoDataUpdate message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        GroupInfoDataUpdate.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.groupId);
                            return writer;
                        };

                        /**
                         * Encodes the specified GroupInfoDataUpdate message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Data.Update.GroupInfoDataUpdate.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.GroupInfoDataUpdate
                         * @static
                         * @param {AcFunDanmu.Im.Cloud.Data.Update.IGroupInfoDataUpdate} message GroupInfoDataUpdate message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        GroupInfoDataUpdate.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a GroupInfoDataUpdate message from the specified reader or buffer.
                         * @function decode
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.GroupInfoDataUpdate
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {AcFunDanmu.Im.Cloud.Data.Update.GroupInfoDataUpdate} GroupInfoDataUpdate
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        GroupInfoDataUpdate.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Data.Update.GroupInfoDataUpdate();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.groupId = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a GroupInfoDataUpdate message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.GroupInfoDataUpdate
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {AcFunDanmu.Im.Cloud.Data.Update.GroupInfoDataUpdate} GroupInfoDataUpdate
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        GroupInfoDataUpdate.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a GroupInfoDataUpdate message.
                         * @function verify
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.GroupInfoDataUpdate
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        GroupInfoDataUpdate.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.groupId != null && message.hasOwnProperty("groupId"))
                                if (!$util.isString(message.groupId))
                                    return "groupId: string expected";
                            return null;
                        };

                        /**
                         * Creates a GroupInfoDataUpdate message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.GroupInfoDataUpdate
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {AcFunDanmu.Im.Cloud.Data.Update.GroupInfoDataUpdate} GroupInfoDataUpdate
                         */
                        GroupInfoDataUpdate.fromObject = function fromObject(object) {
                            if (object instanceof $root.AcFunDanmu.Im.Cloud.Data.Update.GroupInfoDataUpdate)
                                return object;
                            let message = new $root.AcFunDanmu.Im.Cloud.Data.Update.GroupInfoDataUpdate();
                            if (object.groupId != null)
                                message.groupId = String(object.groupId);
                            return message;
                        };

                        /**
                         * Creates a plain object from a GroupInfoDataUpdate message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.GroupInfoDataUpdate
                         * @static
                         * @param {AcFunDanmu.Im.Cloud.Data.Update.GroupInfoDataUpdate} message GroupInfoDataUpdate
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        GroupInfoDataUpdate.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults)
                                object.groupId = "";
                            if (message.groupId != null && message.hasOwnProperty("groupId"))
                                object.groupId = message.groupId;
                            return object;
                        };

                        /**
                         * Converts this GroupInfoDataUpdate to JSON.
                         * @function toJSON
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.GroupInfoDataUpdate
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        GroupInfoDataUpdate.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return GroupInfoDataUpdate;
                    })();

                    Update.GroupMemberListUpdate = (function() {

                        /**
                         * Properties of a GroupMemberListUpdate.
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update
                         * @interface IGroupMemberListUpdate
                         * @property {string|null} [groupId] GroupMemberListUpdate groupId
                         */

                        /**
                         * Constructs a new GroupMemberListUpdate.
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update
                         * @classdesc Represents a GroupMemberListUpdate.
                         * @implements IGroupMemberListUpdate
                         * @constructor
                         * @param {AcFunDanmu.Im.Cloud.Data.Update.IGroupMemberListUpdate=} [properties] Properties to set
                         */
                        function GroupMemberListUpdate(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * GroupMemberListUpdate groupId.
                         * @member {string} groupId
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.GroupMemberListUpdate
                         * @instance
                         */
                        GroupMemberListUpdate.prototype.groupId = "";

                        /**
                         * Creates a new GroupMemberListUpdate instance using the specified properties.
                         * @function create
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.GroupMemberListUpdate
                         * @static
                         * @param {AcFunDanmu.Im.Cloud.Data.Update.IGroupMemberListUpdate=} [properties] Properties to set
                         * @returns {AcFunDanmu.Im.Cloud.Data.Update.GroupMemberListUpdate} GroupMemberListUpdate instance
                         */
                        GroupMemberListUpdate.create = function create(properties) {
                            return new GroupMemberListUpdate(properties);
                        };

                        /**
                         * Encodes the specified GroupMemberListUpdate message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Data.Update.GroupMemberListUpdate.verify|verify} messages.
                         * @function encode
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.GroupMemberListUpdate
                         * @static
                         * @param {AcFunDanmu.Im.Cloud.Data.Update.IGroupMemberListUpdate} message GroupMemberListUpdate message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        GroupMemberListUpdate.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.groupId);
                            return writer;
                        };

                        /**
                         * Encodes the specified GroupMemberListUpdate message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Data.Update.GroupMemberListUpdate.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.GroupMemberListUpdate
                         * @static
                         * @param {AcFunDanmu.Im.Cloud.Data.Update.IGroupMemberListUpdate} message GroupMemberListUpdate message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        GroupMemberListUpdate.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a GroupMemberListUpdate message from the specified reader or buffer.
                         * @function decode
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.GroupMemberListUpdate
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {AcFunDanmu.Im.Cloud.Data.Update.GroupMemberListUpdate} GroupMemberListUpdate
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        GroupMemberListUpdate.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Data.Update.GroupMemberListUpdate();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.groupId = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a GroupMemberListUpdate message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.GroupMemberListUpdate
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {AcFunDanmu.Im.Cloud.Data.Update.GroupMemberListUpdate} GroupMemberListUpdate
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        GroupMemberListUpdate.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a GroupMemberListUpdate message.
                         * @function verify
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.GroupMemberListUpdate
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        GroupMemberListUpdate.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.groupId != null && message.hasOwnProperty("groupId"))
                                if (!$util.isString(message.groupId))
                                    return "groupId: string expected";
                            return null;
                        };

                        /**
                         * Creates a GroupMemberListUpdate message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.GroupMemberListUpdate
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {AcFunDanmu.Im.Cloud.Data.Update.GroupMemberListUpdate} GroupMemberListUpdate
                         */
                        GroupMemberListUpdate.fromObject = function fromObject(object) {
                            if (object instanceof $root.AcFunDanmu.Im.Cloud.Data.Update.GroupMemberListUpdate)
                                return object;
                            let message = new $root.AcFunDanmu.Im.Cloud.Data.Update.GroupMemberListUpdate();
                            if (object.groupId != null)
                                message.groupId = String(object.groupId);
                            return message;
                        };

                        /**
                         * Creates a plain object from a GroupMemberListUpdate message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.GroupMemberListUpdate
                         * @static
                         * @param {AcFunDanmu.Im.Cloud.Data.Update.GroupMemberListUpdate} message GroupMemberListUpdate
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        GroupMemberListUpdate.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults)
                                object.groupId = "";
                            if (message.groupId != null && message.hasOwnProperty("groupId"))
                                object.groupId = message.groupId;
                            return object;
                        };

                        /**
                         * Converts this GroupMemberListUpdate to JSON.
                         * @function toJSON
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.GroupMemberListUpdate
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        GroupMemberListUpdate.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return GroupMemberListUpdate;
                    })();

                    Update.YouBeKicked = (function() {

                        /**
                         * Properties of a YouBeKicked.
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update
                         * @interface IYouBeKicked
                         * @property {string|null} [groupId] YouBeKicked groupId
                         */

                        /**
                         * Constructs a new YouBeKicked.
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update
                         * @classdesc Represents a YouBeKicked.
                         * @implements IYouBeKicked
                         * @constructor
                         * @param {AcFunDanmu.Im.Cloud.Data.Update.IYouBeKicked=} [properties] Properties to set
                         */
                        function YouBeKicked(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * YouBeKicked groupId.
                         * @member {string} groupId
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.YouBeKicked
                         * @instance
                         */
                        YouBeKicked.prototype.groupId = "";

                        /**
                         * Creates a new YouBeKicked instance using the specified properties.
                         * @function create
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.YouBeKicked
                         * @static
                         * @param {AcFunDanmu.Im.Cloud.Data.Update.IYouBeKicked=} [properties] Properties to set
                         * @returns {AcFunDanmu.Im.Cloud.Data.Update.YouBeKicked} YouBeKicked instance
                         */
                        YouBeKicked.create = function create(properties) {
                            return new YouBeKicked(properties);
                        };

                        /**
                         * Encodes the specified YouBeKicked message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Data.Update.YouBeKicked.verify|verify} messages.
                         * @function encode
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.YouBeKicked
                         * @static
                         * @param {AcFunDanmu.Im.Cloud.Data.Update.IYouBeKicked} message YouBeKicked message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        YouBeKicked.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.groupId);
                            return writer;
                        };

                        /**
                         * Encodes the specified YouBeKicked message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Data.Update.YouBeKicked.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.YouBeKicked
                         * @static
                         * @param {AcFunDanmu.Im.Cloud.Data.Update.IYouBeKicked} message YouBeKicked message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        YouBeKicked.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a YouBeKicked message from the specified reader or buffer.
                         * @function decode
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.YouBeKicked
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {AcFunDanmu.Im.Cloud.Data.Update.YouBeKicked} YouBeKicked
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        YouBeKicked.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Data.Update.YouBeKicked();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.groupId = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a YouBeKicked message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.YouBeKicked
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {AcFunDanmu.Im.Cloud.Data.Update.YouBeKicked} YouBeKicked
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        YouBeKicked.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a YouBeKicked message.
                         * @function verify
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.YouBeKicked
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        YouBeKicked.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.groupId != null && message.hasOwnProperty("groupId"))
                                if (!$util.isString(message.groupId))
                                    return "groupId: string expected";
                            return null;
                        };

                        /**
                         * Creates a YouBeKicked message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.YouBeKicked
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {AcFunDanmu.Im.Cloud.Data.Update.YouBeKicked} YouBeKicked
                         */
                        YouBeKicked.fromObject = function fromObject(object) {
                            if (object instanceof $root.AcFunDanmu.Im.Cloud.Data.Update.YouBeKicked)
                                return object;
                            let message = new $root.AcFunDanmu.Im.Cloud.Data.Update.YouBeKicked();
                            if (object.groupId != null)
                                message.groupId = String(object.groupId);
                            return message;
                        };

                        /**
                         * Creates a plain object from a YouBeKicked message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.YouBeKicked
                         * @static
                         * @param {AcFunDanmu.Im.Cloud.Data.Update.YouBeKicked} message YouBeKicked
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        YouBeKicked.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults)
                                object.groupId = "";
                            if (message.groupId != null && message.hasOwnProperty("groupId"))
                                object.groupId = message.groupId;
                            return object;
                        };

                        /**
                         * Converts this YouBeKicked to JSON.
                         * @function toJSON
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.YouBeKicked
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        YouBeKicked.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return YouBeKicked;
                    })();

                    Update.MessageRead = (function() {

                        /**
                         * Properties of a MessageRead.
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update
                         * @interface IMessageRead
                         * @property {string|null} [strTargetId] MessageRead strTargetId
                         * @property {number|Long|null} [readSeq] MessageRead readSeq
                         * @property {AcFunDanmu.Im.Message.ChatTargetType|null} [chatTargetType] MessageRead chatTargetType
                         */

                        /**
                         * Constructs a new MessageRead.
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update
                         * @classdesc Represents a MessageRead.
                         * @implements IMessageRead
                         * @constructor
                         * @param {AcFunDanmu.Im.Cloud.Data.Update.IMessageRead=} [properties] Properties to set
                         */
                        function MessageRead(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * MessageRead strTargetId.
                         * @member {string} strTargetId
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.MessageRead
                         * @instance
                         */
                        MessageRead.prototype.strTargetId = "";

                        /**
                         * MessageRead readSeq.
                         * @member {number|Long} readSeq
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.MessageRead
                         * @instance
                         */
                        MessageRead.prototype.readSeq = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                        /**
                         * MessageRead chatTargetType.
                         * @member {AcFunDanmu.Im.Message.ChatTargetType} chatTargetType
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.MessageRead
                         * @instance
                         */
                        MessageRead.prototype.chatTargetType = 0;

                        /**
                         * Creates a new MessageRead instance using the specified properties.
                         * @function create
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.MessageRead
                         * @static
                         * @param {AcFunDanmu.Im.Cloud.Data.Update.IMessageRead=} [properties] Properties to set
                         * @returns {AcFunDanmu.Im.Cloud.Data.Update.MessageRead} MessageRead instance
                         */
                        MessageRead.create = function create(properties) {
                            return new MessageRead(properties);
                        };

                        /**
                         * Encodes the specified MessageRead message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Data.Update.MessageRead.verify|verify} messages.
                         * @function encode
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.MessageRead
                         * @static
                         * @param {AcFunDanmu.Im.Cloud.Data.Update.IMessageRead} message MessageRead message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        MessageRead.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.strTargetId != null && Object.hasOwnProperty.call(message, "strTargetId"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.strTargetId);
                            if (message.readSeq != null && Object.hasOwnProperty.call(message, "readSeq"))
                                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.readSeq);
                            if (message.chatTargetType != null && Object.hasOwnProperty.call(message, "chatTargetType"))
                                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.chatTargetType);
                            return writer;
                        };

                        /**
                         * Encodes the specified MessageRead message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Data.Update.MessageRead.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.MessageRead
                         * @static
                         * @param {AcFunDanmu.Im.Cloud.Data.Update.IMessageRead} message MessageRead message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        MessageRead.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a MessageRead message from the specified reader or buffer.
                         * @function decode
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.MessageRead
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {AcFunDanmu.Im.Cloud.Data.Update.MessageRead} MessageRead
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        MessageRead.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Data.Update.MessageRead();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.strTargetId = reader.string();
                                    break;
                                case 2:
                                    message.readSeq = reader.int64();
                                    break;
                                case 3:
                                    message.chatTargetType = reader.int32();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a MessageRead message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.MessageRead
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {AcFunDanmu.Im.Cloud.Data.Update.MessageRead} MessageRead
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        MessageRead.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a MessageRead message.
                         * @function verify
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.MessageRead
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        MessageRead.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.strTargetId != null && message.hasOwnProperty("strTargetId"))
                                if (!$util.isString(message.strTargetId))
                                    return "strTargetId: string expected";
                            if (message.readSeq != null && message.hasOwnProperty("readSeq"))
                                if (!$util.isInteger(message.readSeq) && !(message.readSeq && $util.isInteger(message.readSeq.low) && $util.isInteger(message.readSeq.high)))
                                    return "readSeq: integer|Long expected";
                            if (message.chatTargetType != null && message.hasOwnProperty("chatTargetType"))
                                switch (message.chatTargetType) {
                                default:
                                    return "chatTargetType: enum value expected";
                                case 0:
                                case 2:
                                case 3:
                                case 4:
                                case 5:
                                case 6:
                                    break;
                                }
                            return null;
                        };

                        /**
                         * Creates a MessageRead message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.MessageRead
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {AcFunDanmu.Im.Cloud.Data.Update.MessageRead} MessageRead
                         */
                        MessageRead.fromObject = function fromObject(object) {
                            if (object instanceof $root.AcFunDanmu.Im.Cloud.Data.Update.MessageRead)
                                return object;
                            let message = new $root.AcFunDanmu.Im.Cloud.Data.Update.MessageRead();
                            if (object.strTargetId != null)
                                message.strTargetId = String(object.strTargetId);
                            if (object.readSeq != null)
                                if ($util.Long)
                                    (message.readSeq = $util.Long.fromValue(object.readSeq)).unsigned = false;
                                else if (typeof object.readSeq === "string")
                                    message.readSeq = parseInt(object.readSeq, 10);
                                else if (typeof object.readSeq === "number")
                                    message.readSeq = object.readSeq;
                                else if (typeof object.readSeq === "object")
                                    message.readSeq = new $util.LongBits(object.readSeq.low >>> 0, object.readSeq.high >>> 0).toNumber();
                            switch (object.chatTargetType) {
                            case "CTT_USER":
                            case 0:
                                message.chatTargetType = 0;
                                break;
                            case "CTT_CHAT_ROOM":
                            case 2:
                                message.chatTargetType = 2;
                                break;
                            case "CTT_MULTI_PLAYER_ROOM":
                            case 3:
                                message.chatTargetType = 3;
                                break;
                            case "CTT_GROUP":
                            case 4:
                                message.chatTargetType = 4;
                                break;
                            case "CTT_CHANNEL":
                            case 5:
                                message.chatTargetType = 5;
                                break;
                            case "CTT_AGGREGATE":
                            case 6:
                                message.chatTargetType = 6;
                                break;
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a MessageRead message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.MessageRead
                         * @static
                         * @param {AcFunDanmu.Im.Cloud.Data.Update.MessageRead} message MessageRead
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        MessageRead.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                object.strTargetId = "";
                                if ($util.Long) {
                                    let long = new $util.Long(0, 0, false);
                                    object.readSeq = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                                } else
                                    object.readSeq = options.longs === String ? "0" : 0;
                                object.chatTargetType = options.enums === String ? "CTT_USER" : 0;
                            }
                            if (message.strTargetId != null && message.hasOwnProperty("strTargetId"))
                                object.strTargetId = message.strTargetId;
                            if (message.readSeq != null && message.hasOwnProperty("readSeq"))
                                if (typeof message.readSeq === "number")
                                    object.readSeq = options.longs === String ? String(message.readSeq) : message.readSeq;
                                else
                                    object.readSeq = options.longs === String ? $util.Long.prototype.toString.call(message.readSeq) : options.longs === Number ? new $util.LongBits(message.readSeq.low >>> 0, message.readSeq.high >>> 0).toNumber() : message.readSeq;
                            if (message.chatTargetType != null && message.hasOwnProperty("chatTargetType"))
                                object.chatTargetType = options.enums === String ? $root.AcFunDanmu.Im.Message.ChatTargetType[message.chatTargetType] : message.chatTargetType;
                            return object;
                        };

                        /**
                         * Converts this MessageRead to JSON.
                         * @function toJSON
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.MessageRead
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        MessageRead.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return MessageRead;
                    })();

                    Update.MessageReceipt = (function() {

                        /**
                         * Properties of a MessageReceipt.
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update
                         * @interface IMessageReceipt
                         * @property {AcFunDanmu.Im.Message.IChatTarget|null} [chatTarget] MessageReceipt chatTarget
                         * @property {AcFunDanmu.Im.Message.IMessageReceiptStatus|null} [receiptStatus] MessageReceipt receiptStatus
                         */

                        /**
                         * Constructs a new MessageReceipt.
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update
                         * @classdesc Represents a MessageReceipt.
                         * @implements IMessageReceipt
                         * @constructor
                         * @param {AcFunDanmu.Im.Cloud.Data.Update.IMessageReceipt=} [properties] Properties to set
                         */
                        function MessageReceipt(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * MessageReceipt chatTarget.
                         * @member {AcFunDanmu.Im.Message.IChatTarget|null|undefined} chatTarget
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.MessageReceipt
                         * @instance
                         */
                        MessageReceipt.prototype.chatTarget = null;

                        /**
                         * MessageReceipt receiptStatus.
                         * @member {AcFunDanmu.Im.Message.IMessageReceiptStatus|null|undefined} receiptStatus
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.MessageReceipt
                         * @instance
                         */
                        MessageReceipt.prototype.receiptStatus = null;

                        /**
                         * Creates a new MessageReceipt instance using the specified properties.
                         * @function create
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.MessageReceipt
                         * @static
                         * @param {AcFunDanmu.Im.Cloud.Data.Update.IMessageReceipt=} [properties] Properties to set
                         * @returns {AcFunDanmu.Im.Cloud.Data.Update.MessageReceipt} MessageReceipt instance
                         */
                        MessageReceipt.create = function create(properties) {
                            return new MessageReceipt(properties);
                        };

                        /**
                         * Encodes the specified MessageReceipt message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Data.Update.MessageReceipt.verify|verify} messages.
                         * @function encode
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.MessageReceipt
                         * @static
                         * @param {AcFunDanmu.Im.Cloud.Data.Update.IMessageReceipt} message MessageReceipt message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        MessageReceipt.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.chatTarget != null && Object.hasOwnProperty.call(message, "chatTarget"))
                                $root.AcFunDanmu.Im.Message.ChatTarget.encode(message.chatTarget, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                            if (message.receiptStatus != null && Object.hasOwnProperty.call(message, "receiptStatus"))
                                $root.AcFunDanmu.Im.Message.MessageReceiptStatus.encode(message.receiptStatus, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                            return writer;
                        };

                        /**
                         * Encodes the specified MessageReceipt message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Data.Update.MessageReceipt.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.MessageReceipt
                         * @static
                         * @param {AcFunDanmu.Im.Cloud.Data.Update.IMessageReceipt} message MessageReceipt message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        MessageReceipt.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a MessageReceipt message from the specified reader or buffer.
                         * @function decode
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.MessageReceipt
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {AcFunDanmu.Im.Cloud.Data.Update.MessageReceipt} MessageReceipt
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        MessageReceipt.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Data.Update.MessageReceipt();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.chatTarget = $root.AcFunDanmu.Im.Message.ChatTarget.decode(reader, reader.uint32());
                                    break;
                                case 2:
                                    message.receiptStatus = $root.AcFunDanmu.Im.Message.MessageReceiptStatus.decode(reader, reader.uint32());
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a MessageReceipt message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.MessageReceipt
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {AcFunDanmu.Im.Cloud.Data.Update.MessageReceipt} MessageReceipt
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        MessageReceipt.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a MessageReceipt message.
                         * @function verify
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.MessageReceipt
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        MessageReceipt.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.chatTarget != null && message.hasOwnProperty("chatTarget")) {
                                let error = $root.AcFunDanmu.Im.Message.ChatTarget.verify(message.chatTarget);
                                if (error)
                                    return "chatTarget." + error;
                            }
                            if (message.receiptStatus != null && message.hasOwnProperty("receiptStatus")) {
                                let error = $root.AcFunDanmu.Im.Message.MessageReceiptStatus.verify(message.receiptStatus);
                                if (error)
                                    return "receiptStatus." + error;
                            }
                            return null;
                        };

                        /**
                         * Creates a MessageReceipt message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.MessageReceipt
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {AcFunDanmu.Im.Cloud.Data.Update.MessageReceipt} MessageReceipt
                         */
                        MessageReceipt.fromObject = function fromObject(object) {
                            if (object instanceof $root.AcFunDanmu.Im.Cloud.Data.Update.MessageReceipt)
                                return object;
                            let message = new $root.AcFunDanmu.Im.Cloud.Data.Update.MessageReceipt();
                            if (object.chatTarget != null) {
                                if (typeof object.chatTarget !== "object")
                                    throw TypeError(".AcFunDanmu.Im.Cloud.Data.Update.MessageReceipt.chatTarget: object expected");
                                message.chatTarget = $root.AcFunDanmu.Im.Message.ChatTarget.fromObject(object.chatTarget);
                            }
                            if (object.receiptStatus != null) {
                                if (typeof object.receiptStatus !== "object")
                                    throw TypeError(".AcFunDanmu.Im.Cloud.Data.Update.MessageReceipt.receiptStatus: object expected");
                                message.receiptStatus = $root.AcFunDanmu.Im.Message.MessageReceiptStatus.fromObject(object.receiptStatus);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a MessageReceipt message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.MessageReceipt
                         * @static
                         * @param {AcFunDanmu.Im.Cloud.Data.Update.MessageReceipt} message MessageReceipt
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        MessageReceipt.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                object.chatTarget = null;
                                object.receiptStatus = null;
                            }
                            if (message.chatTarget != null && message.hasOwnProperty("chatTarget"))
                                object.chatTarget = $root.AcFunDanmu.Im.Message.ChatTarget.toObject(message.chatTarget, options);
                            if (message.receiptStatus != null && message.hasOwnProperty("receiptStatus"))
                                object.receiptStatus = $root.AcFunDanmu.Im.Message.MessageReceiptStatus.toObject(message.receiptStatus, options);
                            return object;
                        };

                        /**
                         * Converts this MessageReceipt to JSON.
                         * @function toJSON
                         * @memberof AcFunDanmu.Im.Cloud.Data.Update.MessageReceipt
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        MessageReceipt.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return MessageReceipt;
                    })();

                    return Update;
                })();

                return Data;
            })();

            Cloud.Message = (function() {

                /**
                 * Properties of a Message.
                 * @memberof AcFunDanmu.Im.Cloud
                 * @interface IMessage
                 */

                /**
                 * Constructs a new Message.
                 * @memberof AcFunDanmu.Im.Cloud
                 * @classdesc Represents a Message.
                 * @implements IMessage
                 * @constructor
                 * @param {AcFunDanmu.Im.Cloud.IMessage=} [properties] Properties to set
                 */
                function Message(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new Message instance using the specified properties.
                 * @function create
                 * @memberof AcFunDanmu.Im.Cloud.Message
                 * @static
                 * @param {AcFunDanmu.Im.Cloud.IMessage=} [properties] Properties to set
                 * @returns {AcFunDanmu.Im.Cloud.Message} Message instance
                 */
                Message.create = function create(properties) {
                    return new Message(properties);
                };

                /**
                 * Encodes the specified Message message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.verify|verify} messages.
                 * @function encode
                 * @memberof AcFunDanmu.Im.Cloud.Message
                 * @static
                 * @param {AcFunDanmu.Im.Cloud.IMessage} message Message message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Message.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified Message message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof AcFunDanmu.Im.Cloud.Message
                 * @static
                 * @param {AcFunDanmu.Im.Cloud.IMessage} message Message message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Message.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Message message from the specified reader or buffer.
                 * @function decode
                 * @memberof AcFunDanmu.Im.Cloud.Message
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {AcFunDanmu.Im.Cloud.Message} Message
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Message.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Message message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof AcFunDanmu.Im.Cloud.Message
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {AcFunDanmu.Im.Cloud.Message} Message
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Message.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Message message.
                 * @function verify
                 * @memberof AcFunDanmu.Im.Cloud.Message
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Message.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a Message message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof AcFunDanmu.Im.Cloud.Message
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {AcFunDanmu.Im.Cloud.Message} Message
                 */
                Message.fromObject = function fromObject(object) {
                    if (object instanceof $root.AcFunDanmu.Im.Cloud.Message)
                        return object;
                    return new $root.AcFunDanmu.Im.Cloud.Message();
                };

                /**
                 * Creates a plain object from a Message message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof AcFunDanmu.Im.Cloud.Message
                 * @static
                 * @param {AcFunDanmu.Im.Cloud.Message} message Message
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Message.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this Message to JSON.
                 * @function toJSON
                 * @memberof AcFunDanmu.Im.Cloud.Message
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Message.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * ImcMessageType enum.
                 * @name AcFunDanmu.Im.Cloud.Message.ImcMessageType
                 * @enum {number}
                 * @property {number} TEXT=0 TEXT value
                 * @property {number} IMAGE=1 IMAGE value
                 * @property {number} CUSTOM=2 CUSTOM value
                 * @property {number} AUDIO=3 AUDIO value
                 * @property {number} VIDEO=4 VIDEO value
                 * @property {number} EMOTICON=5 EMOTICON value
                 * @property {number} FILE=6 FILE value
                 * @property {number} NOTICE=10 NOTICE value
                 * @property {number} RECALLED=11 RECALLED value
                 * @property {number} REFERENCE=12 REFERENCE value
                 * @property {number} MERGE_FORWARD=13 MERGE_FORWARD value
                 * @property {number} PLACE_HOLDER=100 PLACE_HOLDER value
                 * @property {number} REPLACE=101 REPLACE value
                 * @property {number} INVISIBLE_TYPE_MAS=199 INVISIBLE_TYPE_MAS value
                 * @property {number} RICH_NOTICE=200 RICH_NOTICE value
                 */
                Message.ImcMessageType = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "TEXT"] = 0;
                    values[valuesById[1] = "IMAGE"] = 1;
                    values[valuesById[2] = "CUSTOM"] = 2;
                    values[valuesById[3] = "AUDIO"] = 3;
                    values[valuesById[4] = "VIDEO"] = 4;
                    values[valuesById[5] = "EMOTICON"] = 5;
                    values[valuesById[6] = "FILE"] = 6;
                    values[valuesById[10] = "NOTICE"] = 10;
                    values[valuesById[11] = "RECALLED"] = 11;
                    values[valuesById[12] = "REFERENCE"] = 12;
                    values[valuesById[13] = "MERGE_FORWARD"] = 13;
                    values[valuesById[100] = "PLACE_HOLDER"] = 100;
                    values[valuesById[101] = "REPLACE"] = 101;
                    values[valuesById[199] = "INVISIBLE_TYPE_MAS"] = 199;
                    values[valuesById[200] = "RICH_NOTICE"] = 200;
                    return values;
                })();

                Message.ImcRecalledMessage = (function() {

                    /**
                     * Properties of an ImcRecalledMessage.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface IImcRecalledMessage
                     * @property {AcFunDanmu.Im.Message.IMessage|null} [originMsg] ImcRecalledMessage originMsg
                     * @property {AcFunDanmu.Im.Cloud.Message.IImcNoticeMessage|null} [noticeMsg] ImcRecalledMessage noticeMsg
                     */

                    /**
                     * Constructs a new ImcRecalledMessage.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents an ImcRecalledMessage.
                     * @implements IImcRecalledMessage
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.IImcRecalledMessage=} [properties] Properties to set
                     */
                    function ImcRecalledMessage(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * ImcRecalledMessage originMsg.
                     * @member {AcFunDanmu.Im.Message.IMessage|null|undefined} originMsg
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcRecalledMessage
                     * @instance
                     */
                    ImcRecalledMessage.prototype.originMsg = null;

                    /**
                     * ImcRecalledMessage noticeMsg.
                     * @member {AcFunDanmu.Im.Cloud.Message.IImcNoticeMessage|null|undefined} noticeMsg
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcRecalledMessage
                     * @instance
                     */
                    ImcRecalledMessage.prototype.noticeMsg = null;

                    /**
                     * Creates a new ImcRecalledMessage instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcRecalledMessage
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IImcRecalledMessage=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.ImcRecalledMessage} ImcRecalledMessage instance
                     */
                    ImcRecalledMessage.create = function create(properties) {
                        return new ImcRecalledMessage(properties);
                    };

                    /**
                     * Encodes the specified ImcRecalledMessage message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.ImcRecalledMessage.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcRecalledMessage
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IImcRecalledMessage} message ImcRecalledMessage message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ImcRecalledMessage.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.originMsg != null && Object.hasOwnProperty.call(message, "originMsg"))
                            $root.AcFunDanmu.Im.Message.Message.encode(message.originMsg, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.noticeMsg != null && Object.hasOwnProperty.call(message, "noticeMsg"))
                            $root.AcFunDanmu.Im.Cloud.Message.ImcNoticeMessage.encode(message.noticeMsg, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified ImcRecalledMessage message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.ImcRecalledMessage.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcRecalledMessage
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IImcRecalledMessage} message ImcRecalledMessage message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ImcRecalledMessage.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes an ImcRecalledMessage message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcRecalledMessage
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.ImcRecalledMessage} ImcRecalledMessage
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ImcRecalledMessage.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.ImcRecalledMessage();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.originMsg = $root.AcFunDanmu.Im.Message.Message.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.noticeMsg = $root.AcFunDanmu.Im.Cloud.Message.ImcNoticeMessage.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes an ImcRecalledMessage message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcRecalledMessage
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.ImcRecalledMessage} ImcRecalledMessage
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ImcRecalledMessage.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies an ImcRecalledMessage message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcRecalledMessage
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ImcRecalledMessage.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.originMsg != null && message.hasOwnProperty("originMsg")) {
                            let error = $root.AcFunDanmu.Im.Message.Message.verify(message.originMsg);
                            if (error)
                                return "originMsg." + error;
                        }
                        if (message.noticeMsg != null && message.hasOwnProperty("noticeMsg")) {
                            let error = $root.AcFunDanmu.Im.Cloud.Message.ImcNoticeMessage.verify(message.noticeMsg);
                            if (error)
                                return "noticeMsg." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates an ImcRecalledMessage message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcRecalledMessage
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.ImcRecalledMessage} ImcRecalledMessage
                     */
                    ImcRecalledMessage.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.ImcRecalledMessage)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Message.ImcRecalledMessage();
                        if (object.originMsg != null) {
                            if (typeof object.originMsg !== "object")
                                throw TypeError(".AcFunDanmu.Im.Cloud.Message.ImcRecalledMessage.originMsg: object expected");
                            message.originMsg = $root.AcFunDanmu.Im.Message.Message.fromObject(object.originMsg);
                        }
                        if (object.noticeMsg != null) {
                            if (typeof object.noticeMsg !== "object")
                                throw TypeError(".AcFunDanmu.Im.Cloud.Message.ImcRecalledMessage.noticeMsg: object expected");
                            message.noticeMsg = $root.AcFunDanmu.Im.Cloud.Message.ImcNoticeMessage.fromObject(object.noticeMsg);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from an ImcRecalledMessage message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcRecalledMessage
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.ImcRecalledMessage} message ImcRecalledMessage
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ImcRecalledMessage.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.originMsg = null;
                            object.noticeMsg = null;
                        }
                        if (message.originMsg != null && message.hasOwnProperty("originMsg"))
                            object.originMsg = $root.AcFunDanmu.Im.Message.Message.toObject(message.originMsg, options);
                        if (message.noticeMsg != null && message.hasOwnProperty("noticeMsg"))
                            object.noticeMsg = $root.AcFunDanmu.Im.Cloud.Message.ImcNoticeMessage.toObject(message.noticeMsg, options);
                        return object;
                    };

                    /**
                     * Converts this ImcRecalledMessage to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcRecalledMessage
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ImcRecalledMessage.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return ImcRecalledMessage;
                })();

                Message.ImcReplaceMessage = (function() {

                    /**
                     * Properties of an ImcReplaceMessage.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface IImcReplaceMessage
                     * @property {AcFunDanmu.Im.Message.IMessage|null} [replaceMsg] ImcReplaceMessage replaceMsg
                     */

                    /**
                     * Constructs a new ImcReplaceMessage.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents an ImcReplaceMessage.
                     * @implements IImcReplaceMessage
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.IImcReplaceMessage=} [properties] Properties to set
                     */
                    function ImcReplaceMessage(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * ImcReplaceMessage replaceMsg.
                     * @member {AcFunDanmu.Im.Message.IMessage|null|undefined} replaceMsg
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcReplaceMessage
                     * @instance
                     */
                    ImcReplaceMessage.prototype.replaceMsg = null;

                    /**
                     * Creates a new ImcReplaceMessage instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcReplaceMessage
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IImcReplaceMessage=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.ImcReplaceMessage} ImcReplaceMessage instance
                     */
                    ImcReplaceMessage.create = function create(properties) {
                        return new ImcReplaceMessage(properties);
                    };

                    /**
                     * Encodes the specified ImcReplaceMessage message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.ImcReplaceMessage.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcReplaceMessage
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IImcReplaceMessage} message ImcReplaceMessage message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ImcReplaceMessage.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.replaceMsg != null && Object.hasOwnProperty.call(message, "replaceMsg"))
                            $root.AcFunDanmu.Im.Message.Message.encode(message.replaceMsg, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified ImcReplaceMessage message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.ImcReplaceMessage.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcReplaceMessage
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IImcReplaceMessage} message ImcReplaceMessage message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ImcReplaceMessage.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes an ImcReplaceMessage message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcReplaceMessage
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.ImcReplaceMessage} ImcReplaceMessage
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ImcReplaceMessage.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.ImcReplaceMessage();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.replaceMsg = $root.AcFunDanmu.Im.Message.Message.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes an ImcReplaceMessage message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcReplaceMessage
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.ImcReplaceMessage} ImcReplaceMessage
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ImcReplaceMessage.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies an ImcReplaceMessage message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcReplaceMessage
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ImcReplaceMessage.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.replaceMsg != null && message.hasOwnProperty("replaceMsg")) {
                            let error = $root.AcFunDanmu.Im.Message.Message.verify(message.replaceMsg);
                            if (error)
                                return "replaceMsg." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates an ImcReplaceMessage message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcReplaceMessage
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.ImcReplaceMessage} ImcReplaceMessage
                     */
                    ImcReplaceMessage.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.ImcReplaceMessage)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Message.ImcReplaceMessage();
                        if (object.replaceMsg != null) {
                            if (typeof object.replaceMsg !== "object")
                                throw TypeError(".AcFunDanmu.Im.Cloud.Message.ImcReplaceMessage.replaceMsg: object expected");
                            message.replaceMsg = $root.AcFunDanmu.Im.Message.Message.fromObject(object.replaceMsg);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from an ImcReplaceMessage message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcReplaceMessage
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.ImcReplaceMessage} message ImcReplaceMessage
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ImcReplaceMessage.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.replaceMsg = null;
                        if (message.replaceMsg != null && message.hasOwnProperty("replaceMsg"))
                            object.replaceMsg = $root.AcFunDanmu.Im.Message.Message.toObject(message.replaceMsg, options);
                        return object;
                    };

                    /**
                     * Converts this ImcReplaceMessage to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcReplaceMessage
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ImcReplaceMessage.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return ImcReplaceMessage;
                })();

                Message.Text = (function() {

                    /**
                     * Properties of a Text.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface IText
                     * @property {string|null} [text] Text text
                     */

                    /**
                     * Constructs a new Text.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents a Text.
                     * @implements IText
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.IText=} [properties] Properties to set
                     */
                    function Text(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Text text.
                     * @member {string} text
                     * @memberof AcFunDanmu.Im.Cloud.Message.Text
                     * @instance
                     */
                    Text.prototype.text = "";

                    /**
                     * Creates a new Text instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.Text
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IText=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.Text} Text instance
                     */
                    Text.create = function create(properties) {
                        return new Text(properties);
                    };

                    /**
                     * Encodes the specified Text message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.Text.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.Text
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IText} message Text message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Text.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.text);
                        return writer;
                    };

                    /**
                     * Encodes the specified Text message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.Text.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.Text
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IText} message Text message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Text.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Text message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.Text
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.Text} Text
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Text.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.Text();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.text = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Text message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.Text
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.Text} Text
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Text.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Text message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.Text
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Text.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.text != null && message.hasOwnProperty("text"))
                            if (!$util.isString(message.text))
                                return "text: string expected";
                        return null;
                    };

                    /**
                     * Creates a Text message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.Text
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.Text} Text
                     */
                    Text.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.Text)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Message.Text();
                        if (object.text != null)
                            message.text = String(object.text);
                        return message;
                    };

                    /**
                     * Creates a plain object from a Text message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.Text
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.Text} message Text
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Text.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.text = "";
                        if (message.text != null && message.hasOwnProperty("text"))
                            object.text = message.text;
                        return object;
                    };

                    /**
                     * Converts this Text to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.Text
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Text.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Text;
                })();

                Message.Image = (function() {

                    /**
                     * Properties of an Image.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface IImage
                     * @property {string|null} [uri] Image uri
                     * @property {number|null} [width] Image width
                     * @property {number|null} [height] Image height
                     */

                    /**
                     * Constructs a new Image.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents an Image.
                     * @implements IImage
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.IImage=} [properties] Properties to set
                     */
                    function Image(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Image uri.
                     * @member {string} uri
                     * @memberof AcFunDanmu.Im.Cloud.Message.Image
                     * @instance
                     */
                    Image.prototype.uri = "";

                    /**
                     * Image width.
                     * @member {number} width
                     * @memberof AcFunDanmu.Im.Cloud.Message.Image
                     * @instance
                     */
                    Image.prototype.width = 0;

                    /**
                     * Image height.
                     * @member {number} height
                     * @memberof AcFunDanmu.Im.Cloud.Message.Image
                     * @instance
                     */
                    Image.prototype.height = 0;

                    /**
                     * Creates a new Image instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.Image
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IImage=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.Image} Image instance
                     */
                    Image.create = function create(properties) {
                        return new Image(properties);
                    };

                    /**
                     * Encodes the specified Image message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.Image.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.Image
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IImage} message Image message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Image.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.uri != null && Object.hasOwnProperty.call(message, "uri"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.uri);
                        if (message.width != null && Object.hasOwnProperty.call(message, "width"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.width);
                        if (message.height != null && Object.hasOwnProperty.call(message, "height"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.height);
                        return writer;
                    };

                    /**
                     * Encodes the specified Image message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.Image.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.Image
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IImage} message Image message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Image.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes an Image message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.Image
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.Image} Image
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Image.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.Image();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.uri = reader.string();
                                break;
                            case 2:
                                message.width = reader.int32();
                                break;
                            case 3:
                                message.height = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes an Image message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.Image
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.Image} Image
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Image.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies an Image message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.Image
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Image.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.uri != null && message.hasOwnProperty("uri"))
                            if (!$util.isString(message.uri))
                                return "uri: string expected";
                        if (message.width != null && message.hasOwnProperty("width"))
                            if (!$util.isInteger(message.width))
                                return "width: integer expected";
                        if (message.height != null && message.hasOwnProperty("height"))
                            if (!$util.isInteger(message.height))
                                return "height: integer expected";
                        return null;
                    };

                    /**
                     * Creates an Image message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.Image
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.Image} Image
                     */
                    Image.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.Image)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Message.Image();
                        if (object.uri != null)
                            message.uri = String(object.uri);
                        if (object.width != null)
                            message.width = object.width | 0;
                        if (object.height != null)
                            message.height = object.height | 0;
                        return message;
                    };

                    /**
                     * Creates a plain object from an Image message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.Image
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.Image} message Image
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Image.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.uri = "";
                            object.width = 0;
                            object.height = 0;
                        }
                        if (message.uri != null && message.hasOwnProperty("uri"))
                            object.uri = message.uri;
                        if (message.width != null && message.hasOwnProperty("width"))
                            object.width = message.width;
                        if (message.height != null && message.hasOwnProperty("height"))
                            object.height = message.height;
                        return object;
                    };

                    /**
                     * Converts this Image to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.Image
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Image.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Image;
                })();

                Message.Audio = (function() {

                    /**
                     * Properties of an Audio.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface IAudio
                     * @property {string|null} [uri] Audio uri
                     * @property {number|null} [duration] Audio duration
                     * @property {string|null} [type] Audio type
                     */

                    /**
                     * Constructs a new Audio.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents an Audio.
                     * @implements IAudio
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.IAudio=} [properties] Properties to set
                     */
                    function Audio(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Audio uri.
                     * @member {string} uri
                     * @memberof AcFunDanmu.Im.Cloud.Message.Audio
                     * @instance
                     */
                    Audio.prototype.uri = "";

                    /**
                     * Audio duration.
                     * @member {number} duration
                     * @memberof AcFunDanmu.Im.Cloud.Message.Audio
                     * @instance
                     */
                    Audio.prototype.duration = 0;

                    /**
                     * Audio type.
                     * @member {string} type
                     * @memberof AcFunDanmu.Im.Cloud.Message.Audio
                     * @instance
                     */
                    Audio.prototype.type = "";

                    /**
                     * Creates a new Audio instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.Audio
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IAudio=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.Audio} Audio instance
                     */
                    Audio.create = function create(properties) {
                        return new Audio(properties);
                    };

                    /**
                     * Encodes the specified Audio message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.Audio.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.Audio
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IAudio} message Audio message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Audio.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.uri != null && Object.hasOwnProperty.call(message, "uri"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.uri);
                        if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.duration);
                        if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.type);
                        return writer;
                    };

                    /**
                     * Encodes the specified Audio message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.Audio.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.Audio
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IAudio} message Audio message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Audio.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes an Audio message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.Audio
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.Audio} Audio
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Audio.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.Audio();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.uri = reader.string();
                                break;
                            case 2:
                                message.duration = reader.int32();
                                break;
                            case 3:
                                message.type = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes an Audio message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.Audio
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.Audio} Audio
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Audio.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies an Audio message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.Audio
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Audio.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.uri != null && message.hasOwnProperty("uri"))
                            if (!$util.isString(message.uri))
                                return "uri: string expected";
                        if (message.duration != null && message.hasOwnProperty("duration"))
                            if (!$util.isInteger(message.duration))
                                return "duration: integer expected";
                        if (message.type != null && message.hasOwnProperty("type"))
                            if (!$util.isString(message.type))
                                return "type: string expected";
                        return null;
                    };

                    /**
                     * Creates an Audio message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.Audio
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.Audio} Audio
                     */
                    Audio.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.Audio)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Message.Audio();
                        if (object.uri != null)
                            message.uri = String(object.uri);
                        if (object.duration != null)
                            message.duration = object.duration | 0;
                        if (object.type != null)
                            message.type = String(object.type);
                        return message;
                    };

                    /**
                     * Creates a plain object from an Audio message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.Audio
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.Audio} message Audio
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Audio.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.uri = "";
                            object.duration = 0;
                            object.type = "";
                        }
                        if (message.uri != null && message.hasOwnProperty("uri"))
                            object.uri = message.uri;
                        if (message.duration != null && message.hasOwnProperty("duration"))
                            object.duration = message.duration;
                        if (message.type != null && message.hasOwnProperty("type"))
                            object.type = message.type;
                        return object;
                    };

                    /**
                     * Converts this Audio to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.Audio
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Audio.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Audio;
                })();

                Message.Video = (function() {

                    /**
                     * Properties of a Video.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface IVideo
                     * @property {string|null} [uri] Video uri
                     * @property {number|null} [duration] Video duration
                     * @property {number|null} [width] Video width
                     * @property {number|null} [height] Video height
                     * @property {string|null} [coverUri] Video coverUri
                     * @property {string|null} [type] Video type
                     */

                    /**
                     * Constructs a new Video.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents a Video.
                     * @implements IVideo
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.IVideo=} [properties] Properties to set
                     */
                    function Video(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Video uri.
                     * @member {string} uri
                     * @memberof AcFunDanmu.Im.Cloud.Message.Video
                     * @instance
                     */
                    Video.prototype.uri = "";

                    /**
                     * Video duration.
                     * @member {number} duration
                     * @memberof AcFunDanmu.Im.Cloud.Message.Video
                     * @instance
                     */
                    Video.prototype.duration = 0;

                    /**
                     * Video width.
                     * @member {number} width
                     * @memberof AcFunDanmu.Im.Cloud.Message.Video
                     * @instance
                     */
                    Video.prototype.width = 0;

                    /**
                     * Video height.
                     * @member {number} height
                     * @memberof AcFunDanmu.Im.Cloud.Message.Video
                     * @instance
                     */
                    Video.prototype.height = 0;

                    /**
                     * Video coverUri.
                     * @member {string} coverUri
                     * @memberof AcFunDanmu.Im.Cloud.Message.Video
                     * @instance
                     */
                    Video.prototype.coverUri = "";

                    /**
                     * Video type.
                     * @member {string} type
                     * @memberof AcFunDanmu.Im.Cloud.Message.Video
                     * @instance
                     */
                    Video.prototype.type = "";

                    /**
                     * Creates a new Video instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.Video
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IVideo=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.Video} Video instance
                     */
                    Video.create = function create(properties) {
                        return new Video(properties);
                    };

                    /**
                     * Encodes the specified Video message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.Video.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.Video
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IVideo} message Video message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Video.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.uri != null && Object.hasOwnProperty.call(message, "uri"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.uri);
                        if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.duration);
                        if (message.width != null && Object.hasOwnProperty.call(message, "width"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.width);
                        if (message.height != null && Object.hasOwnProperty.call(message, "height"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.height);
                        if (message.coverUri != null && Object.hasOwnProperty.call(message, "coverUri"))
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.coverUri);
                        if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                            writer.uint32(/* id 6, wireType 2 =*/50).string(message.type);
                        return writer;
                    };

                    /**
                     * Encodes the specified Video message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.Video.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.Video
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IVideo} message Video message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Video.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Video message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.Video
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.Video} Video
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Video.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.Video();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.uri = reader.string();
                                break;
                            case 2:
                                message.duration = reader.int32();
                                break;
                            case 3:
                                message.width = reader.int32();
                                break;
                            case 4:
                                message.height = reader.int32();
                                break;
                            case 5:
                                message.coverUri = reader.string();
                                break;
                            case 6:
                                message.type = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Video message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.Video
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.Video} Video
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Video.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Video message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.Video
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Video.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.uri != null && message.hasOwnProperty("uri"))
                            if (!$util.isString(message.uri))
                                return "uri: string expected";
                        if (message.duration != null && message.hasOwnProperty("duration"))
                            if (!$util.isInteger(message.duration))
                                return "duration: integer expected";
                        if (message.width != null && message.hasOwnProperty("width"))
                            if (!$util.isInteger(message.width))
                                return "width: integer expected";
                        if (message.height != null && message.hasOwnProperty("height"))
                            if (!$util.isInteger(message.height))
                                return "height: integer expected";
                        if (message.coverUri != null && message.hasOwnProperty("coverUri"))
                            if (!$util.isString(message.coverUri))
                                return "coverUri: string expected";
                        if (message.type != null && message.hasOwnProperty("type"))
                            if (!$util.isString(message.type))
                                return "type: string expected";
                        return null;
                    };

                    /**
                     * Creates a Video message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.Video
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.Video} Video
                     */
                    Video.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.Video)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Message.Video();
                        if (object.uri != null)
                            message.uri = String(object.uri);
                        if (object.duration != null)
                            message.duration = object.duration | 0;
                        if (object.width != null)
                            message.width = object.width | 0;
                        if (object.height != null)
                            message.height = object.height | 0;
                        if (object.coverUri != null)
                            message.coverUri = String(object.coverUri);
                        if (object.type != null)
                            message.type = String(object.type);
                        return message;
                    };

                    /**
                     * Creates a plain object from a Video message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.Video
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.Video} message Video
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Video.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.uri = "";
                            object.duration = 0;
                            object.width = 0;
                            object.height = 0;
                            object.coverUri = "";
                            object.type = "";
                        }
                        if (message.uri != null && message.hasOwnProperty("uri"))
                            object.uri = message.uri;
                        if (message.duration != null && message.hasOwnProperty("duration"))
                            object.duration = message.duration;
                        if (message.width != null && message.hasOwnProperty("width"))
                            object.width = message.width;
                        if (message.height != null && message.hasOwnProperty("height"))
                            object.height = message.height;
                        if (message.coverUri != null && message.hasOwnProperty("coverUri"))
                            object.coverUri = message.coverUri;
                        if (message.type != null && message.hasOwnProperty("type"))
                            object.type = message.type;
                        return object;
                    };

                    /**
                     * Converts this Video to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.Video
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Video.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Video;
                })();

                Message.Custon = (function() {

                    /**
                     * Properties of a Custon.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface ICuston
                     * @property {string|null} [payload] Custon payload
                     */

                    /**
                     * Constructs a new Custon.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents a Custon.
                     * @implements ICuston
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.ICuston=} [properties] Properties to set
                     */
                    function Custon(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Custon payload.
                     * @member {string} payload
                     * @memberof AcFunDanmu.Im.Cloud.Message.Custon
                     * @instance
                     */
                    Custon.prototype.payload = "";

                    /**
                     * Creates a new Custon instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.Custon
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.ICuston=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.Custon} Custon instance
                     */
                    Custon.create = function create(properties) {
                        return new Custon(properties);
                    };

                    /**
                     * Encodes the specified Custon message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.Custon.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.Custon
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.ICuston} message Custon message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Custon.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.payload);
                        return writer;
                    };

                    /**
                     * Encodes the specified Custon message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.Custon.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.Custon
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.ICuston} message Custon message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Custon.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Custon message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.Custon
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.Custon} Custon
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Custon.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.Custon();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.payload = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Custon message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.Custon
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.Custon} Custon
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Custon.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Custon message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.Custon
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Custon.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.payload != null && message.hasOwnProperty("payload"))
                            if (!$util.isString(message.payload))
                                return "payload: string expected";
                        return null;
                    };

                    /**
                     * Creates a Custon message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.Custon
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.Custon} Custon
                     */
                    Custon.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.Custon)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Message.Custon();
                        if (object.payload != null)
                            message.payload = String(object.payload);
                        return message;
                    };

                    /**
                     * Creates a plain object from a Custon message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.Custon
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.Custon} message Custon
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Custon.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.payload = "";
                        if (message.payload != null && message.hasOwnProperty("payload"))
                            object.payload = message.payload;
                        return object;
                    };

                    /**
                     * Converts this Custon to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.Custon
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Custon.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Custon;
                })();

                Message.PicUrl = (function() {

                    /**
                     * Properties of a PicUrl.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface IPicUrl
                     * @property {string|null} [cdn] PicUrl cdn
                     * @property {string|null} [url] PicUrl url
                     * @property {string|null} [urlPattern] PicUrl urlPattern
                     * @property {string|null} [ip] PicUrl ip
                     */

                    /**
                     * Constructs a new PicUrl.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents a PicUrl.
                     * @implements IPicUrl
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.IPicUrl=} [properties] Properties to set
                     */
                    function PicUrl(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * PicUrl cdn.
                     * @member {string} cdn
                     * @memberof AcFunDanmu.Im.Cloud.Message.PicUrl
                     * @instance
                     */
                    PicUrl.prototype.cdn = "";

                    /**
                     * PicUrl url.
                     * @member {string} url
                     * @memberof AcFunDanmu.Im.Cloud.Message.PicUrl
                     * @instance
                     */
                    PicUrl.prototype.url = "";

                    /**
                     * PicUrl urlPattern.
                     * @member {string} urlPattern
                     * @memberof AcFunDanmu.Im.Cloud.Message.PicUrl
                     * @instance
                     */
                    PicUrl.prototype.urlPattern = "";

                    /**
                     * PicUrl ip.
                     * @member {string} ip
                     * @memberof AcFunDanmu.Im.Cloud.Message.PicUrl
                     * @instance
                     */
                    PicUrl.prototype.ip = "";

                    /**
                     * Creates a new PicUrl instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.PicUrl
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IPicUrl=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.PicUrl} PicUrl instance
                     */
                    PicUrl.create = function create(properties) {
                        return new PicUrl(properties);
                    };

                    /**
                     * Encodes the specified PicUrl message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.PicUrl.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.PicUrl
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IPicUrl} message PicUrl message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    PicUrl.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.cdn != null && Object.hasOwnProperty.call(message, "cdn"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.cdn);
                        if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.url);
                        if (message.urlPattern != null && Object.hasOwnProperty.call(message, "urlPattern"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.urlPattern);
                        if (message.ip != null && Object.hasOwnProperty.call(message, "ip"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.ip);
                        return writer;
                    };

                    /**
                     * Encodes the specified PicUrl message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.PicUrl.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.PicUrl
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IPicUrl} message PicUrl message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    PicUrl.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a PicUrl message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.PicUrl
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.PicUrl} PicUrl
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    PicUrl.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.PicUrl();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.cdn = reader.string();
                                break;
                            case 2:
                                message.url = reader.string();
                                break;
                            case 3:
                                message.urlPattern = reader.string();
                                break;
                            case 4:
                                message.ip = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a PicUrl message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.PicUrl
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.PicUrl} PicUrl
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    PicUrl.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a PicUrl message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.PicUrl
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    PicUrl.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.cdn != null && message.hasOwnProperty("cdn"))
                            if (!$util.isString(message.cdn))
                                return "cdn: string expected";
                        if (message.url != null && message.hasOwnProperty("url"))
                            if (!$util.isString(message.url))
                                return "url: string expected";
                        if (message.urlPattern != null && message.hasOwnProperty("urlPattern"))
                            if (!$util.isString(message.urlPattern))
                                return "urlPattern: string expected";
                        if (message.ip != null && message.hasOwnProperty("ip"))
                            if (!$util.isString(message.ip))
                                return "ip: string expected";
                        return null;
                    };

                    /**
                     * Creates a PicUrl message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.PicUrl
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.PicUrl} PicUrl
                     */
                    PicUrl.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.PicUrl)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Message.PicUrl();
                        if (object.cdn != null)
                            message.cdn = String(object.cdn);
                        if (object.url != null)
                            message.url = String(object.url);
                        if (object.urlPattern != null)
                            message.urlPattern = String(object.urlPattern);
                        if (object.ip != null)
                            message.ip = String(object.ip);
                        return message;
                    };

                    /**
                     * Creates a plain object from a PicUrl message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.PicUrl
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.PicUrl} message PicUrl
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    PicUrl.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.cdn = "";
                            object.url = "";
                            object.urlPattern = "";
                            object.ip = "";
                        }
                        if (message.cdn != null && message.hasOwnProperty("cdn"))
                            object.cdn = message.cdn;
                        if (message.url != null && message.hasOwnProperty("url"))
                            object.url = message.url;
                        if (message.urlPattern != null && message.hasOwnProperty("urlPattern"))
                            object.urlPattern = message.urlPattern;
                        if (message.ip != null && message.hasOwnProperty("ip"))
                            object.ip = message.ip;
                        return object;
                    };

                    /**
                     * Converts this PicUrl to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.PicUrl
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    PicUrl.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return PicUrl;
                })();

                Message.Emoticon = (function() {

                    /**
                     * Properties of an Emoticon.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface IEmoticon
                     * @property {string|null} [id] Emoticon id
                     * @property {string|null} [packageId] Emoticon packageId
                     * @property {string|null} [name] Emoticon name
                     * @property {AcFunDanmu.Im.Cloud.Message.Emoticon.Type|null} [type] Emoticon type
                     * @property {Array.<AcFunDanmu.Im.Cloud.Message.IPicUrl>|null} [bigUrl] Emoticon bigUrl
                     * @property {number|null} [width] Emoticon width
                     * @property {number|null} [height] Emoticon height
                     * @property {Array.<AcFunDanmu.Im.Cloud.Message.Emoticon.ICode>|null} [emoticonCOde] Emoticon emoticonCOde
                     */

                    /**
                     * Constructs a new Emoticon.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents an Emoticon.
                     * @implements IEmoticon
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.IEmoticon=} [properties] Properties to set
                     */
                    function Emoticon(properties) {
                        this.bigUrl = [];
                        this.emoticonCOde = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Emoticon id.
                     * @member {string} id
                     * @memberof AcFunDanmu.Im.Cloud.Message.Emoticon
                     * @instance
                     */
                    Emoticon.prototype.id = "";

                    /**
                     * Emoticon packageId.
                     * @member {string} packageId
                     * @memberof AcFunDanmu.Im.Cloud.Message.Emoticon
                     * @instance
                     */
                    Emoticon.prototype.packageId = "";

                    /**
                     * Emoticon name.
                     * @member {string} name
                     * @memberof AcFunDanmu.Im.Cloud.Message.Emoticon
                     * @instance
                     */
                    Emoticon.prototype.name = "";

                    /**
                     * Emoticon type.
                     * @member {AcFunDanmu.Im.Cloud.Message.Emoticon.Type} type
                     * @memberof AcFunDanmu.Im.Cloud.Message.Emoticon
                     * @instance
                     */
                    Emoticon.prototype.type = 0;

                    /**
                     * Emoticon bigUrl.
                     * @member {Array.<AcFunDanmu.Im.Cloud.Message.IPicUrl>} bigUrl
                     * @memberof AcFunDanmu.Im.Cloud.Message.Emoticon
                     * @instance
                     */
                    Emoticon.prototype.bigUrl = $util.emptyArray;

                    /**
                     * Emoticon width.
                     * @member {number} width
                     * @memberof AcFunDanmu.Im.Cloud.Message.Emoticon
                     * @instance
                     */
                    Emoticon.prototype.width = 0;

                    /**
                     * Emoticon height.
                     * @member {number} height
                     * @memberof AcFunDanmu.Im.Cloud.Message.Emoticon
                     * @instance
                     */
                    Emoticon.prototype.height = 0;

                    /**
                     * Emoticon emoticonCOde.
                     * @member {Array.<AcFunDanmu.Im.Cloud.Message.Emoticon.ICode>} emoticonCOde
                     * @memberof AcFunDanmu.Im.Cloud.Message.Emoticon
                     * @instance
                     */
                    Emoticon.prototype.emoticonCOde = $util.emptyArray;

                    /**
                     * Creates a new Emoticon instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.Emoticon
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IEmoticon=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.Emoticon} Emoticon instance
                     */
                    Emoticon.create = function create(properties) {
                        return new Emoticon(properties);
                    };

                    /**
                     * Encodes the specified Emoticon message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.Emoticon.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.Emoticon
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IEmoticon} message Emoticon message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Emoticon.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                        if (message.packageId != null && Object.hasOwnProperty.call(message, "packageId"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.packageId);
                        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
                        if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.type);
                        if (message.bigUrl != null && message.bigUrl.length)
                            for (let i = 0; i < message.bigUrl.length; ++i)
                                $root.AcFunDanmu.Im.Cloud.Message.PicUrl.encode(message.bigUrl[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                        if (message.width != null && Object.hasOwnProperty.call(message, "width"))
                            writer.uint32(/* id 6, wireType 0 =*/48).int32(message.width);
                        if (message.height != null && Object.hasOwnProperty.call(message, "height"))
                            writer.uint32(/* id 7, wireType 0 =*/56).int32(message.height);
                        if (message.emoticonCOde != null && message.emoticonCOde.length)
                            for (let i = 0; i < message.emoticonCOde.length; ++i)
                                $root.AcFunDanmu.Im.Cloud.Message.Emoticon.Code.encode(message.emoticonCOde[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified Emoticon message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.Emoticon.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.Emoticon
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IEmoticon} message Emoticon message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Emoticon.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes an Emoticon message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.Emoticon
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.Emoticon} Emoticon
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Emoticon.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.Emoticon();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.id = reader.string();
                                break;
                            case 2:
                                message.packageId = reader.string();
                                break;
                            case 3:
                                message.name = reader.string();
                                break;
                            case 4:
                                message.type = reader.int32();
                                break;
                            case 5:
                                if (!(message.bigUrl && message.bigUrl.length))
                                    message.bigUrl = [];
                                message.bigUrl.push($root.AcFunDanmu.Im.Cloud.Message.PicUrl.decode(reader, reader.uint32()));
                                break;
                            case 6:
                                message.width = reader.int32();
                                break;
                            case 7:
                                message.height = reader.int32();
                                break;
                            case 8:
                                if (!(message.emoticonCOde && message.emoticonCOde.length))
                                    message.emoticonCOde = [];
                                message.emoticonCOde.push($root.AcFunDanmu.Im.Cloud.Message.Emoticon.Code.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes an Emoticon message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.Emoticon
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.Emoticon} Emoticon
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Emoticon.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies an Emoticon message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.Emoticon
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Emoticon.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.id != null && message.hasOwnProperty("id"))
                            if (!$util.isString(message.id))
                                return "id: string expected";
                        if (message.packageId != null && message.hasOwnProperty("packageId"))
                            if (!$util.isString(message.packageId))
                                return "packageId: string expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.type != null && message.hasOwnProperty("type"))
                            switch (message.type) {
                            default:
                                return "type: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                                break;
                            }
                        if (message.bigUrl != null && message.hasOwnProperty("bigUrl")) {
                            if (!Array.isArray(message.bigUrl))
                                return "bigUrl: array expected";
                            for (let i = 0; i < message.bigUrl.length; ++i) {
                                let error = $root.AcFunDanmu.Im.Cloud.Message.PicUrl.verify(message.bigUrl[i]);
                                if (error)
                                    return "bigUrl." + error;
                            }
                        }
                        if (message.width != null && message.hasOwnProperty("width"))
                            if (!$util.isInteger(message.width))
                                return "width: integer expected";
                        if (message.height != null && message.hasOwnProperty("height"))
                            if (!$util.isInteger(message.height))
                                return "height: integer expected";
                        if (message.emoticonCOde != null && message.hasOwnProperty("emoticonCOde")) {
                            if (!Array.isArray(message.emoticonCOde))
                                return "emoticonCOde: array expected";
                            for (let i = 0; i < message.emoticonCOde.length; ++i) {
                                let error = $root.AcFunDanmu.Im.Cloud.Message.Emoticon.Code.verify(message.emoticonCOde[i]);
                                if (error)
                                    return "emoticonCOde." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates an Emoticon message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.Emoticon
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.Emoticon} Emoticon
                     */
                    Emoticon.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.Emoticon)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Message.Emoticon();
                        if (object.id != null)
                            message.id = String(object.id);
                        if (object.packageId != null)
                            message.packageId = String(object.packageId);
                        if (object.name != null)
                            message.name = String(object.name);
                        switch (object.type) {
                        case "UNKNOWN":
                        case 0:
                            message.type = 0;
                            break;
                        case "BASIC":
                        case 1:
                            message.type = 1;
                            break;
                        case "IMAGE":
                        case 2:
                            message.type = 2;
                            break;
                        case "GIF":
                        case 3:
                            message.type = 3;
                            break;
                        case "SPECIAL_EFFECT":
                        case 4:
                            message.type = 4;
                            break;
                        case "SCRIPT":
                        case 5:
                            message.type = 5;
                            break;
                        }
                        if (object.bigUrl) {
                            if (!Array.isArray(object.bigUrl))
                                throw TypeError(".AcFunDanmu.Im.Cloud.Message.Emoticon.bigUrl: array expected");
                            message.bigUrl = [];
                            for (let i = 0; i < object.bigUrl.length; ++i) {
                                if (typeof object.bigUrl[i] !== "object")
                                    throw TypeError(".AcFunDanmu.Im.Cloud.Message.Emoticon.bigUrl: object expected");
                                message.bigUrl[i] = $root.AcFunDanmu.Im.Cloud.Message.PicUrl.fromObject(object.bigUrl[i]);
                            }
                        }
                        if (object.width != null)
                            message.width = object.width | 0;
                        if (object.height != null)
                            message.height = object.height | 0;
                        if (object.emoticonCOde) {
                            if (!Array.isArray(object.emoticonCOde))
                                throw TypeError(".AcFunDanmu.Im.Cloud.Message.Emoticon.emoticonCOde: array expected");
                            message.emoticonCOde = [];
                            for (let i = 0; i < object.emoticonCOde.length; ++i) {
                                if (typeof object.emoticonCOde[i] !== "object")
                                    throw TypeError(".AcFunDanmu.Im.Cloud.Message.Emoticon.emoticonCOde: object expected");
                                message.emoticonCOde[i] = $root.AcFunDanmu.Im.Cloud.Message.Emoticon.Code.fromObject(object.emoticonCOde[i]);
                            }
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from an Emoticon message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.Emoticon
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.Emoticon} message Emoticon
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Emoticon.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults) {
                            object.bigUrl = [];
                            object.emoticonCOde = [];
                        }
                        if (options.defaults) {
                            object.id = "";
                            object.packageId = "";
                            object.name = "";
                            object.type = options.enums === String ? "UNKNOWN" : 0;
                            object.width = 0;
                            object.height = 0;
                        }
                        if (message.id != null && message.hasOwnProperty("id"))
                            object.id = message.id;
                        if (message.packageId != null && message.hasOwnProperty("packageId"))
                            object.packageId = message.packageId;
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.type != null && message.hasOwnProperty("type"))
                            object.type = options.enums === String ? $root.AcFunDanmu.Im.Cloud.Message.Emoticon.Type[message.type] : message.type;
                        if (message.bigUrl && message.bigUrl.length) {
                            object.bigUrl = [];
                            for (let j = 0; j < message.bigUrl.length; ++j)
                                object.bigUrl[j] = $root.AcFunDanmu.Im.Cloud.Message.PicUrl.toObject(message.bigUrl[j], options);
                        }
                        if (message.width != null && message.hasOwnProperty("width"))
                            object.width = message.width;
                        if (message.height != null && message.hasOwnProperty("height"))
                            object.height = message.height;
                        if (message.emoticonCOde && message.emoticonCOde.length) {
                            object.emoticonCOde = [];
                            for (let j = 0; j < message.emoticonCOde.length; ++j)
                                object.emoticonCOde[j] = $root.AcFunDanmu.Im.Cloud.Message.Emoticon.Code.toObject(message.emoticonCOde[j], options);
                        }
                        return object;
                    };

                    /**
                     * Converts this Emoticon to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.Emoticon
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Emoticon.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Type enum.
                     * @name AcFunDanmu.Im.Cloud.Message.Emoticon.Type
                     * @enum {number}
                     * @property {number} UNKNOWN=0 UNKNOWN value
                     * @property {number} BASIC=1 BASIC value
                     * @property {number} IMAGE=2 IMAGE value
                     * @property {number} GIF=3 GIF value
                     * @property {number} SPECIAL_EFFECT=4 SPECIAL_EFFECT value
                     * @property {number} SCRIPT=5 SCRIPT value
                     */
                    Emoticon.Type = (function() {
                        const valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "UNKNOWN"] = 0;
                        values[valuesById[1] = "BASIC"] = 1;
                        values[valuesById[2] = "IMAGE"] = 2;
                        values[valuesById[3] = "GIF"] = 3;
                        values[valuesById[4] = "SPECIAL_EFFECT"] = 4;
                        values[valuesById[5] = "SCRIPT"] = 5;
                        return values;
                    })();

                    Emoticon.Code = (function() {

                        /**
                         * Properties of a Code.
                         * @memberof AcFunDanmu.Im.Cloud.Message.Emoticon
                         * @interface ICode
                         * @property {string|null} [language] Code language
                         * @property {Array.<string>|null} [code] Code code
                         */

                        /**
                         * Constructs a new Code.
                         * @memberof AcFunDanmu.Im.Cloud.Message.Emoticon
                         * @classdesc Represents a Code.
                         * @implements ICode
                         * @constructor
                         * @param {AcFunDanmu.Im.Cloud.Message.Emoticon.ICode=} [properties] Properties to set
                         */
                        function Code(properties) {
                            this.code = [];
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Code language.
                         * @member {string} language
                         * @memberof AcFunDanmu.Im.Cloud.Message.Emoticon.Code
                         * @instance
                         */
                        Code.prototype.language = "";

                        /**
                         * Code code.
                         * @member {Array.<string>} code
                         * @memberof AcFunDanmu.Im.Cloud.Message.Emoticon.Code
                         * @instance
                         */
                        Code.prototype.code = $util.emptyArray;

                        /**
                         * Creates a new Code instance using the specified properties.
                         * @function create
                         * @memberof AcFunDanmu.Im.Cloud.Message.Emoticon.Code
                         * @static
                         * @param {AcFunDanmu.Im.Cloud.Message.Emoticon.ICode=} [properties] Properties to set
                         * @returns {AcFunDanmu.Im.Cloud.Message.Emoticon.Code} Code instance
                         */
                        Code.create = function create(properties) {
                            return new Code(properties);
                        };

                        /**
                         * Encodes the specified Code message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.Emoticon.Code.verify|verify} messages.
                         * @function encode
                         * @memberof AcFunDanmu.Im.Cloud.Message.Emoticon.Code
                         * @static
                         * @param {AcFunDanmu.Im.Cloud.Message.Emoticon.ICode} message Code message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Code.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.language != null && Object.hasOwnProperty.call(message, "language"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.language);
                            if (message.code != null && message.code.length)
                                for (let i = 0; i < message.code.length; ++i)
                                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.code[i]);
                            return writer;
                        };

                        /**
                         * Encodes the specified Code message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.Emoticon.Code.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof AcFunDanmu.Im.Cloud.Message.Emoticon.Code
                         * @static
                         * @param {AcFunDanmu.Im.Cloud.Message.Emoticon.ICode} message Code message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Code.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a Code message from the specified reader or buffer.
                         * @function decode
                         * @memberof AcFunDanmu.Im.Cloud.Message.Emoticon.Code
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {AcFunDanmu.Im.Cloud.Message.Emoticon.Code} Code
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Code.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.Emoticon.Code();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.language = reader.string();
                                    break;
                                case 2:
                                    if (!(message.code && message.code.length))
                                        message.code = [];
                                    message.code.push(reader.string());
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a Code message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof AcFunDanmu.Im.Cloud.Message.Emoticon.Code
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {AcFunDanmu.Im.Cloud.Message.Emoticon.Code} Code
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Code.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a Code message.
                         * @function verify
                         * @memberof AcFunDanmu.Im.Cloud.Message.Emoticon.Code
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Code.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.language != null && message.hasOwnProperty("language"))
                                if (!$util.isString(message.language))
                                    return "language: string expected";
                            if (message.code != null && message.hasOwnProperty("code")) {
                                if (!Array.isArray(message.code))
                                    return "code: array expected";
                                for (let i = 0; i < message.code.length; ++i)
                                    if (!$util.isString(message.code[i]))
                                        return "code: string[] expected";
                            }
                            return null;
                        };

                        /**
                         * Creates a Code message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof AcFunDanmu.Im.Cloud.Message.Emoticon.Code
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {AcFunDanmu.Im.Cloud.Message.Emoticon.Code} Code
                         */
                        Code.fromObject = function fromObject(object) {
                            if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.Emoticon.Code)
                                return object;
                            let message = new $root.AcFunDanmu.Im.Cloud.Message.Emoticon.Code();
                            if (object.language != null)
                                message.language = String(object.language);
                            if (object.code) {
                                if (!Array.isArray(object.code))
                                    throw TypeError(".AcFunDanmu.Im.Cloud.Message.Emoticon.Code.code: array expected");
                                message.code = [];
                                for (let i = 0; i < object.code.length; ++i)
                                    message.code[i] = String(object.code[i]);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a Code message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof AcFunDanmu.Im.Cloud.Message.Emoticon.Code
                         * @static
                         * @param {AcFunDanmu.Im.Cloud.Message.Emoticon.Code} message Code
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Code.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.arrays || options.defaults)
                                object.code = [];
                            if (options.defaults)
                                object.language = "";
                            if (message.language != null && message.hasOwnProperty("language"))
                                object.language = message.language;
                            if (message.code && message.code.length) {
                                object.code = [];
                                for (let j = 0; j < message.code.length; ++j)
                                    object.code[j] = message.code[j];
                            }
                            return object;
                        };

                        /**
                         * Converts this Code to JSON.
                         * @function toJSON
                         * @memberof AcFunDanmu.Im.Cloud.Message.Emoticon.Code
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Code.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Code;
                    })();

                    return Emoticon;
                })();

                Message.File = (function() {

                    /**
                     * Properties of a File.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface IFile
                     * @property {string|null} [uri] File uri
                     * @property {string|null} [name] File name
                     * @property {string|null} [ext] File ext
                     * @property {string|null} [extra] File extra
                     */

                    /**
                     * Constructs a new File.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents a File.
                     * @implements IFile
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.IFile=} [properties] Properties to set
                     */
                    function File(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * File uri.
                     * @member {string} uri
                     * @memberof AcFunDanmu.Im.Cloud.Message.File
                     * @instance
                     */
                    File.prototype.uri = "";

                    /**
                     * File name.
                     * @member {string} name
                     * @memberof AcFunDanmu.Im.Cloud.Message.File
                     * @instance
                     */
                    File.prototype.name = "";

                    /**
                     * File ext.
                     * @member {string} ext
                     * @memberof AcFunDanmu.Im.Cloud.Message.File
                     * @instance
                     */
                    File.prototype.ext = "";

                    /**
                     * File extra.
                     * @member {string} extra
                     * @memberof AcFunDanmu.Im.Cloud.Message.File
                     * @instance
                     */
                    File.prototype.extra = "";

                    /**
                     * Creates a new File instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.File
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IFile=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.File} File instance
                     */
                    File.create = function create(properties) {
                        return new File(properties);
                    };

                    /**
                     * Encodes the specified File message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.File.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.File
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IFile} message File message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    File.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.uri != null && Object.hasOwnProperty.call(message, "uri"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.uri);
                        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                        if (message.ext != null && Object.hasOwnProperty.call(message, "ext"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.ext);
                        if (message.extra != null && Object.hasOwnProperty.call(message, "extra"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.extra);
                        return writer;
                    };

                    /**
                     * Encodes the specified File message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.File.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.File
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IFile} message File message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    File.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a File message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.File
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.File} File
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    File.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.File();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.uri = reader.string();
                                break;
                            case 2:
                                message.name = reader.string();
                                break;
                            case 3:
                                message.ext = reader.string();
                                break;
                            case 4:
                                message.extra = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a File message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.File
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.File} File
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    File.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a File message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.File
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    File.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.uri != null && message.hasOwnProperty("uri"))
                            if (!$util.isString(message.uri))
                                return "uri: string expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.ext != null && message.hasOwnProperty("ext"))
                            if (!$util.isString(message.ext))
                                return "ext: string expected";
                        if (message.extra != null && message.hasOwnProperty("extra"))
                            if (!$util.isString(message.extra))
                                return "extra: string expected";
                        return null;
                    };

                    /**
                     * Creates a File message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.File
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.File} File
                     */
                    File.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.File)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Message.File();
                        if (object.uri != null)
                            message.uri = String(object.uri);
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.ext != null)
                            message.ext = String(object.ext);
                        if (object.extra != null)
                            message.extra = String(object.extra);
                        return message;
                    };

                    /**
                     * Creates a plain object from a File message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.File
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.File} message File
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    File.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.uri = "";
                            object.name = "";
                            object.ext = "";
                            object.extra = "";
                        }
                        if (message.uri != null && message.hasOwnProperty("uri"))
                            object.uri = message.uri;
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.ext != null && message.hasOwnProperty("ext"))
                            object.ext = message.ext;
                        if (message.extra != null && message.hasOwnProperty("extra"))
                            object.extra = message.extra;
                        return object;
                    };

                    /**
                     * Converts this File to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.File
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    File.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return File;
                })();

                Message.Reference = (function() {

                    /**
                     * Properties of a Reference.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface IReference
                     * @property {AcFunDanmu.Im.Message.IMessage|null} [originMsg] Reference originMsg
                     * @property {AcFunDanmu.Im.Cloud.Message.Reference.IReferenceMessage|null} [referenceMsg] Reference referenceMsg
                     */

                    /**
                     * Constructs a new Reference.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents a Reference.
                     * @implements IReference
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.IReference=} [properties] Properties to set
                     */
                    function Reference(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Reference originMsg.
                     * @member {AcFunDanmu.Im.Message.IMessage|null|undefined} originMsg
                     * @memberof AcFunDanmu.Im.Cloud.Message.Reference
                     * @instance
                     */
                    Reference.prototype.originMsg = null;

                    /**
                     * Reference referenceMsg.
                     * @member {AcFunDanmu.Im.Cloud.Message.Reference.IReferenceMessage|null|undefined} referenceMsg
                     * @memberof AcFunDanmu.Im.Cloud.Message.Reference
                     * @instance
                     */
                    Reference.prototype.referenceMsg = null;

                    /**
                     * Creates a new Reference instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.Reference
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IReference=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.Reference} Reference instance
                     */
                    Reference.create = function create(properties) {
                        return new Reference(properties);
                    };

                    /**
                     * Encodes the specified Reference message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.Reference.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.Reference
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IReference} message Reference message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Reference.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.originMsg != null && Object.hasOwnProperty.call(message, "originMsg"))
                            $root.AcFunDanmu.Im.Message.Message.encode(message.originMsg, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.referenceMsg != null && Object.hasOwnProperty.call(message, "referenceMsg"))
                            $root.AcFunDanmu.Im.Cloud.Message.Reference.ReferenceMessage.encode(message.referenceMsg, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified Reference message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.Reference.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.Reference
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IReference} message Reference message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Reference.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Reference message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.Reference
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.Reference} Reference
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Reference.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.Reference();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.originMsg = $root.AcFunDanmu.Im.Message.Message.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.referenceMsg = $root.AcFunDanmu.Im.Cloud.Message.Reference.ReferenceMessage.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Reference message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.Reference
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.Reference} Reference
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Reference.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Reference message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.Reference
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Reference.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.originMsg != null && message.hasOwnProperty("originMsg")) {
                            let error = $root.AcFunDanmu.Im.Message.Message.verify(message.originMsg);
                            if (error)
                                return "originMsg." + error;
                        }
                        if (message.referenceMsg != null && message.hasOwnProperty("referenceMsg")) {
                            let error = $root.AcFunDanmu.Im.Cloud.Message.Reference.ReferenceMessage.verify(message.referenceMsg);
                            if (error)
                                return "referenceMsg." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a Reference message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.Reference
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.Reference} Reference
                     */
                    Reference.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.Reference)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Message.Reference();
                        if (object.originMsg != null) {
                            if (typeof object.originMsg !== "object")
                                throw TypeError(".AcFunDanmu.Im.Cloud.Message.Reference.originMsg: object expected");
                            message.originMsg = $root.AcFunDanmu.Im.Message.Message.fromObject(object.originMsg);
                        }
                        if (object.referenceMsg != null) {
                            if (typeof object.referenceMsg !== "object")
                                throw TypeError(".AcFunDanmu.Im.Cloud.Message.Reference.referenceMsg: object expected");
                            message.referenceMsg = $root.AcFunDanmu.Im.Cloud.Message.Reference.ReferenceMessage.fromObject(object.referenceMsg);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Reference message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.Reference
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.Reference} message Reference
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Reference.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.originMsg = null;
                            object.referenceMsg = null;
                        }
                        if (message.originMsg != null && message.hasOwnProperty("originMsg"))
                            object.originMsg = $root.AcFunDanmu.Im.Message.Message.toObject(message.originMsg, options);
                        if (message.referenceMsg != null && message.hasOwnProperty("referenceMsg"))
                            object.referenceMsg = $root.AcFunDanmu.Im.Cloud.Message.Reference.ReferenceMessage.toObject(message.referenceMsg, options);
                        return object;
                    };

                    /**
                     * Converts this Reference to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.Reference
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Reference.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    Reference.ReferenceMessage = (function() {

                        /**
                         * Properties of a ReferenceMessage.
                         * @memberof AcFunDanmu.Im.Cloud.Message.Reference
                         * @interface IReferenceMessage
                         * @property {number|null} [contentType] ReferenceMessage contentType
                         * @property {Uint8Array|null} [content] ReferenceMessage content
                         */

                        /**
                         * Constructs a new ReferenceMessage.
                         * @memberof AcFunDanmu.Im.Cloud.Message.Reference
                         * @classdesc Represents a ReferenceMessage.
                         * @implements IReferenceMessage
                         * @constructor
                         * @param {AcFunDanmu.Im.Cloud.Message.Reference.IReferenceMessage=} [properties] Properties to set
                         */
                        function ReferenceMessage(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * ReferenceMessage contentType.
                         * @member {number} contentType
                         * @memberof AcFunDanmu.Im.Cloud.Message.Reference.ReferenceMessage
                         * @instance
                         */
                        ReferenceMessage.prototype.contentType = 0;

                        /**
                         * ReferenceMessage content.
                         * @member {Uint8Array} content
                         * @memberof AcFunDanmu.Im.Cloud.Message.Reference.ReferenceMessage
                         * @instance
                         */
                        ReferenceMessage.prototype.content = $util.newBuffer([]);

                        /**
                         * Creates a new ReferenceMessage instance using the specified properties.
                         * @function create
                         * @memberof AcFunDanmu.Im.Cloud.Message.Reference.ReferenceMessage
                         * @static
                         * @param {AcFunDanmu.Im.Cloud.Message.Reference.IReferenceMessage=} [properties] Properties to set
                         * @returns {AcFunDanmu.Im.Cloud.Message.Reference.ReferenceMessage} ReferenceMessage instance
                         */
                        ReferenceMessage.create = function create(properties) {
                            return new ReferenceMessage(properties);
                        };

                        /**
                         * Encodes the specified ReferenceMessage message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.Reference.ReferenceMessage.verify|verify} messages.
                         * @function encode
                         * @memberof AcFunDanmu.Im.Cloud.Message.Reference.ReferenceMessage
                         * @static
                         * @param {AcFunDanmu.Im.Cloud.Message.Reference.IReferenceMessage} message ReferenceMessage message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        ReferenceMessage.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.contentType != null && Object.hasOwnProperty.call(message, "contentType"))
                                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.contentType);
                            if (message.content != null && Object.hasOwnProperty.call(message, "content"))
                                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.content);
                            return writer;
                        };

                        /**
                         * Encodes the specified ReferenceMessage message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.Reference.ReferenceMessage.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof AcFunDanmu.Im.Cloud.Message.Reference.ReferenceMessage
                         * @static
                         * @param {AcFunDanmu.Im.Cloud.Message.Reference.IReferenceMessage} message ReferenceMessage message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        ReferenceMessage.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a ReferenceMessage message from the specified reader or buffer.
                         * @function decode
                         * @memberof AcFunDanmu.Im.Cloud.Message.Reference.ReferenceMessage
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {AcFunDanmu.Im.Cloud.Message.Reference.ReferenceMessage} ReferenceMessage
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        ReferenceMessage.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.Reference.ReferenceMessage();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.contentType = reader.int32();
                                    break;
                                case 2:
                                    message.content = reader.bytes();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a ReferenceMessage message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof AcFunDanmu.Im.Cloud.Message.Reference.ReferenceMessage
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {AcFunDanmu.Im.Cloud.Message.Reference.ReferenceMessage} ReferenceMessage
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        ReferenceMessage.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a ReferenceMessage message.
                         * @function verify
                         * @memberof AcFunDanmu.Im.Cloud.Message.Reference.ReferenceMessage
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        ReferenceMessage.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.contentType != null && message.hasOwnProperty("contentType"))
                                if (!$util.isInteger(message.contentType))
                                    return "contentType: integer expected";
                            if (message.content != null && message.hasOwnProperty("content"))
                                if (!(message.content && typeof message.content.length === "number" || $util.isString(message.content)))
                                    return "content: buffer expected";
                            return null;
                        };

                        /**
                         * Creates a ReferenceMessage message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof AcFunDanmu.Im.Cloud.Message.Reference.ReferenceMessage
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {AcFunDanmu.Im.Cloud.Message.Reference.ReferenceMessage} ReferenceMessage
                         */
                        ReferenceMessage.fromObject = function fromObject(object) {
                            if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.Reference.ReferenceMessage)
                                return object;
                            let message = new $root.AcFunDanmu.Im.Cloud.Message.Reference.ReferenceMessage();
                            if (object.contentType != null)
                                message.contentType = object.contentType | 0;
                            if (object.content != null)
                                if (typeof object.content === "string")
                                    $util.base64.decode(object.content, message.content = $util.newBuffer($util.base64.length(object.content)), 0);
                                else if (object.content.length)
                                    message.content = object.content;
                            return message;
                        };

                        /**
                         * Creates a plain object from a ReferenceMessage message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof AcFunDanmu.Im.Cloud.Message.Reference.ReferenceMessage
                         * @static
                         * @param {AcFunDanmu.Im.Cloud.Message.Reference.ReferenceMessage} message ReferenceMessage
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        ReferenceMessage.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                object.contentType = 0;
                                if (options.bytes === String)
                                    object.content = "";
                                else {
                                    object.content = [];
                                    if (options.bytes !== Array)
                                        object.content = $util.newBuffer(object.content);
                                }
                            }
                            if (message.contentType != null && message.hasOwnProperty("contentType"))
                                object.contentType = message.contentType;
                            if (message.content != null && message.hasOwnProperty("content"))
                                object.content = options.bytes === String ? $util.base64.encode(message.content, 0, message.content.length) : options.bytes === Array ? Array.prototype.slice.call(message.content) : message.content;
                            return object;
                        };

                        /**
                         * Converts this ReferenceMessage to JSON.
                         * @function toJSON
                         * @memberof AcFunDanmu.Im.Cloud.Message.Reference.ReferenceMessage
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        ReferenceMessage.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return ReferenceMessage;
                    })();

                    return Reference;
                })();

                Message.ForwardMessageContent = (function() {

                    /**
                     * Properties of a ForwardMessageContent.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface IForwardMessageContent
                     * @property {Array.<AcFunDanmu.Im.Message.IMessage>|null} [message] ForwardMessageContent message
                     */

                    /**
                     * Constructs a new ForwardMessageContent.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents a ForwardMessageContent.
                     * @implements IForwardMessageContent
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.IForwardMessageContent=} [properties] Properties to set
                     */
                    function ForwardMessageContent(properties) {
                        this.message = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * ForwardMessageContent message.
                     * @member {Array.<AcFunDanmu.Im.Message.IMessage>} message
                     * @memberof AcFunDanmu.Im.Cloud.Message.ForwardMessageContent
                     * @instance
                     */
                    ForwardMessageContent.prototype.message = $util.emptyArray;

                    /**
                     * Creates a new ForwardMessageContent instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.ForwardMessageContent
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IForwardMessageContent=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.ForwardMessageContent} ForwardMessageContent instance
                     */
                    ForwardMessageContent.create = function create(properties) {
                        return new ForwardMessageContent(properties);
                    };

                    /**
                     * Encodes the specified ForwardMessageContent message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.ForwardMessageContent.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.ForwardMessageContent
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IForwardMessageContent} message ForwardMessageContent message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ForwardMessageContent.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.message != null && message.message.length)
                            for (let i = 0; i < message.message.length; ++i)
                                $root.AcFunDanmu.Im.Message.Message.encode(message.message[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified ForwardMessageContent message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.ForwardMessageContent.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.ForwardMessageContent
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IForwardMessageContent} message ForwardMessageContent message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ForwardMessageContent.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a ForwardMessageContent message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.ForwardMessageContent
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.ForwardMessageContent} ForwardMessageContent
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ForwardMessageContent.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.ForwardMessageContent();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.message && message.message.length))
                                    message.message = [];
                                message.message.push($root.AcFunDanmu.Im.Message.Message.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a ForwardMessageContent message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.ForwardMessageContent
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.ForwardMessageContent} ForwardMessageContent
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ForwardMessageContent.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a ForwardMessageContent message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.ForwardMessageContent
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ForwardMessageContent.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.message != null && message.hasOwnProperty("message")) {
                            if (!Array.isArray(message.message))
                                return "message: array expected";
                            for (let i = 0; i < message.message.length; ++i) {
                                let error = $root.AcFunDanmu.Im.Message.Message.verify(message.message[i]);
                                if (error)
                                    return "message." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a ForwardMessageContent message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.ForwardMessageContent
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.ForwardMessageContent} ForwardMessageContent
                     */
                    ForwardMessageContent.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.ForwardMessageContent)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Message.ForwardMessageContent();
                        if (object.message) {
                            if (!Array.isArray(object.message))
                                throw TypeError(".AcFunDanmu.Im.Cloud.Message.ForwardMessageContent.message: array expected");
                            message.message = [];
                            for (let i = 0; i < object.message.length; ++i) {
                                if (typeof object.message[i] !== "object")
                                    throw TypeError(".AcFunDanmu.Im.Cloud.Message.ForwardMessageContent.message: object expected");
                                message.message[i] = $root.AcFunDanmu.Im.Message.Message.fromObject(object.message[i]);
                            }
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a ForwardMessageContent message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.ForwardMessageContent
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.ForwardMessageContent} message ForwardMessageContent
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ForwardMessageContent.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.message = [];
                        if (message.message && message.message.length) {
                            object.message = [];
                            for (let j = 0; j < message.message.length; ++j)
                                object.message[j] = $root.AcFunDanmu.Im.Message.Message.toObject(message.message[j], options);
                        }
                        return object;
                    };

                    /**
                     * Converts this ForwardMessageContent to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.ForwardMessageContent
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ForwardMessageContent.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return ForwardMessageContent;
                })();

                Message.NoticePlaceholderMeta = (function() {

                    /**
                     * Properties of a NoticePlaceholderMeta.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface INoticePlaceholderMeta
                     * @property {string|null} [targetId] NoticePlaceholderMeta targetId
                     * @property {number|null} [startIndex] NoticePlaceholderMeta startIndex
                     * @property {number|null} [length] NoticePlaceholderMeta length
                     */

                    /**
                     * Constructs a new NoticePlaceholderMeta.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents a NoticePlaceholderMeta.
                     * @implements INoticePlaceholderMeta
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.INoticePlaceholderMeta=} [properties] Properties to set
                     */
                    function NoticePlaceholderMeta(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * NoticePlaceholderMeta targetId.
                     * @member {string} targetId
                     * @memberof AcFunDanmu.Im.Cloud.Message.NoticePlaceholderMeta
                     * @instance
                     */
                    NoticePlaceholderMeta.prototype.targetId = "";

                    /**
                     * NoticePlaceholderMeta startIndex.
                     * @member {number} startIndex
                     * @memberof AcFunDanmu.Im.Cloud.Message.NoticePlaceholderMeta
                     * @instance
                     */
                    NoticePlaceholderMeta.prototype.startIndex = 0;

                    /**
                     * NoticePlaceholderMeta length.
                     * @member {number} length
                     * @memberof AcFunDanmu.Im.Cloud.Message.NoticePlaceholderMeta
                     * @instance
                     */
                    NoticePlaceholderMeta.prototype.length = 0;

                    /**
                     * Creates a new NoticePlaceholderMeta instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.NoticePlaceholderMeta
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.INoticePlaceholderMeta=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.NoticePlaceholderMeta} NoticePlaceholderMeta instance
                     */
                    NoticePlaceholderMeta.create = function create(properties) {
                        return new NoticePlaceholderMeta(properties);
                    };

                    /**
                     * Encodes the specified NoticePlaceholderMeta message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.NoticePlaceholderMeta.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.NoticePlaceholderMeta
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.INoticePlaceholderMeta} message NoticePlaceholderMeta message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    NoticePlaceholderMeta.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.targetId != null && Object.hasOwnProperty.call(message, "targetId"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.targetId);
                        if (message.startIndex != null && Object.hasOwnProperty.call(message, "startIndex"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.startIndex);
                        if (message.length != null && Object.hasOwnProperty.call(message, "length"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.length);
                        return writer;
                    };

                    /**
                     * Encodes the specified NoticePlaceholderMeta message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.NoticePlaceholderMeta.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.NoticePlaceholderMeta
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.INoticePlaceholderMeta} message NoticePlaceholderMeta message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    NoticePlaceholderMeta.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a NoticePlaceholderMeta message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.NoticePlaceholderMeta
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.NoticePlaceholderMeta} NoticePlaceholderMeta
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    NoticePlaceholderMeta.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.NoticePlaceholderMeta();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.targetId = reader.string();
                                break;
                            case 2:
                                message.startIndex = reader.int32();
                                break;
                            case 3:
                                message.length = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a NoticePlaceholderMeta message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.NoticePlaceholderMeta
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.NoticePlaceholderMeta} NoticePlaceholderMeta
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    NoticePlaceholderMeta.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a NoticePlaceholderMeta message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.NoticePlaceholderMeta
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    NoticePlaceholderMeta.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.targetId != null && message.hasOwnProperty("targetId"))
                            if (!$util.isString(message.targetId))
                                return "targetId: string expected";
                        if (message.startIndex != null && message.hasOwnProperty("startIndex"))
                            if (!$util.isInteger(message.startIndex))
                                return "startIndex: integer expected";
                        if (message.length != null && message.hasOwnProperty("length"))
                            if (!$util.isInteger(message.length))
                                return "length: integer expected";
                        return null;
                    };

                    /**
                     * Creates a NoticePlaceholderMeta message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.NoticePlaceholderMeta
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.NoticePlaceholderMeta} NoticePlaceholderMeta
                     */
                    NoticePlaceholderMeta.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.NoticePlaceholderMeta)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Message.NoticePlaceholderMeta();
                        if (object.targetId != null)
                            message.targetId = String(object.targetId);
                        if (object.startIndex != null)
                            message.startIndex = object.startIndex | 0;
                        if (object.length != null)
                            message.length = object.length | 0;
                        return message;
                    };

                    /**
                     * Creates a plain object from a NoticePlaceholderMeta message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.NoticePlaceholderMeta
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.NoticePlaceholderMeta} message NoticePlaceholderMeta
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    NoticePlaceholderMeta.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.targetId = "";
                            object.startIndex = 0;
                            object.length = 0;
                        }
                        if (message.targetId != null && message.hasOwnProperty("targetId"))
                            object.targetId = message.targetId;
                        if (message.startIndex != null && message.hasOwnProperty("startIndex"))
                            object.startIndex = message.startIndex;
                        if (message.length != null && message.hasOwnProperty("length"))
                            object.length = message.length;
                        return object;
                    };

                    /**
                     * Converts this NoticePlaceholderMeta to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.NoticePlaceholderMeta
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    NoticePlaceholderMeta.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return NoticePlaceholderMeta;
                })();

                Message.ImcNoticeMessage = (function() {

                    /**
                     * Properties of an ImcNoticeMessage.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface IImcNoticeMessage
                     * @property {string|null} [text] ImcNoticeMessage text
                     * @property {Array.<AcFunDanmu.Im.Cloud.Message.INoticePlaceholderMeta>|null} [noticePlaceholderMeta] ImcNoticeMessage noticePlaceholderMeta
                     * @property {number|null} [noticeMetaType] ImcNoticeMessage noticeMetaType
                     * @property {Uint8Array|null} [noticeMetaInfo] ImcNoticeMessage noticeMetaInfo
                     */

                    /**
                     * Constructs a new ImcNoticeMessage.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents an ImcNoticeMessage.
                     * @implements IImcNoticeMessage
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.IImcNoticeMessage=} [properties] Properties to set
                     */
                    function ImcNoticeMessage(properties) {
                        this.noticePlaceholderMeta = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * ImcNoticeMessage text.
                     * @member {string} text
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcNoticeMessage
                     * @instance
                     */
                    ImcNoticeMessage.prototype.text = "";

                    /**
                     * ImcNoticeMessage noticePlaceholderMeta.
                     * @member {Array.<AcFunDanmu.Im.Cloud.Message.INoticePlaceholderMeta>} noticePlaceholderMeta
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcNoticeMessage
                     * @instance
                     */
                    ImcNoticeMessage.prototype.noticePlaceholderMeta = $util.emptyArray;

                    /**
                     * ImcNoticeMessage noticeMetaType.
                     * @member {number} noticeMetaType
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcNoticeMessage
                     * @instance
                     */
                    ImcNoticeMessage.prototype.noticeMetaType = 0;

                    /**
                     * ImcNoticeMessage noticeMetaInfo.
                     * @member {Uint8Array} noticeMetaInfo
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcNoticeMessage
                     * @instance
                     */
                    ImcNoticeMessage.prototype.noticeMetaInfo = $util.newBuffer([]);

                    /**
                     * Creates a new ImcNoticeMessage instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcNoticeMessage
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IImcNoticeMessage=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.ImcNoticeMessage} ImcNoticeMessage instance
                     */
                    ImcNoticeMessage.create = function create(properties) {
                        return new ImcNoticeMessage(properties);
                    };

                    /**
                     * Encodes the specified ImcNoticeMessage message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.ImcNoticeMessage.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcNoticeMessage
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IImcNoticeMessage} message ImcNoticeMessage message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ImcNoticeMessage.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.text);
                        if (message.noticePlaceholderMeta != null && message.noticePlaceholderMeta.length)
                            for (let i = 0; i < message.noticePlaceholderMeta.length; ++i)
                                $root.AcFunDanmu.Im.Cloud.Message.NoticePlaceholderMeta.encode(message.noticePlaceholderMeta[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.noticeMetaType != null && Object.hasOwnProperty.call(message, "noticeMetaType"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.noticeMetaType);
                        if (message.noticeMetaInfo != null && Object.hasOwnProperty.call(message, "noticeMetaInfo"))
                            writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.noticeMetaInfo);
                        return writer;
                    };

                    /**
                     * Encodes the specified ImcNoticeMessage message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.ImcNoticeMessage.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcNoticeMessage
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IImcNoticeMessage} message ImcNoticeMessage message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ImcNoticeMessage.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes an ImcNoticeMessage message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcNoticeMessage
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.ImcNoticeMessage} ImcNoticeMessage
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ImcNoticeMessage.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.ImcNoticeMessage();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.text = reader.string();
                                break;
                            case 2:
                                if (!(message.noticePlaceholderMeta && message.noticePlaceholderMeta.length))
                                    message.noticePlaceholderMeta = [];
                                message.noticePlaceholderMeta.push($root.AcFunDanmu.Im.Cloud.Message.NoticePlaceholderMeta.decode(reader, reader.uint32()));
                                break;
                            case 3:
                                message.noticeMetaType = reader.int32();
                                break;
                            case 4:
                                message.noticeMetaInfo = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes an ImcNoticeMessage message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcNoticeMessage
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.ImcNoticeMessage} ImcNoticeMessage
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ImcNoticeMessage.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies an ImcNoticeMessage message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcNoticeMessage
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ImcNoticeMessage.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.text != null && message.hasOwnProperty("text"))
                            if (!$util.isString(message.text))
                                return "text: string expected";
                        if (message.noticePlaceholderMeta != null && message.hasOwnProperty("noticePlaceholderMeta")) {
                            if (!Array.isArray(message.noticePlaceholderMeta))
                                return "noticePlaceholderMeta: array expected";
                            for (let i = 0; i < message.noticePlaceholderMeta.length; ++i) {
                                let error = $root.AcFunDanmu.Im.Cloud.Message.NoticePlaceholderMeta.verify(message.noticePlaceholderMeta[i]);
                                if (error)
                                    return "noticePlaceholderMeta." + error;
                            }
                        }
                        if (message.noticeMetaType != null && message.hasOwnProperty("noticeMetaType"))
                            if (!$util.isInteger(message.noticeMetaType))
                                return "noticeMetaType: integer expected";
                        if (message.noticeMetaInfo != null && message.hasOwnProperty("noticeMetaInfo"))
                            if (!(message.noticeMetaInfo && typeof message.noticeMetaInfo.length === "number" || $util.isString(message.noticeMetaInfo)))
                                return "noticeMetaInfo: buffer expected";
                        return null;
                    };

                    /**
                     * Creates an ImcNoticeMessage message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcNoticeMessage
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.ImcNoticeMessage} ImcNoticeMessage
                     */
                    ImcNoticeMessage.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.ImcNoticeMessage)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Message.ImcNoticeMessage();
                        if (object.text != null)
                            message.text = String(object.text);
                        if (object.noticePlaceholderMeta) {
                            if (!Array.isArray(object.noticePlaceholderMeta))
                                throw TypeError(".AcFunDanmu.Im.Cloud.Message.ImcNoticeMessage.noticePlaceholderMeta: array expected");
                            message.noticePlaceholderMeta = [];
                            for (let i = 0; i < object.noticePlaceholderMeta.length; ++i) {
                                if (typeof object.noticePlaceholderMeta[i] !== "object")
                                    throw TypeError(".AcFunDanmu.Im.Cloud.Message.ImcNoticeMessage.noticePlaceholderMeta: object expected");
                                message.noticePlaceholderMeta[i] = $root.AcFunDanmu.Im.Cloud.Message.NoticePlaceholderMeta.fromObject(object.noticePlaceholderMeta[i]);
                            }
                        }
                        if (object.noticeMetaType != null)
                            message.noticeMetaType = object.noticeMetaType | 0;
                        if (object.noticeMetaInfo != null)
                            if (typeof object.noticeMetaInfo === "string")
                                $util.base64.decode(object.noticeMetaInfo, message.noticeMetaInfo = $util.newBuffer($util.base64.length(object.noticeMetaInfo)), 0);
                            else if (object.noticeMetaInfo.length)
                                message.noticeMetaInfo = object.noticeMetaInfo;
                        return message;
                    };

                    /**
                     * Creates a plain object from an ImcNoticeMessage message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcNoticeMessage
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.ImcNoticeMessage} message ImcNoticeMessage
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ImcNoticeMessage.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.noticePlaceholderMeta = [];
                        if (options.defaults) {
                            object.text = "";
                            object.noticeMetaType = 0;
                            if (options.bytes === String)
                                object.noticeMetaInfo = "";
                            else {
                                object.noticeMetaInfo = [];
                                if (options.bytes !== Array)
                                    object.noticeMetaInfo = $util.newBuffer(object.noticeMetaInfo);
                            }
                        }
                        if (message.text != null && message.hasOwnProperty("text"))
                            object.text = message.text;
                        if (message.noticePlaceholderMeta && message.noticePlaceholderMeta.length) {
                            object.noticePlaceholderMeta = [];
                            for (let j = 0; j < message.noticePlaceholderMeta.length; ++j)
                                object.noticePlaceholderMeta[j] = $root.AcFunDanmu.Im.Cloud.Message.NoticePlaceholderMeta.toObject(message.noticePlaceholderMeta[j], options);
                        }
                        if (message.noticeMetaType != null && message.hasOwnProperty("noticeMetaType"))
                            object.noticeMetaType = message.noticeMetaType;
                        if (message.noticeMetaInfo != null && message.hasOwnProperty("noticeMetaInfo"))
                            object.noticeMetaInfo = options.bytes === String ? $util.base64.encode(message.noticeMetaInfo, 0, message.noticeMetaInfo.length) : options.bytes === Array ? Array.prototype.slice.call(message.noticeMetaInfo) : message.noticeMetaInfo;
                        return object;
                    };

                    /**
                     * Converts this ImcNoticeMessage to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcNoticeMessage
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ImcNoticeMessage.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return ImcNoticeMessage;
                })();

                /**
                 * NoticeMetaType enum.
                 * @name AcFunDanmu.Im.Cloud.Message.NoticeMetaType
                 * @enum {number}
                 * @property {number} UNKNOWN_NOTICE_META_TYPE=0 UNKNOWN_NOTICE_META_TYPE value
                 * @property {number} COMMON_NOTICE_META_TYPE=1 COMMON_NOTICE_META_TYPE value
                 * @property {number} CONFIRM_INVITE_INTO_GROUP_META=2 CONFIRM_INVITE_INTO_GROUP_META value
                 * @property {number} CONFIRM_JOIN_INTO_GROUP_META=3 CONFIRM_JOIN_INTO_GROUP_META value
                 * @property {number} LINKED_PROFILE_META_TYPE=4 LINKED_PROFILE_META_TYPE value
                 */
                Message.NoticeMetaType = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "UNKNOWN_NOTICE_META_TYPE"] = 0;
                    values[valuesById[1] = "COMMON_NOTICE_META_TYPE"] = 1;
                    values[valuesById[2] = "CONFIRM_INVITE_INTO_GROUP_META"] = 2;
                    values[valuesById[3] = "CONFIRM_JOIN_INTO_GROUP_META"] = 3;
                    values[valuesById[4] = "LINKED_PROFILE_META_TYPE"] = 4;
                    return values;
                })();

                Message.LinkedProfileMetaInfo = (function() {

                    /**
                     * Properties of a LinkedProfileMetaInfo.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface ILinkedProfileMetaInfo
                     * @property {Array.<number|Long>|null} [userId] LinkedProfileMetaInfo userId
                     */

                    /**
                     * Constructs a new LinkedProfileMetaInfo.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents a LinkedProfileMetaInfo.
                     * @implements ILinkedProfileMetaInfo
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.ILinkedProfileMetaInfo=} [properties] Properties to set
                     */
                    function LinkedProfileMetaInfo(properties) {
                        this.userId = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * LinkedProfileMetaInfo userId.
                     * @member {Array.<number|Long>} userId
                     * @memberof AcFunDanmu.Im.Cloud.Message.LinkedProfileMetaInfo
                     * @instance
                     */
                    LinkedProfileMetaInfo.prototype.userId = $util.emptyArray;

                    /**
                     * Creates a new LinkedProfileMetaInfo instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.LinkedProfileMetaInfo
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.ILinkedProfileMetaInfo=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.LinkedProfileMetaInfo} LinkedProfileMetaInfo instance
                     */
                    LinkedProfileMetaInfo.create = function create(properties) {
                        return new LinkedProfileMetaInfo(properties);
                    };

                    /**
                     * Encodes the specified LinkedProfileMetaInfo message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.LinkedProfileMetaInfo.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.LinkedProfileMetaInfo
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.ILinkedProfileMetaInfo} message LinkedProfileMetaInfo message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    LinkedProfileMetaInfo.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.userId != null && message.userId.length) {
                            writer.uint32(/* id 1, wireType 2 =*/10).fork();
                            for (let i = 0; i < message.userId.length; ++i)
                                writer.int64(message.userId[i]);
                            writer.ldelim();
                        }
                        return writer;
                    };

                    /**
                     * Encodes the specified LinkedProfileMetaInfo message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.LinkedProfileMetaInfo.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.LinkedProfileMetaInfo
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.ILinkedProfileMetaInfo} message LinkedProfileMetaInfo message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    LinkedProfileMetaInfo.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a LinkedProfileMetaInfo message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.LinkedProfileMetaInfo
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.LinkedProfileMetaInfo} LinkedProfileMetaInfo
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    LinkedProfileMetaInfo.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.LinkedProfileMetaInfo();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.userId && message.userId.length))
                                    message.userId = [];
                                if ((tag & 7) === 2) {
                                    let end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.userId.push(reader.int64());
                                } else
                                    message.userId.push(reader.int64());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a LinkedProfileMetaInfo message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.LinkedProfileMetaInfo
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.LinkedProfileMetaInfo} LinkedProfileMetaInfo
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    LinkedProfileMetaInfo.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a LinkedProfileMetaInfo message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.LinkedProfileMetaInfo
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    LinkedProfileMetaInfo.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.userId != null && message.hasOwnProperty("userId")) {
                            if (!Array.isArray(message.userId))
                                return "userId: array expected";
                            for (let i = 0; i < message.userId.length; ++i)
                                if (!$util.isInteger(message.userId[i]) && !(message.userId[i] && $util.isInteger(message.userId[i].low) && $util.isInteger(message.userId[i].high)))
                                    return "userId: integer|Long[] expected";
                        }
                        return null;
                    };

                    /**
                     * Creates a LinkedProfileMetaInfo message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.LinkedProfileMetaInfo
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.LinkedProfileMetaInfo} LinkedProfileMetaInfo
                     */
                    LinkedProfileMetaInfo.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.LinkedProfileMetaInfo)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Message.LinkedProfileMetaInfo();
                        if (object.userId) {
                            if (!Array.isArray(object.userId))
                                throw TypeError(".AcFunDanmu.Im.Cloud.Message.LinkedProfileMetaInfo.userId: array expected");
                            message.userId = [];
                            for (let i = 0; i < object.userId.length; ++i)
                                if ($util.Long)
                                    (message.userId[i] = $util.Long.fromValue(object.userId[i])).unsigned = false;
                                else if (typeof object.userId[i] === "string")
                                    message.userId[i] = parseInt(object.userId[i], 10);
                                else if (typeof object.userId[i] === "number")
                                    message.userId[i] = object.userId[i];
                                else if (typeof object.userId[i] === "object")
                                    message.userId[i] = new $util.LongBits(object.userId[i].low >>> 0, object.userId[i].high >>> 0).toNumber();
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a LinkedProfileMetaInfo message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.LinkedProfileMetaInfo
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.LinkedProfileMetaInfo} message LinkedProfileMetaInfo
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    LinkedProfileMetaInfo.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.userId = [];
                        if (message.userId && message.userId.length) {
                            object.userId = [];
                            for (let j = 0; j < message.userId.length; ++j)
                                if (typeof message.userId[j] === "number")
                                    object.userId[j] = options.longs === String ? String(message.userId[j]) : message.userId[j];
                                else
                                    object.userId[j] = options.longs === String ? $util.Long.prototype.toString.call(message.userId[j]) : options.longs === Number ? new $util.LongBits(message.userId[j].low >>> 0, message.userId[j].high >>> 0).toNumber() : message.userId[j];
                        }
                        return object;
                    };

                    /**
                     * Converts this LinkedProfileMetaInfo to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.LinkedProfileMetaInfo
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    LinkedProfileMetaInfo.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return LinkedProfileMetaInfo;
                })();

                Message.ConfirmInviteIntoGroupNoticeMetaInfo = (function() {

                    /**
                     * Properties of a ConfirmInviteIntoGroupNoticeMetaInfo.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface IConfirmInviteIntoGroupNoticeMetaInfo
                     * @property {number|Long|null} [requestId] ConfirmInviteIntoGroupNoticeMetaInfo requestId
                     * @property {string|null} [groupId] ConfirmInviteIntoGroupNoticeMetaInfo groupId
                     * @property {AcFunDanmu.Im.Cloud.Message.JoinRequestStatus|null} [status] ConfirmInviteIntoGroupNoticeMetaInfo status
                     */

                    /**
                     * Constructs a new ConfirmInviteIntoGroupNoticeMetaInfo.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents a ConfirmInviteIntoGroupNoticeMetaInfo.
                     * @implements IConfirmInviteIntoGroupNoticeMetaInfo
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.IConfirmInviteIntoGroupNoticeMetaInfo=} [properties] Properties to set
                     */
                    function ConfirmInviteIntoGroupNoticeMetaInfo(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * ConfirmInviteIntoGroupNoticeMetaInfo requestId.
                     * @member {number|Long} requestId
                     * @memberof AcFunDanmu.Im.Cloud.Message.ConfirmInviteIntoGroupNoticeMetaInfo
                     * @instance
                     */
                    ConfirmInviteIntoGroupNoticeMetaInfo.prototype.requestId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * ConfirmInviteIntoGroupNoticeMetaInfo groupId.
                     * @member {string} groupId
                     * @memberof AcFunDanmu.Im.Cloud.Message.ConfirmInviteIntoGroupNoticeMetaInfo
                     * @instance
                     */
                    ConfirmInviteIntoGroupNoticeMetaInfo.prototype.groupId = "";

                    /**
                     * ConfirmInviteIntoGroupNoticeMetaInfo status.
                     * @member {AcFunDanmu.Im.Cloud.Message.JoinRequestStatus} status
                     * @memberof AcFunDanmu.Im.Cloud.Message.ConfirmInviteIntoGroupNoticeMetaInfo
                     * @instance
                     */
                    ConfirmInviteIntoGroupNoticeMetaInfo.prototype.status = 0;

                    /**
                     * Creates a new ConfirmInviteIntoGroupNoticeMetaInfo instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.ConfirmInviteIntoGroupNoticeMetaInfo
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IConfirmInviteIntoGroupNoticeMetaInfo=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.ConfirmInviteIntoGroupNoticeMetaInfo} ConfirmInviteIntoGroupNoticeMetaInfo instance
                     */
                    ConfirmInviteIntoGroupNoticeMetaInfo.create = function create(properties) {
                        return new ConfirmInviteIntoGroupNoticeMetaInfo(properties);
                    };

                    /**
                     * Encodes the specified ConfirmInviteIntoGroupNoticeMetaInfo message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.ConfirmInviteIntoGroupNoticeMetaInfo.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.ConfirmInviteIntoGroupNoticeMetaInfo
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IConfirmInviteIntoGroupNoticeMetaInfo} message ConfirmInviteIntoGroupNoticeMetaInfo message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ConfirmInviteIntoGroupNoticeMetaInfo.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.requestId != null && Object.hasOwnProperty.call(message, "requestId"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.requestId);
                        if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.groupId);
                        if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.status);
                        return writer;
                    };

                    /**
                     * Encodes the specified ConfirmInviteIntoGroupNoticeMetaInfo message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.ConfirmInviteIntoGroupNoticeMetaInfo.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.ConfirmInviteIntoGroupNoticeMetaInfo
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IConfirmInviteIntoGroupNoticeMetaInfo} message ConfirmInviteIntoGroupNoticeMetaInfo message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ConfirmInviteIntoGroupNoticeMetaInfo.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a ConfirmInviteIntoGroupNoticeMetaInfo message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.ConfirmInviteIntoGroupNoticeMetaInfo
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.ConfirmInviteIntoGroupNoticeMetaInfo} ConfirmInviteIntoGroupNoticeMetaInfo
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ConfirmInviteIntoGroupNoticeMetaInfo.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.ConfirmInviteIntoGroupNoticeMetaInfo();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.requestId = reader.int64();
                                break;
                            case 2:
                                message.groupId = reader.string();
                                break;
                            case 3:
                                message.status = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a ConfirmInviteIntoGroupNoticeMetaInfo message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.ConfirmInviteIntoGroupNoticeMetaInfo
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.ConfirmInviteIntoGroupNoticeMetaInfo} ConfirmInviteIntoGroupNoticeMetaInfo
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ConfirmInviteIntoGroupNoticeMetaInfo.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a ConfirmInviteIntoGroupNoticeMetaInfo message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.ConfirmInviteIntoGroupNoticeMetaInfo
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ConfirmInviteIntoGroupNoticeMetaInfo.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.requestId != null && message.hasOwnProperty("requestId"))
                            if (!$util.isInteger(message.requestId) && !(message.requestId && $util.isInteger(message.requestId.low) && $util.isInteger(message.requestId.high)))
                                return "requestId: integer|Long expected";
                        if (message.groupId != null && message.hasOwnProperty("groupId"))
                            if (!$util.isString(message.groupId))
                                return "groupId: string expected";
                        if (message.status != null && message.hasOwnProperty("status"))
                            switch (message.status) {
                            default:
                                return "status: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                                break;
                            }
                        return null;
                    };

                    /**
                     * Creates a ConfirmInviteIntoGroupNoticeMetaInfo message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.ConfirmInviteIntoGroupNoticeMetaInfo
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.ConfirmInviteIntoGroupNoticeMetaInfo} ConfirmInviteIntoGroupNoticeMetaInfo
                     */
                    ConfirmInviteIntoGroupNoticeMetaInfo.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.ConfirmInviteIntoGroupNoticeMetaInfo)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Message.ConfirmInviteIntoGroupNoticeMetaInfo();
                        if (object.requestId != null)
                            if ($util.Long)
                                (message.requestId = $util.Long.fromValue(object.requestId)).unsigned = false;
                            else if (typeof object.requestId === "string")
                                message.requestId = parseInt(object.requestId, 10);
                            else if (typeof object.requestId === "number")
                                message.requestId = object.requestId;
                            else if (typeof object.requestId === "object")
                                message.requestId = new $util.LongBits(object.requestId.low >>> 0, object.requestId.high >>> 0).toNumber();
                        if (object.groupId != null)
                            message.groupId = String(object.groupId);
                        switch (object.status) {
                        case "UNKNOWN_STATUS":
                        case 0:
                            message.status = 0;
                            break;
                        case "REQUESTED":
                        case 1:
                            message.status = 1;
                            break;
                        case "APPROVED":
                        case 2:
                            message.status = 2;
                            break;
                        case "REFUSED":
                        case 3:
                            message.status = 3;
                            break;
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a ConfirmInviteIntoGroupNoticeMetaInfo message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.ConfirmInviteIntoGroupNoticeMetaInfo
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.ConfirmInviteIntoGroupNoticeMetaInfo} message ConfirmInviteIntoGroupNoticeMetaInfo
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ConfirmInviteIntoGroupNoticeMetaInfo.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, false);
                                object.requestId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.requestId = options.longs === String ? "0" : 0;
                            object.groupId = "";
                            object.status = options.enums === String ? "UNKNOWN_STATUS" : 0;
                        }
                        if (message.requestId != null && message.hasOwnProperty("requestId"))
                            if (typeof message.requestId === "number")
                                object.requestId = options.longs === String ? String(message.requestId) : message.requestId;
                            else
                                object.requestId = options.longs === String ? $util.Long.prototype.toString.call(message.requestId) : options.longs === Number ? new $util.LongBits(message.requestId.low >>> 0, message.requestId.high >>> 0).toNumber() : message.requestId;
                        if (message.groupId != null && message.hasOwnProperty("groupId"))
                            object.groupId = message.groupId;
                        if (message.status != null && message.hasOwnProperty("status"))
                            object.status = options.enums === String ? $root.AcFunDanmu.Im.Cloud.Message.JoinRequestStatus[message.status] : message.status;
                        return object;
                    };

                    /**
                     * Converts this ConfirmInviteIntoGroupNoticeMetaInfo to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.ConfirmInviteIntoGroupNoticeMetaInfo
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ConfirmInviteIntoGroupNoticeMetaInfo.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return ConfirmInviteIntoGroupNoticeMetaInfo;
                })();

                Message.ConfirmJoinIntoGroupNoticeMetaInfo = (function() {

                    /**
                     * Properties of a ConfirmJoinIntoGroupNoticeMetaInfo.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface IConfirmJoinIntoGroupNoticeMetaInfo
                     * @property {number|Long|null} [requestId] ConfirmJoinIntoGroupNoticeMetaInfo requestId
                     * @property {string|null} [groupId] ConfirmJoinIntoGroupNoticeMetaInfo groupId
                     * @property {AcFunDanmu.Im.Cloud.Message.JoinRequestStatus|null} [status] ConfirmJoinIntoGroupNoticeMetaInfo status
                     */

                    /**
                     * Constructs a new ConfirmJoinIntoGroupNoticeMetaInfo.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents a ConfirmJoinIntoGroupNoticeMetaInfo.
                     * @implements IConfirmJoinIntoGroupNoticeMetaInfo
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.IConfirmJoinIntoGroupNoticeMetaInfo=} [properties] Properties to set
                     */
                    function ConfirmJoinIntoGroupNoticeMetaInfo(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * ConfirmJoinIntoGroupNoticeMetaInfo requestId.
                     * @member {number|Long} requestId
                     * @memberof AcFunDanmu.Im.Cloud.Message.ConfirmJoinIntoGroupNoticeMetaInfo
                     * @instance
                     */
                    ConfirmJoinIntoGroupNoticeMetaInfo.prototype.requestId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * ConfirmJoinIntoGroupNoticeMetaInfo groupId.
                     * @member {string} groupId
                     * @memberof AcFunDanmu.Im.Cloud.Message.ConfirmJoinIntoGroupNoticeMetaInfo
                     * @instance
                     */
                    ConfirmJoinIntoGroupNoticeMetaInfo.prototype.groupId = "";

                    /**
                     * ConfirmJoinIntoGroupNoticeMetaInfo status.
                     * @member {AcFunDanmu.Im.Cloud.Message.JoinRequestStatus} status
                     * @memberof AcFunDanmu.Im.Cloud.Message.ConfirmJoinIntoGroupNoticeMetaInfo
                     * @instance
                     */
                    ConfirmJoinIntoGroupNoticeMetaInfo.prototype.status = 0;

                    /**
                     * Creates a new ConfirmJoinIntoGroupNoticeMetaInfo instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.ConfirmJoinIntoGroupNoticeMetaInfo
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IConfirmJoinIntoGroupNoticeMetaInfo=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.ConfirmJoinIntoGroupNoticeMetaInfo} ConfirmJoinIntoGroupNoticeMetaInfo instance
                     */
                    ConfirmJoinIntoGroupNoticeMetaInfo.create = function create(properties) {
                        return new ConfirmJoinIntoGroupNoticeMetaInfo(properties);
                    };

                    /**
                     * Encodes the specified ConfirmJoinIntoGroupNoticeMetaInfo message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.ConfirmJoinIntoGroupNoticeMetaInfo.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.ConfirmJoinIntoGroupNoticeMetaInfo
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IConfirmJoinIntoGroupNoticeMetaInfo} message ConfirmJoinIntoGroupNoticeMetaInfo message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ConfirmJoinIntoGroupNoticeMetaInfo.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.requestId != null && Object.hasOwnProperty.call(message, "requestId"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.requestId);
                        if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.groupId);
                        if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.status);
                        return writer;
                    };

                    /**
                     * Encodes the specified ConfirmJoinIntoGroupNoticeMetaInfo message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.ConfirmJoinIntoGroupNoticeMetaInfo.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.ConfirmJoinIntoGroupNoticeMetaInfo
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IConfirmJoinIntoGroupNoticeMetaInfo} message ConfirmJoinIntoGroupNoticeMetaInfo message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ConfirmJoinIntoGroupNoticeMetaInfo.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a ConfirmJoinIntoGroupNoticeMetaInfo message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.ConfirmJoinIntoGroupNoticeMetaInfo
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.ConfirmJoinIntoGroupNoticeMetaInfo} ConfirmJoinIntoGroupNoticeMetaInfo
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ConfirmJoinIntoGroupNoticeMetaInfo.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.ConfirmJoinIntoGroupNoticeMetaInfo();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.requestId = reader.int64();
                                break;
                            case 2:
                                message.groupId = reader.string();
                                break;
                            case 3:
                                message.status = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a ConfirmJoinIntoGroupNoticeMetaInfo message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.ConfirmJoinIntoGroupNoticeMetaInfo
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.ConfirmJoinIntoGroupNoticeMetaInfo} ConfirmJoinIntoGroupNoticeMetaInfo
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ConfirmJoinIntoGroupNoticeMetaInfo.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a ConfirmJoinIntoGroupNoticeMetaInfo message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.ConfirmJoinIntoGroupNoticeMetaInfo
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ConfirmJoinIntoGroupNoticeMetaInfo.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.requestId != null && message.hasOwnProperty("requestId"))
                            if (!$util.isInteger(message.requestId) && !(message.requestId && $util.isInteger(message.requestId.low) && $util.isInteger(message.requestId.high)))
                                return "requestId: integer|Long expected";
                        if (message.groupId != null && message.hasOwnProperty("groupId"))
                            if (!$util.isString(message.groupId))
                                return "groupId: string expected";
                        if (message.status != null && message.hasOwnProperty("status"))
                            switch (message.status) {
                            default:
                                return "status: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                                break;
                            }
                        return null;
                    };

                    /**
                     * Creates a ConfirmJoinIntoGroupNoticeMetaInfo message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.ConfirmJoinIntoGroupNoticeMetaInfo
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.ConfirmJoinIntoGroupNoticeMetaInfo} ConfirmJoinIntoGroupNoticeMetaInfo
                     */
                    ConfirmJoinIntoGroupNoticeMetaInfo.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.ConfirmJoinIntoGroupNoticeMetaInfo)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Message.ConfirmJoinIntoGroupNoticeMetaInfo();
                        if (object.requestId != null)
                            if ($util.Long)
                                (message.requestId = $util.Long.fromValue(object.requestId)).unsigned = false;
                            else if (typeof object.requestId === "string")
                                message.requestId = parseInt(object.requestId, 10);
                            else if (typeof object.requestId === "number")
                                message.requestId = object.requestId;
                            else if (typeof object.requestId === "object")
                                message.requestId = new $util.LongBits(object.requestId.low >>> 0, object.requestId.high >>> 0).toNumber();
                        if (object.groupId != null)
                            message.groupId = String(object.groupId);
                        switch (object.status) {
                        case "UNKNOWN_STATUS":
                        case 0:
                            message.status = 0;
                            break;
                        case "REQUESTED":
                        case 1:
                            message.status = 1;
                            break;
                        case "APPROVED":
                        case 2:
                            message.status = 2;
                            break;
                        case "REFUSED":
                        case 3:
                            message.status = 3;
                            break;
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a ConfirmJoinIntoGroupNoticeMetaInfo message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.ConfirmJoinIntoGroupNoticeMetaInfo
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.ConfirmJoinIntoGroupNoticeMetaInfo} message ConfirmJoinIntoGroupNoticeMetaInfo
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ConfirmJoinIntoGroupNoticeMetaInfo.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, false);
                                object.requestId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.requestId = options.longs === String ? "0" : 0;
                            object.groupId = "";
                            object.status = options.enums === String ? "UNKNOWN_STATUS" : 0;
                        }
                        if (message.requestId != null && message.hasOwnProperty("requestId"))
                            if (typeof message.requestId === "number")
                                object.requestId = options.longs === String ? String(message.requestId) : message.requestId;
                            else
                                object.requestId = options.longs === String ? $util.Long.prototype.toString.call(message.requestId) : options.longs === Number ? new $util.LongBits(message.requestId.low >>> 0, message.requestId.high >>> 0).toNumber() : message.requestId;
                        if (message.groupId != null && message.hasOwnProperty("groupId"))
                            object.groupId = message.groupId;
                        if (message.status != null && message.hasOwnProperty("status"))
                            object.status = options.enums === String ? $root.AcFunDanmu.Im.Cloud.Message.JoinRequestStatus[message.status] : message.status;
                        return object;
                    };

                    /**
                     * Converts this ConfirmJoinIntoGroupNoticeMetaInfo to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.ConfirmJoinIntoGroupNoticeMetaInfo
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ConfirmJoinIntoGroupNoticeMetaInfo.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return ConfirmJoinIntoGroupNoticeMetaInfo;
                })();

                /**
                 * GroupFindType enum.
                 * @name AcFunDanmu.Im.Cloud.Message.GroupFindType
                 * @enum {number}
                 * @property {number} BY_UNKNOWN=0 BY_UNKNOWN value
                 * @property {number} BY_ID=1 BY_ID value
                 * @property {number} BY_NAME=2 BY_NAME value
                 * @property {number} BY_QR_CODE=3 BY_QR_CODE value
                 * @property {number} BY_CARD=4 BY_CARD value
                 * @property {number} BY_INVITATION=5 BY_INVITATION value
                 * @property {number} BY_SHARE_LINK=6 BY_SHARE_LINK value
                 */
                Message.GroupFindType = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "BY_UNKNOWN"] = 0;
                    values[valuesById[1] = "BY_ID"] = 1;
                    values[valuesById[2] = "BY_NAME"] = 2;
                    values[valuesById[3] = "BY_QR_CODE"] = 3;
                    values[valuesById[4] = "BY_CARD"] = 4;
                    values[valuesById[5] = "BY_INVITATION"] = 5;
                    values[valuesById[6] = "BY_SHARE_LINK"] = 6;
                    return values;
                })();

                Message.GroupCreateRequest = (function() {

                    /**
                     * Properties of a GroupCreateRequest.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface IGroupCreateRequest
                     * @property {Array.<AcFunDanmu.Im.Basic.IUser>|null} [members] GroupCreateRequest members
                     */

                    /**
                     * Constructs a new GroupCreateRequest.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents a GroupCreateRequest.
                     * @implements IGroupCreateRequest
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupCreateRequest=} [properties] Properties to set
                     */
                    function GroupCreateRequest(properties) {
                        this.members = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * GroupCreateRequest members.
                     * @member {Array.<AcFunDanmu.Im.Basic.IUser>} members
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupCreateRequest
                     * @instance
                     */
                    GroupCreateRequest.prototype.members = $util.emptyArray;

                    /**
                     * Creates a new GroupCreateRequest instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupCreateRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupCreateRequest=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupCreateRequest} GroupCreateRequest instance
                     */
                    GroupCreateRequest.create = function create(properties) {
                        return new GroupCreateRequest(properties);
                    };

                    /**
                     * Encodes the specified GroupCreateRequest message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupCreateRequest.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupCreateRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupCreateRequest} message GroupCreateRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupCreateRequest.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.members != null && message.members.length)
                            for (let i = 0; i < message.members.length; ++i)
                                $root.AcFunDanmu.Im.Basic.User.encode(message.members[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified GroupCreateRequest message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupCreateRequest.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupCreateRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupCreateRequest} message GroupCreateRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupCreateRequest.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a GroupCreateRequest message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupCreateRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupCreateRequest} GroupCreateRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupCreateRequest.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.GroupCreateRequest();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.members && message.members.length))
                                    message.members = [];
                                message.members.push($root.AcFunDanmu.Im.Basic.User.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a GroupCreateRequest message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupCreateRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupCreateRequest} GroupCreateRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupCreateRequest.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a GroupCreateRequest message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupCreateRequest
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GroupCreateRequest.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.members != null && message.hasOwnProperty("members")) {
                            if (!Array.isArray(message.members))
                                return "members: array expected";
                            for (let i = 0; i < message.members.length; ++i) {
                                let error = $root.AcFunDanmu.Im.Basic.User.verify(message.members[i]);
                                if (error)
                                    return "members." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a GroupCreateRequest message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupCreateRequest
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupCreateRequest} GroupCreateRequest
                     */
                    GroupCreateRequest.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.GroupCreateRequest)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Message.GroupCreateRequest();
                        if (object.members) {
                            if (!Array.isArray(object.members))
                                throw TypeError(".AcFunDanmu.Im.Cloud.Message.GroupCreateRequest.members: array expected");
                            message.members = [];
                            for (let i = 0; i < object.members.length; ++i) {
                                if (typeof object.members[i] !== "object")
                                    throw TypeError(".AcFunDanmu.Im.Cloud.Message.GroupCreateRequest.members: object expected");
                                message.members[i] = $root.AcFunDanmu.Im.Basic.User.fromObject(object.members[i]);
                            }
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a GroupCreateRequest message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupCreateRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.GroupCreateRequest} message GroupCreateRequest
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GroupCreateRequest.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.members = [];
                        if (message.members && message.members.length) {
                            object.members = [];
                            for (let j = 0; j < message.members.length; ++j)
                                object.members[j] = $root.AcFunDanmu.Im.Basic.User.toObject(message.members[j], options);
                        }
                        return object;
                    };

                    /**
                     * Converts this GroupCreateRequest to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupCreateRequest
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GroupCreateRequest.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return GroupCreateRequest;
                })();

                Message.GroupCreateReponse = (function() {

                    /**
                     * Properties of a GroupCreateReponse.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface IGroupCreateReponse
                     * @property {string|null} [groupId] GroupCreateReponse groupId
                     * @property {AcFunDanmu.Im.Cloud.Message.IGroupInfo|null} [groupInfo] GroupCreateReponse groupInfo
                     * @property {Array.<AcFunDanmu.Im.Cloud.Message.IGroupMember>|null} [members] GroupCreateReponse members
                     */

                    /**
                     * Constructs a new GroupCreateReponse.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents a GroupCreateReponse.
                     * @implements IGroupCreateReponse
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupCreateReponse=} [properties] Properties to set
                     */
                    function GroupCreateReponse(properties) {
                        this.members = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * GroupCreateReponse groupId.
                     * @member {string} groupId
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupCreateReponse
                     * @instance
                     */
                    GroupCreateReponse.prototype.groupId = "";

                    /**
                     * GroupCreateReponse groupInfo.
                     * @member {AcFunDanmu.Im.Cloud.Message.IGroupInfo|null|undefined} groupInfo
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupCreateReponse
                     * @instance
                     */
                    GroupCreateReponse.prototype.groupInfo = null;

                    /**
                     * GroupCreateReponse members.
                     * @member {Array.<AcFunDanmu.Im.Cloud.Message.IGroupMember>} members
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupCreateReponse
                     * @instance
                     */
                    GroupCreateReponse.prototype.members = $util.emptyArray;

                    /**
                     * Creates a new GroupCreateReponse instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupCreateReponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupCreateReponse=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupCreateReponse} GroupCreateReponse instance
                     */
                    GroupCreateReponse.create = function create(properties) {
                        return new GroupCreateReponse(properties);
                    };

                    /**
                     * Encodes the specified GroupCreateReponse message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupCreateReponse.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupCreateReponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupCreateReponse} message GroupCreateReponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupCreateReponse.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.groupId);
                        if (message.groupInfo != null && Object.hasOwnProperty.call(message, "groupInfo"))
                            $root.AcFunDanmu.Im.Cloud.Message.GroupInfo.encode(message.groupInfo, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.members != null && message.members.length)
                            for (let i = 0; i < message.members.length; ++i)
                                $root.AcFunDanmu.Im.Cloud.Message.GroupMember.encode(message.members[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified GroupCreateReponse message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupCreateReponse.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupCreateReponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupCreateReponse} message GroupCreateReponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupCreateReponse.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a GroupCreateReponse message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupCreateReponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupCreateReponse} GroupCreateReponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupCreateReponse.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.GroupCreateReponse();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.groupId = reader.string();
                                break;
                            case 2:
                                message.groupInfo = $root.AcFunDanmu.Im.Cloud.Message.GroupInfo.decode(reader, reader.uint32());
                                break;
                            case 3:
                                if (!(message.members && message.members.length))
                                    message.members = [];
                                message.members.push($root.AcFunDanmu.Im.Cloud.Message.GroupMember.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a GroupCreateReponse message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupCreateReponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupCreateReponse} GroupCreateReponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupCreateReponse.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a GroupCreateReponse message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupCreateReponse
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GroupCreateReponse.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.groupId != null && message.hasOwnProperty("groupId"))
                            if (!$util.isString(message.groupId))
                                return "groupId: string expected";
                        if (message.groupInfo != null && message.hasOwnProperty("groupInfo")) {
                            let error = $root.AcFunDanmu.Im.Cloud.Message.GroupInfo.verify(message.groupInfo);
                            if (error)
                                return "groupInfo." + error;
                        }
                        if (message.members != null && message.hasOwnProperty("members")) {
                            if (!Array.isArray(message.members))
                                return "members: array expected";
                            for (let i = 0; i < message.members.length; ++i) {
                                let error = $root.AcFunDanmu.Im.Cloud.Message.GroupMember.verify(message.members[i]);
                                if (error)
                                    return "members." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a GroupCreateReponse message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupCreateReponse
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupCreateReponse} GroupCreateReponse
                     */
                    GroupCreateReponse.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.GroupCreateReponse)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Message.GroupCreateReponse();
                        if (object.groupId != null)
                            message.groupId = String(object.groupId);
                        if (object.groupInfo != null) {
                            if (typeof object.groupInfo !== "object")
                                throw TypeError(".AcFunDanmu.Im.Cloud.Message.GroupCreateReponse.groupInfo: object expected");
                            message.groupInfo = $root.AcFunDanmu.Im.Cloud.Message.GroupInfo.fromObject(object.groupInfo);
                        }
                        if (object.members) {
                            if (!Array.isArray(object.members))
                                throw TypeError(".AcFunDanmu.Im.Cloud.Message.GroupCreateReponse.members: array expected");
                            message.members = [];
                            for (let i = 0; i < object.members.length; ++i) {
                                if (typeof object.members[i] !== "object")
                                    throw TypeError(".AcFunDanmu.Im.Cloud.Message.GroupCreateReponse.members: object expected");
                                message.members[i] = $root.AcFunDanmu.Im.Cloud.Message.GroupMember.fromObject(object.members[i]);
                            }
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a GroupCreateReponse message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupCreateReponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.GroupCreateReponse} message GroupCreateReponse
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GroupCreateReponse.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.members = [];
                        if (options.defaults) {
                            object.groupId = "";
                            object.groupInfo = null;
                        }
                        if (message.groupId != null && message.hasOwnProperty("groupId"))
                            object.groupId = message.groupId;
                        if (message.groupInfo != null && message.hasOwnProperty("groupInfo"))
                            object.groupInfo = $root.AcFunDanmu.Im.Cloud.Message.GroupInfo.toObject(message.groupInfo, options);
                        if (message.members && message.members.length) {
                            object.members = [];
                            for (let j = 0; j < message.members.length; ++j)
                                object.members[j] = $root.AcFunDanmu.Im.Cloud.Message.GroupMember.toObject(message.members[j], options);
                        }
                        return object;
                    };

                    /**
                     * Converts this GroupCreateReponse to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupCreateReponse
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GroupCreateReponse.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return GroupCreateReponse;
                })();

                Message.GroupDeleteRequest = (function() {

                    /**
                     * Properties of a GroupDeleteRequest.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface IGroupDeleteRequest
                     * @property {string|null} [groupId] GroupDeleteRequest groupId
                     */

                    /**
                     * Constructs a new GroupDeleteRequest.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents a GroupDeleteRequest.
                     * @implements IGroupDeleteRequest
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupDeleteRequest=} [properties] Properties to set
                     */
                    function GroupDeleteRequest(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * GroupDeleteRequest groupId.
                     * @member {string} groupId
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupDeleteRequest
                     * @instance
                     */
                    GroupDeleteRequest.prototype.groupId = "";

                    /**
                     * Creates a new GroupDeleteRequest instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupDeleteRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupDeleteRequest=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupDeleteRequest} GroupDeleteRequest instance
                     */
                    GroupDeleteRequest.create = function create(properties) {
                        return new GroupDeleteRequest(properties);
                    };

                    /**
                     * Encodes the specified GroupDeleteRequest message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupDeleteRequest.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupDeleteRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupDeleteRequest} message GroupDeleteRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupDeleteRequest.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.groupId);
                        return writer;
                    };

                    /**
                     * Encodes the specified GroupDeleteRequest message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupDeleteRequest.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupDeleteRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupDeleteRequest} message GroupDeleteRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupDeleteRequest.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a GroupDeleteRequest message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupDeleteRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupDeleteRequest} GroupDeleteRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupDeleteRequest.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.GroupDeleteRequest();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.groupId = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a GroupDeleteRequest message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupDeleteRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupDeleteRequest} GroupDeleteRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupDeleteRequest.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a GroupDeleteRequest message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupDeleteRequest
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GroupDeleteRequest.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.groupId != null && message.hasOwnProperty("groupId"))
                            if (!$util.isString(message.groupId))
                                return "groupId: string expected";
                        return null;
                    };

                    /**
                     * Creates a GroupDeleteRequest message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupDeleteRequest
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupDeleteRequest} GroupDeleteRequest
                     */
                    GroupDeleteRequest.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.GroupDeleteRequest)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Message.GroupDeleteRequest();
                        if (object.groupId != null)
                            message.groupId = String(object.groupId);
                        return message;
                    };

                    /**
                     * Creates a plain object from a GroupDeleteRequest message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupDeleteRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.GroupDeleteRequest} message GroupDeleteRequest
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GroupDeleteRequest.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.groupId = "";
                        if (message.groupId != null && message.hasOwnProperty("groupId"))
                            object.groupId = message.groupId;
                        return object;
                    };

                    /**
                     * Converts this GroupDeleteRequest to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupDeleteRequest
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GroupDeleteRequest.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return GroupDeleteRequest;
                })();

                Message.GroupDeleteResponse = (function() {

                    /**
                     * Properties of a GroupDeleteResponse.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface IGroupDeleteResponse
                     */

                    /**
                     * Constructs a new GroupDeleteResponse.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents a GroupDeleteResponse.
                     * @implements IGroupDeleteResponse
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupDeleteResponse=} [properties] Properties to set
                     */
                    function GroupDeleteResponse(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Creates a new GroupDeleteResponse instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupDeleteResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupDeleteResponse=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupDeleteResponse} GroupDeleteResponse instance
                     */
                    GroupDeleteResponse.create = function create(properties) {
                        return new GroupDeleteResponse(properties);
                    };

                    /**
                     * Encodes the specified GroupDeleteResponse message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupDeleteResponse.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupDeleteResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupDeleteResponse} message GroupDeleteResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupDeleteResponse.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };

                    /**
                     * Encodes the specified GroupDeleteResponse message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupDeleteResponse.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupDeleteResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupDeleteResponse} message GroupDeleteResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupDeleteResponse.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a GroupDeleteResponse message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupDeleteResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupDeleteResponse} GroupDeleteResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupDeleteResponse.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.GroupDeleteResponse();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a GroupDeleteResponse message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupDeleteResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupDeleteResponse} GroupDeleteResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupDeleteResponse.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a GroupDeleteResponse message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupDeleteResponse
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GroupDeleteResponse.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };

                    /**
                     * Creates a GroupDeleteResponse message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupDeleteResponse
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupDeleteResponse} GroupDeleteResponse
                     */
                    GroupDeleteResponse.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.GroupDeleteResponse)
                            return object;
                        return new $root.AcFunDanmu.Im.Cloud.Message.GroupDeleteResponse();
                    };

                    /**
                     * Creates a plain object from a GroupDeleteResponse message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupDeleteResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.GroupDeleteResponse} message GroupDeleteResponse
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GroupDeleteResponse.toObject = function toObject() {
                        return {};
                    };

                    /**
                     * Converts this GroupDeleteResponse to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupDeleteResponse
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GroupDeleteResponse.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return GroupDeleteResponse;
                })();

                Message.GroupInviteRequest = (function() {

                    /**
                     * Properties of a GroupInviteRequest.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface IGroupInviteRequest
                     * @property {string|null} [groupId] GroupInviteRequest groupId
                     * @property {Array.<AcFunDanmu.Im.Basic.IUser>|null} [members] GroupInviteRequest members
                     * @property {string|null} [descContent] GroupInviteRequest descContent
                     */

                    /**
                     * Constructs a new GroupInviteRequest.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents a GroupInviteRequest.
                     * @implements IGroupInviteRequest
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupInviteRequest=} [properties] Properties to set
                     */
                    function GroupInviteRequest(properties) {
                        this.members = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * GroupInviteRequest groupId.
                     * @member {string} groupId
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupInviteRequest
                     * @instance
                     */
                    GroupInviteRequest.prototype.groupId = "";

                    /**
                     * GroupInviteRequest members.
                     * @member {Array.<AcFunDanmu.Im.Basic.IUser>} members
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupInviteRequest
                     * @instance
                     */
                    GroupInviteRequest.prototype.members = $util.emptyArray;

                    /**
                     * GroupInviteRequest descContent.
                     * @member {string} descContent
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupInviteRequest
                     * @instance
                     */
                    GroupInviteRequest.prototype.descContent = "";

                    /**
                     * Creates a new GroupInviteRequest instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupInviteRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupInviteRequest=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupInviteRequest} GroupInviteRequest instance
                     */
                    GroupInviteRequest.create = function create(properties) {
                        return new GroupInviteRequest(properties);
                    };

                    /**
                     * Encodes the specified GroupInviteRequest message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupInviteRequest.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupInviteRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupInviteRequest} message GroupInviteRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupInviteRequest.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.groupId);
                        if (message.members != null && message.members.length)
                            for (let i = 0; i < message.members.length; ++i)
                                $root.AcFunDanmu.Im.Basic.User.encode(message.members[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.descContent != null && Object.hasOwnProperty.call(message, "descContent"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.descContent);
                        return writer;
                    };

                    /**
                     * Encodes the specified GroupInviteRequest message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupInviteRequest.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupInviteRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupInviteRequest} message GroupInviteRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupInviteRequest.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a GroupInviteRequest message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupInviteRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupInviteRequest} GroupInviteRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupInviteRequest.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.GroupInviteRequest();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.groupId = reader.string();
                                break;
                            case 2:
                                if (!(message.members && message.members.length))
                                    message.members = [];
                                message.members.push($root.AcFunDanmu.Im.Basic.User.decode(reader, reader.uint32()));
                                break;
                            case 3:
                                message.descContent = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a GroupInviteRequest message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupInviteRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupInviteRequest} GroupInviteRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupInviteRequest.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a GroupInviteRequest message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupInviteRequest
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GroupInviteRequest.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.groupId != null && message.hasOwnProperty("groupId"))
                            if (!$util.isString(message.groupId))
                                return "groupId: string expected";
                        if (message.members != null && message.hasOwnProperty("members")) {
                            if (!Array.isArray(message.members))
                                return "members: array expected";
                            for (let i = 0; i < message.members.length; ++i) {
                                let error = $root.AcFunDanmu.Im.Basic.User.verify(message.members[i]);
                                if (error)
                                    return "members." + error;
                            }
                        }
                        if (message.descContent != null && message.hasOwnProperty("descContent"))
                            if (!$util.isString(message.descContent))
                                return "descContent: string expected";
                        return null;
                    };

                    /**
                     * Creates a GroupInviteRequest message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupInviteRequest
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupInviteRequest} GroupInviteRequest
                     */
                    GroupInviteRequest.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.GroupInviteRequest)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Message.GroupInviteRequest();
                        if (object.groupId != null)
                            message.groupId = String(object.groupId);
                        if (object.members) {
                            if (!Array.isArray(object.members))
                                throw TypeError(".AcFunDanmu.Im.Cloud.Message.GroupInviteRequest.members: array expected");
                            message.members = [];
                            for (let i = 0; i < object.members.length; ++i) {
                                if (typeof object.members[i] !== "object")
                                    throw TypeError(".AcFunDanmu.Im.Cloud.Message.GroupInviteRequest.members: object expected");
                                message.members[i] = $root.AcFunDanmu.Im.Basic.User.fromObject(object.members[i]);
                            }
                        }
                        if (object.descContent != null)
                            message.descContent = String(object.descContent);
                        return message;
                    };

                    /**
                     * Creates a plain object from a GroupInviteRequest message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupInviteRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.GroupInviteRequest} message GroupInviteRequest
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GroupInviteRequest.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.members = [];
                        if (options.defaults) {
                            object.groupId = "";
                            object.descContent = "";
                        }
                        if (message.groupId != null && message.hasOwnProperty("groupId"))
                            object.groupId = message.groupId;
                        if (message.members && message.members.length) {
                            object.members = [];
                            for (let j = 0; j < message.members.length; ++j)
                                object.members[j] = $root.AcFunDanmu.Im.Basic.User.toObject(message.members[j], options);
                        }
                        if (message.descContent != null && message.hasOwnProperty("descContent"))
                            object.descContent = message.descContent;
                        return object;
                    };

                    /**
                     * Converts this GroupInviteRequest to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupInviteRequest
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GroupInviteRequest.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return GroupInviteRequest;
                })();

                Message.GroupInvideResponse = (function() {

                    /**
                     * Properties of a GroupInvideResponse.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface IGroupInvideResponse
                     * @property {string|null} [groupId] GroupInvideResponse groupId
                     * @property {AcFunDanmu.Im.Cloud.Message.GroupInvideResponse.InviteStatus|null} [inviteStatus] GroupInvideResponse inviteStatus
                     */

                    /**
                     * Constructs a new GroupInvideResponse.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents a GroupInvideResponse.
                     * @implements IGroupInvideResponse
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupInvideResponse=} [properties] Properties to set
                     */
                    function GroupInvideResponse(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * GroupInvideResponse groupId.
                     * @member {string} groupId
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupInvideResponse
                     * @instance
                     */
                    GroupInvideResponse.prototype.groupId = "";

                    /**
                     * GroupInvideResponse inviteStatus.
                     * @member {AcFunDanmu.Im.Cloud.Message.GroupInvideResponse.InviteStatus} inviteStatus
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupInvideResponse
                     * @instance
                     */
                    GroupInvideResponse.prototype.inviteStatus = 0;

                    /**
                     * Creates a new GroupInvideResponse instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupInvideResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupInvideResponse=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupInvideResponse} GroupInvideResponse instance
                     */
                    GroupInvideResponse.create = function create(properties) {
                        return new GroupInvideResponse(properties);
                    };

                    /**
                     * Encodes the specified GroupInvideResponse message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupInvideResponse.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupInvideResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupInvideResponse} message GroupInvideResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupInvideResponse.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.groupId);
                        if (message.inviteStatus != null && Object.hasOwnProperty.call(message, "inviteStatus"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.inviteStatus);
                        return writer;
                    };

                    /**
                     * Encodes the specified GroupInvideResponse message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupInvideResponse.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupInvideResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupInvideResponse} message GroupInvideResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupInvideResponse.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a GroupInvideResponse message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupInvideResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupInvideResponse} GroupInvideResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupInvideResponse.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.GroupInvideResponse();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.groupId = reader.string();
                                break;
                            case 2:
                                message.inviteStatus = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a GroupInvideResponse message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupInvideResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupInvideResponse} GroupInvideResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupInvideResponse.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a GroupInvideResponse message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupInvideResponse
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GroupInvideResponse.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.groupId != null && message.hasOwnProperty("groupId"))
                            if (!$util.isString(message.groupId))
                                return "groupId: string expected";
                        if (message.inviteStatus != null && message.hasOwnProperty("inviteStatus"))
                            switch (message.inviteStatus) {
                            default:
                                return "inviteStatus: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                                break;
                            }
                        return null;
                    };

                    /**
                     * Creates a GroupInvideResponse message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupInvideResponse
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupInvideResponse} GroupInvideResponse
                     */
                    GroupInvideResponse.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.GroupInvideResponse)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Message.GroupInvideResponse();
                        if (object.groupId != null)
                            message.groupId = String(object.groupId);
                        switch (object.inviteStatus) {
                        case "UNKNOWN_STATUS":
                        case 0:
                            message.inviteStatus = 0;
                            break;
                        case "SUCC":
                        case 1:
                            message.inviteStatus = 1;
                            break;
                        case "PENDING":
                        case 2:
                            message.inviteStatus = 2;
                            break;
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a GroupInvideResponse message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupInvideResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.GroupInvideResponse} message GroupInvideResponse
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GroupInvideResponse.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.groupId = "";
                            object.inviteStatus = options.enums === String ? "UNKNOWN_STATUS" : 0;
                        }
                        if (message.groupId != null && message.hasOwnProperty("groupId"))
                            object.groupId = message.groupId;
                        if (message.inviteStatus != null && message.hasOwnProperty("inviteStatus"))
                            object.inviteStatus = options.enums === String ? $root.AcFunDanmu.Im.Cloud.Message.GroupInvideResponse.InviteStatus[message.inviteStatus] : message.inviteStatus;
                        return object;
                    };

                    /**
                     * Converts this GroupInvideResponse to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupInvideResponse
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GroupInvideResponse.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * InviteStatus enum.
                     * @name AcFunDanmu.Im.Cloud.Message.GroupInvideResponse.InviteStatus
                     * @enum {number}
                     * @property {number} UNKNOWN_STATUS=0 UNKNOWN_STATUS value
                     * @property {number} SUCC=1 SUCC value
                     * @property {number} PENDING=2 PENDING value
                     */
                    GroupInvideResponse.InviteStatus = (function() {
                        const valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "UNKNOWN_STATUS"] = 0;
                        values[valuesById[1] = "SUCC"] = 1;
                        values[valuesById[2] = "PENDING"] = 2;
                        return values;
                    })();

                    return GroupInvideResponse;
                })();

                Message.GroupJoinRequest = (function() {

                    /**
                     * Properties of a GroupJoinRequest.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface IGroupJoinRequest
                     * @property {string|null} [groupId] GroupJoinRequest groupId
                     * @property {AcFunDanmu.Im.Basic.IUser|null} [inviter] GroupJoinRequest inviter
                     * @property {string|null} [descContent] GroupJoinRequest descContent
                     * @property {AcFunDanmu.Im.Cloud.Message.GroupFindType|null} [findType] GroupJoinRequest findType
                     */

                    /**
                     * Constructs a new GroupJoinRequest.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents a GroupJoinRequest.
                     * @implements IGroupJoinRequest
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupJoinRequest=} [properties] Properties to set
                     */
                    function GroupJoinRequest(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * GroupJoinRequest groupId.
                     * @member {string} groupId
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequest
                     * @instance
                     */
                    GroupJoinRequest.prototype.groupId = "";

                    /**
                     * GroupJoinRequest inviter.
                     * @member {AcFunDanmu.Im.Basic.IUser|null|undefined} inviter
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequest
                     * @instance
                     */
                    GroupJoinRequest.prototype.inviter = null;

                    /**
                     * GroupJoinRequest descContent.
                     * @member {string} descContent
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequest
                     * @instance
                     */
                    GroupJoinRequest.prototype.descContent = "";

                    /**
                     * GroupJoinRequest findType.
                     * @member {AcFunDanmu.Im.Cloud.Message.GroupFindType} findType
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequest
                     * @instance
                     */
                    GroupJoinRequest.prototype.findType = 0;

                    /**
                     * Creates a new GroupJoinRequest instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupJoinRequest=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupJoinRequest} GroupJoinRequest instance
                     */
                    GroupJoinRequest.create = function create(properties) {
                        return new GroupJoinRequest(properties);
                    };

                    /**
                     * Encodes the specified GroupJoinRequest message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupJoinRequest.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupJoinRequest} message GroupJoinRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupJoinRequest.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.groupId);
                        if (message.inviter != null && Object.hasOwnProperty.call(message, "inviter"))
                            $root.AcFunDanmu.Im.Basic.User.encode(message.inviter, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.descContent != null && Object.hasOwnProperty.call(message, "descContent"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.descContent);
                        if (message.findType != null && Object.hasOwnProperty.call(message, "findType"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.findType);
                        return writer;
                    };

                    /**
                     * Encodes the specified GroupJoinRequest message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupJoinRequest.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupJoinRequest} message GroupJoinRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupJoinRequest.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a GroupJoinRequest message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupJoinRequest} GroupJoinRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupJoinRequest.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.GroupJoinRequest();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.groupId = reader.string();
                                break;
                            case 2:
                                message.inviter = $root.AcFunDanmu.Im.Basic.User.decode(reader, reader.uint32());
                                break;
                            case 3:
                                message.descContent = reader.string();
                                break;
                            case 4:
                                message.findType = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a GroupJoinRequest message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupJoinRequest} GroupJoinRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupJoinRequest.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a GroupJoinRequest message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequest
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GroupJoinRequest.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.groupId != null && message.hasOwnProperty("groupId"))
                            if (!$util.isString(message.groupId))
                                return "groupId: string expected";
                        if (message.inviter != null && message.hasOwnProperty("inviter")) {
                            let error = $root.AcFunDanmu.Im.Basic.User.verify(message.inviter);
                            if (error)
                                return "inviter." + error;
                        }
                        if (message.descContent != null && message.hasOwnProperty("descContent"))
                            if (!$util.isString(message.descContent))
                                return "descContent: string expected";
                        if (message.findType != null && message.hasOwnProperty("findType"))
                            switch (message.findType) {
                            default:
                                return "findType: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 6:
                                break;
                            }
                        return null;
                    };

                    /**
                     * Creates a GroupJoinRequest message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequest
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupJoinRequest} GroupJoinRequest
                     */
                    GroupJoinRequest.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.GroupJoinRequest)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Message.GroupJoinRequest();
                        if (object.groupId != null)
                            message.groupId = String(object.groupId);
                        if (object.inviter != null) {
                            if (typeof object.inviter !== "object")
                                throw TypeError(".AcFunDanmu.Im.Cloud.Message.GroupJoinRequest.inviter: object expected");
                            message.inviter = $root.AcFunDanmu.Im.Basic.User.fromObject(object.inviter);
                        }
                        if (object.descContent != null)
                            message.descContent = String(object.descContent);
                        switch (object.findType) {
                        case "BY_UNKNOWN":
                        case 0:
                            message.findType = 0;
                            break;
                        case "BY_ID":
                        case 1:
                            message.findType = 1;
                            break;
                        case "BY_NAME":
                        case 2:
                            message.findType = 2;
                            break;
                        case "BY_QR_CODE":
                        case 3:
                            message.findType = 3;
                            break;
                        case "BY_CARD":
                        case 4:
                            message.findType = 4;
                            break;
                        case "BY_INVITATION":
                        case 5:
                            message.findType = 5;
                            break;
                        case "BY_SHARE_LINK":
                        case 6:
                            message.findType = 6;
                            break;
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a GroupJoinRequest message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.GroupJoinRequest} message GroupJoinRequest
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GroupJoinRequest.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.groupId = "";
                            object.inviter = null;
                            object.descContent = "";
                            object.findType = options.enums === String ? "BY_UNKNOWN" : 0;
                        }
                        if (message.groupId != null && message.hasOwnProperty("groupId"))
                            object.groupId = message.groupId;
                        if (message.inviter != null && message.hasOwnProperty("inviter"))
                            object.inviter = $root.AcFunDanmu.Im.Basic.User.toObject(message.inviter, options);
                        if (message.descContent != null && message.hasOwnProperty("descContent"))
                            object.descContent = message.descContent;
                        if (message.findType != null && message.hasOwnProperty("findType"))
                            object.findType = options.enums === String ? $root.AcFunDanmu.Im.Cloud.Message.GroupFindType[message.findType] : message.findType;
                        return object;
                    };

                    /**
                     * Converts this GroupJoinRequest to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequest
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GroupJoinRequest.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return GroupJoinRequest;
                })();

                Message.GroupJoinResponse = (function() {

                    /**
                     * Properties of a GroupJoinResponse.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface IGroupJoinResponse
                     * @property {AcFunDanmu.Im.Cloud.Message.GroupJoinResponse.JoinStatus|null} [joinStatus] GroupJoinResponse joinStatus
                     */

                    /**
                     * Constructs a new GroupJoinResponse.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents a GroupJoinResponse.
                     * @implements IGroupJoinResponse
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupJoinResponse=} [properties] Properties to set
                     */
                    function GroupJoinResponse(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * GroupJoinResponse joinStatus.
                     * @member {AcFunDanmu.Im.Cloud.Message.GroupJoinResponse.JoinStatus} joinStatus
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinResponse
                     * @instance
                     */
                    GroupJoinResponse.prototype.joinStatus = 0;

                    /**
                     * Creates a new GroupJoinResponse instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupJoinResponse=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupJoinResponse} GroupJoinResponse instance
                     */
                    GroupJoinResponse.create = function create(properties) {
                        return new GroupJoinResponse(properties);
                    };

                    /**
                     * Encodes the specified GroupJoinResponse message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupJoinResponse.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupJoinResponse} message GroupJoinResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupJoinResponse.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.joinStatus != null && Object.hasOwnProperty.call(message, "joinStatus"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.joinStatus);
                        return writer;
                    };

                    /**
                     * Encodes the specified GroupJoinResponse message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupJoinResponse.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupJoinResponse} message GroupJoinResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupJoinResponse.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a GroupJoinResponse message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupJoinResponse} GroupJoinResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupJoinResponse.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.GroupJoinResponse();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.joinStatus = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a GroupJoinResponse message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupJoinResponse} GroupJoinResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupJoinResponse.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a GroupJoinResponse message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinResponse
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GroupJoinResponse.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.joinStatus != null && message.hasOwnProperty("joinStatus"))
                            switch (message.joinStatus) {
                            default:
                                return "joinStatus: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                                break;
                            }
                        return null;
                    };

                    /**
                     * Creates a GroupJoinResponse message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinResponse
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupJoinResponse} GroupJoinResponse
                     */
                    GroupJoinResponse.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.GroupJoinResponse)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Message.GroupJoinResponse();
                        switch (object.joinStatus) {
                        case "UNKNOWN_STATUS":
                        case 0:
                            message.joinStatus = 0;
                            break;
                        case "SUCC":
                        case 1:
                            message.joinStatus = 1;
                            break;
                        case "PENDING":
                        case 2:
                            message.joinStatus = 2;
                            break;
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a GroupJoinResponse message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.GroupJoinResponse} message GroupJoinResponse
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GroupJoinResponse.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.joinStatus = options.enums === String ? "UNKNOWN_STATUS" : 0;
                        if (message.joinStatus != null && message.hasOwnProperty("joinStatus"))
                            object.joinStatus = options.enums === String ? $root.AcFunDanmu.Im.Cloud.Message.GroupJoinResponse.JoinStatus[message.joinStatus] : message.joinStatus;
                        return object;
                    };

                    /**
                     * Converts this GroupJoinResponse to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinResponse
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GroupJoinResponse.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * JoinStatus enum.
                     * @name AcFunDanmu.Im.Cloud.Message.GroupJoinResponse.JoinStatus
                     * @enum {number}
                     * @property {number} UNKNOWN_STATUS=0 UNKNOWN_STATUS value
                     * @property {number} SUCC=1 SUCC value
                     * @property {number} PENDING=2 PENDING value
                     */
                    GroupJoinResponse.JoinStatus = (function() {
                        const valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "UNKNOWN_STATUS"] = 0;
                        values[valuesById[1] = "SUCC"] = 1;
                        values[valuesById[2] = "PENDING"] = 2;
                        return values;
                    })();

                    return GroupJoinResponse;
                })();

                Message.GroupJoinRequestAckRequest = (function() {

                    /**
                     * Properties of a GroupJoinRequestAckRequest.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface IGroupJoinRequestAckRequest
                     * @property {number|Long|null} [reqId] GroupJoinRequestAckRequest reqId
                     * @property {string|null} [groupId] GroupJoinRequestAckRequest groupId
                     * @property {AcFunDanmu.Im.Cloud.Message.GroupJoinRequestAckRequest.GroupJoinAckType|null} [groupJoinAckType] GroupJoinRequestAckRequest groupJoinAckType
                     */

                    /**
                     * Constructs a new GroupJoinRequestAckRequest.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents a GroupJoinRequestAckRequest.
                     * @implements IGroupJoinRequestAckRequest
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupJoinRequestAckRequest=} [properties] Properties to set
                     */
                    function GroupJoinRequestAckRequest(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * GroupJoinRequestAckRequest reqId.
                     * @member {number|Long} reqId
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestAckRequest
                     * @instance
                     */
                    GroupJoinRequestAckRequest.prototype.reqId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * GroupJoinRequestAckRequest groupId.
                     * @member {string} groupId
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestAckRequest
                     * @instance
                     */
                    GroupJoinRequestAckRequest.prototype.groupId = "";

                    /**
                     * GroupJoinRequestAckRequest groupJoinAckType.
                     * @member {AcFunDanmu.Im.Cloud.Message.GroupJoinRequestAckRequest.GroupJoinAckType} groupJoinAckType
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestAckRequest
                     * @instance
                     */
                    GroupJoinRequestAckRequest.prototype.groupJoinAckType = 0;

                    /**
                     * Creates a new GroupJoinRequestAckRequest instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestAckRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupJoinRequestAckRequest=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupJoinRequestAckRequest} GroupJoinRequestAckRequest instance
                     */
                    GroupJoinRequestAckRequest.create = function create(properties) {
                        return new GroupJoinRequestAckRequest(properties);
                    };

                    /**
                     * Encodes the specified GroupJoinRequestAckRequest message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupJoinRequestAckRequest.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestAckRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupJoinRequestAckRequest} message GroupJoinRequestAckRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupJoinRequestAckRequest.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.reqId != null && Object.hasOwnProperty.call(message, "reqId"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.reqId);
                        if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.groupId);
                        if (message.groupJoinAckType != null && Object.hasOwnProperty.call(message, "groupJoinAckType"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.groupJoinAckType);
                        return writer;
                    };

                    /**
                     * Encodes the specified GroupJoinRequestAckRequest message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupJoinRequestAckRequest.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestAckRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupJoinRequestAckRequest} message GroupJoinRequestAckRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupJoinRequestAckRequest.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a GroupJoinRequestAckRequest message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestAckRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupJoinRequestAckRequest} GroupJoinRequestAckRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupJoinRequestAckRequest.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.GroupJoinRequestAckRequest();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.reqId = reader.int64();
                                break;
                            case 2:
                                message.groupId = reader.string();
                                break;
                            case 3:
                                message.groupJoinAckType = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a GroupJoinRequestAckRequest message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestAckRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupJoinRequestAckRequest} GroupJoinRequestAckRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupJoinRequestAckRequest.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a GroupJoinRequestAckRequest message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestAckRequest
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GroupJoinRequestAckRequest.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.reqId != null && message.hasOwnProperty("reqId"))
                            if (!$util.isInteger(message.reqId) && !(message.reqId && $util.isInteger(message.reqId.low) && $util.isInteger(message.reqId.high)))
                                return "reqId: integer|Long expected";
                        if (message.groupId != null && message.hasOwnProperty("groupId"))
                            if (!$util.isString(message.groupId))
                                return "groupId: string expected";
                        if (message.groupJoinAckType != null && message.hasOwnProperty("groupJoinAckType"))
                            switch (message.groupJoinAckType) {
                            default:
                                return "groupJoinAckType: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                                break;
                            }
                        return null;
                    };

                    /**
                     * Creates a GroupJoinRequestAckRequest message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestAckRequest
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupJoinRequestAckRequest} GroupJoinRequestAckRequest
                     */
                    GroupJoinRequestAckRequest.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.GroupJoinRequestAckRequest)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Message.GroupJoinRequestAckRequest();
                        if (object.reqId != null)
                            if ($util.Long)
                                (message.reqId = $util.Long.fromValue(object.reqId)).unsigned = false;
                            else if (typeof object.reqId === "string")
                                message.reqId = parseInt(object.reqId, 10);
                            else if (typeof object.reqId === "number")
                                message.reqId = object.reqId;
                            else if (typeof object.reqId === "object")
                                message.reqId = new $util.LongBits(object.reqId.low >>> 0, object.reqId.high >>> 0).toNumber();
                        if (object.groupId != null)
                            message.groupId = String(object.groupId);
                        switch (object.groupJoinAckType) {
                        case "UNKNOWN_TYPE":
                        case 0:
                            message.groupJoinAckType = 0;
                            break;
                        case "AGREE":
                        case 1:
                            message.groupJoinAckType = 1;
                            break;
                        case "REFUSE":
                        case 2:
                            message.groupJoinAckType = 2;
                            break;
                        case "IGNORE":
                        case 3:
                            message.groupJoinAckType = 3;
                            break;
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a GroupJoinRequestAckRequest message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestAckRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.GroupJoinRequestAckRequest} message GroupJoinRequestAckRequest
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GroupJoinRequestAckRequest.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, false);
                                object.reqId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.reqId = options.longs === String ? "0" : 0;
                            object.groupId = "";
                            object.groupJoinAckType = options.enums === String ? "UNKNOWN_TYPE" : 0;
                        }
                        if (message.reqId != null && message.hasOwnProperty("reqId"))
                            if (typeof message.reqId === "number")
                                object.reqId = options.longs === String ? String(message.reqId) : message.reqId;
                            else
                                object.reqId = options.longs === String ? $util.Long.prototype.toString.call(message.reqId) : options.longs === Number ? new $util.LongBits(message.reqId.low >>> 0, message.reqId.high >>> 0).toNumber() : message.reqId;
                        if (message.groupId != null && message.hasOwnProperty("groupId"))
                            object.groupId = message.groupId;
                        if (message.groupJoinAckType != null && message.hasOwnProperty("groupJoinAckType"))
                            object.groupJoinAckType = options.enums === String ? $root.AcFunDanmu.Im.Cloud.Message.GroupJoinRequestAckRequest.GroupJoinAckType[message.groupJoinAckType] : message.groupJoinAckType;
                        return object;
                    };

                    /**
                     * Converts this GroupJoinRequestAckRequest to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestAckRequest
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GroupJoinRequestAckRequest.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * GroupJoinAckType enum.
                     * @name AcFunDanmu.Im.Cloud.Message.GroupJoinRequestAckRequest.GroupJoinAckType
                     * @enum {number}
                     * @property {number} UNKNOWN_TYPE=0 UNKNOWN_TYPE value
                     * @property {number} AGREE=1 AGREE value
                     * @property {number} REFUSE=2 REFUSE value
                     * @property {number} IGNORE=3 IGNORE value
                     */
                    GroupJoinRequestAckRequest.GroupJoinAckType = (function() {
                        const valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "UNKNOWN_TYPE"] = 0;
                        values[valuesById[1] = "AGREE"] = 1;
                        values[valuesById[2] = "REFUSE"] = 2;
                        values[valuesById[3] = "IGNORE"] = 3;
                        return values;
                    })();

                    return GroupJoinRequestAckRequest;
                })();

                Message.GroupJoinRequestAckResponse = (function() {

                    /**
                     * Properties of a GroupJoinRequestAckResponse.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface IGroupJoinRequestAckResponse
                     */

                    /**
                     * Constructs a new GroupJoinRequestAckResponse.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents a GroupJoinRequestAckResponse.
                     * @implements IGroupJoinRequestAckResponse
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupJoinRequestAckResponse=} [properties] Properties to set
                     */
                    function GroupJoinRequestAckResponse(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Creates a new GroupJoinRequestAckResponse instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestAckResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupJoinRequestAckResponse=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupJoinRequestAckResponse} GroupJoinRequestAckResponse instance
                     */
                    GroupJoinRequestAckResponse.create = function create(properties) {
                        return new GroupJoinRequestAckResponse(properties);
                    };

                    /**
                     * Encodes the specified GroupJoinRequestAckResponse message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupJoinRequestAckResponse.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestAckResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupJoinRequestAckResponse} message GroupJoinRequestAckResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupJoinRequestAckResponse.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };

                    /**
                     * Encodes the specified GroupJoinRequestAckResponse message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupJoinRequestAckResponse.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestAckResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupJoinRequestAckResponse} message GroupJoinRequestAckResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupJoinRequestAckResponse.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a GroupJoinRequestAckResponse message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestAckResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupJoinRequestAckResponse} GroupJoinRequestAckResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupJoinRequestAckResponse.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.GroupJoinRequestAckResponse();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a GroupJoinRequestAckResponse message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestAckResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupJoinRequestAckResponse} GroupJoinRequestAckResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupJoinRequestAckResponse.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a GroupJoinRequestAckResponse message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestAckResponse
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GroupJoinRequestAckResponse.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };

                    /**
                     * Creates a GroupJoinRequestAckResponse message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestAckResponse
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupJoinRequestAckResponse} GroupJoinRequestAckResponse
                     */
                    GroupJoinRequestAckResponse.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.GroupJoinRequestAckResponse)
                            return object;
                        return new $root.AcFunDanmu.Im.Cloud.Message.GroupJoinRequestAckResponse();
                    };

                    /**
                     * Creates a plain object from a GroupJoinRequestAckResponse message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestAckResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.GroupJoinRequestAckResponse} message GroupJoinRequestAckResponse
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GroupJoinRequestAckResponse.toObject = function toObject() {
                        return {};
                    };

                    /**
                     * Converts this GroupJoinRequestAckResponse to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestAckResponse
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GroupJoinRequestAckResponse.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return GroupJoinRequestAckResponse;
                })();

                Message.GroupJoinRequestGetRequest = (function() {

                    /**
                     * Properties of a GroupJoinRequestGetRequest.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface IGroupJoinRequestGetRequest
                     * @property {number|Long|null} [reqSeq] GroupJoinRequestGetRequest reqSeq
                     * @property {string|null} [groupId] GroupJoinRequestGetRequest groupId
                     */

                    /**
                     * Constructs a new GroupJoinRequestGetRequest.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents a GroupJoinRequestGetRequest.
                     * @implements IGroupJoinRequestGetRequest
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupJoinRequestGetRequest=} [properties] Properties to set
                     */
                    function GroupJoinRequestGetRequest(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * GroupJoinRequestGetRequest reqSeq.
                     * @member {number|Long} reqSeq
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestGetRequest
                     * @instance
                     */
                    GroupJoinRequestGetRequest.prototype.reqSeq = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * GroupJoinRequestGetRequest groupId.
                     * @member {string} groupId
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestGetRequest
                     * @instance
                     */
                    GroupJoinRequestGetRequest.prototype.groupId = "";

                    /**
                     * Creates a new GroupJoinRequestGetRequest instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestGetRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupJoinRequestGetRequest=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupJoinRequestGetRequest} GroupJoinRequestGetRequest instance
                     */
                    GroupJoinRequestGetRequest.create = function create(properties) {
                        return new GroupJoinRequestGetRequest(properties);
                    };

                    /**
                     * Encodes the specified GroupJoinRequestGetRequest message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupJoinRequestGetRequest.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestGetRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupJoinRequestGetRequest} message GroupJoinRequestGetRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupJoinRequestGetRequest.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.reqSeq != null && Object.hasOwnProperty.call(message, "reqSeq"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.reqSeq);
                        if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.groupId);
                        return writer;
                    };

                    /**
                     * Encodes the specified GroupJoinRequestGetRequest message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupJoinRequestGetRequest.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestGetRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupJoinRequestGetRequest} message GroupJoinRequestGetRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupJoinRequestGetRequest.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a GroupJoinRequestGetRequest message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestGetRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupJoinRequestGetRequest} GroupJoinRequestGetRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupJoinRequestGetRequest.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.GroupJoinRequestGetRequest();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.reqSeq = reader.int64();
                                break;
                            case 2:
                                message.groupId = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a GroupJoinRequestGetRequest message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestGetRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupJoinRequestGetRequest} GroupJoinRequestGetRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupJoinRequestGetRequest.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a GroupJoinRequestGetRequest message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestGetRequest
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GroupJoinRequestGetRequest.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.reqSeq != null && message.hasOwnProperty("reqSeq"))
                            if (!$util.isInteger(message.reqSeq) && !(message.reqSeq && $util.isInteger(message.reqSeq.low) && $util.isInteger(message.reqSeq.high)))
                                return "reqSeq: integer|Long expected";
                        if (message.groupId != null && message.hasOwnProperty("groupId"))
                            if (!$util.isString(message.groupId))
                                return "groupId: string expected";
                        return null;
                    };

                    /**
                     * Creates a GroupJoinRequestGetRequest message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestGetRequest
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupJoinRequestGetRequest} GroupJoinRequestGetRequest
                     */
                    GroupJoinRequestGetRequest.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.GroupJoinRequestGetRequest)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Message.GroupJoinRequestGetRequest();
                        if (object.reqSeq != null)
                            if ($util.Long)
                                (message.reqSeq = $util.Long.fromValue(object.reqSeq)).unsigned = false;
                            else if (typeof object.reqSeq === "string")
                                message.reqSeq = parseInt(object.reqSeq, 10);
                            else if (typeof object.reqSeq === "number")
                                message.reqSeq = object.reqSeq;
                            else if (typeof object.reqSeq === "object")
                                message.reqSeq = new $util.LongBits(object.reqSeq.low >>> 0, object.reqSeq.high >>> 0).toNumber();
                        if (object.groupId != null)
                            message.groupId = String(object.groupId);
                        return message;
                    };

                    /**
                     * Creates a plain object from a GroupJoinRequestGetRequest message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestGetRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.GroupJoinRequestGetRequest} message GroupJoinRequestGetRequest
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GroupJoinRequestGetRequest.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, false);
                                object.reqSeq = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.reqSeq = options.longs === String ? "0" : 0;
                            object.groupId = "";
                        }
                        if (message.reqSeq != null && message.hasOwnProperty("reqSeq"))
                            if (typeof message.reqSeq === "number")
                                object.reqSeq = options.longs === String ? String(message.reqSeq) : message.reqSeq;
                            else
                                object.reqSeq = options.longs === String ? $util.Long.prototype.toString.call(message.reqSeq) : options.longs === Number ? new $util.LongBits(message.reqSeq.low >>> 0, message.reqSeq.high >>> 0).toNumber() : message.reqSeq;
                        if (message.groupId != null && message.hasOwnProperty("groupId"))
                            object.groupId = message.groupId;
                        return object;
                    };

                    /**
                     * Converts this GroupJoinRequestGetRequest to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestGetRequest
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GroupJoinRequestGetRequest.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return GroupJoinRequestGetRequest;
                })();

                Message.GroupJoinRequestGetResponse = (function() {

                    /**
                     * Properties of a GroupJoinRequestGetResponse.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface IGroupJoinRequestGetResponse
                     * @property {string|null} [groupId] GroupJoinRequestGetResponse groupId
                     * @property {AcFunDanmu.Im.Basic.IUser|null} [inviter] GroupJoinRequestGetResponse inviter
                     * @property {Array.<AcFunDanmu.Im.Basic.IUser>|null} [invitees] GroupJoinRequestGetResponse invitees
                     * @property {AcFunDanmu.Im.Cloud.Message.GroupFindType|null} [findWay] GroupJoinRequestGetResponse findWay
                     * @property {string|null} [descContent] GroupJoinRequestGetResponse descContent
                     * @property {AcFunDanmu.Im.Cloud.Message.JoinRequestStatus|null} [status] GroupJoinRequestGetResponse status
                     */

                    /**
                     * Constructs a new GroupJoinRequestGetResponse.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents a GroupJoinRequestGetResponse.
                     * @implements IGroupJoinRequestGetResponse
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupJoinRequestGetResponse=} [properties] Properties to set
                     */
                    function GroupJoinRequestGetResponse(properties) {
                        this.invitees = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * GroupJoinRequestGetResponse groupId.
                     * @member {string} groupId
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestGetResponse
                     * @instance
                     */
                    GroupJoinRequestGetResponse.prototype.groupId = "";

                    /**
                     * GroupJoinRequestGetResponse inviter.
                     * @member {AcFunDanmu.Im.Basic.IUser|null|undefined} inviter
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestGetResponse
                     * @instance
                     */
                    GroupJoinRequestGetResponse.prototype.inviter = null;

                    /**
                     * GroupJoinRequestGetResponse invitees.
                     * @member {Array.<AcFunDanmu.Im.Basic.IUser>} invitees
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestGetResponse
                     * @instance
                     */
                    GroupJoinRequestGetResponse.prototype.invitees = $util.emptyArray;

                    /**
                     * GroupJoinRequestGetResponse findWay.
                     * @member {AcFunDanmu.Im.Cloud.Message.GroupFindType} findWay
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestGetResponse
                     * @instance
                     */
                    GroupJoinRequestGetResponse.prototype.findWay = 0;

                    /**
                     * GroupJoinRequestGetResponse descContent.
                     * @member {string} descContent
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestGetResponse
                     * @instance
                     */
                    GroupJoinRequestGetResponse.prototype.descContent = "";

                    /**
                     * GroupJoinRequestGetResponse status.
                     * @member {AcFunDanmu.Im.Cloud.Message.JoinRequestStatus} status
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestGetResponse
                     * @instance
                     */
                    GroupJoinRequestGetResponse.prototype.status = 0;

                    /**
                     * Creates a new GroupJoinRequestGetResponse instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestGetResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupJoinRequestGetResponse=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupJoinRequestGetResponse} GroupJoinRequestGetResponse instance
                     */
                    GroupJoinRequestGetResponse.create = function create(properties) {
                        return new GroupJoinRequestGetResponse(properties);
                    };

                    /**
                     * Encodes the specified GroupJoinRequestGetResponse message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupJoinRequestGetResponse.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestGetResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupJoinRequestGetResponse} message GroupJoinRequestGetResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupJoinRequestGetResponse.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.groupId);
                        if (message.inviter != null && Object.hasOwnProperty.call(message, "inviter"))
                            $root.AcFunDanmu.Im.Basic.User.encode(message.inviter, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.invitees != null && message.invitees.length)
                            for (let i = 0; i < message.invitees.length; ++i)
                                $root.AcFunDanmu.Im.Basic.User.encode(message.invitees[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.findWay != null && Object.hasOwnProperty.call(message, "findWay"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.findWay);
                        if (message.descContent != null && Object.hasOwnProperty.call(message, "descContent"))
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.descContent);
                        if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                            writer.uint32(/* id 6, wireType 0 =*/48).int32(message.status);
                        return writer;
                    };

                    /**
                     * Encodes the specified GroupJoinRequestGetResponse message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupJoinRequestGetResponse.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestGetResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupJoinRequestGetResponse} message GroupJoinRequestGetResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupJoinRequestGetResponse.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a GroupJoinRequestGetResponse message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestGetResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupJoinRequestGetResponse} GroupJoinRequestGetResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupJoinRequestGetResponse.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.GroupJoinRequestGetResponse();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.groupId = reader.string();
                                break;
                            case 2:
                                message.inviter = $root.AcFunDanmu.Im.Basic.User.decode(reader, reader.uint32());
                                break;
                            case 3:
                                if (!(message.invitees && message.invitees.length))
                                    message.invitees = [];
                                message.invitees.push($root.AcFunDanmu.Im.Basic.User.decode(reader, reader.uint32()));
                                break;
                            case 4:
                                message.findWay = reader.int32();
                                break;
                            case 5:
                                message.descContent = reader.string();
                                break;
                            case 6:
                                message.status = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a GroupJoinRequestGetResponse message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestGetResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupJoinRequestGetResponse} GroupJoinRequestGetResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupJoinRequestGetResponse.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a GroupJoinRequestGetResponse message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestGetResponse
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GroupJoinRequestGetResponse.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.groupId != null && message.hasOwnProperty("groupId"))
                            if (!$util.isString(message.groupId))
                                return "groupId: string expected";
                        if (message.inviter != null && message.hasOwnProperty("inviter")) {
                            let error = $root.AcFunDanmu.Im.Basic.User.verify(message.inviter);
                            if (error)
                                return "inviter." + error;
                        }
                        if (message.invitees != null && message.hasOwnProperty("invitees")) {
                            if (!Array.isArray(message.invitees))
                                return "invitees: array expected";
                            for (let i = 0; i < message.invitees.length; ++i) {
                                let error = $root.AcFunDanmu.Im.Basic.User.verify(message.invitees[i]);
                                if (error)
                                    return "invitees." + error;
                            }
                        }
                        if (message.findWay != null && message.hasOwnProperty("findWay"))
                            switch (message.findWay) {
                            default:
                                return "findWay: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 6:
                                break;
                            }
                        if (message.descContent != null && message.hasOwnProperty("descContent"))
                            if (!$util.isString(message.descContent))
                                return "descContent: string expected";
                        if (message.status != null && message.hasOwnProperty("status"))
                            switch (message.status) {
                            default:
                                return "status: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                                break;
                            }
                        return null;
                    };

                    /**
                     * Creates a GroupJoinRequestGetResponse message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestGetResponse
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupJoinRequestGetResponse} GroupJoinRequestGetResponse
                     */
                    GroupJoinRequestGetResponse.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.GroupJoinRequestGetResponse)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Message.GroupJoinRequestGetResponse();
                        if (object.groupId != null)
                            message.groupId = String(object.groupId);
                        if (object.inviter != null) {
                            if (typeof object.inviter !== "object")
                                throw TypeError(".AcFunDanmu.Im.Cloud.Message.GroupJoinRequestGetResponse.inviter: object expected");
                            message.inviter = $root.AcFunDanmu.Im.Basic.User.fromObject(object.inviter);
                        }
                        if (object.invitees) {
                            if (!Array.isArray(object.invitees))
                                throw TypeError(".AcFunDanmu.Im.Cloud.Message.GroupJoinRequestGetResponse.invitees: array expected");
                            message.invitees = [];
                            for (let i = 0; i < object.invitees.length; ++i) {
                                if (typeof object.invitees[i] !== "object")
                                    throw TypeError(".AcFunDanmu.Im.Cloud.Message.GroupJoinRequestGetResponse.invitees: object expected");
                                message.invitees[i] = $root.AcFunDanmu.Im.Basic.User.fromObject(object.invitees[i]);
                            }
                        }
                        switch (object.findWay) {
                        case "BY_UNKNOWN":
                        case 0:
                            message.findWay = 0;
                            break;
                        case "BY_ID":
                        case 1:
                            message.findWay = 1;
                            break;
                        case "BY_NAME":
                        case 2:
                            message.findWay = 2;
                            break;
                        case "BY_QR_CODE":
                        case 3:
                            message.findWay = 3;
                            break;
                        case "BY_CARD":
                        case 4:
                            message.findWay = 4;
                            break;
                        case "BY_INVITATION":
                        case 5:
                            message.findWay = 5;
                            break;
                        case "BY_SHARE_LINK":
                        case 6:
                            message.findWay = 6;
                            break;
                        }
                        if (object.descContent != null)
                            message.descContent = String(object.descContent);
                        switch (object.status) {
                        case "UNKNOWN_STATUS":
                        case 0:
                            message.status = 0;
                            break;
                        case "REQUESTED":
                        case 1:
                            message.status = 1;
                            break;
                        case "APPROVED":
                        case 2:
                            message.status = 2;
                            break;
                        case "REFUSED":
                        case 3:
                            message.status = 3;
                            break;
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a GroupJoinRequestGetResponse message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestGetResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.GroupJoinRequestGetResponse} message GroupJoinRequestGetResponse
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GroupJoinRequestGetResponse.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.invitees = [];
                        if (options.defaults) {
                            object.groupId = "";
                            object.inviter = null;
                            object.findWay = options.enums === String ? "BY_UNKNOWN" : 0;
                            object.descContent = "";
                            object.status = options.enums === String ? "UNKNOWN_STATUS" : 0;
                        }
                        if (message.groupId != null && message.hasOwnProperty("groupId"))
                            object.groupId = message.groupId;
                        if (message.inviter != null && message.hasOwnProperty("inviter"))
                            object.inviter = $root.AcFunDanmu.Im.Basic.User.toObject(message.inviter, options);
                        if (message.invitees && message.invitees.length) {
                            object.invitees = [];
                            for (let j = 0; j < message.invitees.length; ++j)
                                object.invitees[j] = $root.AcFunDanmu.Im.Basic.User.toObject(message.invitees[j], options);
                        }
                        if (message.findWay != null && message.hasOwnProperty("findWay"))
                            object.findWay = options.enums === String ? $root.AcFunDanmu.Im.Cloud.Message.GroupFindType[message.findWay] : message.findWay;
                        if (message.descContent != null && message.hasOwnProperty("descContent"))
                            object.descContent = message.descContent;
                        if (message.status != null && message.hasOwnProperty("status"))
                            object.status = options.enums === String ? $root.AcFunDanmu.Im.Cloud.Message.JoinRequestStatus[message.status] : message.status;
                        return object;
                    };

                    /**
                     * Converts this GroupJoinRequestGetResponse to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestGetResponse
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GroupJoinRequestGetResponse.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return GroupJoinRequestGetResponse;
                })();

                Message.GroupJoinRequestCancelRequest = (function() {

                    /**
                     * Properties of a GroupJoinRequestCancelRequest.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface IGroupJoinRequestCancelRequest
                     * @property {number|Long|null} [reqSeq] GroupJoinRequestCancelRequest reqSeq
                     * @property {string|null} [groupId] GroupJoinRequestCancelRequest groupId
                     */

                    /**
                     * Constructs a new GroupJoinRequestCancelRequest.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents a GroupJoinRequestCancelRequest.
                     * @implements IGroupJoinRequestCancelRequest
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupJoinRequestCancelRequest=} [properties] Properties to set
                     */
                    function GroupJoinRequestCancelRequest(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * GroupJoinRequestCancelRequest reqSeq.
                     * @member {number|Long} reqSeq
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestCancelRequest
                     * @instance
                     */
                    GroupJoinRequestCancelRequest.prototype.reqSeq = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * GroupJoinRequestCancelRequest groupId.
                     * @member {string} groupId
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestCancelRequest
                     * @instance
                     */
                    GroupJoinRequestCancelRequest.prototype.groupId = "";

                    /**
                     * Creates a new GroupJoinRequestCancelRequest instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestCancelRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupJoinRequestCancelRequest=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupJoinRequestCancelRequest} GroupJoinRequestCancelRequest instance
                     */
                    GroupJoinRequestCancelRequest.create = function create(properties) {
                        return new GroupJoinRequestCancelRequest(properties);
                    };

                    /**
                     * Encodes the specified GroupJoinRequestCancelRequest message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupJoinRequestCancelRequest.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestCancelRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupJoinRequestCancelRequest} message GroupJoinRequestCancelRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupJoinRequestCancelRequest.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.reqSeq != null && Object.hasOwnProperty.call(message, "reqSeq"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.reqSeq);
                        if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.groupId);
                        return writer;
                    };

                    /**
                     * Encodes the specified GroupJoinRequestCancelRequest message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupJoinRequestCancelRequest.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestCancelRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupJoinRequestCancelRequest} message GroupJoinRequestCancelRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupJoinRequestCancelRequest.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a GroupJoinRequestCancelRequest message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestCancelRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupJoinRequestCancelRequest} GroupJoinRequestCancelRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupJoinRequestCancelRequest.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.GroupJoinRequestCancelRequest();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.reqSeq = reader.int64();
                                break;
                            case 2:
                                message.groupId = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a GroupJoinRequestCancelRequest message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestCancelRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupJoinRequestCancelRequest} GroupJoinRequestCancelRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupJoinRequestCancelRequest.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a GroupJoinRequestCancelRequest message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestCancelRequest
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GroupJoinRequestCancelRequest.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.reqSeq != null && message.hasOwnProperty("reqSeq"))
                            if (!$util.isInteger(message.reqSeq) && !(message.reqSeq && $util.isInteger(message.reqSeq.low) && $util.isInteger(message.reqSeq.high)))
                                return "reqSeq: integer|Long expected";
                        if (message.groupId != null && message.hasOwnProperty("groupId"))
                            if (!$util.isString(message.groupId))
                                return "groupId: string expected";
                        return null;
                    };

                    /**
                     * Creates a GroupJoinRequestCancelRequest message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestCancelRequest
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupJoinRequestCancelRequest} GroupJoinRequestCancelRequest
                     */
                    GroupJoinRequestCancelRequest.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.GroupJoinRequestCancelRequest)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Message.GroupJoinRequestCancelRequest();
                        if (object.reqSeq != null)
                            if ($util.Long)
                                (message.reqSeq = $util.Long.fromValue(object.reqSeq)).unsigned = false;
                            else if (typeof object.reqSeq === "string")
                                message.reqSeq = parseInt(object.reqSeq, 10);
                            else if (typeof object.reqSeq === "number")
                                message.reqSeq = object.reqSeq;
                            else if (typeof object.reqSeq === "object")
                                message.reqSeq = new $util.LongBits(object.reqSeq.low >>> 0, object.reqSeq.high >>> 0).toNumber();
                        if (object.groupId != null)
                            message.groupId = String(object.groupId);
                        return message;
                    };

                    /**
                     * Creates a plain object from a GroupJoinRequestCancelRequest message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestCancelRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.GroupJoinRequestCancelRequest} message GroupJoinRequestCancelRequest
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GroupJoinRequestCancelRequest.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, false);
                                object.reqSeq = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.reqSeq = options.longs === String ? "0" : 0;
                            object.groupId = "";
                        }
                        if (message.reqSeq != null && message.hasOwnProperty("reqSeq"))
                            if (typeof message.reqSeq === "number")
                                object.reqSeq = options.longs === String ? String(message.reqSeq) : message.reqSeq;
                            else
                                object.reqSeq = options.longs === String ? $util.Long.prototype.toString.call(message.reqSeq) : options.longs === Number ? new $util.LongBits(message.reqSeq.low >>> 0, message.reqSeq.high >>> 0).toNumber() : message.reqSeq;
                        if (message.groupId != null && message.hasOwnProperty("groupId"))
                            object.groupId = message.groupId;
                        return object;
                    };

                    /**
                     * Converts this GroupJoinRequestCancelRequest to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestCancelRequest
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GroupJoinRequestCancelRequest.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return GroupJoinRequestCancelRequest;
                })();

                Message.GroupJoinRequestCancelResposne = (function() {

                    /**
                     * Properties of a GroupJoinRequestCancelResposne.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface IGroupJoinRequestCancelResposne
                     * @property {string|null} [groupId] GroupJoinRequestCancelResposne groupId
                     * @property {AcFunDanmu.Im.Basic.IUser|null} [inviter] GroupJoinRequestCancelResposne inviter
                     * @property {Array.<AcFunDanmu.Im.Basic.IUser>|null} [invitees] GroupJoinRequestCancelResposne invitees
                     * @property {AcFunDanmu.Im.Cloud.Message.GroupFindType|null} [findWay] GroupJoinRequestCancelResposne findWay
                     * @property {string|null} [descContent] GroupJoinRequestCancelResposne descContent
                     * @property {AcFunDanmu.Im.Cloud.Message.JoinRequestStatus|null} [status] GroupJoinRequestCancelResposne status
                     */

                    /**
                     * Constructs a new GroupJoinRequestCancelResposne.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents a GroupJoinRequestCancelResposne.
                     * @implements IGroupJoinRequestCancelResposne
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupJoinRequestCancelResposne=} [properties] Properties to set
                     */
                    function GroupJoinRequestCancelResposne(properties) {
                        this.invitees = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * GroupJoinRequestCancelResposne groupId.
                     * @member {string} groupId
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestCancelResposne
                     * @instance
                     */
                    GroupJoinRequestCancelResposne.prototype.groupId = "";

                    /**
                     * GroupJoinRequestCancelResposne inviter.
                     * @member {AcFunDanmu.Im.Basic.IUser|null|undefined} inviter
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestCancelResposne
                     * @instance
                     */
                    GroupJoinRequestCancelResposne.prototype.inviter = null;

                    /**
                     * GroupJoinRequestCancelResposne invitees.
                     * @member {Array.<AcFunDanmu.Im.Basic.IUser>} invitees
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestCancelResposne
                     * @instance
                     */
                    GroupJoinRequestCancelResposne.prototype.invitees = $util.emptyArray;

                    /**
                     * GroupJoinRequestCancelResposne findWay.
                     * @member {AcFunDanmu.Im.Cloud.Message.GroupFindType} findWay
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestCancelResposne
                     * @instance
                     */
                    GroupJoinRequestCancelResposne.prototype.findWay = 0;

                    /**
                     * GroupJoinRequestCancelResposne descContent.
                     * @member {string} descContent
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestCancelResposne
                     * @instance
                     */
                    GroupJoinRequestCancelResposne.prototype.descContent = "";

                    /**
                     * GroupJoinRequestCancelResposne status.
                     * @member {AcFunDanmu.Im.Cloud.Message.JoinRequestStatus} status
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestCancelResposne
                     * @instance
                     */
                    GroupJoinRequestCancelResposne.prototype.status = 0;

                    /**
                     * Creates a new GroupJoinRequestCancelResposne instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestCancelResposne
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupJoinRequestCancelResposne=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupJoinRequestCancelResposne} GroupJoinRequestCancelResposne instance
                     */
                    GroupJoinRequestCancelResposne.create = function create(properties) {
                        return new GroupJoinRequestCancelResposne(properties);
                    };

                    /**
                     * Encodes the specified GroupJoinRequestCancelResposne message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupJoinRequestCancelResposne.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestCancelResposne
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupJoinRequestCancelResposne} message GroupJoinRequestCancelResposne message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupJoinRequestCancelResposne.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.groupId);
                        if (message.inviter != null && Object.hasOwnProperty.call(message, "inviter"))
                            $root.AcFunDanmu.Im.Basic.User.encode(message.inviter, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.invitees != null && message.invitees.length)
                            for (let i = 0; i < message.invitees.length; ++i)
                                $root.AcFunDanmu.Im.Basic.User.encode(message.invitees[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.findWay != null && Object.hasOwnProperty.call(message, "findWay"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.findWay);
                        if (message.descContent != null && Object.hasOwnProperty.call(message, "descContent"))
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.descContent);
                        if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                            writer.uint32(/* id 6, wireType 0 =*/48).int32(message.status);
                        return writer;
                    };

                    /**
                     * Encodes the specified GroupJoinRequestCancelResposne message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupJoinRequestCancelResposne.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestCancelResposne
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupJoinRequestCancelResposne} message GroupJoinRequestCancelResposne message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupJoinRequestCancelResposne.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a GroupJoinRequestCancelResposne message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestCancelResposne
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupJoinRequestCancelResposne} GroupJoinRequestCancelResposne
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupJoinRequestCancelResposne.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.GroupJoinRequestCancelResposne();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.groupId = reader.string();
                                break;
                            case 2:
                                message.inviter = $root.AcFunDanmu.Im.Basic.User.decode(reader, reader.uint32());
                                break;
                            case 3:
                                if (!(message.invitees && message.invitees.length))
                                    message.invitees = [];
                                message.invitees.push($root.AcFunDanmu.Im.Basic.User.decode(reader, reader.uint32()));
                                break;
                            case 4:
                                message.findWay = reader.int32();
                                break;
                            case 5:
                                message.descContent = reader.string();
                                break;
                            case 6:
                                message.status = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a GroupJoinRequestCancelResposne message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestCancelResposne
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupJoinRequestCancelResposne} GroupJoinRequestCancelResposne
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupJoinRequestCancelResposne.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a GroupJoinRequestCancelResposne message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestCancelResposne
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GroupJoinRequestCancelResposne.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.groupId != null && message.hasOwnProperty("groupId"))
                            if (!$util.isString(message.groupId))
                                return "groupId: string expected";
                        if (message.inviter != null && message.hasOwnProperty("inviter")) {
                            let error = $root.AcFunDanmu.Im.Basic.User.verify(message.inviter);
                            if (error)
                                return "inviter." + error;
                        }
                        if (message.invitees != null && message.hasOwnProperty("invitees")) {
                            if (!Array.isArray(message.invitees))
                                return "invitees: array expected";
                            for (let i = 0; i < message.invitees.length; ++i) {
                                let error = $root.AcFunDanmu.Im.Basic.User.verify(message.invitees[i]);
                                if (error)
                                    return "invitees." + error;
                            }
                        }
                        if (message.findWay != null && message.hasOwnProperty("findWay"))
                            switch (message.findWay) {
                            default:
                                return "findWay: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 6:
                                break;
                            }
                        if (message.descContent != null && message.hasOwnProperty("descContent"))
                            if (!$util.isString(message.descContent))
                                return "descContent: string expected";
                        if (message.status != null && message.hasOwnProperty("status"))
                            switch (message.status) {
                            default:
                                return "status: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                                break;
                            }
                        return null;
                    };

                    /**
                     * Creates a GroupJoinRequestCancelResposne message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestCancelResposne
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupJoinRequestCancelResposne} GroupJoinRequestCancelResposne
                     */
                    GroupJoinRequestCancelResposne.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.GroupJoinRequestCancelResposne)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Message.GroupJoinRequestCancelResposne();
                        if (object.groupId != null)
                            message.groupId = String(object.groupId);
                        if (object.inviter != null) {
                            if (typeof object.inviter !== "object")
                                throw TypeError(".AcFunDanmu.Im.Cloud.Message.GroupJoinRequestCancelResposne.inviter: object expected");
                            message.inviter = $root.AcFunDanmu.Im.Basic.User.fromObject(object.inviter);
                        }
                        if (object.invitees) {
                            if (!Array.isArray(object.invitees))
                                throw TypeError(".AcFunDanmu.Im.Cloud.Message.GroupJoinRequestCancelResposne.invitees: array expected");
                            message.invitees = [];
                            for (let i = 0; i < object.invitees.length; ++i) {
                                if (typeof object.invitees[i] !== "object")
                                    throw TypeError(".AcFunDanmu.Im.Cloud.Message.GroupJoinRequestCancelResposne.invitees: object expected");
                                message.invitees[i] = $root.AcFunDanmu.Im.Basic.User.fromObject(object.invitees[i]);
                            }
                        }
                        switch (object.findWay) {
                        case "BY_UNKNOWN":
                        case 0:
                            message.findWay = 0;
                            break;
                        case "BY_ID":
                        case 1:
                            message.findWay = 1;
                            break;
                        case "BY_NAME":
                        case 2:
                            message.findWay = 2;
                            break;
                        case "BY_QR_CODE":
                        case 3:
                            message.findWay = 3;
                            break;
                        case "BY_CARD":
                        case 4:
                            message.findWay = 4;
                            break;
                        case "BY_INVITATION":
                        case 5:
                            message.findWay = 5;
                            break;
                        case "BY_SHARE_LINK":
                        case 6:
                            message.findWay = 6;
                            break;
                        }
                        if (object.descContent != null)
                            message.descContent = String(object.descContent);
                        switch (object.status) {
                        case "UNKNOWN_STATUS":
                        case 0:
                            message.status = 0;
                            break;
                        case "REQUESTED":
                        case 1:
                            message.status = 1;
                            break;
                        case "APPROVED":
                        case 2:
                            message.status = 2;
                            break;
                        case "REFUSED":
                        case 3:
                            message.status = 3;
                            break;
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a GroupJoinRequestCancelResposne message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestCancelResposne
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.GroupJoinRequestCancelResposne} message GroupJoinRequestCancelResposne
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GroupJoinRequestCancelResposne.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.invitees = [];
                        if (options.defaults) {
                            object.groupId = "";
                            object.inviter = null;
                            object.findWay = options.enums === String ? "BY_UNKNOWN" : 0;
                            object.descContent = "";
                            object.status = options.enums === String ? "UNKNOWN_STATUS" : 0;
                        }
                        if (message.groupId != null && message.hasOwnProperty("groupId"))
                            object.groupId = message.groupId;
                        if (message.inviter != null && message.hasOwnProperty("inviter"))
                            object.inviter = $root.AcFunDanmu.Im.Basic.User.toObject(message.inviter, options);
                        if (message.invitees && message.invitees.length) {
                            object.invitees = [];
                            for (let j = 0; j < message.invitees.length; ++j)
                                object.invitees[j] = $root.AcFunDanmu.Im.Basic.User.toObject(message.invitees[j], options);
                        }
                        if (message.findWay != null && message.hasOwnProperty("findWay"))
                            object.findWay = options.enums === String ? $root.AcFunDanmu.Im.Cloud.Message.GroupFindType[message.findWay] : message.findWay;
                        if (message.descContent != null && message.hasOwnProperty("descContent"))
                            object.descContent = message.descContent;
                        if (message.status != null && message.hasOwnProperty("status"))
                            object.status = options.enums === String ? $root.AcFunDanmu.Im.Cloud.Message.JoinRequestStatus[message.status] : message.status;
                        return object;
                    };

                    /**
                     * Converts this GroupJoinRequestCancelResposne to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupJoinRequestCancelResposne
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GroupJoinRequestCancelResposne.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return GroupJoinRequestCancelResposne;
                })();

                /**
                 * JoinRequestStatus enum.
                 * @name AcFunDanmu.Im.Cloud.Message.JoinRequestStatus
                 * @enum {number}
                 * @property {number} UNKNOWN_STATUS=0 UNKNOWN_STATUS value
                 * @property {number} REQUESTED=1 REQUESTED value
                 * @property {number} APPROVED=2 APPROVED value
                 * @property {number} REFUSED=3 REFUSED value
                 */
                Message.JoinRequestStatus = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "UNKNOWN_STATUS"] = 0;
                    values[valuesById[1] = "REQUESTED"] = 1;
                    values[valuesById[2] = "APPROVED"] = 2;
                    values[valuesById[3] = "REFUSED"] = 3;
                    return values;
                })();

                Message.GroupQuitRequest = (function() {

                    /**
                     * Properties of a GroupQuitRequest.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface IGroupQuitRequest
                     * @property {string|null} [groupId] GroupQuitRequest groupId
                     */

                    /**
                     * Constructs a new GroupQuitRequest.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents a GroupQuitRequest.
                     * @implements IGroupQuitRequest
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupQuitRequest=} [properties] Properties to set
                     */
                    function GroupQuitRequest(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * GroupQuitRequest groupId.
                     * @member {string} groupId
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupQuitRequest
                     * @instance
                     */
                    GroupQuitRequest.prototype.groupId = "";

                    /**
                     * Creates a new GroupQuitRequest instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupQuitRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupQuitRequest=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupQuitRequest} GroupQuitRequest instance
                     */
                    GroupQuitRequest.create = function create(properties) {
                        return new GroupQuitRequest(properties);
                    };

                    /**
                     * Encodes the specified GroupQuitRequest message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupQuitRequest.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupQuitRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupQuitRequest} message GroupQuitRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupQuitRequest.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.groupId);
                        return writer;
                    };

                    /**
                     * Encodes the specified GroupQuitRequest message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupQuitRequest.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupQuitRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupQuitRequest} message GroupQuitRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupQuitRequest.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a GroupQuitRequest message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupQuitRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupQuitRequest} GroupQuitRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupQuitRequest.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.GroupQuitRequest();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.groupId = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a GroupQuitRequest message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupQuitRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupQuitRequest} GroupQuitRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupQuitRequest.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a GroupQuitRequest message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupQuitRequest
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GroupQuitRequest.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.groupId != null && message.hasOwnProperty("groupId"))
                            if (!$util.isString(message.groupId))
                                return "groupId: string expected";
                        return null;
                    };

                    /**
                     * Creates a GroupQuitRequest message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupQuitRequest
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupQuitRequest} GroupQuitRequest
                     */
                    GroupQuitRequest.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.GroupQuitRequest)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Message.GroupQuitRequest();
                        if (object.groupId != null)
                            message.groupId = String(object.groupId);
                        return message;
                    };

                    /**
                     * Creates a plain object from a GroupQuitRequest message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupQuitRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.GroupQuitRequest} message GroupQuitRequest
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GroupQuitRequest.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.groupId = "";
                        if (message.groupId != null && message.hasOwnProperty("groupId"))
                            object.groupId = message.groupId;
                        return object;
                    };

                    /**
                     * Converts this GroupQuitRequest to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupQuitRequest
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GroupQuitRequest.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return GroupQuitRequest;
                })();

                Message.GroupQuitResponse = (function() {

                    /**
                     * Properties of a GroupQuitResponse.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface IGroupQuitResponse
                     * @property {string|null} [groupId] GroupQuitResponse groupId
                     */

                    /**
                     * Constructs a new GroupQuitResponse.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents a GroupQuitResponse.
                     * @implements IGroupQuitResponse
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupQuitResponse=} [properties] Properties to set
                     */
                    function GroupQuitResponse(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * GroupQuitResponse groupId.
                     * @member {string} groupId
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupQuitResponse
                     * @instance
                     */
                    GroupQuitResponse.prototype.groupId = "";

                    /**
                     * Creates a new GroupQuitResponse instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupQuitResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupQuitResponse=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupQuitResponse} GroupQuitResponse instance
                     */
                    GroupQuitResponse.create = function create(properties) {
                        return new GroupQuitResponse(properties);
                    };

                    /**
                     * Encodes the specified GroupQuitResponse message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupQuitResponse.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupQuitResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupQuitResponse} message GroupQuitResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupQuitResponse.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.groupId);
                        return writer;
                    };

                    /**
                     * Encodes the specified GroupQuitResponse message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupQuitResponse.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupQuitResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupQuitResponse} message GroupQuitResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupQuitResponse.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a GroupQuitResponse message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupQuitResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupQuitResponse} GroupQuitResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupQuitResponse.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.GroupQuitResponse();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.groupId = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a GroupQuitResponse message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupQuitResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupQuitResponse} GroupQuitResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupQuitResponse.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a GroupQuitResponse message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupQuitResponse
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GroupQuitResponse.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.groupId != null && message.hasOwnProperty("groupId"))
                            if (!$util.isString(message.groupId))
                                return "groupId: string expected";
                        return null;
                    };

                    /**
                     * Creates a GroupQuitResponse message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupQuitResponse
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupQuitResponse} GroupQuitResponse
                     */
                    GroupQuitResponse.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.GroupQuitResponse)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Message.GroupQuitResponse();
                        if (object.groupId != null)
                            message.groupId = String(object.groupId);
                        return message;
                    };

                    /**
                     * Creates a plain object from a GroupQuitResponse message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupQuitResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.GroupQuitResponse} message GroupQuitResponse
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GroupQuitResponse.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.groupId = "";
                        if (message.groupId != null && message.hasOwnProperty("groupId"))
                            object.groupId = message.groupId;
                        return object;
                    };

                    /**
                     * Converts this GroupQuitResponse to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupQuitResponse
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GroupQuitResponse.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return GroupQuitResponse;
                })();

                Message.GroupKickRequest = (function() {

                    /**
                     * Properties of a GroupKickRequest.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface IGroupKickRequest
                     * @property {string|null} [groupId] GroupKickRequest groupId
                     * @property {Array.<AcFunDanmu.Im.Basic.IUser>|null} [target] GroupKickRequest target
                     */

                    /**
                     * Constructs a new GroupKickRequest.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents a GroupKickRequest.
                     * @implements IGroupKickRequest
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupKickRequest=} [properties] Properties to set
                     */
                    function GroupKickRequest(properties) {
                        this.target = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * GroupKickRequest groupId.
                     * @member {string} groupId
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupKickRequest
                     * @instance
                     */
                    GroupKickRequest.prototype.groupId = "";

                    /**
                     * GroupKickRequest target.
                     * @member {Array.<AcFunDanmu.Im.Basic.IUser>} target
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupKickRequest
                     * @instance
                     */
                    GroupKickRequest.prototype.target = $util.emptyArray;

                    /**
                     * Creates a new GroupKickRequest instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupKickRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupKickRequest=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupKickRequest} GroupKickRequest instance
                     */
                    GroupKickRequest.create = function create(properties) {
                        return new GroupKickRequest(properties);
                    };

                    /**
                     * Encodes the specified GroupKickRequest message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupKickRequest.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupKickRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupKickRequest} message GroupKickRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupKickRequest.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.groupId);
                        if (message.target != null && message.target.length)
                            for (let i = 0; i < message.target.length; ++i)
                                $root.AcFunDanmu.Im.Basic.User.encode(message.target[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified GroupKickRequest message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupKickRequest.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupKickRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupKickRequest} message GroupKickRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupKickRequest.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a GroupKickRequest message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupKickRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupKickRequest} GroupKickRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupKickRequest.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.GroupKickRequest();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.groupId = reader.string();
                                break;
                            case 2:
                                if (!(message.target && message.target.length))
                                    message.target = [];
                                message.target.push($root.AcFunDanmu.Im.Basic.User.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a GroupKickRequest message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupKickRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupKickRequest} GroupKickRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupKickRequest.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a GroupKickRequest message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupKickRequest
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GroupKickRequest.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.groupId != null && message.hasOwnProperty("groupId"))
                            if (!$util.isString(message.groupId))
                                return "groupId: string expected";
                        if (message.target != null && message.hasOwnProperty("target")) {
                            if (!Array.isArray(message.target))
                                return "target: array expected";
                            for (let i = 0; i < message.target.length; ++i) {
                                let error = $root.AcFunDanmu.Im.Basic.User.verify(message.target[i]);
                                if (error)
                                    return "target." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a GroupKickRequest message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupKickRequest
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupKickRequest} GroupKickRequest
                     */
                    GroupKickRequest.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.GroupKickRequest)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Message.GroupKickRequest();
                        if (object.groupId != null)
                            message.groupId = String(object.groupId);
                        if (object.target) {
                            if (!Array.isArray(object.target))
                                throw TypeError(".AcFunDanmu.Im.Cloud.Message.GroupKickRequest.target: array expected");
                            message.target = [];
                            for (let i = 0; i < object.target.length; ++i) {
                                if (typeof object.target[i] !== "object")
                                    throw TypeError(".AcFunDanmu.Im.Cloud.Message.GroupKickRequest.target: object expected");
                                message.target[i] = $root.AcFunDanmu.Im.Basic.User.fromObject(object.target[i]);
                            }
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a GroupKickRequest message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupKickRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.GroupKickRequest} message GroupKickRequest
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GroupKickRequest.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.target = [];
                        if (options.defaults)
                            object.groupId = "";
                        if (message.groupId != null && message.hasOwnProperty("groupId"))
                            object.groupId = message.groupId;
                        if (message.target && message.target.length) {
                            object.target = [];
                            for (let j = 0; j < message.target.length; ++j)
                                object.target[j] = $root.AcFunDanmu.Im.Basic.User.toObject(message.target[j], options);
                        }
                        return object;
                    };

                    /**
                     * Converts this GroupKickRequest to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupKickRequest
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GroupKickRequest.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return GroupKickRequest;
                })();

                Message.GroupKickResponse = (function() {

                    /**
                     * Properties of a GroupKickResponse.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface IGroupKickResponse
                     * @property {string|null} [groupId] GroupKickResponse groupId
                     */

                    /**
                     * Constructs a new GroupKickResponse.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents a GroupKickResponse.
                     * @implements IGroupKickResponse
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupKickResponse=} [properties] Properties to set
                     */
                    function GroupKickResponse(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * GroupKickResponse groupId.
                     * @member {string} groupId
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupKickResponse
                     * @instance
                     */
                    GroupKickResponse.prototype.groupId = "";

                    /**
                     * Creates a new GroupKickResponse instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupKickResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupKickResponse=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupKickResponse} GroupKickResponse instance
                     */
                    GroupKickResponse.create = function create(properties) {
                        return new GroupKickResponse(properties);
                    };

                    /**
                     * Encodes the specified GroupKickResponse message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupKickResponse.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupKickResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupKickResponse} message GroupKickResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupKickResponse.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.groupId);
                        return writer;
                    };

                    /**
                     * Encodes the specified GroupKickResponse message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupKickResponse.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupKickResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupKickResponse} message GroupKickResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupKickResponse.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a GroupKickResponse message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupKickResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupKickResponse} GroupKickResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupKickResponse.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.GroupKickResponse();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.groupId = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a GroupKickResponse message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupKickResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupKickResponse} GroupKickResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupKickResponse.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a GroupKickResponse message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupKickResponse
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GroupKickResponse.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.groupId != null && message.hasOwnProperty("groupId"))
                            if (!$util.isString(message.groupId))
                                return "groupId: string expected";
                        return null;
                    };

                    /**
                     * Creates a GroupKickResponse message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupKickResponse
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupKickResponse} GroupKickResponse
                     */
                    GroupKickResponse.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.GroupKickResponse)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Message.GroupKickResponse();
                        if (object.groupId != null)
                            message.groupId = String(object.groupId);
                        return message;
                    };

                    /**
                     * Creates a plain object from a GroupKickResponse message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupKickResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.GroupKickResponse} message GroupKickResponse
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GroupKickResponse.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.groupId = "";
                        if (message.groupId != null && message.hasOwnProperty("groupId"))
                            object.groupId = message.groupId;
                        return object;
                    };

                    /**
                     * Converts this GroupKickResponse to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupKickResponse
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GroupKickResponse.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return GroupKickResponse;
                })();

                Message.GroupSettingRequest = (function() {

                    /**
                     * Properties of a GroupSettingRequest.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface IGroupSettingRequest
                     * @property {string|null} [groupId] GroupSettingRequest groupId
                     * @property {AcFunDanmu.Im.Cloud.Message.IGroupSettingRename|null} [rename] GroupSettingRequest rename
                     * @property {AcFunDanmu.Im.Cloud.Message.IGroupSettingDesc|null} [desc] GroupSettingRequest desc
                     * @property {AcFunDanmu.Im.Cloud.Message.IGroupSettingJoinNeedPermission|null} [joinNeedPermission] GroupSettingRequest joinNeedPermission
                     * @property {AcFunDanmu.Im.Cloud.Message.IGroupSettingInvitePermission|null} [invitePermission] GroupSettingRequest invitePermission
                     */

                    /**
                     * Constructs a new GroupSettingRequest.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents a GroupSettingRequest.
                     * @implements IGroupSettingRequest
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupSettingRequest=} [properties] Properties to set
                     */
                    function GroupSettingRequest(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * GroupSettingRequest groupId.
                     * @member {string} groupId
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingRequest
                     * @instance
                     */
                    GroupSettingRequest.prototype.groupId = "";

                    /**
                     * GroupSettingRequest rename.
                     * @member {AcFunDanmu.Im.Cloud.Message.IGroupSettingRename|null|undefined} rename
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingRequest
                     * @instance
                     */
                    GroupSettingRequest.prototype.rename = null;

                    /**
                     * GroupSettingRequest desc.
                     * @member {AcFunDanmu.Im.Cloud.Message.IGroupSettingDesc|null|undefined} desc
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingRequest
                     * @instance
                     */
                    GroupSettingRequest.prototype.desc = null;

                    /**
                     * GroupSettingRequest joinNeedPermission.
                     * @member {AcFunDanmu.Im.Cloud.Message.IGroupSettingJoinNeedPermission|null|undefined} joinNeedPermission
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingRequest
                     * @instance
                     */
                    GroupSettingRequest.prototype.joinNeedPermission = null;

                    /**
                     * GroupSettingRequest invitePermission.
                     * @member {AcFunDanmu.Im.Cloud.Message.IGroupSettingInvitePermission|null|undefined} invitePermission
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingRequest
                     * @instance
                     */
                    GroupSettingRequest.prototype.invitePermission = null;

                    // OneOf field names bound to virtual getters and setters
                    let $oneOfFields;

                    /**
                     * GroupSettingRequest GroupSetting.
                     * @member {"rename"|"desc"|"joinNeedPermission"|"invitePermission"|undefined} GroupSetting
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingRequest
                     * @instance
                     */
                    Object.defineProperty(GroupSettingRequest.prototype, "GroupSetting", {
                        get: $util.oneOfGetter($oneOfFields = ["rename", "desc", "joinNeedPermission", "invitePermission"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });

                    /**
                     * Creates a new GroupSettingRequest instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupSettingRequest=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupSettingRequest} GroupSettingRequest instance
                     */
                    GroupSettingRequest.create = function create(properties) {
                        return new GroupSettingRequest(properties);
                    };

                    /**
                     * Encodes the specified GroupSettingRequest message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupSettingRequest.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupSettingRequest} message GroupSettingRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupSettingRequest.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.groupId);
                        if (message.rename != null && Object.hasOwnProperty.call(message, "rename"))
                            $root.AcFunDanmu.Im.Cloud.Message.GroupSettingRename.encode(message.rename, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.desc != null && Object.hasOwnProperty.call(message, "desc"))
                            $root.AcFunDanmu.Im.Cloud.Message.GroupSettingDesc.encode(message.desc, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.joinNeedPermission != null && Object.hasOwnProperty.call(message, "joinNeedPermission"))
                            $root.AcFunDanmu.Im.Cloud.Message.GroupSettingJoinNeedPermission.encode(message.joinNeedPermission, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                        if (message.invitePermission != null && Object.hasOwnProperty.call(message, "invitePermission"))
                            $root.AcFunDanmu.Im.Cloud.Message.GroupSettingInvitePermission.encode(message.invitePermission, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified GroupSettingRequest message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupSettingRequest.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupSettingRequest} message GroupSettingRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupSettingRequest.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a GroupSettingRequest message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupSettingRequest} GroupSettingRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupSettingRequest.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.GroupSettingRequest();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.groupId = reader.string();
                                break;
                            case 2:
                                message.rename = $root.AcFunDanmu.Im.Cloud.Message.GroupSettingRename.decode(reader, reader.uint32());
                                break;
                            case 3:
                                message.desc = $root.AcFunDanmu.Im.Cloud.Message.GroupSettingDesc.decode(reader, reader.uint32());
                                break;
                            case 4:
                                message.joinNeedPermission = $root.AcFunDanmu.Im.Cloud.Message.GroupSettingJoinNeedPermission.decode(reader, reader.uint32());
                                break;
                            case 5:
                                message.invitePermission = $root.AcFunDanmu.Im.Cloud.Message.GroupSettingInvitePermission.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a GroupSettingRequest message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupSettingRequest} GroupSettingRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupSettingRequest.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a GroupSettingRequest message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingRequest
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GroupSettingRequest.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        let properties = {};
                        if (message.groupId != null && message.hasOwnProperty("groupId"))
                            if (!$util.isString(message.groupId))
                                return "groupId: string expected";
                        if (message.rename != null && message.hasOwnProperty("rename")) {
                            properties.GroupSetting = 1;
                            {
                                let error = $root.AcFunDanmu.Im.Cloud.Message.GroupSettingRename.verify(message.rename);
                                if (error)
                                    return "rename." + error;
                            }
                        }
                        if (message.desc != null && message.hasOwnProperty("desc")) {
                            if (properties.GroupSetting === 1)
                                return "GroupSetting: multiple values";
                            properties.GroupSetting = 1;
                            {
                                let error = $root.AcFunDanmu.Im.Cloud.Message.GroupSettingDesc.verify(message.desc);
                                if (error)
                                    return "desc." + error;
                            }
                        }
                        if (message.joinNeedPermission != null && message.hasOwnProperty("joinNeedPermission")) {
                            if (properties.GroupSetting === 1)
                                return "GroupSetting: multiple values";
                            properties.GroupSetting = 1;
                            {
                                let error = $root.AcFunDanmu.Im.Cloud.Message.GroupSettingJoinNeedPermission.verify(message.joinNeedPermission);
                                if (error)
                                    return "joinNeedPermission." + error;
                            }
                        }
                        if (message.invitePermission != null && message.hasOwnProperty("invitePermission")) {
                            if (properties.GroupSetting === 1)
                                return "GroupSetting: multiple values";
                            properties.GroupSetting = 1;
                            {
                                let error = $root.AcFunDanmu.Im.Cloud.Message.GroupSettingInvitePermission.verify(message.invitePermission);
                                if (error)
                                    return "invitePermission." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a GroupSettingRequest message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingRequest
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupSettingRequest} GroupSettingRequest
                     */
                    GroupSettingRequest.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.GroupSettingRequest)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Message.GroupSettingRequest();
                        if (object.groupId != null)
                            message.groupId = String(object.groupId);
                        if (object.rename != null) {
                            if (typeof object.rename !== "object")
                                throw TypeError(".AcFunDanmu.Im.Cloud.Message.GroupSettingRequest.rename: object expected");
                            message.rename = $root.AcFunDanmu.Im.Cloud.Message.GroupSettingRename.fromObject(object.rename);
                        }
                        if (object.desc != null) {
                            if (typeof object.desc !== "object")
                                throw TypeError(".AcFunDanmu.Im.Cloud.Message.GroupSettingRequest.desc: object expected");
                            message.desc = $root.AcFunDanmu.Im.Cloud.Message.GroupSettingDesc.fromObject(object.desc);
                        }
                        if (object.joinNeedPermission != null) {
                            if (typeof object.joinNeedPermission !== "object")
                                throw TypeError(".AcFunDanmu.Im.Cloud.Message.GroupSettingRequest.joinNeedPermission: object expected");
                            message.joinNeedPermission = $root.AcFunDanmu.Im.Cloud.Message.GroupSettingJoinNeedPermission.fromObject(object.joinNeedPermission);
                        }
                        if (object.invitePermission != null) {
                            if (typeof object.invitePermission !== "object")
                                throw TypeError(".AcFunDanmu.Im.Cloud.Message.GroupSettingRequest.invitePermission: object expected");
                            message.invitePermission = $root.AcFunDanmu.Im.Cloud.Message.GroupSettingInvitePermission.fromObject(object.invitePermission);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a GroupSettingRequest message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.GroupSettingRequest} message GroupSettingRequest
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GroupSettingRequest.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.groupId = "";
                        if (message.groupId != null && message.hasOwnProperty("groupId"))
                            object.groupId = message.groupId;
                        if (message.rename != null && message.hasOwnProperty("rename")) {
                            object.rename = $root.AcFunDanmu.Im.Cloud.Message.GroupSettingRename.toObject(message.rename, options);
                            if (options.oneofs)
                                object.GroupSetting = "rename";
                        }
                        if (message.desc != null && message.hasOwnProperty("desc")) {
                            object.desc = $root.AcFunDanmu.Im.Cloud.Message.GroupSettingDesc.toObject(message.desc, options);
                            if (options.oneofs)
                                object.GroupSetting = "desc";
                        }
                        if (message.joinNeedPermission != null && message.hasOwnProperty("joinNeedPermission")) {
                            object.joinNeedPermission = $root.AcFunDanmu.Im.Cloud.Message.GroupSettingJoinNeedPermission.toObject(message.joinNeedPermission, options);
                            if (options.oneofs)
                                object.GroupSetting = "joinNeedPermission";
                        }
                        if (message.invitePermission != null && message.hasOwnProperty("invitePermission")) {
                            object.invitePermission = $root.AcFunDanmu.Im.Cloud.Message.GroupSettingInvitePermission.toObject(message.invitePermission, options);
                            if (options.oneofs)
                                object.GroupSetting = "invitePermission";
                        }
                        return object;
                    };

                    /**
                     * Converts this GroupSettingRequest to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingRequest
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GroupSettingRequest.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return GroupSettingRequest;
                })();

                Message.GroupSettingRename = (function() {

                    /**
                     * Properties of a GroupSettingRename.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface IGroupSettingRename
                     * @property {string|null} [groupName] GroupSettingRename groupName
                     */

                    /**
                     * Constructs a new GroupSettingRename.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents a GroupSettingRename.
                     * @implements IGroupSettingRename
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupSettingRename=} [properties] Properties to set
                     */
                    function GroupSettingRename(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * GroupSettingRename groupName.
                     * @member {string} groupName
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingRename
                     * @instance
                     */
                    GroupSettingRename.prototype.groupName = "";

                    /**
                     * Creates a new GroupSettingRename instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingRename
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupSettingRename=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupSettingRename} GroupSettingRename instance
                     */
                    GroupSettingRename.create = function create(properties) {
                        return new GroupSettingRename(properties);
                    };

                    /**
                     * Encodes the specified GroupSettingRename message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupSettingRename.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingRename
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupSettingRename} message GroupSettingRename message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupSettingRename.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.groupName != null && Object.hasOwnProperty.call(message, "groupName"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.groupName);
                        return writer;
                    };

                    /**
                     * Encodes the specified GroupSettingRename message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupSettingRename.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingRename
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupSettingRename} message GroupSettingRename message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupSettingRename.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a GroupSettingRename message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingRename
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupSettingRename} GroupSettingRename
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupSettingRename.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.GroupSettingRename();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.groupName = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a GroupSettingRename message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingRename
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupSettingRename} GroupSettingRename
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupSettingRename.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a GroupSettingRename message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingRename
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GroupSettingRename.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.groupName != null && message.hasOwnProperty("groupName"))
                            if (!$util.isString(message.groupName))
                                return "groupName: string expected";
                        return null;
                    };

                    /**
                     * Creates a GroupSettingRename message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingRename
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupSettingRename} GroupSettingRename
                     */
                    GroupSettingRename.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.GroupSettingRename)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Message.GroupSettingRename();
                        if (object.groupName != null)
                            message.groupName = String(object.groupName);
                        return message;
                    };

                    /**
                     * Creates a plain object from a GroupSettingRename message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingRename
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.GroupSettingRename} message GroupSettingRename
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GroupSettingRename.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.groupName = "";
                        if (message.groupName != null && message.hasOwnProperty("groupName"))
                            object.groupName = message.groupName;
                        return object;
                    };

                    /**
                     * Converts this GroupSettingRename to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingRename
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GroupSettingRename.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return GroupSettingRename;
                })();

                Message.GroupSettingDesc = (function() {

                    /**
                     * Properties of a GroupSettingDesc.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface IGroupSettingDesc
                     * @property {string|null} [desc] GroupSettingDesc desc
                     */

                    /**
                     * Constructs a new GroupSettingDesc.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents a GroupSettingDesc.
                     * @implements IGroupSettingDesc
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupSettingDesc=} [properties] Properties to set
                     */
                    function GroupSettingDesc(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * GroupSettingDesc desc.
                     * @member {string} desc
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingDesc
                     * @instance
                     */
                    GroupSettingDesc.prototype.desc = "";

                    /**
                     * Creates a new GroupSettingDesc instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingDesc
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupSettingDesc=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupSettingDesc} GroupSettingDesc instance
                     */
                    GroupSettingDesc.create = function create(properties) {
                        return new GroupSettingDesc(properties);
                    };

                    /**
                     * Encodes the specified GroupSettingDesc message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupSettingDesc.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingDesc
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupSettingDesc} message GroupSettingDesc message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupSettingDesc.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.desc != null && Object.hasOwnProperty.call(message, "desc"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.desc);
                        return writer;
                    };

                    /**
                     * Encodes the specified GroupSettingDesc message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupSettingDesc.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingDesc
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupSettingDesc} message GroupSettingDesc message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupSettingDesc.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a GroupSettingDesc message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingDesc
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupSettingDesc} GroupSettingDesc
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupSettingDesc.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.GroupSettingDesc();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.desc = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a GroupSettingDesc message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingDesc
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupSettingDesc} GroupSettingDesc
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupSettingDesc.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a GroupSettingDesc message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingDesc
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GroupSettingDesc.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.desc != null && message.hasOwnProperty("desc"))
                            if (!$util.isString(message.desc))
                                return "desc: string expected";
                        return null;
                    };

                    /**
                     * Creates a GroupSettingDesc message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingDesc
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupSettingDesc} GroupSettingDesc
                     */
                    GroupSettingDesc.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.GroupSettingDesc)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Message.GroupSettingDesc();
                        if (object.desc != null)
                            message.desc = String(object.desc);
                        return message;
                    };

                    /**
                     * Creates a plain object from a GroupSettingDesc message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingDesc
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.GroupSettingDesc} message GroupSettingDesc
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GroupSettingDesc.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.desc = "";
                        if (message.desc != null && message.hasOwnProperty("desc"))
                            object.desc = message.desc;
                        return object;
                    };

                    /**
                     * Converts this GroupSettingDesc to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingDesc
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GroupSettingDesc.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return GroupSettingDesc;
                })();

                Message.GroupSettingJoinNeedPermission = (function() {

                    /**
                     * Properties of a GroupSettingJoinNeedPermission.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface IGroupSettingJoinNeedPermission
                     * @property {AcFunDanmu.Im.Cloud.Message.JoinNeedPermissionType|null} [joinNeedPermission] GroupSettingJoinNeedPermission joinNeedPermission
                     */

                    /**
                     * Constructs a new GroupSettingJoinNeedPermission.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents a GroupSettingJoinNeedPermission.
                     * @implements IGroupSettingJoinNeedPermission
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupSettingJoinNeedPermission=} [properties] Properties to set
                     */
                    function GroupSettingJoinNeedPermission(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * GroupSettingJoinNeedPermission joinNeedPermission.
                     * @member {AcFunDanmu.Im.Cloud.Message.JoinNeedPermissionType} joinNeedPermission
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingJoinNeedPermission
                     * @instance
                     */
                    GroupSettingJoinNeedPermission.prototype.joinNeedPermission = 0;

                    /**
                     * Creates a new GroupSettingJoinNeedPermission instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingJoinNeedPermission
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupSettingJoinNeedPermission=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupSettingJoinNeedPermission} GroupSettingJoinNeedPermission instance
                     */
                    GroupSettingJoinNeedPermission.create = function create(properties) {
                        return new GroupSettingJoinNeedPermission(properties);
                    };

                    /**
                     * Encodes the specified GroupSettingJoinNeedPermission message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupSettingJoinNeedPermission.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingJoinNeedPermission
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupSettingJoinNeedPermission} message GroupSettingJoinNeedPermission message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupSettingJoinNeedPermission.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.joinNeedPermission != null && Object.hasOwnProperty.call(message, "joinNeedPermission"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.joinNeedPermission);
                        return writer;
                    };

                    /**
                     * Encodes the specified GroupSettingJoinNeedPermission message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupSettingJoinNeedPermission.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingJoinNeedPermission
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupSettingJoinNeedPermission} message GroupSettingJoinNeedPermission message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupSettingJoinNeedPermission.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a GroupSettingJoinNeedPermission message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingJoinNeedPermission
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupSettingJoinNeedPermission} GroupSettingJoinNeedPermission
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupSettingJoinNeedPermission.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.GroupSettingJoinNeedPermission();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.joinNeedPermission = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a GroupSettingJoinNeedPermission message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingJoinNeedPermission
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupSettingJoinNeedPermission} GroupSettingJoinNeedPermission
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupSettingJoinNeedPermission.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a GroupSettingJoinNeedPermission message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingJoinNeedPermission
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GroupSettingJoinNeedPermission.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.joinNeedPermission != null && message.hasOwnProperty("joinNeedPermission"))
                            switch (message.joinNeedPermission) {
                            default:
                                return "joinNeedPermission: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                                break;
                            }
                        return null;
                    };

                    /**
                     * Creates a GroupSettingJoinNeedPermission message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingJoinNeedPermission
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupSettingJoinNeedPermission} GroupSettingJoinNeedPermission
                     */
                    GroupSettingJoinNeedPermission.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.GroupSettingJoinNeedPermission)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Message.GroupSettingJoinNeedPermission();
                        switch (object.joinNeedPermission) {
                        case "UNKNOWN_JOIN_NEED_PERMISSION_TYPE":
                        case 0:
                            message.joinNeedPermission = 0;
                            break;
                        case "NONE":
                        case 1:
                            message.joinNeedPermission = 1;
                            break;
                        case "ADMIN":
                        case 2:
                            message.joinNeedPermission = 2;
                            break;
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a GroupSettingJoinNeedPermission message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingJoinNeedPermission
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.GroupSettingJoinNeedPermission} message GroupSettingJoinNeedPermission
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GroupSettingJoinNeedPermission.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.joinNeedPermission = options.enums === String ? "UNKNOWN_JOIN_NEED_PERMISSION_TYPE" : 0;
                        if (message.joinNeedPermission != null && message.hasOwnProperty("joinNeedPermission"))
                            object.joinNeedPermission = options.enums === String ? $root.AcFunDanmu.Im.Cloud.Message.JoinNeedPermissionType[message.joinNeedPermission] : message.joinNeedPermission;
                        return object;
                    };

                    /**
                     * Converts this GroupSettingJoinNeedPermission to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingJoinNeedPermission
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GroupSettingJoinNeedPermission.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return GroupSettingJoinNeedPermission;
                })();

                Message.GroupSettingInvitePermission = (function() {

                    /**
                     * Properties of a GroupSettingInvitePermission.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface IGroupSettingInvitePermission
                     * @property {AcFunDanmu.Im.Cloud.Message.InvitePermissionType|null} [invitePermissionType] GroupSettingInvitePermission invitePermissionType
                     */

                    /**
                     * Constructs a new GroupSettingInvitePermission.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents a GroupSettingInvitePermission.
                     * @implements IGroupSettingInvitePermission
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupSettingInvitePermission=} [properties] Properties to set
                     */
                    function GroupSettingInvitePermission(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * GroupSettingInvitePermission invitePermissionType.
                     * @member {AcFunDanmu.Im.Cloud.Message.InvitePermissionType} invitePermissionType
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingInvitePermission
                     * @instance
                     */
                    GroupSettingInvitePermission.prototype.invitePermissionType = 0;

                    /**
                     * Creates a new GroupSettingInvitePermission instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingInvitePermission
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupSettingInvitePermission=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupSettingInvitePermission} GroupSettingInvitePermission instance
                     */
                    GroupSettingInvitePermission.create = function create(properties) {
                        return new GroupSettingInvitePermission(properties);
                    };

                    /**
                     * Encodes the specified GroupSettingInvitePermission message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupSettingInvitePermission.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingInvitePermission
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupSettingInvitePermission} message GroupSettingInvitePermission message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupSettingInvitePermission.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.invitePermissionType != null && Object.hasOwnProperty.call(message, "invitePermissionType"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.invitePermissionType);
                        return writer;
                    };

                    /**
                     * Encodes the specified GroupSettingInvitePermission message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupSettingInvitePermission.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingInvitePermission
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupSettingInvitePermission} message GroupSettingInvitePermission message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupSettingInvitePermission.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a GroupSettingInvitePermission message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingInvitePermission
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupSettingInvitePermission} GroupSettingInvitePermission
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupSettingInvitePermission.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.GroupSettingInvitePermission();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.invitePermissionType = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a GroupSettingInvitePermission message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingInvitePermission
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupSettingInvitePermission} GroupSettingInvitePermission
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupSettingInvitePermission.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a GroupSettingInvitePermission message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingInvitePermission
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GroupSettingInvitePermission.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.invitePermissionType != null && message.hasOwnProperty("invitePermissionType"))
                            switch (message.invitePermissionType) {
                            default:
                                return "invitePermissionType: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                                break;
                            }
                        return null;
                    };

                    /**
                     * Creates a GroupSettingInvitePermission message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingInvitePermission
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupSettingInvitePermission} GroupSettingInvitePermission
                     */
                    GroupSettingInvitePermission.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.GroupSettingInvitePermission)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Message.GroupSettingInvitePermission();
                        switch (object.invitePermissionType) {
                        case "UNKNOWN_INVITE_PERMISSION_TYPE":
                        case 0:
                            message.invitePermissionType = 0;
                            break;
                        case "EVERYONE":
                        case 1:
                            message.invitePermissionType = 1;
                            break;
                        case "ONLY_ADMIN":
                        case 2:
                            message.invitePermissionType = 2;
                            break;
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a GroupSettingInvitePermission message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingInvitePermission
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.GroupSettingInvitePermission} message GroupSettingInvitePermission
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GroupSettingInvitePermission.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.invitePermissionType = options.enums === String ? "UNKNOWN_INVITE_PERMISSION_TYPE" : 0;
                        if (message.invitePermissionType != null && message.hasOwnProperty("invitePermissionType"))
                            object.invitePermissionType = options.enums === String ? $root.AcFunDanmu.Im.Cloud.Message.InvitePermissionType[message.invitePermissionType] : message.invitePermissionType;
                        return object;
                    };

                    /**
                     * Converts this GroupSettingInvitePermission to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingInvitePermission
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GroupSettingInvitePermission.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return GroupSettingInvitePermission;
                })();

                Message.GroupSettingResponse = (function() {

                    /**
                     * Properties of a GroupSettingResponse.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface IGroupSettingResponse
                     */

                    /**
                     * Constructs a new GroupSettingResponse.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents a GroupSettingResponse.
                     * @implements IGroupSettingResponse
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupSettingResponse=} [properties] Properties to set
                     */
                    function GroupSettingResponse(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Creates a new GroupSettingResponse instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupSettingResponse=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupSettingResponse} GroupSettingResponse instance
                     */
                    GroupSettingResponse.create = function create(properties) {
                        return new GroupSettingResponse(properties);
                    };

                    /**
                     * Encodes the specified GroupSettingResponse message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupSettingResponse.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupSettingResponse} message GroupSettingResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupSettingResponse.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };

                    /**
                     * Encodes the specified GroupSettingResponse message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupSettingResponse.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupSettingResponse} message GroupSettingResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupSettingResponse.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a GroupSettingResponse message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupSettingResponse} GroupSettingResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupSettingResponse.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.GroupSettingResponse();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a GroupSettingResponse message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupSettingResponse} GroupSettingResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupSettingResponse.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a GroupSettingResponse message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingResponse
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GroupSettingResponse.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };

                    /**
                     * Creates a GroupSettingResponse message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingResponse
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupSettingResponse} GroupSettingResponse
                     */
                    GroupSettingResponse.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.GroupSettingResponse)
                            return object;
                        return new $root.AcFunDanmu.Im.Cloud.Message.GroupSettingResponse();
                    };

                    /**
                     * Creates a plain object from a GroupSettingResponse message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.GroupSettingResponse} message GroupSettingResponse
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GroupSettingResponse.toObject = function toObject() {
                        return {};
                    };

                    /**
                     * Converts this GroupSettingResponse to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupSettingResponse
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GroupSettingResponse.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return GroupSettingResponse;
                })();

                Message.GroupMemberSettingRequest = (function() {

                    /**
                     * Properties of a GroupMemberSettingRequest.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface IGroupMemberSettingRequest
                     * @property {string|null} [groupId] GroupMemberSettingRequest groupId
                     * @property {AcFunDanmu.Im.Cloud.Message.ISetUserNickname|null} [setNickname] GroupMemberSettingRequest setNickname
                     * @property {AcFunDanmu.Im.Cloud.Message.ISetUserAntiDisturbing|null} [setAntiDisturbing] GroupMemberSettingRequest setAntiDisturbing
                     */

                    /**
                     * Constructs a new GroupMemberSettingRequest.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents a GroupMemberSettingRequest.
                     * @implements IGroupMemberSettingRequest
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupMemberSettingRequest=} [properties] Properties to set
                     */
                    function GroupMemberSettingRequest(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * GroupMemberSettingRequest groupId.
                     * @member {string} groupId
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberSettingRequest
                     * @instance
                     */
                    GroupMemberSettingRequest.prototype.groupId = "";

                    /**
                     * GroupMemberSettingRequest setNickname.
                     * @member {AcFunDanmu.Im.Cloud.Message.ISetUserNickname|null|undefined} setNickname
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberSettingRequest
                     * @instance
                     */
                    GroupMemberSettingRequest.prototype.setNickname = null;

                    /**
                     * GroupMemberSettingRequest setAntiDisturbing.
                     * @member {AcFunDanmu.Im.Cloud.Message.ISetUserAntiDisturbing|null|undefined} setAntiDisturbing
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberSettingRequest
                     * @instance
                     */
                    GroupMemberSettingRequest.prototype.setAntiDisturbing = null;

                    // OneOf field names bound to virtual getters and setters
                    let $oneOfFields;

                    /**
                     * GroupMemberSettingRequest UserSetting.
                     * @member {"setNickname"|"setAntiDisturbing"|undefined} UserSetting
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberSettingRequest
                     * @instance
                     */
                    Object.defineProperty(GroupMemberSettingRequest.prototype, "UserSetting", {
                        get: $util.oneOfGetter($oneOfFields = ["setNickname", "setAntiDisturbing"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });

                    /**
                     * Creates a new GroupMemberSettingRequest instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberSettingRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupMemberSettingRequest=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupMemberSettingRequest} GroupMemberSettingRequest instance
                     */
                    GroupMemberSettingRequest.create = function create(properties) {
                        return new GroupMemberSettingRequest(properties);
                    };

                    /**
                     * Encodes the specified GroupMemberSettingRequest message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupMemberSettingRequest.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberSettingRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupMemberSettingRequest} message GroupMemberSettingRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupMemberSettingRequest.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.groupId);
                        if (message.setNickname != null && Object.hasOwnProperty.call(message, "setNickname"))
                            $root.AcFunDanmu.Im.Cloud.Message.SetUserNickname.encode(message.setNickname, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.setAntiDisturbing != null && Object.hasOwnProperty.call(message, "setAntiDisturbing"))
                            $root.AcFunDanmu.Im.Cloud.Message.SetUserAntiDisturbing.encode(message.setAntiDisturbing, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified GroupMemberSettingRequest message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupMemberSettingRequest.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberSettingRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupMemberSettingRequest} message GroupMemberSettingRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupMemberSettingRequest.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a GroupMemberSettingRequest message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberSettingRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupMemberSettingRequest} GroupMemberSettingRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupMemberSettingRequest.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.GroupMemberSettingRequest();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.groupId = reader.string();
                                break;
                            case 2:
                                message.setNickname = $root.AcFunDanmu.Im.Cloud.Message.SetUserNickname.decode(reader, reader.uint32());
                                break;
                            case 3:
                                message.setAntiDisturbing = $root.AcFunDanmu.Im.Cloud.Message.SetUserAntiDisturbing.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a GroupMemberSettingRequest message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberSettingRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupMemberSettingRequest} GroupMemberSettingRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupMemberSettingRequest.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a GroupMemberSettingRequest message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberSettingRequest
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GroupMemberSettingRequest.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        let properties = {};
                        if (message.groupId != null && message.hasOwnProperty("groupId"))
                            if (!$util.isString(message.groupId))
                                return "groupId: string expected";
                        if (message.setNickname != null && message.hasOwnProperty("setNickname")) {
                            properties.UserSetting = 1;
                            {
                                let error = $root.AcFunDanmu.Im.Cloud.Message.SetUserNickname.verify(message.setNickname);
                                if (error)
                                    return "setNickname." + error;
                            }
                        }
                        if (message.setAntiDisturbing != null && message.hasOwnProperty("setAntiDisturbing")) {
                            if (properties.UserSetting === 1)
                                return "UserSetting: multiple values";
                            properties.UserSetting = 1;
                            {
                                let error = $root.AcFunDanmu.Im.Cloud.Message.SetUserAntiDisturbing.verify(message.setAntiDisturbing);
                                if (error)
                                    return "setAntiDisturbing." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a GroupMemberSettingRequest message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberSettingRequest
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupMemberSettingRequest} GroupMemberSettingRequest
                     */
                    GroupMemberSettingRequest.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.GroupMemberSettingRequest)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Message.GroupMemberSettingRequest();
                        if (object.groupId != null)
                            message.groupId = String(object.groupId);
                        if (object.setNickname != null) {
                            if (typeof object.setNickname !== "object")
                                throw TypeError(".AcFunDanmu.Im.Cloud.Message.GroupMemberSettingRequest.setNickname: object expected");
                            message.setNickname = $root.AcFunDanmu.Im.Cloud.Message.SetUserNickname.fromObject(object.setNickname);
                        }
                        if (object.setAntiDisturbing != null) {
                            if (typeof object.setAntiDisturbing !== "object")
                                throw TypeError(".AcFunDanmu.Im.Cloud.Message.GroupMemberSettingRequest.setAntiDisturbing: object expected");
                            message.setAntiDisturbing = $root.AcFunDanmu.Im.Cloud.Message.SetUserAntiDisturbing.fromObject(object.setAntiDisturbing);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a GroupMemberSettingRequest message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberSettingRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.GroupMemberSettingRequest} message GroupMemberSettingRequest
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GroupMemberSettingRequest.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.groupId = "";
                        if (message.groupId != null && message.hasOwnProperty("groupId"))
                            object.groupId = message.groupId;
                        if (message.setNickname != null && message.hasOwnProperty("setNickname")) {
                            object.setNickname = $root.AcFunDanmu.Im.Cloud.Message.SetUserNickname.toObject(message.setNickname, options);
                            if (options.oneofs)
                                object.UserSetting = "setNickname";
                        }
                        if (message.setAntiDisturbing != null && message.hasOwnProperty("setAntiDisturbing")) {
                            object.setAntiDisturbing = $root.AcFunDanmu.Im.Cloud.Message.SetUserAntiDisturbing.toObject(message.setAntiDisturbing, options);
                            if (options.oneofs)
                                object.UserSetting = "setAntiDisturbing";
                        }
                        return object;
                    };

                    /**
                     * Converts this GroupMemberSettingRequest to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberSettingRequest
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GroupMemberSettingRequest.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return GroupMemberSettingRequest;
                })();

                Message.SetUserNickname = (function() {

                    /**
                     * Properties of a SetUserNickname.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface ISetUserNickname
                     * @property {string|null} [nickname] SetUserNickname nickname
                     */

                    /**
                     * Constructs a new SetUserNickname.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents a SetUserNickname.
                     * @implements ISetUserNickname
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.ISetUserNickname=} [properties] Properties to set
                     */
                    function SetUserNickname(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * SetUserNickname nickname.
                     * @member {string} nickname
                     * @memberof AcFunDanmu.Im.Cloud.Message.SetUserNickname
                     * @instance
                     */
                    SetUserNickname.prototype.nickname = "";

                    /**
                     * Creates a new SetUserNickname instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.SetUserNickname
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.ISetUserNickname=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.SetUserNickname} SetUserNickname instance
                     */
                    SetUserNickname.create = function create(properties) {
                        return new SetUserNickname(properties);
                    };

                    /**
                     * Encodes the specified SetUserNickname message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.SetUserNickname.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.SetUserNickname
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.ISetUserNickname} message SetUserNickname message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SetUserNickname.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.nickname != null && Object.hasOwnProperty.call(message, "nickname"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.nickname);
                        return writer;
                    };

                    /**
                     * Encodes the specified SetUserNickname message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.SetUserNickname.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.SetUserNickname
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.ISetUserNickname} message SetUserNickname message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SetUserNickname.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a SetUserNickname message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.SetUserNickname
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.SetUserNickname} SetUserNickname
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SetUserNickname.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.SetUserNickname();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.nickname = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a SetUserNickname message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.SetUserNickname
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.SetUserNickname} SetUserNickname
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SetUserNickname.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a SetUserNickname message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.SetUserNickname
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SetUserNickname.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.nickname != null && message.hasOwnProperty("nickname"))
                            if (!$util.isString(message.nickname))
                                return "nickname: string expected";
                        return null;
                    };

                    /**
                     * Creates a SetUserNickname message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.SetUserNickname
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.SetUserNickname} SetUserNickname
                     */
                    SetUserNickname.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.SetUserNickname)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Message.SetUserNickname();
                        if (object.nickname != null)
                            message.nickname = String(object.nickname);
                        return message;
                    };

                    /**
                     * Creates a plain object from a SetUserNickname message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.SetUserNickname
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.SetUserNickname} message SetUserNickname
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SetUserNickname.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.nickname = "";
                        if (message.nickname != null && message.hasOwnProperty("nickname"))
                            object.nickname = message.nickname;
                        return object;
                    };

                    /**
                     * Converts this SetUserNickname to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.SetUserNickname
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SetUserNickname.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return SetUserNickname;
                })();

                Message.SetUserAntiDisturbing = (function() {

                    /**
                     * Properties of a SetUserAntiDisturbing.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface ISetUserAntiDisturbing
                     * @property {boolean|null} [antiDisturbing] SetUserAntiDisturbing antiDisturbing
                     */

                    /**
                     * Constructs a new SetUserAntiDisturbing.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents a SetUserAntiDisturbing.
                     * @implements ISetUserAntiDisturbing
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.ISetUserAntiDisturbing=} [properties] Properties to set
                     */
                    function SetUserAntiDisturbing(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * SetUserAntiDisturbing antiDisturbing.
                     * @member {boolean} antiDisturbing
                     * @memberof AcFunDanmu.Im.Cloud.Message.SetUserAntiDisturbing
                     * @instance
                     */
                    SetUserAntiDisturbing.prototype.antiDisturbing = false;

                    /**
                     * Creates a new SetUserAntiDisturbing instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.SetUserAntiDisturbing
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.ISetUserAntiDisturbing=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.SetUserAntiDisturbing} SetUserAntiDisturbing instance
                     */
                    SetUserAntiDisturbing.create = function create(properties) {
                        return new SetUserAntiDisturbing(properties);
                    };

                    /**
                     * Encodes the specified SetUserAntiDisturbing message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.SetUserAntiDisturbing.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.SetUserAntiDisturbing
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.ISetUserAntiDisturbing} message SetUserAntiDisturbing message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SetUserAntiDisturbing.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.antiDisturbing != null && Object.hasOwnProperty.call(message, "antiDisturbing"))
                            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.antiDisturbing);
                        return writer;
                    };

                    /**
                     * Encodes the specified SetUserAntiDisturbing message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.SetUserAntiDisturbing.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.SetUserAntiDisturbing
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.ISetUserAntiDisturbing} message SetUserAntiDisturbing message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SetUserAntiDisturbing.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a SetUserAntiDisturbing message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.SetUserAntiDisturbing
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.SetUserAntiDisturbing} SetUserAntiDisturbing
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SetUserAntiDisturbing.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.SetUserAntiDisturbing();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.antiDisturbing = reader.bool();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a SetUserAntiDisturbing message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.SetUserAntiDisturbing
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.SetUserAntiDisturbing} SetUserAntiDisturbing
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SetUserAntiDisturbing.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a SetUserAntiDisturbing message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.SetUserAntiDisturbing
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SetUserAntiDisturbing.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.antiDisturbing != null && message.hasOwnProperty("antiDisturbing"))
                            if (typeof message.antiDisturbing !== "boolean")
                                return "antiDisturbing: boolean expected";
                        return null;
                    };

                    /**
                     * Creates a SetUserAntiDisturbing message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.SetUserAntiDisturbing
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.SetUserAntiDisturbing} SetUserAntiDisturbing
                     */
                    SetUserAntiDisturbing.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.SetUserAntiDisturbing)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Message.SetUserAntiDisturbing();
                        if (object.antiDisturbing != null)
                            message.antiDisturbing = Boolean(object.antiDisturbing);
                        return message;
                    };

                    /**
                     * Creates a plain object from a SetUserAntiDisturbing message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.SetUserAntiDisturbing
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.SetUserAntiDisturbing} message SetUserAntiDisturbing
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SetUserAntiDisturbing.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.antiDisturbing = false;
                        if (message.antiDisturbing != null && message.hasOwnProperty("antiDisturbing"))
                            object.antiDisturbing = message.antiDisturbing;
                        return object;
                    };

                    /**
                     * Converts this SetUserAntiDisturbing to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.SetUserAntiDisturbing
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SetUserAntiDisturbing.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return SetUserAntiDisturbing;
                })();

                Message.GroupMemberSettingResponse = (function() {

                    /**
                     * Properties of a GroupMemberSettingResponse.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface IGroupMemberSettingResponse
                     */

                    /**
                     * Constructs a new GroupMemberSettingResponse.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents a GroupMemberSettingResponse.
                     * @implements IGroupMemberSettingResponse
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupMemberSettingResponse=} [properties] Properties to set
                     */
                    function GroupMemberSettingResponse(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Creates a new GroupMemberSettingResponse instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberSettingResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupMemberSettingResponse=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupMemberSettingResponse} GroupMemberSettingResponse instance
                     */
                    GroupMemberSettingResponse.create = function create(properties) {
                        return new GroupMemberSettingResponse(properties);
                    };

                    /**
                     * Encodes the specified GroupMemberSettingResponse message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupMemberSettingResponse.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberSettingResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupMemberSettingResponse} message GroupMemberSettingResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupMemberSettingResponse.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };

                    /**
                     * Encodes the specified GroupMemberSettingResponse message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupMemberSettingResponse.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberSettingResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupMemberSettingResponse} message GroupMemberSettingResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupMemberSettingResponse.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a GroupMemberSettingResponse message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberSettingResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupMemberSettingResponse} GroupMemberSettingResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupMemberSettingResponse.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.GroupMemberSettingResponse();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a GroupMemberSettingResponse message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberSettingResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupMemberSettingResponse} GroupMemberSettingResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupMemberSettingResponse.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a GroupMemberSettingResponse message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberSettingResponse
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GroupMemberSettingResponse.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };

                    /**
                     * Creates a GroupMemberSettingResponse message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberSettingResponse
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupMemberSettingResponse} GroupMemberSettingResponse
                     */
                    GroupMemberSettingResponse.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.GroupMemberSettingResponse)
                            return object;
                        return new $root.AcFunDanmu.Im.Cloud.Message.GroupMemberSettingResponse();
                    };

                    /**
                     * Creates a plain object from a GroupMemberSettingResponse message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberSettingResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.GroupMemberSettingResponse} message GroupMemberSettingResponse
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GroupMemberSettingResponse.toObject = function toObject() {
                        return {};
                    };

                    /**
                     * Converts this GroupMemberSettingResponse to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberSettingResponse
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GroupMemberSettingResponse.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return GroupMemberSettingResponse;
                })();

                Message.GroupMemberListGetRequest = (function() {

                    /**
                     * Properties of a GroupMemberListGetRequest.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface IGroupMemberListGetRequest
                     * @property {string|null} [groupId] GroupMemberListGetRequest groupId
                     * @property {AcFunDanmu.Im.Basic.ISyncCookie|null} [syncCookie] GroupMemberListGetRequest syncCookie
                     */

                    /**
                     * Constructs a new GroupMemberListGetRequest.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents a GroupMemberListGetRequest.
                     * @implements IGroupMemberListGetRequest
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupMemberListGetRequest=} [properties] Properties to set
                     */
                    function GroupMemberListGetRequest(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * GroupMemberListGetRequest groupId.
                     * @member {string} groupId
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberListGetRequest
                     * @instance
                     */
                    GroupMemberListGetRequest.prototype.groupId = "";

                    /**
                     * GroupMemberListGetRequest syncCookie.
                     * @member {AcFunDanmu.Im.Basic.ISyncCookie|null|undefined} syncCookie
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberListGetRequest
                     * @instance
                     */
                    GroupMemberListGetRequest.prototype.syncCookie = null;

                    /**
                     * Creates a new GroupMemberListGetRequest instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberListGetRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupMemberListGetRequest=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupMemberListGetRequest} GroupMemberListGetRequest instance
                     */
                    GroupMemberListGetRequest.create = function create(properties) {
                        return new GroupMemberListGetRequest(properties);
                    };

                    /**
                     * Encodes the specified GroupMemberListGetRequest message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupMemberListGetRequest.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberListGetRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupMemberListGetRequest} message GroupMemberListGetRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupMemberListGetRequest.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.groupId);
                        if (message.syncCookie != null && Object.hasOwnProperty.call(message, "syncCookie"))
                            $root.AcFunDanmu.Im.Basic.SyncCookie.encode(message.syncCookie, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified GroupMemberListGetRequest message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupMemberListGetRequest.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberListGetRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupMemberListGetRequest} message GroupMemberListGetRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupMemberListGetRequest.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a GroupMemberListGetRequest message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberListGetRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupMemberListGetRequest} GroupMemberListGetRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupMemberListGetRequest.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.GroupMemberListGetRequest();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.groupId = reader.string();
                                break;
                            case 2:
                                message.syncCookie = $root.AcFunDanmu.Im.Basic.SyncCookie.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a GroupMemberListGetRequest message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberListGetRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupMemberListGetRequest} GroupMemberListGetRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupMemberListGetRequest.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a GroupMemberListGetRequest message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberListGetRequest
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GroupMemberListGetRequest.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.groupId != null && message.hasOwnProperty("groupId"))
                            if (!$util.isString(message.groupId))
                                return "groupId: string expected";
                        if (message.syncCookie != null && message.hasOwnProperty("syncCookie")) {
                            let error = $root.AcFunDanmu.Im.Basic.SyncCookie.verify(message.syncCookie);
                            if (error)
                                return "syncCookie." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a GroupMemberListGetRequest message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberListGetRequest
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupMemberListGetRequest} GroupMemberListGetRequest
                     */
                    GroupMemberListGetRequest.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.GroupMemberListGetRequest)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Message.GroupMemberListGetRequest();
                        if (object.groupId != null)
                            message.groupId = String(object.groupId);
                        if (object.syncCookie != null) {
                            if (typeof object.syncCookie !== "object")
                                throw TypeError(".AcFunDanmu.Im.Cloud.Message.GroupMemberListGetRequest.syncCookie: object expected");
                            message.syncCookie = $root.AcFunDanmu.Im.Basic.SyncCookie.fromObject(object.syncCookie);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a GroupMemberListGetRequest message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberListGetRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.GroupMemberListGetRequest} message GroupMemberListGetRequest
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GroupMemberListGetRequest.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.groupId = "";
                            object.syncCookie = null;
                        }
                        if (message.groupId != null && message.hasOwnProperty("groupId"))
                            object.groupId = message.groupId;
                        if (message.syncCookie != null && message.hasOwnProperty("syncCookie"))
                            object.syncCookie = $root.AcFunDanmu.Im.Basic.SyncCookie.toObject(message.syncCookie, options);
                        return object;
                    };

                    /**
                     * Converts this GroupMemberListGetRequest to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberListGetRequest
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GroupMemberListGetRequest.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return GroupMemberListGetRequest;
                })();

                Message.GroupMemberListGetResponse = (function() {

                    /**
                     * Properties of a GroupMemberListGetResponse.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface IGroupMemberListGetResponse
                     * @property {Array.<AcFunDanmu.Im.Cloud.Message.IGroupMember>|null} [members] GroupMemberListGetResponse members
                     * @property {AcFunDanmu.Im.Basic.ISyncCookie|null} [syncCookie] GroupMemberListGetResponse syncCookie
                     */

                    /**
                     * Constructs a new GroupMemberListGetResponse.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents a GroupMemberListGetResponse.
                     * @implements IGroupMemberListGetResponse
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupMemberListGetResponse=} [properties] Properties to set
                     */
                    function GroupMemberListGetResponse(properties) {
                        this.members = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * GroupMemberListGetResponse members.
                     * @member {Array.<AcFunDanmu.Im.Cloud.Message.IGroupMember>} members
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberListGetResponse
                     * @instance
                     */
                    GroupMemberListGetResponse.prototype.members = $util.emptyArray;

                    /**
                     * GroupMemberListGetResponse syncCookie.
                     * @member {AcFunDanmu.Im.Basic.ISyncCookie|null|undefined} syncCookie
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberListGetResponse
                     * @instance
                     */
                    GroupMemberListGetResponse.prototype.syncCookie = null;

                    /**
                     * Creates a new GroupMemberListGetResponse instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberListGetResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupMemberListGetResponse=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupMemberListGetResponse} GroupMemberListGetResponse instance
                     */
                    GroupMemberListGetResponse.create = function create(properties) {
                        return new GroupMemberListGetResponse(properties);
                    };

                    /**
                     * Encodes the specified GroupMemberListGetResponse message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupMemberListGetResponse.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberListGetResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupMemberListGetResponse} message GroupMemberListGetResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupMemberListGetResponse.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.members != null && message.members.length)
                            for (let i = 0; i < message.members.length; ++i)
                                $root.AcFunDanmu.Im.Cloud.Message.GroupMember.encode(message.members[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.syncCookie != null && Object.hasOwnProperty.call(message, "syncCookie"))
                            $root.AcFunDanmu.Im.Basic.SyncCookie.encode(message.syncCookie, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified GroupMemberListGetResponse message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupMemberListGetResponse.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberListGetResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupMemberListGetResponse} message GroupMemberListGetResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupMemberListGetResponse.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a GroupMemberListGetResponse message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberListGetResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupMemberListGetResponse} GroupMemberListGetResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupMemberListGetResponse.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.GroupMemberListGetResponse();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.members && message.members.length))
                                    message.members = [];
                                message.members.push($root.AcFunDanmu.Im.Cloud.Message.GroupMember.decode(reader, reader.uint32()));
                                break;
                            case 2:
                                message.syncCookie = $root.AcFunDanmu.Im.Basic.SyncCookie.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a GroupMemberListGetResponse message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberListGetResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupMemberListGetResponse} GroupMemberListGetResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupMemberListGetResponse.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a GroupMemberListGetResponse message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberListGetResponse
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GroupMemberListGetResponse.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.members != null && message.hasOwnProperty("members")) {
                            if (!Array.isArray(message.members))
                                return "members: array expected";
                            for (let i = 0; i < message.members.length; ++i) {
                                let error = $root.AcFunDanmu.Im.Cloud.Message.GroupMember.verify(message.members[i]);
                                if (error)
                                    return "members." + error;
                            }
                        }
                        if (message.syncCookie != null && message.hasOwnProperty("syncCookie")) {
                            let error = $root.AcFunDanmu.Im.Basic.SyncCookie.verify(message.syncCookie);
                            if (error)
                                return "syncCookie." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a GroupMemberListGetResponse message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberListGetResponse
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupMemberListGetResponse} GroupMemberListGetResponse
                     */
                    GroupMemberListGetResponse.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.GroupMemberListGetResponse)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Message.GroupMemberListGetResponse();
                        if (object.members) {
                            if (!Array.isArray(object.members))
                                throw TypeError(".AcFunDanmu.Im.Cloud.Message.GroupMemberListGetResponse.members: array expected");
                            message.members = [];
                            for (let i = 0; i < object.members.length; ++i) {
                                if (typeof object.members[i] !== "object")
                                    throw TypeError(".AcFunDanmu.Im.Cloud.Message.GroupMemberListGetResponse.members: object expected");
                                message.members[i] = $root.AcFunDanmu.Im.Cloud.Message.GroupMember.fromObject(object.members[i]);
                            }
                        }
                        if (object.syncCookie != null) {
                            if (typeof object.syncCookie !== "object")
                                throw TypeError(".AcFunDanmu.Im.Cloud.Message.GroupMemberListGetResponse.syncCookie: object expected");
                            message.syncCookie = $root.AcFunDanmu.Im.Basic.SyncCookie.fromObject(object.syncCookie);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a GroupMemberListGetResponse message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberListGetResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.GroupMemberListGetResponse} message GroupMemberListGetResponse
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GroupMemberListGetResponse.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.members = [];
                        if (options.defaults)
                            object.syncCookie = null;
                        if (message.members && message.members.length) {
                            object.members = [];
                            for (let j = 0; j < message.members.length; ++j)
                                object.members[j] = $root.AcFunDanmu.Im.Cloud.Message.GroupMember.toObject(message.members[j], options);
                        }
                        if (message.syncCookie != null && message.hasOwnProperty("syncCookie"))
                            object.syncCookie = $root.AcFunDanmu.Im.Basic.SyncCookie.toObject(message.syncCookie, options);
                        return object;
                    };

                    /**
                     * Converts this GroupMemberListGetResponse to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberListGetResponse
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GroupMemberListGetResponse.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return GroupMemberListGetResponse;
                })();

                Message.GroupMemberGetRequest = (function() {

                    /**
                     * Properties of a GroupMemberGetRequest.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface IGroupMemberGetRequest
                     * @property {string|null} [groupId] GroupMemberGetRequest groupId
                     * @property {AcFunDanmu.Im.Basic.IUser|null} [user] GroupMemberGetRequest user
                     */

                    /**
                     * Constructs a new GroupMemberGetRequest.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents a GroupMemberGetRequest.
                     * @implements IGroupMemberGetRequest
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupMemberGetRequest=} [properties] Properties to set
                     */
                    function GroupMemberGetRequest(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * GroupMemberGetRequest groupId.
                     * @member {string} groupId
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberGetRequest
                     * @instance
                     */
                    GroupMemberGetRequest.prototype.groupId = "";

                    /**
                     * GroupMemberGetRequest user.
                     * @member {AcFunDanmu.Im.Basic.IUser|null|undefined} user
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberGetRequest
                     * @instance
                     */
                    GroupMemberGetRequest.prototype.user = null;

                    /**
                     * Creates a new GroupMemberGetRequest instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberGetRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupMemberGetRequest=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupMemberGetRequest} GroupMemberGetRequest instance
                     */
                    GroupMemberGetRequest.create = function create(properties) {
                        return new GroupMemberGetRequest(properties);
                    };

                    /**
                     * Encodes the specified GroupMemberGetRequest message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupMemberGetRequest.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberGetRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupMemberGetRequest} message GroupMemberGetRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupMemberGetRequest.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.groupId);
                        if (message.user != null && Object.hasOwnProperty.call(message, "user"))
                            $root.AcFunDanmu.Im.Basic.User.encode(message.user, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified GroupMemberGetRequest message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupMemberGetRequest.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberGetRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupMemberGetRequest} message GroupMemberGetRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupMemberGetRequest.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a GroupMemberGetRequest message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberGetRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupMemberGetRequest} GroupMemberGetRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupMemberGetRequest.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.GroupMemberGetRequest();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.groupId = reader.string();
                                break;
                            case 2:
                                message.user = $root.AcFunDanmu.Im.Basic.User.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a GroupMemberGetRequest message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberGetRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupMemberGetRequest} GroupMemberGetRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupMemberGetRequest.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a GroupMemberGetRequest message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberGetRequest
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GroupMemberGetRequest.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.groupId != null && message.hasOwnProperty("groupId"))
                            if (!$util.isString(message.groupId))
                                return "groupId: string expected";
                        if (message.user != null && message.hasOwnProperty("user")) {
                            let error = $root.AcFunDanmu.Im.Basic.User.verify(message.user);
                            if (error)
                                return "user." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a GroupMemberGetRequest message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberGetRequest
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupMemberGetRequest} GroupMemberGetRequest
                     */
                    GroupMemberGetRequest.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.GroupMemberGetRequest)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Message.GroupMemberGetRequest();
                        if (object.groupId != null)
                            message.groupId = String(object.groupId);
                        if (object.user != null) {
                            if (typeof object.user !== "object")
                                throw TypeError(".AcFunDanmu.Im.Cloud.Message.GroupMemberGetRequest.user: object expected");
                            message.user = $root.AcFunDanmu.Im.Basic.User.fromObject(object.user);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a GroupMemberGetRequest message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberGetRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.GroupMemberGetRequest} message GroupMemberGetRequest
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GroupMemberGetRequest.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.groupId = "";
                            object.user = null;
                        }
                        if (message.groupId != null && message.hasOwnProperty("groupId"))
                            object.groupId = message.groupId;
                        if (message.user != null && message.hasOwnProperty("user"))
                            object.user = $root.AcFunDanmu.Im.Basic.User.toObject(message.user, options);
                        return object;
                    };

                    /**
                     * Converts this GroupMemberGetRequest to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberGetRequest
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GroupMemberGetRequest.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return GroupMemberGetRequest;
                })();

                Message.GroupMemberGetResponse = (function() {

                    /**
                     * Properties of a GroupMemberGetResponse.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface IGroupMemberGetResponse
                     * @property {AcFunDanmu.Im.Cloud.Message.IGroupMember|null} [member] GroupMemberGetResponse member
                     */

                    /**
                     * Constructs a new GroupMemberGetResponse.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents a GroupMemberGetResponse.
                     * @implements IGroupMemberGetResponse
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupMemberGetResponse=} [properties] Properties to set
                     */
                    function GroupMemberGetResponse(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * GroupMemberGetResponse member.
                     * @member {AcFunDanmu.Im.Cloud.Message.IGroupMember|null|undefined} member
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberGetResponse
                     * @instance
                     */
                    GroupMemberGetResponse.prototype.member = null;

                    /**
                     * Creates a new GroupMemberGetResponse instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberGetResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupMemberGetResponse=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupMemberGetResponse} GroupMemberGetResponse instance
                     */
                    GroupMemberGetResponse.create = function create(properties) {
                        return new GroupMemberGetResponse(properties);
                    };

                    /**
                     * Encodes the specified GroupMemberGetResponse message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupMemberGetResponse.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberGetResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupMemberGetResponse} message GroupMemberGetResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupMemberGetResponse.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.member != null && Object.hasOwnProperty.call(message, "member"))
                            $root.AcFunDanmu.Im.Cloud.Message.GroupMember.encode(message.member, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified GroupMemberGetResponse message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupMemberGetResponse.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberGetResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupMemberGetResponse} message GroupMemberGetResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupMemberGetResponse.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a GroupMemberGetResponse message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberGetResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupMemberGetResponse} GroupMemberGetResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupMemberGetResponse.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.GroupMemberGetResponse();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.member = $root.AcFunDanmu.Im.Cloud.Message.GroupMember.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a GroupMemberGetResponse message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberGetResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupMemberGetResponse} GroupMemberGetResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupMemberGetResponse.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a GroupMemberGetResponse message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberGetResponse
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GroupMemberGetResponse.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.member != null && message.hasOwnProperty("member")) {
                            let error = $root.AcFunDanmu.Im.Cloud.Message.GroupMember.verify(message.member);
                            if (error)
                                return "member." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a GroupMemberGetResponse message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberGetResponse
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupMemberGetResponse} GroupMemberGetResponse
                     */
                    GroupMemberGetResponse.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.GroupMemberGetResponse)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Message.GroupMemberGetResponse();
                        if (object.member != null) {
                            if (typeof object.member !== "object")
                                throw TypeError(".AcFunDanmu.Im.Cloud.Message.GroupMemberGetResponse.member: object expected");
                            message.member = $root.AcFunDanmu.Im.Cloud.Message.GroupMember.fromObject(object.member);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a GroupMemberGetResponse message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberGetResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.GroupMemberGetResponse} message GroupMemberGetResponse
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GroupMemberGetResponse.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.member = null;
                        if (message.member != null && message.hasOwnProperty("member"))
                            object.member = $root.AcFunDanmu.Im.Cloud.Message.GroupMember.toObject(message.member, options);
                        return object;
                    };

                    /**
                     * Converts this GroupMemberGetResponse to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberGetResponse
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GroupMemberGetResponse.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return GroupMemberGetResponse;
                })();

                Message.UserGroupListRequest = (function() {

                    /**
                     * Properties of a UserGroupListRequest.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface IUserGroupListRequest
                     * @property {AcFunDanmu.Im.Basic.ISyncCookie|null} [syncCookie] UserGroupListRequest syncCookie
                     */

                    /**
                     * Constructs a new UserGroupListRequest.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents a UserGroupListRequest.
                     * @implements IUserGroupListRequest
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.IUserGroupListRequest=} [properties] Properties to set
                     */
                    function UserGroupListRequest(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * UserGroupListRequest syncCookie.
                     * @member {AcFunDanmu.Im.Basic.ISyncCookie|null|undefined} syncCookie
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupListRequest
                     * @instance
                     */
                    UserGroupListRequest.prototype.syncCookie = null;

                    /**
                     * Creates a new UserGroupListRequest instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupListRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IUserGroupListRequest=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.UserGroupListRequest} UserGroupListRequest instance
                     */
                    UserGroupListRequest.create = function create(properties) {
                        return new UserGroupListRequest(properties);
                    };

                    /**
                     * Encodes the specified UserGroupListRequest message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.UserGroupListRequest.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupListRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IUserGroupListRequest} message UserGroupListRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    UserGroupListRequest.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.syncCookie != null && Object.hasOwnProperty.call(message, "syncCookie"))
                            $root.AcFunDanmu.Im.Basic.SyncCookie.encode(message.syncCookie, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified UserGroupListRequest message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.UserGroupListRequest.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupListRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IUserGroupListRequest} message UserGroupListRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    UserGroupListRequest.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a UserGroupListRequest message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupListRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.UserGroupListRequest} UserGroupListRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    UserGroupListRequest.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.UserGroupListRequest();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 2:
                                message.syncCookie = $root.AcFunDanmu.Im.Basic.SyncCookie.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a UserGroupListRequest message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupListRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.UserGroupListRequest} UserGroupListRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    UserGroupListRequest.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a UserGroupListRequest message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupListRequest
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    UserGroupListRequest.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.syncCookie != null && message.hasOwnProperty("syncCookie")) {
                            let error = $root.AcFunDanmu.Im.Basic.SyncCookie.verify(message.syncCookie);
                            if (error)
                                return "syncCookie." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a UserGroupListRequest message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupListRequest
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.UserGroupListRequest} UserGroupListRequest
                     */
                    UserGroupListRequest.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.UserGroupListRequest)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Message.UserGroupListRequest();
                        if (object.syncCookie != null) {
                            if (typeof object.syncCookie !== "object")
                                throw TypeError(".AcFunDanmu.Im.Cloud.Message.UserGroupListRequest.syncCookie: object expected");
                            message.syncCookie = $root.AcFunDanmu.Im.Basic.SyncCookie.fromObject(object.syncCookie);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a UserGroupListRequest message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupListRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.UserGroupListRequest} message UserGroupListRequest
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    UserGroupListRequest.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.syncCookie = null;
                        if (message.syncCookie != null && message.hasOwnProperty("syncCookie"))
                            object.syncCookie = $root.AcFunDanmu.Im.Basic.SyncCookie.toObject(message.syncCookie, options);
                        return object;
                    };

                    /**
                     * Converts this UserGroupListRequest to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupListRequest
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    UserGroupListRequest.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return UserGroupListRequest;
                })();

                Message.UserGroupListResponse = (function() {

                    /**
                     * Properties of a UserGroupListResponse.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface IUserGroupListResponse
                     * @property {Array.<AcFunDanmu.Im.Cloud.Message.IUserGroupInfo>|null} [userGroupInfo] UserGroupListResponse userGroupInfo
                     * @property {AcFunDanmu.Im.Basic.ISyncCookie|null} [syncCookie] UserGroupListResponse syncCookie
                     */

                    /**
                     * Constructs a new UserGroupListResponse.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents a UserGroupListResponse.
                     * @implements IUserGroupListResponse
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.IUserGroupListResponse=} [properties] Properties to set
                     */
                    function UserGroupListResponse(properties) {
                        this.userGroupInfo = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * UserGroupListResponse userGroupInfo.
                     * @member {Array.<AcFunDanmu.Im.Cloud.Message.IUserGroupInfo>} userGroupInfo
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupListResponse
                     * @instance
                     */
                    UserGroupListResponse.prototype.userGroupInfo = $util.emptyArray;

                    /**
                     * UserGroupListResponse syncCookie.
                     * @member {AcFunDanmu.Im.Basic.ISyncCookie|null|undefined} syncCookie
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupListResponse
                     * @instance
                     */
                    UserGroupListResponse.prototype.syncCookie = null;

                    /**
                     * Creates a new UserGroupListResponse instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupListResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IUserGroupListResponse=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.UserGroupListResponse} UserGroupListResponse instance
                     */
                    UserGroupListResponse.create = function create(properties) {
                        return new UserGroupListResponse(properties);
                    };

                    /**
                     * Encodes the specified UserGroupListResponse message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.UserGroupListResponse.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupListResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IUserGroupListResponse} message UserGroupListResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    UserGroupListResponse.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.userGroupInfo != null && message.userGroupInfo.length)
                            for (let i = 0; i < message.userGroupInfo.length; ++i)
                                $root.AcFunDanmu.Im.Cloud.Message.UserGroupInfo.encode(message.userGroupInfo[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.syncCookie != null && Object.hasOwnProperty.call(message, "syncCookie"))
                            $root.AcFunDanmu.Im.Basic.SyncCookie.encode(message.syncCookie, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified UserGroupListResponse message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.UserGroupListResponse.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupListResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IUserGroupListResponse} message UserGroupListResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    UserGroupListResponse.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a UserGroupListResponse message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupListResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.UserGroupListResponse} UserGroupListResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    UserGroupListResponse.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.UserGroupListResponse();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.userGroupInfo && message.userGroupInfo.length))
                                    message.userGroupInfo = [];
                                message.userGroupInfo.push($root.AcFunDanmu.Im.Cloud.Message.UserGroupInfo.decode(reader, reader.uint32()));
                                break;
                            case 2:
                                message.syncCookie = $root.AcFunDanmu.Im.Basic.SyncCookie.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a UserGroupListResponse message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupListResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.UserGroupListResponse} UserGroupListResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    UserGroupListResponse.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a UserGroupListResponse message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupListResponse
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    UserGroupListResponse.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.userGroupInfo != null && message.hasOwnProperty("userGroupInfo")) {
                            if (!Array.isArray(message.userGroupInfo))
                                return "userGroupInfo: array expected";
                            for (let i = 0; i < message.userGroupInfo.length; ++i) {
                                let error = $root.AcFunDanmu.Im.Cloud.Message.UserGroupInfo.verify(message.userGroupInfo[i]);
                                if (error)
                                    return "userGroupInfo." + error;
                            }
                        }
                        if (message.syncCookie != null && message.hasOwnProperty("syncCookie")) {
                            let error = $root.AcFunDanmu.Im.Basic.SyncCookie.verify(message.syncCookie);
                            if (error)
                                return "syncCookie." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a UserGroupListResponse message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupListResponse
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.UserGroupListResponse} UserGroupListResponse
                     */
                    UserGroupListResponse.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.UserGroupListResponse)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Message.UserGroupListResponse();
                        if (object.userGroupInfo) {
                            if (!Array.isArray(object.userGroupInfo))
                                throw TypeError(".AcFunDanmu.Im.Cloud.Message.UserGroupListResponse.userGroupInfo: array expected");
                            message.userGroupInfo = [];
                            for (let i = 0; i < object.userGroupInfo.length; ++i) {
                                if (typeof object.userGroupInfo[i] !== "object")
                                    throw TypeError(".AcFunDanmu.Im.Cloud.Message.UserGroupListResponse.userGroupInfo: object expected");
                                message.userGroupInfo[i] = $root.AcFunDanmu.Im.Cloud.Message.UserGroupInfo.fromObject(object.userGroupInfo[i]);
                            }
                        }
                        if (object.syncCookie != null) {
                            if (typeof object.syncCookie !== "object")
                                throw TypeError(".AcFunDanmu.Im.Cloud.Message.UserGroupListResponse.syncCookie: object expected");
                            message.syncCookie = $root.AcFunDanmu.Im.Basic.SyncCookie.fromObject(object.syncCookie);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a UserGroupListResponse message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupListResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.UserGroupListResponse} message UserGroupListResponse
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    UserGroupListResponse.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.userGroupInfo = [];
                        if (options.defaults)
                            object.syncCookie = null;
                        if (message.userGroupInfo && message.userGroupInfo.length) {
                            object.userGroupInfo = [];
                            for (let j = 0; j < message.userGroupInfo.length; ++j)
                                object.userGroupInfo[j] = $root.AcFunDanmu.Im.Cloud.Message.UserGroupInfo.toObject(message.userGroupInfo[j], options);
                        }
                        if (message.syncCookie != null && message.hasOwnProperty("syncCookie"))
                            object.syncCookie = $root.AcFunDanmu.Im.Basic.SyncCookie.toObject(message.syncCookie, options);
                        return object;
                    };

                    /**
                     * Converts this UserGroupListResponse to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupListResponse
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    UserGroupListResponse.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return UserGroupListResponse;
                })();

                Message.UserGroupRecord = (function() {

                    /**
                     * Properties of a UserGroupRecord.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface IUserGroupRecord
                     * @property {string|null} [groupId] UserGroupRecord groupId
                     * @property {number|Long|null} [updateTime] UserGroupRecord updateTime
                     */

                    /**
                     * Constructs a new UserGroupRecord.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents a UserGroupRecord.
                     * @implements IUserGroupRecord
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.IUserGroupRecord=} [properties] Properties to set
                     */
                    function UserGroupRecord(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * UserGroupRecord groupId.
                     * @member {string} groupId
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupRecord
                     * @instance
                     */
                    UserGroupRecord.prototype.groupId = "";

                    /**
                     * UserGroupRecord updateTime.
                     * @member {number|Long} updateTime
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupRecord
                     * @instance
                     */
                    UserGroupRecord.prototype.updateTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * Creates a new UserGroupRecord instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupRecord
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IUserGroupRecord=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.UserGroupRecord} UserGroupRecord instance
                     */
                    UserGroupRecord.create = function create(properties) {
                        return new UserGroupRecord(properties);
                    };

                    /**
                     * Encodes the specified UserGroupRecord message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.UserGroupRecord.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupRecord
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IUserGroupRecord} message UserGroupRecord message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    UserGroupRecord.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.groupId);
                        if (message.updateTime != null && Object.hasOwnProperty.call(message, "updateTime"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.updateTime);
                        return writer;
                    };

                    /**
                     * Encodes the specified UserGroupRecord message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.UserGroupRecord.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupRecord
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IUserGroupRecord} message UserGroupRecord message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    UserGroupRecord.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a UserGroupRecord message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupRecord
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.UserGroupRecord} UserGroupRecord
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    UserGroupRecord.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.UserGroupRecord();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.groupId = reader.string();
                                break;
                            case 2:
                                message.updateTime = reader.int64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a UserGroupRecord message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupRecord
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.UserGroupRecord} UserGroupRecord
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    UserGroupRecord.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a UserGroupRecord message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupRecord
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    UserGroupRecord.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.groupId != null && message.hasOwnProperty("groupId"))
                            if (!$util.isString(message.groupId))
                                return "groupId: string expected";
                        if (message.updateTime != null && message.hasOwnProperty("updateTime"))
                            if (!$util.isInteger(message.updateTime) && !(message.updateTime && $util.isInteger(message.updateTime.low) && $util.isInteger(message.updateTime.high)))
                                return "updateTime: integer|Long expected";
                        return null;
                    };

                    /**
                     * Creates a UserGroupRecord message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupRecord
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.UserGroupRecord} UserGroupRecord
                     */
                    UserGroupRecord.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.UserGroupRecord)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Message.UserGroupRecord();
                        if (object.groupId != null)
                            message.groupId = String(object.groupId);
                        if (object.updateTime != null)
                            if ($util.Long)
                                (message.updateTime = $util.Long.fromValue(object.updateTime)).unsigned = false;
                            else if (typeof object.updateTime === "string")
                                message.updateTime = parseInt(object.updateTime, 10);
                            else if (typeof object.updateTime === "number")
                                message.updateTime = object.updateTime;
                            else if (typeof object.updateTime === "object")
                                message.updateTime = new $util.LongBits(object.updateTime.low >>> 0, object.updateTime.high >>> 0).toNumber();
                        return message;
                    };

                    /**
                     * Creates a plain object from a UserGroupRecord message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupRecord
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.UserGroupRecord} message UserGroupRecord
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    UserGroupRecord.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.groupId = "";
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, false);
                                object.updateTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.updateTime = options.longs === String ? "0" : 0;
                        }
                        if (message.groupId != null && message.hasOwnProperty("groupId"))
                            object.groupId = message.groupId;
                        if (message.updateTime != null && message.hasOwnProperty("updateTime"))
                            if (typeof message.updateTime === "number")
                                object.updateTime = options.longs === String ? String(message.updateTime) : message.updateTime;
                            else
                                object.updateTime = options.longs === String ? $util.Long.prototype.toString.call(message.updateTime) : options.longs === Number ? new $util.LongBits(message.updateTime.low >>> 0, message.updateTime.high >>> 0).toNumber() : message.updateTime;
                        return object;
                    };

                    /**
                     * Converts this UserGroupRecord to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupRecord
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    UserGroupRecord.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return UserGroupRecord;
                })();

                Message.UserGroupGetRequest = (function() {

                    /**
                     * Properties of a UserGroupGetRequest.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface IUserGroupGetRequest
                     * @property {Array.<string>|null} [groupId] UserGroupGetRequest groupId
                     */

                    /**
                     * Constructs a new UserGroupGetRequest.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents a UserGroupGetRequest.
                     * @implements IUserGroupGetRequest
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.IUserGroupGetRequest=} [properties] Properties to set
                     */
                    function UserGroupGetRequest(properties) {
                        this.groupId = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * UserGroupGetRequest groupId.
                     * @member {Array.<string>} groupId
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupGetRequest
                     * @instance
                     */
                    UserGroupGetRequest.prototype.groupId = $util.emptyArray;

                    /**
                     * Creates a new UserGroupGetRequest instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupGetRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IUserGroupGetRequest=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.UserGroupGetRequest} UserGroupGetRequest instance
                     */
                    UserGroupGetRequest.create = function create(properties) {
                        return new UserGroupGetRequest(properties);
                    };

                    /**
                     * Encodes the specified UserGroupGetRequest message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.UserGroupGetRequest.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupGetRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IUserGroupGetRequest} message UserGroupGetRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    UserGroupGetRequest.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.groupId != null && message.groupId.length)
                            for (let i = 0; i < message.groupId.length; ++i)
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.groupId[i]);
                        return writer;
                    };

                    /**
                     * Encodes the specified UserGroupGetRequest message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.UserGroupGetRequest.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupGetRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IUserGroupGetRequest} message UserGroupGetRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    UserGroupGetRequest.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a UserGroupGetRequest message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupGetRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.UserGroupGetRequest} UserGroupGetRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    UserGroupGetRequest.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.UserGroupGetRequest();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.groupId && message.groupId.length))
                                    message.groupId = [];
                                message.groupId.push(reader.string());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a UserGroupGetRequest message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupGetRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.UserGroupGetRequest} UserGroupGetRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    UserGroupGetRequest.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a UserGroupGetRequest message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupGetRequest
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    UserGroupGetRequest.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.groupId != null && message.hasOwnProperty("groupId")) {
                            if (!Array.isArray(message.groupId))
                                return "groupId: array expected";
                            for (let i = 0; i < message.groupId.length; ++i)
                                if (!$util.isString(message.groupId[i]))
                                    return "groupId: string[] expected";
                        }
                        return null;
                    };

                    /**
                     * Creates a UserGroupGetRequest message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupGetRequest
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.UserGroupGetRequest} UserGroupGetRequest
                     */
                    UserGroupGetRequest.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.UserGroupGetRequest)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Message.UserGroupGetRequest();
                        if (object.groupId) {
                            if (!Array.isArray(object.groupId))
                                throw TypeError(".AcFunDanmu.Im.Cloud.Message.UserGroupGetRequest.groupId: array expected");
                            message.groupId = [];
                            for (let i = 0; i < object.groupId.length; ++i)
                                message.groupId[i] = String(object.groupId[i]);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a UserGroupGetRequest message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupGetRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.UserGroupGetRequest} message UserGroupGetRequest
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    UserGroupGetRequest.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.groupId = [];
                        if (message.groupId && message.groupId.length) {
                            object.groupId = [];
                            for (let j = 0; j < message.groupId.length; ++j)
                                object.groupId[j] = message.groupId[j];
                        }
                        return object;
                    };

                    /**
                     * Converts this UserGroupGetRequest to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupGetRequest
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    UserGroupGetRequest.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return UserGroupGetRequest;
                })();

                Message.UserGroupGetResponse = (function() {

                    /**
                     * Properties of a UserGroupGetResponse.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface IUserGroupGetResponse
                     * @property {Array.<AcFunDanmu.Im.Cloud.Message.IUserGroupInfo>|null} [userGroupInfo] UserGroupGetResponse userGroupInfo
                     */

                    /**
                     * Constructs a new UserGroupGetResponse.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents a UserGroupGetResponse.
                     * @implements IUserGroupGetResponse
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.IUserGroupGetResponse=} [properties] Properties to set
                     */
                    function UserGroupGetResponse(properties) {
                        this.userGroupInfo = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * UserGroupGetResponse userGroupInfo.
                     * @member {Array.<AcFunDanmu.Im.Cloud.Message.IUserGroupInfo>} userGroupInfo
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupGetResponse
                     * @instance
                     */
                    UserGroupGetResponse.prototype.userGroupInfo = $util.emptyArray;

                    /**
                     * Creates a new UserGroupGetResponse instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupGetResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IUserGroupGetResponse=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.UserGroupGetResponse} UserGroupGetResponse instance
                     */
                    UserGroupGetResponse.create = function create(properties) {
                        return new UserGroupGetResponse(properties);
                    };

                    /**
                     * Encodes the specified UserGroupGetResponse message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.UserGroupGetResponse.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupGetResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IUserGroupGetResponse} message UserGroupGetResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    UserGroupGetResponse.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.userGroupInfo != null && message.userGroupInfo.length)
                            for (let i = 0; i < message.userGroupInfo.length; ++i)
                                $root.AcFunDanmu.Im.Cloud.Message.UserGroupInfo.encode(message.userGroupInfo[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified UserGroupGetResponse message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.UserGroupGetResponse.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupGetResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IUserGroupGetResponse} message UserGroupGetResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    UserGroupGetResponse.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a UserGroupGetResponse message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupGetResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.UserGroupGetResponse} UserGroupGetResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    UserGroupGetResponse.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.UserGroupGetResponse();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.userGroupInfo && message.userGroupInfo.length))
                                    message.userGroupInfo = [];
                                message.userGroupInfo.push($root.AcFunDanmu.Im.Cloud.Message.UserGroupInfo.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a UserGroupGetResponse message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupGetResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.UserGroupGetResponse} UserGroupGetResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    UserGroupGetResponse.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a UserGroupGetResponse message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupGetResponse
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    UserGroupGetResponse.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.userGroupInfo != null && message.hasOwnProperty("userGroupInfo")) {
                            if (!Array.isArray(message.userGroupInfo))
                                return "userGroupInfo: array expected";
                            for (let i = 0; i < message.userGroupInfo.length; ++i) {
                                let error = $root.AcFunDanmu.Im.Cloud.Message.UserGroupInfo.verify(message.userGroupInfo[i]);
                                if (error)
                                    return "userGroupInfo." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a UserGroupGetResponse message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupGetResponse
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.UserGroupGetResponse} UserGroupGetResponse
                     */
                    UserGroupGetResponse.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.UserGroupGetResponse)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Message.UserGroupGetResponse();
                        if (object.userGroupInfo) {
                            if (!Array.isArray(object.userGroupInfo))
                                throw TypeError(".AcFunDanmu.Im.Cloud.Message.UserGroupGetResponse.userGroupInfo: array expected");
                            message.userGroupInfo = [];
                            for (let i = 0; i < object.userGroupInfo.length; ++i) {
                                if (typeof object.userGroupInfo[i] !== "object")
                                    throw TypeError(".AcFunDanmu.Im.Cloud.Message.UserGroupGetResponse.userGroupInfo: object expected");
                                message.userGroupInfo[i] = $root.AcFunDanmu.Im.Cloud.Message.UserGroupInfo.fromObject(object.userGroupInfo[i]);
                            }
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a UserGroupGetResponse message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupGetResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.UserGroupGetResponse} message UserGroupGetResponse
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    UserGroupGetResponse.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.userGroupInfo = [];
                        if (message.userGroupInfo && message.userGroupInfo.length) {
                            object.userGroupInfo = [];
                            for (let j = 0; j < message.userGroupInfo.length; ++j)
                                object.userGroupInfo[j] = $root.AcFunDanmu.Im.Cloud.Message.UserGroupInfo.toObject(message.userGroupInfo[j], options);
                        }
                        return object;
                    };

                    /**
                     * Converts this UserGroupGetResponse to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupGetResponse
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    UserGroupGetResponse.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return UserGroupGetResponse;
                })();

                Message.UserGroupInfo = (function() {

                    /**
                     * Properties of a UserGroupInfo.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface IUserGroupInfo
                     * @property {AcFunDanmu.Im.Cloud.Message.IGroupInfo|null} [groupInfo] UserGroupInfo groupInfo
                     * @property {AcFunDanmu.Im.Cloud.Message.IGroupMember|null} [groupMember] UserGroupInfo groupMember
                     */

                    /**
                     * Constructs a new UserGroupInfo.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents a UserGroupInfo.
                     * @implements IUserGroupInfo
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.IUserGroupInfo=} [properties] Properties to set
                     */
                    function UserGroupInfo(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * UserGroupInfo groupInfo.
                     * @member {AcFunDanmu.Im.Cloud.Message.IGroupInfo|null|undefined} groupInfo
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupInfo
                     * @instance
                     */
                    UserGroupInfo.prototype.groupInfo = null;

                    /**
                     * UserGroupInfo groupMember.
                     * @member {AcFunDanmu.Im.Cloud.Message.IGroupMember|null|undefined} groupMember
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupInfo
                     * @instance
                     */
                    UserGroupInfo.prototype.groupMember = null;

                    /**
                     * Creates a new UserGroupInfo instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupInfo
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IUserGroupInfo=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.UserGroupInfo} UserGroupInfo instance
                     */
                    UserGroupInfo.create = function create(properties) {
                        return new UserGroupInfo(properties);
                    };

                    /**
                     * Encodes the specified UserGroupInfo message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.UserGroupInfo.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupInfo
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IUserGroupInfo} message UserGroupInfo message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    UserGroupInfo.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.groupInfo != null && Object.hasOwnProperty.call(message, "groupInfo"))
                            $root.AcFunDanmu.Im.Cloud.Message.GroupInfo.encode(message.groupInfo, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.groupMember != null && Object.hasOwnProperty.call(message, "groupMember"))
                            $root.AcFunDanmu.Im.Cloud.Message.GroupMember.encode(message.groupMember, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified UserGroupInfo message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.UserGroupInfo.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupInfo
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IUserGroupInfo} message UserGroupInfo message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    UserGroupInfo.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a UserGroupInfo message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupInfo
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.UserGroupInfo} UserGroupInfo
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    UserGroupInfo.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.UserGroupInfo();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.groupInfo = $root.AcFunDanmu.Im.Cloud.Message.GroupInfo.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.groupMember = $root.AcFunDanmu.Im.Cloud.Message.GroupMember.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a UserGroupInfo message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupInfo
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.UserGroupInfo} UserGroupInfo
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    UserGroupInfo.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a UserGroupInfo message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupInfo
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    UserGroupInfo.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.groupInfo != null && message.hasOwnProperty("groupInfo")) {
                            let error = $root.AcFunDanmu.Im.Cloud.Message.GroupInfo.verify(message.groupInfo);
                            if (error)
                                return "groupInfo." + error;
                        }
                        if (message.groupMember != null && message.hasOwnProperty("groupMember")) {
                            let error = $root.AcFunDanmu.Im.Cloud.Message.GroupMember.verify(message.groupMember);
                            if (error)
                                return "groupMember." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a UserGroupInfo message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupInfo
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.UserGroupInfo} UserGroupInfo
                     */
                    UserGroupInfo.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.UserGroupInfo)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Message.UserGroupInfo();
                        if (object.groupInfo != null) {
                            if (typeof object.groupInfo !== "object")
                                throw TypeError(".AcFunDanmu.Im.Cloud.Message.UserGroupInfo.groupInfo: object expected");
                            message.groupInfo = $root.AcFunDanmu.Im.Cloud.Message.GroupInfo.fromObject(object.groupInfo);
                        }
                        if (object.groupMember != null) {
                            if (typeof object.groupMember !== "object")
                                throw TypeError(".AcFunDanmu.Im.Cloud.Message.UserGroupInfo.groupMember: object expected");
                            message.groupMember = $root.AcFunDanmu.Im.Cloud.Message.GroupMember.fromObject(object.groupMember);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a UserGroupInfo message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupInfo
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.UserGroupInfo} message UserGroupInfo
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    UserGroupInfo.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.groupInfo = null;
                            object.groupMember = null;
                        }
                        if (message.groupInfo != null && message.hasOwnProperty("groupInfo"))
                            object.groupInfo = $root.AcFunDanmu.Im.Cloud.Message.GroupInfo.toObject(message.groupInfo, options);
                        if (message.groupMember != null && message.hasOwnProperty("groupMember"))
                            object.groupMember = $root.AcFunDanmu.Im.Cloud.Message.GroupMember.toObject(message.groupMember, options);
                        return object;
                    };

                    /**
                     * Converts this UserGroupInfo to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.UserGroupInfo
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    UserGroupInfo.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return UserGroupInfo;
                })();

                Message.GroupMember = (function() {

                    /**
                     * Properties of a GroupMember.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface IGroupMember
                     * @property {AcFunDanmu.Im.Basic.IUser|null} [user] GroupMember user
                     * @property {string|null} [nickname] GroupMember nickname
                     * @property {boolean|null} [antiDisturbing] GroupMember antiDisturbing
                     * @property {AcFunDanmu.Im.Cloud.Message.GroupMember.GroupMemberStatus|null} [status] GroupMember status
                     * @property {number|Long|null} [inviterId] GroupMember inviterId
                     * @property {number|Long|null} [joinTime] GroupMember joinTime
                     * @property {number|Long|null} [createTime] GroupMember createTime
                     * @property {number|Long|null} [updateTime] GroupMember updateTime
                     * @property {AcFunDanmu.Im.Cloud.Message.GroupMember.GroupMemberRole|null} [role] GroupMember role
                     * @property {AcFunDanmu.Im.Cloud.Message.GroupFindType|null} [findType] GroupMember findType
                     */

                    /**
                     * Constructs a new GroupMember.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents a GroupMember.
                     * @implements IGroupMember
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupMember=} [properties] Properties to set
                     */
                    function GroupMember(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * GroupMember user.
                     * @member {AcFunDanmu.Im.Basic.IUser|null|undefined} user
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMember
                     * @instance
                     */
                    GroupMember.prototype.user = null;

                    /**
                     * GroupMember nickname.
                     * @member {string} nickname
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMember
                     * @instance
                     */
                    GroupMember.prototype.nickname = "";

                    /**
                     * GroupMember antiDisturbing.
                     * @member {boolean} antiDisturbing
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMember
                     * @instance
                     */
                    GroupMember.prototype.antiDisturbing = false;

                    /**
                     * GroupMember status.
                     * @member {AcFunDanmu.Im.Cloud.Message.GroupMember.GroupMemberStatus} status
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMember
                     * @instance
                     */
                    GroupMember.prototype.status = 0;

                    /**
                     * GroupMember inviterId.
                     * @member {number|Long} inviterId
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMember
                     * @instance
                     */
                    GroupMember.prototype.inviterId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * GroupMember joinTime.
                     * @member {number|Long} joinTime
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMember
                     * @instance
                     */
                    GroupMember.prototype.joinTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * GroupMember createTime.
                     * @member {number|Long} createTime
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMember
                     * @instance
                     */
                    GroupMember.prototype.createTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * GroupMember updateTime.
                     * @member {number|Long} updateTime
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMember
                     * @instance
                     */
                    GroupMember.prototype.updateTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * GroupMember role.
                     * @member {AcFunDanmu.Im.Cloud.Message.GroupMember.GroupMemberRole} role
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMember
                     * @instance
                     */
                    GroupMember.prototype.role = 0;

                    /**
                     * GroupMember findType.
                     * @member {AcFunDanmu.Im.Cloud.Message.GroupFindType} findType
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMember
                     * @instance
                     */
                    GroupMember.prototype.findType = 0;

                    /**
                     * Creates a new GroupMember instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMember
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupMember=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupMember} GroupMember instance
                     */
                    GroupMember.create = function create(properties) {
                        return new GroupMember(properties);
                    };

                    /**
                     * Encodes the specified GroupMember message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupMember.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMember
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupMember} message GroupMember message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupMember.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.user != null && Object.hasOwnProperty.call(message, "user"))
                            $root.AcFunDanmu.Im.Basic.User.encode(message.user, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.nickname != null && Object.hasOwnProperty.call(message, "nickname"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.nickname);
                        if (message.antiDisturbing != null && Object.hasOwnProperty.call(message, "antiDisturbing"))
                            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.antiDisturbing);
                        if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.status);
                        if (message.inviterId != null && Object.hasOwnProperty.call(message, "inviterId"))
                            writer.uint32(/* id 5, wireType 0 =*/40).int64(message.inviterId);
                        if (message.joinTime != null && Object.hasOwnProperty.call(message, "joinTime"))
                            writer.uint32(/* id 6, wireType 0 =*/48).int64(message.joinTime);
                        if (message.createTime != null && Object.hasOwnProperty.call(message, "createTime"))
                            writer.uint32(/* id 7, wireType 0 =*/56).int64(message.createTime);
                        if (message.updateTime != null && Object.hasOwnProperty.call(message, "updateTime"))
                            writer.uint32(/* id 8, wireType 0 =*/64).int64(message.updateTime);
                        if (message.role != null && Object.hasOwnProperty.call(message, "role"))
                            writer.uint32(/* id 9, wireType 0 =*/72).int32(message.role);
                        if (message.findType != null && Object.hasOwnProperty.call(message, "findType"))
                            writer.uint32(/* id 10, wireType 0 =*/80).int32(message.findType);
                        return writer;
                    };

                    /**
                     * Encodes the specified GroupMember message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupMember.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMember
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupMember} message GroupMember message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupMember.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a GroupMember message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMember
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupMember} GroupMember
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupMember.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.GroupMember();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.user = $root.AcFunDanmu.Im.Basic.User.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.nickname = reader.string();
                                break;
                            case 3:
                                message.antiDisturbing = reader.bool();
                                break;
                            case 4:
                                message.status = reader.int32();
                                break;
                            case 5:
                                message.inviterId = reader.int64();
                                break;
                            case 6:
                                message.joinTime = reader.int64();
                                break;
                            case 7:
                                message.createTime = reader.int64();
                                break;
                            case 8:
                                message.updateTime = reader.int64();
                                break;
                            case 9:
                                message.role = reader.int32();
                                break;
                            case 10:
                                message.findType = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a GroupMember message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMember
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupMember} GroupMember
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupMember.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a GroupMember message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMember
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GroupMember.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.user != null && message.hasOwnProperty("user")) {
                            let error = $root.AcFunDanmu.Im.Basic.User.verify(message.user);
                            if (error)
                                return "user." + error;
                        }
                        if (message.nickname != null && message.hasOwnProperty("nickname"))
                            if (!$util.isString(message.nickname))
                                return "nickname: string expected";
                        if (message.antiDisturbing != null && message.hasOwnProperty("antiDisturbing"))
                            if (typeof message.antiDisturbing !== "boolean")
                                return "antiDisturbing: boolean expected";
                        if (message.status != null && message.hasOwnProperty("status"))
                            switch (message.status) {
                            default:
                                return "status: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                                break;
                            }
                        if (message.inviterId != null && message.hasOwnProperty("inviterId"))
                            if (!$util.isInteger(message.inviterId) && !(message.inviterId && $util.isInteger(message.inviterId.low) && $util.isInteger(message.inviterId.high)))
                                return "inviterId: integer|Long expected";
                        if (message.joinTime != null && message.hasOwnProperty("joinTime"))
                            if (!$util.isInteger(message.joinTime) && !(message.joinTime && $util.isInteger(message.joinTime.low) && $util.isInteger(message.joinTime.high)))
                                return "joinTime: integer|Long expected";
                        if (message.createTime != null && message.hasOwnProperty("createTime"))
                            if (!$util.isInteger(message.createTime) && !(message.createTime && $util.isInteger(message.createTime.low) && $util.isInteger(message.createTime.high)))
                                return "createTime: integer|Long expected";
                        if (message.updateTime != null && message.hasOwnProperty("updateTime"))
                            if (!$util.isInteger(message.updateTime) && !(message.updateTime && $util.isInteger(message.updateTime.low) && $util.isInteger(message.updateTime.high)))
                                return "updateTime: integer|Long expected";
                        if (message.role != null && message.hasOwnProperty("role"))
                            switch (message.role) {
                            default:
                                return "role: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                                break;
                            }
                        if (message.findType != null && message.hasOwnProperty("findType"))
                            switch (message.findType) {
                            default:
                                return "findType: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 6:
                                break;
                            }
                        return null;
                    };

                    /**
                     * Creates a GroupMember message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMember
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupMember} GroupMember
                     */
                    GroupMember.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.GroupMember)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Message.GroupMember();
                        if (object.user != null) {
                            if (typeof object.user !== "object")
                                throw TypeError(".AcFunDanmu.Im.Cloud.Message.GroupMember.user: object expected");
                            message.user = $root.AcFunDanmu.Im.Basic.User.fromObject(object.user);
                        }
                        if (object.nickname != null)
                            message.nickname = String(object.nickname);
                        if (object.antiDisturbing != null)
                            message.antiDisturbing = Boolean(object.antiDisturbing);
                        switch (object.status) {
                        case "UNKNOWN_MEMBER_STATUS":
                        case 0:
                            message.status = 0;
                            break;
                        case "NORMAL":
                        case 1:
                            message.status = 1;
                            break;
                        case "QUITTED":
                        case 2:
                            message.status = 2;
                            break;
                        case "KICKED":
                        case 3:
                            message.status = 3;
                            break;
                        case "DISMISSED":
                        case 4:
                            message.status = 4;
                            break;
                        }
                        if (object.inviterId != null)
                            if ($util.Long)
                                (message.inviterId = $util.Long.fromValue(object.inviterId)).unsigned = false;
                            else if (typeof object.inviterId === "string")
                                message.inviterId = parseInt(object.inviterId, 10);
                            else if (typeof object.inviterId === "number")
                                message.inviterId = object.inviterId;
                            else if (typeof object.inviterId === "object")
                                message.inviterId = new $util.LongBits(object.inviterId.low >>> 0, object.inviterId.high >>> 0).toNumber();
                        if (object.joinTime != null)
                            if ($util.Long)
                                (message.joinTime = $util.Long.fromValue(object.joinTime)).unsigned = false;
                            else if (typeof object.joinTime === "string")
                                message.joinTime = parseInt(object.joinTime, 10);
                            else if (typeof object.joinTime === "number")
                                message.joinTime = object.joinTime;
                            else if (typeof object.joinTime === "object")
                                message.joinTime = new $util.LongBits(object.joinTime.low >>> 0, object.joinTime.high >>> 0).toNumber();
                        if (object.createTime != null)
                            if ($util.Long)
                                (message.createTime = $util.Long.fromValue(object.createTime)).unsigned = false;
                            else if (typeof object.createTime === "string")
                                message.createTime = parseInt(object.createTime, 10);
                            else if (typeof object.createTime === "number")
                                message.createTime = object.createTime;
                            else if (typeof object.createTime === "object")
                                message.createTime = new $util.LongBits(object.createTime.low >>> 0, object.createTime.high >>> 0).toNumber();
                        if (object.updateTime != null)
                            if ($util.Long)
                                (message.updateTime = $util.Long.fromValue(object.updateTime)).unsigned = false;
                            else if (typeof object.updateTime === "string")
                                message.updateTime = parseInt(object.updateTime, 10);
                            else if (typeof object.updateTime === "number")
                                message.updateTime = object.updateTime;
                            else if (typeof object.updateTime === "object")
                                message.updateTime = new $util.LongBits(object.updateTime.low >>> 0, object.updateTime.high >>> 0).toNumber();
                        switch (object.role) {
                        case "UNKNOWN_ROLE":
                        case 0:
                            message.role = 0;
                            break;
                        case "COMMON":
                        case 1:
                            message.role = 1;
                            break;
                        case "ADMIN":
                        case 2:
                            message.role = 2;
                            break;
                        }
                        switch (object.findType) {
                        case "BY_UNKNOWN":
                        case 0:
                            message.findType = 0;
                            break;
                        case "BY_ID":
                        case 1:
                            message.findType = 1;
                            break;
                        case "BY_NAME":
                        case 2:
                            message.findType = 2;
                            break;
                        case "BY_QR_CODE":
                        case 3:
                            message.findType = 3;
                            break;
                        case "BY_CARD":
                        case 4:
                            message.findType = 4;
                            break;
                        case "BY_INVITATION":
                        case 5:
                            message.findType = 5;
                            break;
                        case "BY_SHARE_LINK":
                        case 6:
                            message.findType = 6;
                            break;
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a GroupMember message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMember
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.GroupMember} message GroupMember
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GroupMember.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.user = null;
                            object.nickname = "";
                            object.antiDisturbing = false;
                            object.status = options.enums === String ? "UNKNOWN_MEMBER_STATUS" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, false);
                                object.inviterId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.inviterId = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, false);
                                object.joinTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.joinTime = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, false);
                                object.createTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.createTime = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, false);
                                object.updateTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.updateTime = options.longs === String ? "0" : 0;
                            object.role = options.enums === String ? "UNKNOWN_ROLE" : 0;
                            object.findType = options.enums === String ? "BY_UNKNOWN" : 0;
                        }
                        if (message.user != null && message.hasOwnProperty("user"))
                            object.user = $root.AcFunDanmu.Im.Basic.User.toObject(message.user, options);
                        if (message.nickname != null && message.hasOwnProperty("nickname"))
                            object.nickname = message.nickname;
                        if (message.antiDisturbing != null && message.hasOwnProperty("antiDisturbing"))
                            object.antiDisturbing = message.antiDisturbing;
                        if (message.status != null && message.hasOwnProperty("status"))
                            object.status = options.enums === String ? $root.AcFunDanmu.Im.Cloud.Message.GroupMember.GroupMemberStatus[message.status] : message.status;
                        if (message.inviterId != null && message.hasOwnProperty("inviterId"))
                            if (typeof message.inviterId === "number")
                                object.inviterId = options.longs === String ? String(message.inviterId) : message.inviterId;
                            else
                                object.inviterId = options.longs === String ? $util.Long.prototype.toString.call(message.inviterId) : options.longs === Number ? new $util.LongBits(message.inviterId.low >>> 0, message.inviterId.high >>> 0).toNumber() : message.inviterId;
                        if (message.joinTime != null && message.hasOwnProperty("joinTime"))
                            if (typeof message.joinTime === "number")
                                object.joinTime = options.longs === String ? String(message.joinTime) : message.joinTime;
                            else
                                object.joinTime = options.longs === String ? $util.Long.prototype.toString.call(message.joinTime) : options.longs === Number ? new $util.LongBits(message.joinTime.low >>> 0, message.joinTime.high >>> 0).toNumber() : message.joinTime;
                        if (message.createTime != null && message.hasOwnProperty("createTime"))
                            if (typeof message.createTime === "number")
                                object.createTime = options.longs === String ? String(message.createTime) : message.createTime;
                            else
                                object.createTime = options.longs === String ? $util.Long.prototype.toString.call(message.createTime) : options.longs === Number ? new $util.LongBits(message.createTime.low >>> 0, message.createTime.high >>> 0).toNumber() : message.createTime;
                        if (message.updateTime != null && message.hasOwnProperty("updateTime"))
                            if (typeof message.updateTime === "number")
                                object.updateTime = options.longs === String ? String(message.updateTime) : message.updateTime;
                            else
                                object.updateTime = options.longs === String ? $util.Long.prototype.toString.call(message.updateTime) : options.longs === Number ? new $util.LongBits(message.updateTime.low >>> 0, message.updateTime.high >>> 0).toNumber() : message.updateTime;
                        if (message.role != null && message.hasOwnProperty("role"))
                            object.role = options.enums === String ? $root.AcFunDanmu.Im.Cloud.Message.GroupMember.GroupMemberRole[message.role] : message.role;
                        if (message.findType != null && message.hasOwnProperty("findType"))
                            object.findType = options.enums === String ? $root.AcFunDanmu.Im.Cloud.Message.GroupFindType[message.findType] : message.findType;
                        return object;
                    };

                    /**
                     * Converts this GroupMember to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMember
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GroupMember.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * GroupMemberStatus enum.
                     * @name AcFunDanmu.Im.Cloud.Message.GroupMember.GroupMemberStatus
                     * @enum {number}
                     * @property {number} UNKNOWN_MEMBER_STATUS=0 UNKNOWN_MEMBER_STATUS value
                     * @property {number} NORMAL=1 NORMAL value
                     * @property {number} QUITTED=2 QUITTED value
                     * @property {number} KICKED=3 KICKED value
                     * @property {number} DISMISSED=4 DISMISSED value
                     */
                    GroupMember.GroupMemberStatus = (function() {
                        const valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "UNKNOWN_MEMBER_STATUS"] = 0;
                        values[valuesById[1] = "NORMAL"] = 1;
                        values[valuesById[2] = "QUITTED"] = 2;
                        values[valuesById[3] = "KICKED"] = 3;
                        values[valuesById[4] = "DISMISSED"] = 4;
                        return values;
                    })();

                    /**
                     * GroupMemberRole enum.
                     * @name AcFunDanmu.Im.Cloud.Message.GroupMember.GroupMemberRole
                     * @enum {number}
                     * @property {number} UNKNOWN_ROLE=0 UNKNOWN_ROLE value
                     * @property {number} COMMON=1 COMMON value
                     * @property {number} ADMIN=2 ADMIN value
                     */
                    GroupMember.GroupMemberRole = (function() {
                        const valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "UNKNOWN_ROLE"] = 0;
                        values[valuesById[1] = "COMMON"] = 1;
                        values[valuesById[2] = "ADMIN"] = 2;
                        return values;
                    })();

                    return GroupMember;
                })();

                /**
                 * InvitePermissionType enum.
                 * @name AcFunDanmu.Im.Cloud.Message.InvitePermissionType
                 * @enum {number}
                 * @property {number} UNKNOWN_INVITE_PERMISSION_TYPE=0 UNKNOWN_INVITE_PERMISSION_TYPE value
                 * @property {number} EVERYONE=1 EVERYONE value
                 * @property {number} ONLY_ADMIN=2 ONLY_ADMIN value
                 */
                Message.InvitePermissionType = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "UNKNOWN_INVITE_PERMISSION_TYPE"] = 0;
                    values[valuesById[1] = "EVERYONE"] = 1;
                    values[valuesById[2] = "ONLY_ADMIN"] = 2;
                    return values;
                })();

                /**
                 * JoinNeedPermissionType enum.
                 * @name AcFunDanmu.Im.Cloud.Message.JoinNeedPermissionType
                 * @enum {number}
                 * @property {number} UNKNOWN_JOIN_NEED_PERMISSION_TYPE=0 UNKNOWN_JOIN_NEED_PERMISSION_TYPE value
                 * @property {number} NONE=1 NONE value
                 * @property {number} ADMIN=2 ADMIN value
                 */
                Message.JoinNeedPermissionType = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "UNKNOWN_JOIN_NEED_PERMISSION_TYPE"] = 0;
                    values[valuesById[1] = "NONE"] = 1;
                    values[valuesById[2] = "ADMIN"] = 2;
                    return values;
                })();

                Message.GroupInfo = (function() {

                    /**
                     * Properties of a GroupInfo.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface IGroupInfo
                     * @property {AcFunDanmu.Im.Cloud.Message.IGroupBasicInfo|null} [basicInfo] GroupInfo basicInfo
                     * @property {AcFunDanmu.Im.Cloud.Message.IGroupMemberBriefInfo|null} [groupMemberBriefInfo] GroupInfo groupMemberBriefInfo
                     */

                    /**
                     * Constructs a new GroupInfo.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents a GroupInfo.
                     * @implements IGroupInfo
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupInfo=} [properties] Properties to set
                     */
                    function GroupInfo(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * GroupInfo basicInfo.
                     * @member {AcFunDanmu.Im.Cloud.Message.IGroupBasicInfo|null|undefined} basicInfo
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupInfo
                     * @instance
                     */
                    GroupInfo.prototype.basicInfo = null;

                    /**
                     * GroupInfo groupMemberBriefInfo.
                     * @member {AcFunDanmu.Im.Cloud.Message.IGroupMemberBriefInfo|null|undefined} groupMemberBriefInfo
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupInfo
                     * @instance
                     */
                    GroupInfo.prototype.groupMemberBriefInfo = null;

                    /**
                     * Creates a new GroupInfo instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupInfo
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupInfo=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupInfo} GroupInfo instance
                     */
                    GroupInfo.create = function create(properties) {
                        return new GroupInfo(properties);
                    };

                    /**
                     * Encodes the specified GroupInfo message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupInfo.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupInfo
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupInfo} message GroupInfo message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupInfo.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.basicInfo != null && Object.hasOwnProperty.call(message, "basicInfo"))
                            $root.AcFunDanmu.Im.Cloud.Message.GroupBasicInfo.encode(message.basicInfo, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.groupMemberBriefInfo != null && Object.hasOwnProperty.call(message, "groupMemberBriefInfo"))
                            $root.AcFunDanmu.Im.Cloud.Message.GroupMemberBriefInfo.encode(message.groupMemberBriefInfo, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified GroupInfo message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupInfo.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupInfo
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupInfo} message GroupInfo message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupInfo.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a GroupInfo message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupInfo
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupInfo} GroupInfo
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupInfo.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.GroupInfo();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.basicInfo = $root.AcFunDanmu.Im.Cloud.Message.GroupBasicInfo.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.groupMemberBriefInfo = $root.AcFunDanmu.Im.Cloud.Message.GroupMemberBriefInfo.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a GroupInfo message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupInfo
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupInfo} GroupInfo
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupInfo.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a GroupInfo message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupInfo
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GroupInfo.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.basicInfo != null && message.hasOwnProperty("basicInfo")) {
                            let error = $root.AcFunDanmu.Im.Cloud.Message.GroupBasicInfo.verify(message.basicInfo);
                            if (error)
                                return "basicInfo." + error;
                        }
                        if (message.groupMemberBriefInfo != null && message.hasOwnProperty("groupMemberBriefInfo")) {
                            let error = $root.AcFunDanmu.Im.Cloud.Message.GroupMemberBriefInfo.verify(message.groupMemberBriefInfo);
                            if (error)
                                return "groupMemberBriefInfo." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a GroupInfo message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupInfo
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupInfo} GroupInfo
                     */
                    GroupInfo.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.GroupInfo)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Message.GroupInfo();
                        if (object.basicInfo != null) {
                            if (typeof object.basicInfo !== "object")
                                throw TypeError(".AcFunDanmu.Im.Cloud.Message.GroupInfo.basicInfo: object expected");
                            message.basicInfo = $root.AcFunDanmu.Im.Cloud.Message.GroupBasicInfo.fromObject(object.basicInfo);
                        }
                        if (object.groupMemberBriefInfo != null) {
                            if (typeof object.groupMemberBriefInfo !== "object")
                                throw TypeError(".AcFunDanmu.Im.Cloud.Message.GroupInfo.groupMemberBriefInfo: object expected");
                            message.groupMemberBriefInfo = $root.AcFunDanmu.Im.Cloud.Message.GroupMemberBriefInfo.fromObject(object.groupMemberBriefInfo);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a GroupInfo message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupInfo
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.GroupInfo} message GroupInfo
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GroupInfo.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.basicInfo = null;
                            object.groupMemberBriefInfo = null;
                        }
                        if (message.basicInfo != null && message.hasOwnProperty("basicInfo"))
                            object.basicInfo = $root.AcFunDanmu.Im.Cloud.Message.GroupBasicInfo.toObject(message.basicInfo, options);
                        if (message.groupMemberBriefInfo != null && message.hasOwnProperty("groupMemberBriefInfo"))
                            object.groupMemberBriefInfo = $root.AcFunDanmu.Im.Cloud.Message.GroupMemberBriefInfo.toObject(message.groupMemberBriefInfo, options);
                        return object;
                    };

                    /**
                     * Converts this GroupInfo to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupInfo
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GroupInfo.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return GroupInfo;
                })();

                /**
                 * GroupStatus enum.
                 * @name AcFunDanmu.Im.Cloud.Message.GroupStatus
                 * @enum {number}
                 * @property {number} UNKNOW_GROUP_STATUS=0 UNKNOW_GROUP_STATUS value
                 * @property {number} VALID=1 VALID value
                 * @property {number} INVALID=2 INVALID value
                 */
                Message.GroupStatus = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "UNKNOW_GROUP_STATUS"] = 0;
                    values[valuesById[1] = "VALID"] = 1;
                    values[valuesById[2] = "INVALID"] = 2;
                    return values;
                })();

                /**
                 * GroupType enum.
                 * @name AcFunDanmu.Im.Cloud.Message.GroupType
                 * @enum {number}
                 * @property {number} UNKNOW_GROUP_TYPE=0 UNKNOW_GROUP_TYPE value
                 * @property {number} PRIVATE=3 PRIVATE value
                 * @property {number} PUBLIC=4 PUBLIC value
                 */
                Message.GroupType = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "UNKNOW_GROUP_TYPE"] = 0;
                    values[valuesById[3] = "PRIVATE"] = 3;
                    values[valuesById[4] = "PUBLIC"] = 4;
                    return values;
                })();

                /**
                 * ForbiddenState enum.
                 * @name AcFunDanmu.Im.Cloud.Message.ForbiddenState
                 * @enum {number}
                 * @property {number} UNKNOWN_FORBIDDEN_STATE=0 UNKNOWN_FORBIDDEN_STATE value
                 * @property {number} UN_FORBIDDEN=1 UN_FORBIDDEN value
                 * @property {number} FORBID_MESSAGE=2 FORBID_MESSAGE value
                 */
                Message.ForbiddenState = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "UNKNOWN_FORBIDDEN_STATE"] = 0;
                    values[valuesById[1] = "UN_FORBIDDEN"] = 1;
                    values[valuesById[2] = "FORBID_MESSAGE"] = 2;
                    return values;
                })();

                Message.GroupBasicInfo = (function() {

                    /**
                     * Properties of a GroupBasicInfo.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface IGroupBasicInfo
                     * @property {string|null} [groupId] GroupBasicInfo groupId
                     * @property {string|null} [groupName] GroupBasicInfo groupName
                     * @property {AcFunDanmu.Im.Basic.IUser|null} [admin] GroupBasicInfo admin
                     * @property {AcFunDanmu.Im.Cloud.Message.GroupStatus|null} [groupStatus] GroupBasicInfo groupStatus
                     * @property {string|null} [description] GroupBasicInfo description
                     * @property {AcFunDanmu.Im.Cloud.Message.JoinNeedPermissionType|null} [joinNeedPermission] GroupBasicInfo joinNeedPermission
                     * @property {number|Long|null} [createTime] GroupBasicInfo createTime
                     * @property {number|Long|null} [updateTime] GroupBasicInfo updateTime
                     * @property {AcFunDanmu.Im.Cloud.Message.GroupType|null} [groupType] GroupBasicInfo groupType
                     * @property {AcFunDanmu.Im.Cloud.Message.ForbiddenState|null} [forbiddenState] GroupBasicInfo forbiddenState
                     * @property {AcFunDanmu.Im.Cloud.Message.InvitePermissionType|null} [invitePermissionType] GroupBasicInfo invitePermissionType
                     * @property {number|null} [bizDefCode] GroupBasicInfo bizDefCode
                     * @property {string|null} [defalutGroupName] GroupBasicInfo defalutGroupName
                     * @property {string|null} [extra] GroupBasicInfo extra
                     */

                    /**
                     * Constructs a new GroupBasicInfo.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents a GroupBasicInfo.
                     * @implements IGroupBasicInfo
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupBasicInfo=} [properties] Properties to set
                     */
                    function GroupBasicInfo(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * GroupBasicInfo groupId.
                     * @member {string} groupId
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupBasicInfo
                     * @instance
                     */
                    GroupBasicInfo.prototype.groupId = "";

                    /**
                     * GroupBasicInfo groupName.
                     * @member {string} groupName
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupBasicInfo
                     * @instance
                     */
                    GroupBasicInfo.prototype.groupName = "";

                    /**
                     * GroupBasicInfo admin.
                     * @member {AcFunDanmu.Im.Basic.IUser|null|undefined} admin
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupBasicInfo
                     * @instance
                     */
                    GroupBasicInfo.prototype.admin = null;

                    /**
                     * GroupBasicInfo groupStatus.
                     * @member {AcFunDanmu.Im.Cloud.Message.GroupStatus} groupStatus
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupBasicInfo
                     * @instance
                     */
                    GroupBasicInfo.prototype.groupStatus = 0;

                    /**
                     * GroupBasicInfo description.
                     * @member {string} description
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupBasicInfo
                     * @instance
                     */
                    GroupBasicInfo.prototype.description = "";

                    /**
                     * GroupBasicInfo joinNeedPermission.
                     * @member {AcFunDanmu.Im.Cloud.Message.JoinNeedPermissionType} joinNeedPermission
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupBasicInfo
                     * @instance
                     */
                    GroupBasicInfo.prototype.joinNeedPermission = 0;

                    /**
                     * GroupBasicInfo createTime.
                     * @member {number|Long} createTime
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupBasicInfo
                     * @instance
                     */
                    GroupBasicInfo.prototype.createTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * GroupBasicInfo updateTime.
                     * @member {number|Long} updateTime
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupBasicInfo
                     * @instance
                     */
                    GroupBasicInfo.prototype.updateTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * GroupBasicInfo groupType.
                     * @member {AcFunDanmu.Im.Cloud.Message.GroupType} groupType
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupBasicInfo
                     * @instance
                     */
                    GroupBasicInfo.prototype.groupType = 0;

                    /**
                     * GroupBasicInfo forbiddenState.
                     * @member {AcFunDanmu.Im.Cloud.Message.ForbiddenState} forbiddenState
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupBasicInfo
                     * @instance
                     */
                    GroupBasicInfo.prototype.forbiddenState = 0;

                    /**
                     * GroupBasicInfo invitePermissionType.
                     * @member {AcFunDanmu.Im.Cloud.Message.InvitePermissionType} invitePermissionType
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupBasicInfo
                     * @instance
                     */
                    GroupBasicInfo.prototype.invitePermissionType = 0;

                    /**
                     * GroupBasicInfo bizDefCode.
                     * @member {number} bizDefCode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupBasicInfo
                     * @instance
                     */
                    GroupBasicInfo.prototype.bizDefCode = 0;

                    /**
                     * GroupBasicInfo defalutGroupName.
                     * @member {string} defalutGroupName
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupBasicInfo
                     * @instance
                     */
                    GroupBasicInfo.prototype.defalutGroupName = "";

                    /**
                     * GroupBasicInfo extra.
                     * @member {string} extra
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupBasicInfo
                     * @instance
                     */
                    GroupBasicInfo.prototype.extra = "";

                    /**
                     * Creates a new GroupBasicInfo instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupBasicInfo
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupBasicInfo=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupBasicInfo} GroupBasicInfo instance
                     */
                    GroupBasicInfo.create = function create(properties) {
                        return new GroupBasicInfo(properties);
                    };

                    /**
                     * Encodes the specified GroupBasicInfo message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupBasicInfo.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupBasicInfo
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupBasicInfo} message GroupBasicInfo message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupBasicInfo.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.groupId);
                        if (message.groupName != null && Object.hasOwnProperty.call(message, "groupName"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.groupName);
                        if (message.admin != null && Object.hasOwnProperty.call(message, "admin"))
                            $root.AcFunDanmu.Im.Basic.User.encode(message.admin, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.groupStatus != null && Object.hasOwnProperty.call(message, "groupStatus"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.groupStatus);
                        if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.description);
                        if (message.joinNeedPermission != null && Object.hasOwnProperty.call(message, "joinNeedPermission"))
                            writer.uint32(/* id 6, wireType 0 =*/48).int32(message.joinNeedPermission);
                        if (message.createTime != null && Object.hasOwnProperty.call(message, "createTime"))
                            writer.uint32(/* id 7, wireType 0 =*/56).int64(message.createTime);
                        if (message.updateTime != null && Object.hasOwnProperty.call(message, "updateTime"))
                            writer.uint32(/* id 8, wireType 0 =*/64).int64(message.updateTime);
                        if (message.groupType != null && Object.hasOwnProperty.call(message, "groupType"))
                            writer.uint32(/* id 9, wireType 0 =*/72).int32(message.groupType);
                        if (message.forbiddenState != null && Object.hasOwnProperty.call(message, "forbiddenState"))
                            writer.uint32(/* id 10, wireType 0 =*/80).int32(message.forbiddenState);
                        if (message.invitePermissionType != null && Object.hasOwnProperty.call(message, "invitePermissionType"))
                            writer.uint32(/* id 11, wireType 0 =*/88).int32(message.invitePermissionType);
                        if (message.bizDefCode != null && Object.hasOwnProperty.call(message, "bizDefCode"))
                            writer.uint32(/* id 12, wireType 0 =*/96).int32(message.bizDefCode);
                        if (message.defalutGroupName != null && Object.hasOwnProperty.call(message, "defalutGroupName"))
                            writer.uint32(/* id 13, wireType 2 =*/106).string(message.defalutGroupName);
                        if (message.extra != null && Object.hasOwnProperty.call(message, "extra"))
                            writer.uint32(/* id 14, wireType 2 =*/114).string(message.extra);
                        return writer;
                    };

                    /**
                     * Encodes the specified GroupBasicInfo message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupBasicInfo.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupBasicInfo
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupBasicInfo} message GroupBasicInfo message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupBasicInfo.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a GroupBasicInfo message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupBasicInfo
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupBasicInfo} GroupBasicInfo
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupBasicInfo.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.GroupBasicInfo();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.groupId = reader.string();
                                break;
                            case 2:
                                message.groupName = reader.string();
                                break;
                            case 3:
                                message.admin = $root.AcFunDanmu.Im.Basic.User.decode(reader, reader.uint32());
                                break;
                            case 4:
                                message.groupStatus = reader.int32();
                                break;
                            case 5:
                                message.description = reader.string();
                                break;
                            case 6:
                                message.joinNeedPermission = reader.int32();
                                break;
                            case 7:
                                message.createTime = reader.int64();
                                break;
                            case 8:
                                message.updateTime = reader.int64();
                                break;
                            case 9:
                                message.groupType = reader.int32();
                                break;
                            case 10:
                                message.forbiddenState = reader.int32();
                                break;
                            case 11:
                                message.invitePermissionType = reader.int32();
                                break;
                            case 12:
                                message.bizDefCode = reader.int32();
                                break;
                            case 13:
                                message.defalutGroupName = reader.string();
                                break;
                            case 14:
                                message.extra = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a GroupBasicInfo message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupBasicInfo
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupBasicInfo} GroupBasicInfo
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupBasicInfo.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a GroupBasicInfo message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupBasicInfo
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GroupBasicInfo.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.groupId != null && message.hasOwnProperty("groupId"))
                            if (!$util.isString(message.groupId))
                                return "groupId: string expected";
                        if (message.groupName != null && message.hasOwnProperty("groupName"))
                            if (!$util.isString(message.groupName))
                                return "groupName: string expected";
                        if (message.admin != null && message.hasOwnProperty("admin")) {
                            let error = $root.AcFunDanmu.Im.Basic.User.verify(message.admin);
                            if (error)
                                return "admin." + error;
                        }
                        if (message.groupStatus != null && message.hasOwnProperty("groupStatus"))
                            switch (message.groupStatus) {
                            default:
                                return "groupStatus: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                                break;
                            }
                        if (message.description != null && message.hasOwnProperty("description"))
                            if (!$util.isString(message.description))
                                return "description: string expected";
                        if (message.joinNeedPermission != null && message.hasOwnProperty("joinNeedPermission"))
                            switch (message.joinNeedPermission) {
                            default:
                                return "joinNeedPermission: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                                break;
                            }
                        if (message.createTime != null && message.hasOwnProperty("createTime"))
                            if (!$util.isInteger(message.createTime) && !(message.createTime && $util.isInteger(message.createTime.low) && $util.isInteger(message.createTime.high)))
                                return "createTime: integer|Long expected";
                        if (message.updateTime != null && message.hasOwnProperty("updateTime"))
                            if (!$util.isInteger(message.updateTime) && !(message.updateTime && $util.isInteger(message.updateTime.low) && $util.isInteger(message.updateTime.high)))
                                return "updateTime: integer|Long expected";
                        if (message.groupType != null && message.hasOwnProperty("groupType"))
                            switch (message.groupType) {
                            default:
                                return "groupType: enum value expected";
                            case 0:
                            case 3:
                            case 4:
                                break;
                            }
                        if (message.forbiddenState != null && message.hasOwnProperty("forbiddenState"))
                            switch (message.forbiddenState) {
                            default:
                                return "forbiddenState: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                                break;
                            }
                        if (message.invitePermissionType != null && message.hasOwnProperty("invitePermissionType"))
                            switch (message.invitePermissionType) {
                            default:
                                return "invitePermissionType: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                                break;
                            }
                        if (message.bizDefCode != null && message.hasOwnProperty("bizDefCode"))
                            if (!$util.isInteger(message.bizDefCode))
                                return "bizDefCode: integer expected";
                        if (message.defalutGroupName != null && message.hasOwnProperty("defalutGroupName"))
                            if (!$util.isString(message.defalutGroupName))
                                return "defalutGroupName: string expected";
                        if (message.extra != null && message.hasOwnProperty("extra"))
                            if (!$util.isString(message.extra))
                                return "extra: string expected";
                        return null;
                    };

                    /**
                     * Creates a GroupBasicInfo message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupBasicInfo
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupBasicInfo} GroupBasicInfo
                     */
                    GroupBasicInfo.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.GroupBasicInfo)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Message.GroupBasicInfo();
                        if (object.groupId != null)
                            message.groupId = String(object.groupId);
                        if (object.groupName != null)
                            message.groupName = String(object.groupName);
                        if (object.admin != null) {
                            if (typeof object.admin !== "object")
                                throw TypeError(".AcFunDanmu.Im.Cloud.Message.GroupBasicInfo.admin: object expected");
                            message.admin = $root.AcFunDanmu.Im.Basic.User.fromObject(object.admin);
                        }
                        switch (object.groupStatus) {
                        case "UNKNOW_GROUP_STATUS":
                        case 0:
                            message.groupStatus = 0;
                            break;
                        case "VALID":
                        case 1:
                            message.groupStatus = 1;
                            break;
                        case "INVALID":
                        case 2:
                            message.groupStatus = 2;
                            break;
                        }
                        if (object.description != null)
                            message.description = String(object.description);
                        switch (object.joinNeedPermission) {
                        case "UNKNOWN_JOIN_NEED_PERMISSION_TYPE":
                        case 0:
                            message.joinNeedPermission = 0;
                            break;
                        case "NONE":
                        case 1:
                            message.joinNeedPermission = 1;
                            break;
                        case "ADMIN":
                        case 2:
                            message.joinNeedPermission = 2;
                            break;
                        }
                        if (object.createTime != null)
                            if ($util.Long)
                                (message.createTime = $util.Long.fromValue(object.createTime)).unsigned = false;
                            else if (typeof object.createTime === "string")
                                message.createTime = parseInt(object.createTime, 10);
                            else if (typeof object.createTime === "number")
                                message.createTime = object.createTime;
                            else if (typeof object.createTime === "object")
                                message.createTime = new $util.LongBits(object.createTime.low >>> 0, object.createTime.high >>> 0).toNumber();
                        if (object.updateTime != null)
                            if ($util.Long)
                                (message.updateTime = $util.Long.fromValue(object.updateTime)).unsigned = false;
                            else if (typeof object.updateTime === "string")
                                message.updateTime = parseInt(object.updateTime, 10);
                            else if (typeof object.updateTime === "number")
                                message.updateTime = object.updateTime;
                            else if (typeof object.updateTime === "object")
                                message.updateTime = new $util.LongBits(object.updateTime.low >>> 0, object.updateTime.high >>> 0).toNumber();
                        switch (object.groupType) {
                        case "UNKNOW_GROUP_TYPE":
                        case 0:
                            message.groupType = 0;
                            break;
                        case "PRIVATE":
                        case 3:
                            message.groupType = 3;
                            break;
                        case "PUBLIC":
                        case 4:
                            message.groupType = 4;
                            break;
                        }
                        switch (object.forbiddenState) {
                        case "UNKNOWN_FORBIDDEN_STATE":
                        case 0:
                            message.forbiddenState = 0;
                            break;
                        case "UN_FORBIDDEN":
                        case 1:
                            message.forbiddenState = 1;
                            break;
                        case "FORBID_MESSAGE":
                        case 2:
                            message.forbiddenState = 2;
                            break;
                        }
                        switch (object.invitePermissionType) {
                        case "UNKNOWN_INVITE_PERMISSION_TYPE":
                        case 0:
                            message.invitePermissionType = 0;
                            break;
                        case "EVERYONE":
                        case 1:
                            message.invitePermissionType = 1;
                            break;
                        case "ONLY_ADMIN":
                        case 2:
                            message.invitePermissionType = 2;
                            break;
                        }
                        if (object.bizDefCode != null)
                            message.bizDefCode = object.bizDefCode | 0;
                        if (object.defalutGroupName != null)
                            message.defalutGroupName = String(object.defalutGroupName);
                        if (object.extra != null)
                            message.extra = String(object.extra);
                        return message;
                    };

                    /**
                     * Creates a plain object from a GroupBasicInfo message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupBasicInfo
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.GroupBasicInfo} message GroupBasicInfo
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GroupBasicInfo.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.groupId = "";
                            object.groupName = "";
                            object.admin = null;
                            object.groupStatus = options.enums === String ? "UNKNOW_GROUP_STATUS" : 0;
                            object.description = "";
                            object.joinNeedPermission = options.enums === String ? "UNKNOWN_JOIN_NEED_PERMISSION_TYPE" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, false);
                                object.createTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.createTime = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, false);
                                object.updateTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.updateTime = options.longs === String ? "0" : 0;
                            object.groupType = options.enums === String ? "UNKNOW_GROUP_TYPE" : 0;
                            object.forbiddenState = options.enums === String ? "UNKNOWN_FORBIDDEN_STATE" : 0;
                            object.invitePermissionType = options.enums === String ? "UNKNOWN_INVITE_PERMISSION_TYPE" : 0;
                            object.bizDefCode = 0;
                            object.defalutGroupName = "";
                            object.extra = "";
                        }
                        if (message.groupId != null && message.hasOwnProperty("groupId"))
                            object.groupId = message.groupId;
                        if (message.groupName != null && message.hasOwnProperty("groupName"))
                            object.groupName = message.groupName;
                        if (message.admin != null && message.hasOwnProperty("admin"))
                            object.admin = $root.AcFunDanmu.Im.Basic.User.toObject(message.admin, options);
                        if (message.groupStatus != null && message.hasOwnProperty("groupStatus"))
                            object.groupStatus = options.enums === String ? $root.AcFunDanmu.Im.Cloud.Message.GroupStatus[message.groupStatus] : message.groupStatus;
                        if (message.description != null && message.hasOwnProperty("description"))
                            object.description = message.description;
                        if (message.joinNeedPermission != null && message.hasOwnProperty("joinNeedPermission"))
                            object.joinNeedPermission = options.enums === String ? $root.AcFunDanmu.Im.Cloud.Message.JoinNeedPermissionType[message.joinNeedPermission] : message.joinNeedPermission;
                        if (message.createTime != null && message.hasOwnProperty("createTime"))
                            if (typeof message.createTime === "number")
                                object.createTime = options.longs === String ? String(message.createTime) : message.createTime;
                            else
                                object.createTime = options.longs === String ? $util.Long.prototype.toString.call(message.createTime) : options.longs === Number ? new $util.LongBits(message.createTime.low >>> 0, message.createTime.high >>> 0).toNumber() : message.createTime;
                        if (message.updateTime != null && message.hasOwnProperty("updateTime"))
                            if (typeof message.updateTime === "number")
                                object.updateTime = options.longs === String ? String(message.updateTime) : message.updateTime;
                            else
                                object.updateTime = options.longs === String ? $util.Long.prototype.toString.call(message.updateTime) : options.longs === Number ? new $util.LongBits(message.updateTime.low >>> 0, message.updateTime.high >>> 0).toNumber() : message.updateTime;
                        if (message.groupType != null && message.hasOwnProperty("groupType"))
                            object.groupType = options.enums === String ? $root.AcFunDanmu.Im.Cloud.Message.GroupType[message.groupType] : message.groupType;
                        if (message.forbiddenState != null && message.hasOwnProperty("forbiddenState"))
                            object.forbiddenState = options.enums === String ? $root.AcFunDanmu.Im.Cloud.Message.ForbiddenState[message.forbiddenState] : message.forbiddenState;
                        if (message.invitePermissionType != null && message.hasOwnProperty("invitePermissionType"))
                            object.invitePermissionType = options.enums === String ? $root.AcFunDanmu.Im.Cloud.Message.InvitePermissionType[message.invitePermissionType] : message.invitePermissionType;
                        if (message.bizDefCode != null && message.hasOwnProperty("bizDefCode"))
                            object.bizDefCode = message.bizDefCode;
                        if (message.defalutGroupName != null && message.hasOwnProperty("defalutGroupName"))
                            object.defalutGroupName = message.defalutGroupName;
                        if (message.extra != null && message.hasOwnProperty("extra"))
                            object.extra = message.extra;
                        return object;
                    };

                    /**
                     * Converts this GroupBasicInfo to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupBasicInfo
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GroupBasicInfo.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return GroupBasicInfo;
                })();

                Message.GroupMemberBriefInfo = (function() {

                    /**
                     * Properties of a GroupMemberBriefInfo.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface IGroupMemberBriefInfo
                     * @property {number|null} [memberCount] GroupMemberBriefInfo memberCount
                     * @property {Array.<AcFunDanmu.Im.Basic.IUser>|null} [topMembers] GroupMemberBriefInfo topMembers
                     * @property {number|Long|null} [lastUpdateTime] GroupMemberBriefInfo lastUpdateTime
                     */

                    /**
                     * Constructs a new GroupMemberBriefInfo.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents a GroupMemberBriefInfo.
                     * @implements IGroupMemberBriefInfo
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupMemberBriefInfo=} [properties] Properties to set
                     */
                    function GroupMemberBriefInfo(properties) {
                        this.topMembers = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * GroupMemberBriefInfo memberCount.
                     * @member {number} memberCount
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberBriefInfo
                     * @instance
                     */
                    GroupMemberBriefInfo.prototype.memberCount = 0;

                    /**
                     * GroupMemberBriefInfo topMembers.
                     * @member {Array.<AcFunDanmu.Im.Basic.IUser>} topMembers
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberBriefInfo
                     * @instance
                     */
                    GroupMemberBriefInfo.prototype.topMembers = $util.emptyArray;

                    /**
                     * GroupMemberBriefInfo lastUpdateTime.
                     * @member {number|Long} lastUpdateTime
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberBriefInfo
                     * @instance
                     */
                    GroupMemberBriefInfo.prototype.lastUpdateTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * Creates a new GroupMemberBriefInfo instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberBriefInfo
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupMemberBriefInfo=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupMemberBriefInfo} GroupMemberBriefInfo instance
                     */
                    GroupMemberBriefInfo.create = function create(properties) {
                        return new GroupMemberBriefInfo(properties);
                    };

                    /**
                     * Encodes the specified GroupMemberBriefInfo message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupMemberBriefInfo.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberBriefInfo
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupMemberBriefInfo} message GroupMemberBriefInfo message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupMemberBriefInfo.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.memberCount != null && Object.hasOwnProperty.call(message, "memberCount"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.memberCount);
                        if (message.topMembers != null && message.topMembers.length)
                            for (let i = 0; i < message.topMembers.length; ++i)
                                $root.AcFunDanmu.Im.Basic.User.encode(message.topMembers[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.lastUpdateTime != null && Object.hasOwnProperty.call(message, "lastUpdateTime"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.lastUpdateTime);
                        return writer;
                    };

                    /**
                     * Encodes the specified GroupMemberBriefInfo message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.GroupMemberBriefInfo.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberBriefInfo
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IGroupMemberBriefInfo} message GroupMemberBriefInfo message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GroupMemberBriefInfo.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a GroupMemberBriefInfo message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberBriefInfo
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupMemberBriefInfo} GroupMemberBriefInfo
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupMemberBriefInfo.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.GroupMemberBriefInfo();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.memberCount = reader.int32();
                                break;
                            case 2:
                                if (!(message.topMembers && message.topMembers.length))
                                    message.topMembers = [];
                                message.topMembers.push($root.AcFunDanmu.Im.Basic.User.decode(reader, reader.uint32()));
                                break;
                            case 3:
                                message.lastUpdateTime = reader.int64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a GroupMemberBriefInfo message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberBriefInfo
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupMemberBriefInfo} GroupMemberBriefInfo
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GroupMemberBriefInfo.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a GroupMemberBriefInfo message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberBriefInfo
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GroupMemberBriefInfo.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.memberCount != null && message.hasOwnProperty("memberCount"))
                            if (!$util.isInteger(message.memberCount))
                                return "memberCount: integer expected";
                        if (message.topMembers != null && message.hasOwnProperty("topMembers")) {
                            if (!Array.isArray(message.topMembers))
                                return "topMembers: array expected";
                            for (let i = 0; i < message.topMembers.length; ++i) {
                                let error = $root.AcFunDanmu.Im.Basic.User.verify(message.topMembers[i]);
                                if (error)
                                    return "topMembers." + error;
                            }
                        }
                        if (message.lastUpdateTime != null && message.hasOwnProperty("lastUpdateTime"))
                            if (!$util.isInteger(message.lastUpdateTime) && !(message.lastUpdateTime && $util.isInteger(message.lastUpdateTime.low) && $util.isInteger(message.lastUpdateTime.high)))
                                return "lastUpdateTime: integer|Long expected";
                        return null;
                    };

                    /**
                     * Creates a GroupMemberBriefInfo message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberBriefInfo
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.GroupMemberBriefInfo} GroupMemberBriefInfo
                     */
                    GroupMemberBriefInfo.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.GroupMemberBriefInfo)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Message.GroupMemberBriefInfo();
                        if (object.memberCount != null)
                            message.memberCount = object.memberCount | 0;
                        if (object.topMembers) {
                            if (!Array.isArray(object.topMembers))
                                throw TypeError(".AcFunDanmu.Im.Cloud.Message.GroupMemberBriefInfo.topMembers: array expected");
                            message.topMembers = [];
                            for (let i = 0; i < object.topMembers.length; ++i) {
                                if (typeof object.topMembers[i] !== "object")
                                    throw TypeError(".AcFunDanmu.Im.Cloud.Message.GroupMemberBriefInfo.topMembers: object expected");
                                message.topMembers[i] = $root.AcFunDanmu.Im.Basic.User.fromObject(object.topMembers[i]);
                            }
                        }
                        if (object.lastUpdateTime != null)
                            if ($util.Long)
                                (message.lastUpdateTime = $util.Long.fromValue(object.lastUpdateTime)).unsigned = false;
                            else if (typeof object.lastUpdateTime === "string")
                                message.lastUpdateTime = parseInt(object.lastUpdateTime, 10);
                            else if (typeof object.lastUpdateTime === "number")
                                message.lastUpdateTime = object.lastUpdateTime;
                            else if (typeof object.lastUpdateTime === "object")
                                message.lastUpdateTime = new $util.LongBits(object.lastUpdateTime.low >>> 0, object.lastUpdateTime.high >>> 0).toNumber();
                        return message;
                    };

                    /**
                     * Creates a plain object from a GroupMemberBriefInfo message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberBriefInfo
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.GroupMemberBriefInfo} message GroupMemberBriefInfo
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GroupMemberBriefInfo.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.topMembers = [];
                        if (options.defaults) {
                            object.memberCount = 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, false);
                                object.lastUpdateTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.lastUpdateTime = options.longs === String ? "0" : 0;
                        }
                        if (message.memberCount != null && message.hasOwnProperty("memberCount"))
                            object.memberCount = message.memberCount;
                        if (message.topMembers && message.topMembers.length) {
                            object.topMembers = [];
                            for (let j = 0; j < message.topMembers.length; ++j)
                                object.topMembers[j] = $root.AcFunDanmu.Im.Basic.User.toObject(message.topMembers[j], options);
                        }
                        if (message.lastUpdateTime != null && message.hasOwnProperty("lastUpdateTime"))
                            if (typeof message.lastUpdateTime === "number")
                                object.lastUpdateTime = options.longs === String ? String(message.lastUpdateTime) : message.lastUpdateTime;
                            else
                                object.lastUpdateTime = options.longs === String ? $util.Long.prototype.toString.call(message.lastUpdateTime) : options.longs === Number ? new $util.LongBits(message.lastUpdateTime.low >>> 0, message.lastUpdateTime.high >>> 0).toNumber() : message.lastUpdateTime;
                        return object;
                    };

                    /**
                     * Converts this GroupMemberBriefInfo to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.GroupMemberBriefInfo
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GroupMemberBriefInfo.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return GroupMemberBriefInfo;
                })();

                Message.ImcPassThroughRequest = (function() {

                    /**
                     * Properties of an ImcPassThroughRequest.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface IImcPassThroughRequest
                     * @property {AcFunDanmu.Im.Message.IChatTarget|null} [chatTarget] ImcPassThroughRequest chatTarget
                     * @property {Uint8Array|null} [content] ImcPassThroughRequest content
                     * @property {number|null} [contentType] ImcPassThroughRequest contentType
                     */

                    /**
                     * Constructs a new ImcPassThroughRequest.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents an ImcPassThroughRequest.
                     * @implements IImcPassThroughRequest
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.IImcPassThroughRequest=} [properties] Properties to set
                     */
                    function ImcPassThroughRequest(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * ImcPassThroughRequest chatTarget.
                     * @member {AcFunDanmu.Im.Message.IChatTarget|null|undefined} chatTarget
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcPassThroughRequest
                     * @instance
                     */
                    ImcPassThroughRequest.prototype.chatTarget = null;

                    /**
                     * ImcPassThroughRequest content.
                     * @member {Uint8Array} content
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcPassThroughRequest
                     * @instance
                     */
                    ImcPassThroughRequest.prototype.content = $util.newBuffer([]);

                    /**
                     * ImcPassThroughRequest contentType.
                     * @member {number} contentType
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcPassThroughRequest
                     * @instance
                     */
                    ImcPassThroughRequest.prototype.contentType = 0;

                    /**
                     * Creates a new ImcPassThroughRequest instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcPassThroughRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IImcPassThroughRequest=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.ImcPassThroughRequest} ImcPassThroughRequest instance
                     */
                    ImcPassThroughRequest.create = function create(properties) {
                        return new ImcPassThroughRequest(properties);
                    };

                    /**
                     * Encodes the specified ImcPassThroughRequest message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.ImcPassThroughRequest.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcPassThroughRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IImcPassThroughRequest} message ImcPassThroughRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ImcPassThroughRequest.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.chatTarget != null && Object.hasOwnProperty.call(message, "chatTarget"))
                            $root.AcFunDanmu.Im.Message.ChatTarget.encode(message.chatTarget, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.content != null && Object.hasOwnProperty.call(message, "content"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.content);
                        if (message.contentType != null && Object.hasOwnProperty.call(message, "contentType"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.contentType);
                        return writer;
                    };

                    /**
                     * Encodes the specified ImcPassThroughRequest message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.ImcPassThroughRequest.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcPassThroughRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IImcPassThroughRequest} message ImcPassThroughRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ImcPassThroughRequest.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes an ImcPassThroughRequest message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcPassThroughRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.ImcPassThroughRequest} ImcPassThroughRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ImcPassThroughRequest.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.ImcPassThroughRequest();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.chatTarget = $root.AcFunDanmu.Im.Message.ChatTarget.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.content = reader.bytes();
                                break;
                            case 3:
                                message.contentType = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes an ImcPassThroughRequest message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcPassThroughRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.ImcPassThroughRequest} ImcPassThroughRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ImcPassThroughRequest.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies an ImcPassThroughRequest message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcPassThroughRequest
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ImcPassThroughRequest.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.chatTarget != null && message.hasOwnProperty("chatTarget")) {
                            let error = $root.AcFunDanmu.Im.Message.ChatTarget.verify(message.chatTarget);
                            if (error)
                                return "chatTarget." + error;
                        }
                        if (message.content != null && message.hasOwnProperty("content"))
                            if (!(message.content && typeof message.content.length === "number" || $util.isString(message.content)))
                                return "content: buffer expected";
                        if (message.contentType != null && message.hasOwnProperty("contentType"))
                            if (!$util.isInteger(message.contentType))
                                return "contentType: integer expected";
                        return null;
                    };

                    /**
                     * Creates an ImcPassThroughRequest message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcPassThroughRequest
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.ImcPassThroughRequest} ImcPassThroughRequest
                     */
                    ImcPassThroughRequest.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.ImcPassThroughRequest)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Message.ImcPassThroughRequest();
                        if (object.chatTarget != null) {
                            if (typeof object.chatTarget !== "object")
                                throw TypeError(".AcFunDanmu.Im.Cloud.Message.ImcPassThroughRequest.chatTarget: object expected");
                            message.chatTarget = $root.AcFunDanmu.Im.Message.ChatTarget.fromObject(object.chatTarget);
                        }
                        if (object.content != null)
                            if (typeof object.content === "string")
                                $util.base64.decode(object.content, message.content = $util.newBuffer($util.base64.length(object.content)), 0);
                            else if (object.content.length)
                                message.content = object.content;
                        if (object.contentType != null)
                            message.contentType = object.contentType | 0;
                        return message;
                    };

                    /**
                     * Creates a plain object from an ImcPassThroughRequest message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcPassThroughRequest
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.ImcPassThroughRequest} message ImcPassThroughRequest
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ImcPassThroughRequest.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.chatTarget = null;
                            if (options.bytes === String)
                                object.content = "";
                            else {
                                object.content = [];
                                if (options.bytes !== Array)
                                    object.content = $util.newBuffer(object.content);
                            }
                            object.contentType = 0;
                        }
                        if (message.chatTarget != null && message.hasOwnProperty("chatTarget"))
                            object.chatTarget = $root.AcFunDanmu.Im.Message.ChatTarget.toObject(message.chatTarget, options);
                        if (message.content != null && message.hasOwnProperty("content"))
                            object.content = options.bytes === String ? $util.base64.encode(message.content, 0, message.content.length) : options.bytes === Array ? Array.prototype.slice.call(message.content) : message.content;
                        if (message.contentType != null && message.hasOwnProperty("contentType"))
                            object.contentType = message.contentType;
                        return object;
                    };

                    /**
                     * Converts this ImcPassThroughRequest to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcPassThroughRequest
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ImcPassThroughRequest.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return ImcPassThroughRequest;
                })();

                Message.ImcPassThroughResponse = (function() {

                    /**
                     * Properties of an ImcPassThroughResponse.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface IImcPassThroughResponse
                     */

                    /**
                     * Constructs a new ImcPassThroughResponse.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents an ImcPassThroughResponse.
                     * @implements IImcPassThroughResponse
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.IImcPassThroughResponse=} [properties] Properties to set
                     */
                    function ImcPassThroughResponse(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Creates a new ImcPassThroughResponse instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcPassThroughResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IImcPassThroughResponse=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.ImcPassThroughResponse} ImcPassThroughResponse instance
                     */
                    ImcPassThroughResponse.create = function create(properties) {
                        return new ImcPassThroughResponse(properties);
                    };

                    /**
                     * Encodes the specified ImcPassThroughResponse message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.ImcPassThroughResponse.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcPassThroughResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IImcPassThroughResponse} message ImcPassThroughResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ImcPassThroughResponse.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };

                    /**
                     * Encodes the specified ImcPassThroughResponse message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.ImcPassThroughResponse.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcPassThroughResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IImcPassThroughResponse} message ImcPassThroughResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ImcPassThroughResponse.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes an ImcPassThroughResponse message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcPassThroughResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.ImcPassThroughResponse} ImcPassThroughResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ImcPassThroughResponse.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.ImcPassThroughResponse();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes an ImcPassThroughResponse message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcPassThroughResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.ImcPassThroughResponse} ImcPassThroughResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ImcPassThroughResponse.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies an ImcPassThroughResponse message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcPassThroughResponse
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ImcPassThroughResponse.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };

                    /**
                     * Creates an ImcPassThroughResponse message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcPassThroughResponse
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.ImcPassThroughResponse} ImcPassThroughResponse
                     */
                    ImcPassThroughResponse.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.ImcPassThroughResponse)
                            return object;
                        return new $root.AcFunDanmu.Im.Cloud.Message.ImcPassThroughResponse();
                    };

                    /**
                     * Creates a plain object from an ImcPassThroughResponse message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcPassThroughResponse
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.ImcPassThroughResponse} message ImcPassThroughResponse
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ImcPassThroughResponse.toObject = function toObject() {
                        return {};
                    };

                    /**
                     * Converts this ImcPassThroughResponse to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcPassThroughResponse
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ImcPassThroughResponse.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return ImcPassThroughResponse;
                })();

                Message.ImcPassThroughPush = (function() {

                    /**
                     * Properties of an ImcPassThroughPush.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface IImcPassThroughPush
                     * @property {AcFunDanmu.Im.Message.IChatTarget|null} [chatTarget] ImcPassThroughPush chatTarget
                     * @property {AcFunDanmu.Im.Basic.IUser|null} [fromUser] ImcPassThroughPush fromUser
                     * @property {Uint8Array|null} [content] ImcPassThroughPush content
                     * @property {number|null} [contentType] ImcPassThroughPush contentType
                     */

                    /**
                     * Constructs a new ImcPassThroughPush.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents an ImcPassThroughPush.
                     * @implements IImcPassThroughPush
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.IImcPassThroughPush=} [properties] Properties to set
                     */
                    function ImcPassThroughPush(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * ImcPassThroughPush chatTarget.
                     * @member {AcFunDanmu.Im.Message.IChatTarget|null|undefined} chatTarget
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcPassThroughPush
                     * @instance
                     */
                    ImcPassThroughPush.prototype.chatTarget = null;

                    /**
                     * ImcPassThroughPush fromUser.
                     * @member {AcFunDanmu.Im.Basic.IUser|null|undefined} fromUser
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcPassThroughPush
                     * @instance
                     */
                    ImcPassThroughPush.prototype.fromUser = null;

                    /**
                     * ImcPassThroughPush content.
                     * @member {Uint8Array} content
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcPassThroughPush
                     * @instance
                     */
                    ImcPassThroughPush.prototype.content = $util.newBuffer([]);

                    /**
                     * ImcPassThroughPush contentType.
                     * @member {number} contentType
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcPassThroughPush
                     * @instance
                     */
                    ImcPassThroughPush.prototype.contentType = 0;

                    /**
                     * Creates a new ImcPassThroughPush instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcPassThroughPush
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IImcPassThroughPush=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.ImcPassThroughPush} ImcPassThroughPush instance
                     */
                    ImcPassThroughPush.create = function create(properties) {
                        return new ImcPassThroughPush(properties);
                    };

                    /**
                     * Encodes the specified ImcPassThroughPush message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.ImcPassThroughPush.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcPassThroughPush
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IImcPassThroughPush} message ImcPassThroughPush message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ImcPassThroughPush.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.chatTarget != null && Object.hasOwnProperty.call(message, "chatTarget"))
                            $root.AcFunDanmu.Im.Message.ChatTarget.encode(message.chatTarget, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.fromUser != null && Object.hasOwnProperty.call(message, "fromUser"))
                            $root.AcFunDanmu.Im.Basic.User.encode(message.fromUser, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.content != null && Object.hasOwnProperty.call(message, "content"))
                            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.content);
                        if (message.contentType != null && Object.hasOwnProperty.call(message, "contentType"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.contentType);
                        return writer;
                    };

                    /**
                     * Encodes the specified ImcPassThroughPush message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.ImcPassThroughPush.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcPassThroughPush
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IImcPassThroughPush} message ImcPassThroughPush message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ImcPassThroughPush.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes an ImcPassThroughPush message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcPassThroughPush
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.ImcPassThroughPush} ImcPassThroughPush
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ImcPassThroughPush.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.ImcPassThroughPush();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.chatTarget = $root.AcFunDanmu.Im.Message.ChatTarget.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.fromUser = $root.AcFunDanmu.Im.Basic.User.decode(reader, reader.uint32());
                                break;
                            case 3:
                                message.content = reader.bytes();
                                break;
                            case 4:
                                message.contentType = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes an ImcPassThroughPush message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcPassThroughPush
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.ImcPassThroughPush} ImcPassThroughPush
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ImcPassThroughPush.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies an ImcPassThroughPush message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcPassThroughPush
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ImcPassThroughPush.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.chatTarget != null && message.hasOwnProperty("chatTarget")) {
                            let error = $root.AcFunDanmu.Im.Message.ChatTarget.verify(message.chatTarget);
                            if (error)
                                return "chatTarget." + error;
                        }
                        if (message.fromUser != null && message.hasOwnProperty("fromUser")) {
                            let error = $root.AcFunDanmu.Im.Basic.User.verify(message.fromUser);
                            if (error)
                                return "fromUser." + error;
                        }
                        if (message.content != null && message.hasOwnProperty("content"))
                            if (!(message.content && typeof message.content.length === "number" || $util.isString(message.content)))
                                return "content: buffer expected";
                        if (message.contentType != null && message.hasOwnProperty("contentType"))
                            if (!$util.isInteger(message.contentType))
                                return "contentType: integer expected";
                        return null;
                    };

                    /**
                     * Creates an ImcPassThroughPush message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcPassThroughPush
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.ImcPassThroughPush} ImcPassThroughPush
                     */
                    ImcPassThroughPush.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.ImcPassThroughPush)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Message.ImcPassThroughPush();
                        if (object.chatTarget != null) {
                            if (typeof object.chatTarget !== "object")
                                throw TypeError(".AcFunDanmu.Im.Cloud.Message.ImcPassThroughPush.chatTarget: object expected");
                            message.chatTarget = $root.AcFunDanmu.Im.Message.ChatTarget.fromObject(object.chatTarget);
                        }
                        if (object.fromUser != null) {
                            if (typeof object.fromUser !== "object")
                                throw TypeError(".AcFunDanmu.Im.Cloud.Message.ImcPassThroughPush.fromUser: object expected");
                            message.fromUser = $root.AcFunDanmu.Im.Basic.User.fromObject(object.fromUser);
                        }
                        if (object.content != null)
                            if (typeof object.content === "string")
                                $util.base64.decode(object.content, message.content = $util.newBuffer($util.base64.length(object.content)), 0);
                            else if (object.content.length)
                                message.content = object.content;
                        if (object.contentType != null)
                            message.contentType = object.contentType | 0;
                        return message;
                    };

                    /**
                     * Creates a plain object from an ImcPassThroughPush message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcPassThroughPush
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.ImcPassThroughPush} message ImcPassThroughPush
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ImcPassThroughPush.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.chatTarget = null;
                            object.fromUser = null;
                            if (options.bytes === String)
                                object.content = "";
                            else {
                                object.content = [];
                                if (options.bytes !== Array)
                                    object.content = $util.newBuffer(object.content);
                            }
                            object.contentType = 0;
                        }
                        if (message.chatTarget != null && message.hasOwnProperty("chatTarget"))
                            object.chatTarget = $root.AcFunDanmu.Im.Message.ChatTarget.toObject(message.chatTarget, options);
                        if (message.fromUser != null && message.hasOwnProperty("fromUser"))
                            object.fromUser = $root.AcFunDanmu.Im.Basic.User.toObject(message.fromUser, options);
                        if (message.content != null && message.hasOwnProperty("content"))
                            object.content = options.bytes === String ? $util.base64.encode(message.content, 0, message.content.length) : options.bytes === Array ? Array.prototype.slice.call(message.content) : message.content;
                        if (message.contentType != null && message.hasOwnProperty("contentType"))
                            object.contentType = message.contentType;
                        return object;
                    };

                    /**
                     * Converts this ImcPassThroughPush to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.ImcPassThroughPush
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ImcPassThroughPush.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return ImcPassThroughPush;
                })();

                Message.InputtingContent = (function() {

                    /**
                     * Properties of an InputtingContent.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @interface IInputtingContent
                     * @property {number|null} [displayInterval] InputtingContent displayInterval
                     */

                    /**
                     * Constructs a new InputtingContent.
                     * @memberof AcFunDanmu.Im.Cloud.Message
                     * @classdesc Represents an InputtingContent.
                     * @implements IInputtingContent
                     * @constructor
                     * @param {AcFunDanmu.Im.Cloud.Message.IInputtingContent=} [properties] Properties to set
                     */
                    function InputtingContent(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * InputtingContent displayInterval.
                     * @member {number} displayInterval
                     * @memberof AcFunDanmu.Im.Cloud.Message.InputtingContent
                     * @instance
                     */
                    InputtingContent.prototype.displayInterval = 0;

                    /**
                     * Creates a new InputtingContent instance using the specified properties.
                     * @function create
                     * @memberof AcFunDanmu.Im.Cloud.Message.InputtingContent
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IInputtingContent=} [properties] Properties to set
                     * @returns {AcFunDanmu.Im.Cloud.Message.InputtingContent} InputtingContent instance
                     */
                    InputtingContent.create = function create(properties) {
                        return new InputtingContent(properties);
                    };

                    /**
                     * Encodes the specified InputtingContent message. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.InputtingContent.verify|verify} messages.
                     * @function encode
                     * @memberof AcFunDanmu.Im.Cloud.Message.InputtingContent
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IInputtingContent} message InputtingContent message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    InputtingContent.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.displayInterval != null && Object.hasOwnProperty.call(message, "displayInterval"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.displayInterval);
                        return writer;
                    };

                    /**
                     * Encodes the specified InputtingContent message, length delimited. Does not implicitly {@link AcFunDanmu.Im.Cloud.Message.InputtingContent.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.InputtingContent
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.IInputtingContent} message InputtingContent message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    InputtingContent.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes an InputtingContent message from the specified reader or buffer.
                     * @function decode
                     * @memberof AcFunDanmu.Im.Cloud.Message.InputtingContent
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {AcFunDanmu.Im.Cloud.Message.InputtingContent} InputtingContent
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    InputtingContent.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.Im.Cloud.Message.InputtingContent();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.displayInterval = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes an InputtingContent message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof AcFunDanmu.Im.Cloud.Message.InputtingContent
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {AcFunDanmu.Im.Cloud.Message.InputtingContent} InputtingContent
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    InputtingContent.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies an InputtingContent message.
                     * @function verify
                     * @memberof AcFunDanmu.Im.Cloud.Message.InputtingContent
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    InputtingContent.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.displayInterval != null && message.hasOwnProperty("displayInterval"))
                            if (!$util.isInteger(message.displayInterval))
                                return "displayInterval: integer expected";
                        return null;
                    };

                    /**
                     * Creates an InputtingContent message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.InputtingContent
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {AcFunDanmu.Im.Cloud.Message.InputtingContent} InputtingContent
                     */
                    InputtingContent.fromObject = function fromObject(object) {
                        if (object instanceof $root.AcFunDanmu.Im.Cloud.Message.InputtingContent)
                            return object;
                        let message = new $root.AcFunDanmu.Im.Cloud.Message.InputtingContent();
                        if (object.displayInterval != null)
                            message.displayInterval = object.displayInterval | 0;
                        return message;
                    };

                    /**
                     * Creates a plain object from an InputtingContent message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof AcFunDanmu.Im.Cloud.Message.InputtingContent
                     * @static
                     * @param {AcFunDanmu.Im.Cloud.Message.InputtingContent} message InputtingContent
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    InputtingContent.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.displayInterval = 0;
                        if (message.displayInterval != null && message.hasOwnProperty("displayInterval"))
                            object.displayInterval = message.displayInterval;
                        return object;
                    };

                    /**
                     * Converts this InputtingContent to JSON.
                     * @function toJSON
                     * @memberof AcFunDanmu.Im.Cloud.Message.InputtingContent
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    InputtingContent.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return InputtingContent;
                })();

                /**
                 * PassThroughType enum.
                 * @name AcFunDanmu.Im.Cloud.Message.PassThroughType
                 * @enum {number}
                 * @property {number} INVALID_PTT=0 INVALID_PTT value
                 * @property {number} INPUTTING=1 INPUTTING value
                 */
                Message.PassThroughType = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "INVALID_PTT"] = 0;
                    values[valuesById[1] = "INPUTTING"] = 1;
                    return values;
                })();

                return Message;
            })();

            return Cloud;
        })();

        return Im;
    })();

    AcFunDanmu.KeepAliveRequest = (function() {

        /**
         * Properties of a KeepAliveRequest.
         * @memberof AcFunDanmu
         * @interface IKeepAliveRequest
         * @property {AcFunDanmu.RegisterRequest.PresenceStatus|null} [presenceStatus] KeepAliveRequest presenceStatus
         * @property {AcFunDanmu.RegisterRequest.ActiveStatus|null} [appActiveStatus] KeepAliveRequest appActiveStatus
         * @property {AcFunDanmu.IPushServiceToken|null} [pushServiceToken] KeepAliveRequest pushServiceToken
         * @property {Array.<AcFunDanmu.IPushServiceToken>|null} [pushServiceTokenList] KeepAliveRequest pushServiceTokenList
         * @property {number|null} [keepaliveIntervalSec] KeepAliveRequest keepaliveIntervalSec
         */

        /**
         * Constructs a new KeepAliveRequest.
         * @memberof AcFunDanmu
         * @classdesc Represents a KeepAliveRequest.
         * @implements IKeepAliveRequest
         * @constructor
         * @param {AcFunDanmu.IKeepAliveRequest=} [properties] Properties to set
         */
        function KeepAliveRequest(properties) {
            this.pushServiceTokenList = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * KeepAliveRequest presenceStatus.
         * @member {AcFunDanmu.RegisterRequest.PresenceStatus} presenceStatus
         * @memberof AcFunDanmu.KeepAliveRequest
         * @instance
         */
        KeepAliveRequest.prototype.presenceStatus = 0;

        /**
         * KeepAliveRequest appActiveStatus.
         * @member {AcFunDanmu.RegisterRequest.ActiveStatus} appActiveStatus
         * @memberof AcFunDanmu.KeepAliveRequest
         * @instance
         */
        KeepAliveRequest.prototype.appActiveStatus = 0;

        /**
         * KeepAliveRequest pushServiceToken.
         * @member {AcFunDanmu.IPushServiceToken|null|undefined} pushServiceToken
         * @memberof AcFunDanmu.KeepAliveRequest
         * @instance
         */
        KeepAliveRequest.prototype.pushServiceToken = null;

        /**
         * KeepAliveRequest pushServiceTokenList.
         * @member {Array.<AcFunDanmu.IPushServiceToken>} pushServiceTokenList
         * @memberof AcFunDanmu.KeepAliveRequest
         * @instance
         */
        KeepAliveRequest.prototype.pushServiceTokenList = $util.emptyArray;

        /**
         * KeepAliveRequest keepaliveIntervalSec.
         * @member {number} keepaliveIntervalSec
         * @memberof AcFunDanmu.KeepAliveRequest
         * @instance
         */
        KeepAliveRequest.prototype.keepaliveIntervalSec = 0;

        /**
         * Creates a new KeepAliveRequest instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.KeepAliveRequest
         * @static
         * @param {AcFunDanmu.IKeepAliveRequest=} [properties] Properties to set
         * @returns {AcFunDanmu.KeepAliveRequest} KeepAliveRequest instance
         */
        KeepAliveRequest.create = function create(properties) {
            return new KeepAliveRequest(properties);
        };

        /**
         * Encodes the specified KeepAliveRequest message. Does not implicitly {@link AcFunDanmu.KeepAliveRequest.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.KeepAliveRequest
         * @static
         * @param {AcFunDanmu.IKeepAliveRequest} message KeepAliveRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KeepAliveRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.presenceStatus != null && Object.hasOwnProperty.call(message, "presenceStatus"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.presenceStatus);
            if (message.appActiveStatus != null && Object.hasOwnProperty.call(message, "appActiveStatus"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.appActiveStatus);
            if (message.pushServiceToken != null && Object.hasOwnProperty.call(message, "pushServiceToken"))
                $root.AcFunDanmu.PushServiceToken.encode(message.pushServiceToken, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.pushServiceTokenList != null && message.pushServiceTokenList.length)
                for (let i = 0; i < message.pushServiceTokenList.length; ++i)
                    $root.AcFunDanmu.PushServiceToken.encode(message.pushServiceTokenList[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.keepaliveIntervalSec != null && Object.hasOwnProperty.call(message, "keepaliveIntervalSec"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.keepaliveIntervalSec);
            return writer;
        };

        /**
         * Encodes the specified KeepAliveRequest message, length delimited. Does not implicitly {@link AcFunDanmu.KeepAliveRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.KeepAliveRequest
         * @static
         * @param {AcFunDanmu.IKeepAliveRequest} message KeepAliveRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KeepAliveRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a KeepAliveRequest message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.KeepAliveRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.KeepAliveRequest} KeepAliveRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeepAliveRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.KeepAliveRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.presenceStatus = reader.int32();
                    break;
                case 2:
                    message.appActiveStatus = reader.int32();
                    break;
                case 3:
                    message.pushServiceToken = $root.AcFunDanmu.PushServiceToken.decode(reader, reader.uint32());
                    break;
                case 4:
                    if (!(message.pushServiceTokenList && message.pushServiceTokenList.length))
                        message.pushServiceTokenList = [];
                    message.pushServiceTokenList.push($root.AcFunDanmu.PushServiceToken.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.keepaliveIntervalSec = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a KeepAliveRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.KeepAliveRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.KeepAliveRequest} KeepAliveRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeepAliveRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a KeepAliveRequest message.
         * @function verify
         * @memberof AcFunDanmu.KeepAliveRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        KeepAliveRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.presenceStatus != null && message.hasOwnProperty("presenceStatus"))
                switch (message.presenceStatus) {
                default:
                    return "presenceStatus: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.appActiveStatus != null && message.hasOwnProperty("appActiveStatus"))
                switch (message.appActiveStatus) {
                default:
                    return "appActiveStatus: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.pushServiceToken != null && message.hasOwnProperty("pushServiceToken")) {
                let error = $root.AcFunDanmu.PushServiceToken.verify(message.pushServiceToken);
                if (error)
                    return "pushServiceToken." + error;
            }
            if (message.pushServiceTokenList != null && message.hasOwnProperty("pushServiceTokenList")) {
                if (!Array.isArray(message.pushServiceTokenList))
                    return "pushServiceTokenList: array expected";
                for (let i = 0; i < message.pushServiceTokenList.length; ++i) {
                    let error = $root.AcFunDanmu.PushServiceToken.verify(message.pushServiceTokenList[i]);
                    if (error)
                        return "pushServiceTokenList." + error;
                }
            }
            if (message.keepaliveIntervalSec != null && message.hasOwnProperty("keepaliveIntervalSec"))
                if (!$util.isInteger(message.keepaliveIntervalSec))
                    return "keepaliveIntervalSec: integer expected";
            return null;
        };

        /**
         * Creates a KeepAliveRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.KeepAliveRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.KeepAliveRequest} KeepAliveRequest
         */
        KeepAliveRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.KeepAliveRequest)
                return object;
            let message = new $root.AcFunDanmu.KeepAliveRequest();
            switch (object.presenceStatus) {
            case "kPresenceOffline":
            case 0:
                message.presenceStatus = 0;
                break;
            case "kPresenceOnline":
            case 1:
                message.presenceStatus = 1;
                break;
            }
            switch (object.appActiveStatus) {
            case "kInvalid":
            case 0:
                message.appActiveStatus = 0;
                break;
            case "kAppInForeground":
            case 1:
                message.appActiveStatus = 1;
                break;
            case "kAppinBackground":
            case 2:
                message.appActiveStatus = 2;
                break;
            }
            if (object.pushServiceToken != null) {
                if (typeof object.pushServiceToken !== "object")
                    throw TypeError(".AcFunDanmu.KeepAliveRequest.pushServiceToken: object expected");
                message.pushServiceToken = $root.AcFunDanmu.PushServiceToken.fromObject(object.pushServiceToken);
            }
            if (object.pushServiceTokenList) {
                if (!Array.isArray(object.pushServiceTokenList))
                    throw TypeError(".AcFunDanmu.KeepAliveRequest.pushServiceTokenList: array expected");
                message.pushServiceTokenList = [];
                for (let i = 0; i < object.pushServiceTokenList.length; ++i) {
                    if (typeof object.pushServiceTokenList[i] !== "object")
                        throw TypeError(".AcFunDanmu.KeepAliveRequest.pushServiceTokenList: object expected");
                    message.pushServiceTokenList[i] = $root.AcFunDanmu.PushServiceToken.fromObject(object.pushServiceTokenList[i]);
                }
            }
            if (object.keepaliveIntervalSec != null)
                message.keepaliveIntervalSec = object.keepaliveIntervalSec | 0;
            return message;
        };

        /**
         * Creates a plain object from a KeepAliveRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.KeepAliveRequest
         * @static
         * @param {AcFunDanmu.KeepAliveRequest} message KeepAliveRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        KeepAliveRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.pushServiceTokenList = [];
            if (options.defaults) {
                object.presenceStatus = options.enums === String ? "kPresenceOffline" : 0;
                object.appActiveStatus = options.enums === String ? "kInvalid" : 0;
                object.pushServiceToken = null;
                object.keepaliveIntervalSec = 0;
            }
            if (message.presenceStatus != null && message.hasOwnProperty("presenceStatus"))
                object.presenceStatus = options.enums === String ? $root.AcFunDanmu.RegisterRequest.PresenceStatus[message.presenceStatus] : message.presenceStatus;
            if (message.appActiveStatus != null && message.hasOwnProperty("appActiveStatus"))
                object.appActiveStatus = options.enums === String ? $root.AcFunDanmu.RegisterRequest.ActiveStatus[message.appActiveStatus] : message.appActiveStatus;
            if (message.pushServiceToken != null && message.hasOwnProperty("pushServiceToken"))
                object.pushServiceToken = $root.AcFunDanmu.PushServiceToken.toObject(message.pushServiceToken, options);
            if (message.pushServiceTokenList && message.pushServiceTokenList.length) {
                object.pushServiceTokenList = [];
                for (let j = 0; j < message.pushServiceTokenList.length; ++j)
                    object.pushServiceTokenList[j] = $root.AcFunDanmu.PushServiceToken.toObject(message.pushServiceTokenList[j], options);
            }
            if (message.keepaliveIntervalSec != null && message.hasOwnProperty("keepaliveIntervalSec"))
                object.keepaliveIntervalSec = message.keepaliveIntervalSec;
            return object;
        };

        /**
         * Converts this KeepAliveRequest to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.KeepAliveRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        KeepAliveRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return KeepAliveRequest;
    })();

    AcFunDanmu.KeepAliveResponse = (function() {

        /**
         * Properties of a KeepAliveResponse.
         * @memberof AcFunDanmu
         * @interface IKeepAliveResponse
         * @property {AcFunDanmu.IAccessPointsConfig|null} [accessPointsConfig] KeepAliveResponse accessPointsConfig
         * @property {number|Long|null} [serverMsec] KeepAliveResponse serverMsec
         * @property {AcFunDanmu.IAccessPointsConfig|null} [accessPointsConfigIpv6] KeepAliveResponse accessPointsConfigIpv6
         */

        /**
         * Constructs a new KeepAliveResponse.
         * @memberof AcFunDanmu
         * @classdesc Represents a KeepAliveResponse.
         * @implements IKeepAliveResponse
         * @constructor
         * @param {AcFunDanmu.IKeepAliveResponse=} [properties] Properties to set
         */
        function KeepAliveResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * KeepAliveResponse accessPointsConfig.
         * @member {AcFunDanmu.IAccessPointsConfig|null|undefined} accessPointsConfig
         * @memberof AcFunDanmu.KeepAliveResponse
         * @instance
         */
        KeepAliveResponse.prototype.accessPointsConfig = null;

        /**
         * KeepAliveResponse serverMsec.
         * @member {number|Long} serverMsec
         * @memberof AcFunDanmu.KeepAliveResponse
         * @instance
         */
        KeepAliveResponse.prototype.serverMsec = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * KeepAliveResponse accessPointsConfigIpv6.
         * @member {AcFunDanmu.IAccessPointsConfig|null|undefined} accessPointsConfigIpv6
         * @memberof AcFunDanmu.KeepAliveResponse
         * @instance
         */
        KeepAliveResponse.prototype.accessPointsConfigIpv6 = null;

        /**
         * Creates a new KeepAliveResponse instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.KeepAliveResponse
         * @static
         * @param {AcFunDanmu.IKeepAliveResponse=} [properties] Properties to set
         * @returns {AcFunDanmu.KeepAliveResponse} KeepAliveResponse instance
         */
        KeepAliveResponse.create = function create(properties) {
            return new KeepAliveResponse(properties);
        };

        /**
         * Encodes the specified KeepAliveResponse message. Does not implicitly {@link AcFunDanmu.KeepAliveResponse.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.KeepAliveResponse
         * @static
         * @param {AcFunDanmu.IKeepAliveResponse} message KeepAliveResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KeepAliveResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.accessPointsConfig != null && Object.hasOwnProperty.call(message, "accessPointsConfig"))
                $root.AcFunDanmu.AccessPointsConfig.encode(message.accessPointsConfig, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.serverMsec != null && Object.hasOwnProperty.call(message, "serverMsec"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.serverMsec);
            if (message.accessPointsConfigIpv6 != null && Object.hasOwnProperty.call(message, "accessPointsConfigIpv6"))
                $root.AcFunDanmu.AccessPointsConfig.encode(message.accessPointsConfigIpv6, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified KeepAliveResponse message, length delimited. Does not implicitly {@link AcFunDanmu.KeepAliveResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.KeepAliveResponse
         * @static
         * @param {AcFunDanmu.IKeepAliveResponse} message KeepAliveResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KeepAliveResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a KeepAliveResponse message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.KeepAliveResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.KeepAliveResponse} KeepAliveResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeepAliveResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.KeepAliveResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.accessPointsConfig = $root.AcFunDanmu.AccessPointsConfig.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.serverMsec = reader.int64();
                    break;
                case 3:
                    message.accessPointsConfigIpv6 = $root.AcFunDanmu.AccessPointsConfig.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a KeepAliveResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.KeepAliveResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.KeepAliveResponse} KeepAliveResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeepAliveResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a KeepAliveResponse message.
         * @function verify
         * @memberof AcFunDanmu.KeepAliveResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        KeepAliveResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.accessPointsConfig != null && message.hasOwnProperty("accessPointsConfig")) {
                let error = $root.AcFunDanmu.AccessPointsConfig.verify(message.accessPointsConfig);
                if (error)
                    return "accessPointsConfig." + error;
            }
            if (message.serverMsec != null && message.hasOwnProperty("serverMsec"))
                if (!$util.isInteger(message.serverMsec) && !(message.serverMsec && $util.isInteger(message.serverMsec.low) && $util.isInteger(message.serverMsec.high)))
                    return "serverMsec: integer|Long expected";
            if (message.accessPointsConfigIpv6 != null && message.hasOwnProperty("accessPointsConfigIpv6")) {
                let error = $root.AcFunDanmu.AccessPointsConfig.verify(message.accessPointsConfigIpv6);
                if (error)
                    return "accessPointsConfigIpv6." + error;
            }
            return null;
        };

        /**
         * Creates a KeepAliveResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.KeepAliveResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.KeepAliveResponse} KeepAliveResponse
         */
        KeepAliveResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.KeepAliveResponse)
                return object;
            let message = new $root.AcFunDanmu.KeepAliveResponse();
            if (object.accessPointsConfig != null) {
                if (typeof object.accessPointsConfig !== "object")
                    throw TypeError(".AcFunDanmu.KeepAliveResponse.accessPointsConfig: object expected");
                message.accessPointsConfig = $root.AcFunDanmu.AccessPointsConfig.fromObject(object.accessPointsConfig);
            }
            if (object.serverMsec != null)
                if ($util.Long)
                    (message.serverMsec = $util.Long.fromValue(object.serverMsec)).unsigned = false;
                else if (typeof object.serverMsec === "string")
                    message.serverMsec = parseInt(object.serverMsec, 10);
                else if (typeof object.serverMsec === "number")
                    message.serverMsec = object.serverMsec;
                else if (typeof object.serverMsec === "object")
                    message.serverMsec = new $util.LongBits(object.serverMsec.low >>> 0, object.serverMsec.high >>> 0).toNumber();
            if (object.accessPointsConfigIpv6 != null) {
                if (typeof object.accessPointsConfigIpv6 !== "object")
                    throw TypeError(".AcFunDanmu.KeepAliveResponse.accessPointsConfigIpv6: object expected");
                message.accessPointsConfigIpv6 = $root.AcFunDanmu.AccessPointsConfig.fromObject(object.accessPointsConfigIpv6);
            }
            return message;
        };

        /**
         * Creates a plain object from a KeepAliveResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.KeepAliveResponse
         * @static
         * @param {AcFunDanmu.KeepAliveResponse} message KeepAliveResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        KeepAliveResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.accessPointsConfig = null;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.serverMsec = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.serverMsec = options.longs === String ? "0" : 0;
                object.accessPointsConfigIpv6 = null;
            }
            if (message.accessPointsConfig != null && message.hasOwnProperty("accessPointsConfig"))
                object.accessPointsConfig = $root.AcFunDanmu.AccessPointsConfig.toObject(message.accessPointsConfig, options);
            if (message.serverMsec != null && message.hasOwnProperty("serverMsec"))
                if (typeof message.serverMsec === "number")
                    object.serverMsec = options.longs === String ? String(message.serverMsec) : message.serverMsec;
                else
                    object.serverMsec = options.longs === String ? $util.Long.prototype.toString.call(message.serverMsec) : options.longs === Number ? new $util.LongBits(message.serverMsec.low >>> 0, message.serverMsec.high >>> 0).toNumber() : message.serverMsec;
            if (message.accessPointsConfigIpv6 != null && message.hasOwnProperty("accessPointsConfigIpv6"))
                object.accessPointsConfigIpv6 = $root.AcFunDanmu.AccessPointsConfig.toObject(message.accessPointsConfigIpv6, options);
            return object;
        };

        /**
         * Converts this KeepAliveResponse to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.KeepAliveResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        KeepAliveResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return KeepAliveResponse;
    })();

    AcFunDanmu.RegisterRequest = (function() {

        /**
         * Properties of a RegisterRequest.
         * @memberof AcFunDanmu
         * @interface IRegisterRequest
         * @property {AcFunDanmu.IAppInfo|null} [appInfo] RegisterRequest appInfo
         * @property {AcFunDanmu.IDeviceInfo|null} [deviceInfo] RegisterRequest deviceInfo
         * @property {AcFunDanmu.IEnvInfo|null} [envInfo] RegisterRequest envInfo
         * @property {AcFunDanmu.RegisterRequest.PresenceStatus|null} [presenceStatus] RegisterRequest presenceStatus
         * @property {AcFunDanmu.RegisterRequest.ActiveStatus|null} [appActiveStatus] RegisterRequest appActiveStatus
         * @property {Uint8Array|null} [appCustomStatus] RegisterRequest appCustomStatus
         * @property {AcFunDanmu.IPushServiceToken|null} [pushServiceToken] RegisterRequest pushServiceToken
         * @property {number|Long|null} [instanceId] RegisterRequest instanceId
         * @property {Array.<AcFunDanmu.IPushServiceToken>|null} [pushServiceTokenList] RegisterRequest pushServiceTokenList
         * @property {number|null} [keepaliveIntervalSec] RegisterRequest keepaliveIntervalSec
         * @property {AcFunDanmu.IZtCommonInfo|null} [ztCommonInfo] RegisterRequest ztCommonInfo
         */

        /**
         * Constructs a new RegisterRequest.
         * @memberof AcFunDanmu
         * @classdesc Represents a RegisterRequest.
         * @implements IRegisterRequest
         * @constructor
         * @param {AcFunDanmu.IRegisterRequest=} [properties] Properties to set
         */
        function RegisterRequest(properties) {
            this.pushServiceTokenList = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RegisterRequest appInfo.
         * @member {AcFunDanmu.IAppInfo|null|undefined} appInfo
         * @memberof AcFunDanmu.RegisterRequest
         * @instance
         */
        RegisterRequest.prototype.appInfo = null;

        /**
         * RegisterRequest deviceInfo.
         * @member {AcFunDanmu.IDeviceInfo|null|undefined} deviceInfo
         * @memberof AcFunDanmu.RegisterRequest
         * @instance
         */
        RegisterRequest.prototype.deviceInfo = null;

        /**
         * RegisterRequest envInfo.
         * @member {AcFunDanmu.IEnvInfo|null|undefined} envInfo
         * @memberof AcFunDanmu.RegisterRequest
         * @instance
         */
        RegisterRequest.prototype.envInfo = null;

        /**
         * RegisterRequest presenceStatus.
         * @member {AcFunDanmu.RegisterRequest.PresenceStatus} presenceStatus
         * @memberof AcFunDanmu.RegisterRequest
         * @instance
         */
        RegisterRequest.prototype.presenceStatus = 0;

        /**
         * RegisterRequest appActiveStatus.
         * @member {AcFunDanmu.RegisterRequest.ActiveStatus} appActiveStatus
         * @memberof AcFunDanmu.RegisterRequest
         * @instance
         */
        RegisterRequest.prototype.appActiveStatus = 0;

        /**
         * RegisterRequest appCustomStatus.
         * @member {Uint8Array} appCustomStatus
         * @memberof AcFunDanmu.RegisterRequest
         * @instance
         */
        RegisterRequest.prototype.appCustomStatus = $util.newBuffer([]);

        /**
         * RegisterRequest pushServiceToken.
         * @member {AcFunDanmu.IPushServiceToken|null|undefined} pushServiceToken
         * @memberof AcFunDanmu.RegisterRequest
         * @instance
         */
        RegisterRequest.prototype.pushServiceToken = null;

        /**
         * RegisterRequest instanceId.
         * @member {number|Long} instanceId
         * @memberof AcFunDanmu.RegisterRequest
         * @instance
         */
        RegisterRequest.prototype.instanceId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * RegisterRequest pushServiceTokenList.
         * @member {Array.<AcFunDanmu.IPushServiceToken>} pushServiceTokenList
         * @memberof AcFunDanmu.RegisterRequest
         * @instance
         */
        RegisterRequest.prototype.pushServiceTokenList = $util.emptyArray;

        /**
         * RegisterRequest keepaliveIntervalSec.
         * @member {number} keepaliveIntervalSec
         * @memberof AcFunDanmu.RegisterRequest
         * @instance
         */
        RegisterRequest.prototype.keepaliveIntervalSec = 0;

        /**
         * RegisterRequest ztCommonInfo.
         * @member {AcFunDanmu.IZtCommonInfo|null|undefined} ztCommonInfo
         * @memberof AcFunDanmu.RegisterRequest
         * @instance
         */
        RegisterRequest.prototype.ztCommonInfo = null;

        /**
         * Creates a new RegisterRequest instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.RegisterRequest
         * @static
         * @param {AcFunDanmu.IRegisterRequest=} [properties] Properties to set
         * @returns {AcFunDanmu.RegisterRequest} RegisterRequest instance
         */
        RegisterRequest.create = function create(properties) {
            return new RegisterRequest(properties);
        };

        /**
         * Encodes the specified RegisterRequest message. Does not implicitly {@link AcFunDanmu.RegisterRequest.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.RegisterRequest
         * @static
         * @param {AcFunDanmu.IRegisterRequest} message RegisterRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.appInfo != null && Object.hasOwnProperty.call(message, "appInfo"))
                $root.AcFunDanmu.AppInfo.encode(message.appInfo, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.deviceInfo != null && Object.hasOwnProperty.call(message, "deviceInfo"))
                $root.AcFunDanmu.DeviceInfo.encode(message.deviceInfo, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.envInfo != null && Object.hasOwnProperty.call(message, "envInfo"))
                $root.AcFunDanmu.EnvInfo.encode(message.envInfo, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.presenceStatus != null && Object.hasOwnProperty.call(message, "presenceStatus"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.presenceStatus);
            if (message.appActiveStatus != null && Object.hasOwnProperty.call(message, "appActiveStatus"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.appActiveStatus);
            if (message.appCustomStatus != null && Object.hasOwnProperty.call(message, "appCustomStatus"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.appCustomStatus);
            if (message.pushServiceToken != null && Object.hasOwnProperty.call(message, "pushServiceToken"))
                $root.AcFunDanmu.PushServiceToken.encode(message.pushServiceToken, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.instanceId != null && Object.hasOwnProperty.call(message, "instanceId"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.instanceId);
            if (message.pushServiceTokenList != null && message.pushServiceTokenList.length)
                for (let i = 0; i < message.pushServiceTokenList.length; ++i)
                    $root.AcFunDanmu.PushServiceToken.encode(message.pushServiceTokenList[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.keepaliveIntervalSec != null && Object.hasOwnProperty.call(message, "keepaliveIntervalSec"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.keepaliveIntervalSec);
            if (message.ztCommonInfo != null && Object.hasOwnProperty.call(message, "ztCommonInfo"))
                $root.AcFunDanmu.ZtCommonInfo.encode(message.ztCommonInfo, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified RegisterRequest message, length delimited. Does not implicitly {@link AcFunDanmu.RegisterRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.RegisterRequest
         * @static
         * @param {AcFunDanmu.IRegisterRequest} message RegisterRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RegisterRequest message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.RegisterRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.RegisterRequest} RegisterRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.RegisterRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.appInfo = $root.AcFunDanmu.AppInfo.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.deviceInfo = $root.AcFunDanmu.DeviceInfo.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.envInfo = $root.AcFunDanmu.EnvInfo.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.presenceStatus = reader.int32();
                    break;
                case 5:
                    message.appActiveStatus = reader.int32();
                    break;
                case 6:
                    message.appCustomStatus = reader.bytes();
                    break;
                case 7:
                    message.pushServiceToken = $root.AcFunDanmu.PushServiceToken.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.instanceId = reader.int64();
                    break;
                case 9:
                    if (!(message.pushServiceTokenList && message.pushServiceTokenList.length))
                        message.pushServiceTokenList = [];
                    message.pushServiceTokenList.push($root.AcFunDanmu.PushServiceToken.decode(reader, reader.uint32()));
                    break;
                case 10:
                    message.keepaliveIntervalSec = reader.int32();
                    break;
                case 11:
                    message.ztCommonInfo = $root.AcFunDanmu.ZtCommonInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RegisterRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.RegisterRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.RegisterRequest} RegisterRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RegisterRequest message.
         * @function verify
         * @memberof AcFunDanmu.RegisterRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RegisterRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.appInfo != null && message.hasOwnProperty("appInfo")) {
                let error = $root.AcFunDanmu.AppInfo.verify(message.appInfo);
                if (error)
                    return "appInfo." + error;
            }
            if (message.deviceInfo != null && message.hasOwnProperty("deviceInfo")) {
                let error = $root.AcFunDanmu.DeviceInfo.verify(message.deviceInfo);
                if (error)
                    return "deviceInfo." + error;
            }
            if (message.envInfo != null && message.hasOwnProperty("envInfo")) {
                let error = $root.AcFunDanmu.EnvInfo.verify(message.envInfo);
                if (error)
                    return "envInfo." + error;
            }
            if (message.presenceStatus != null && message.hasOwnProperty("presenceStatus"))
                switch (message.presenceStatus) {
                default:
                    return "presenceStatus: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.appActiveStatus != null && message.hasOwnProperty("appActiveStatus"))
                switch (message.appActiveStatus) {
                default:
                    return "appActiveStatus: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.appCustomStatus != null && message.hasOwnProperty("appCustomStatus"))
                if (!(message.appCustomStatus && typeof message.appCustomStatus.length === "number" || $util.isString(message.appCustomStatus)))
                    return "appCustomStatus: buffer expected";
            if (message.pushServiceToken != null && message.hasOwnProperty("pushServiceToken")) {
                let error = $root.AcFunDanmu.PushServiceToken.verify(message.pushServiceToken);
                if (error)
                    return "pushServiceToken." + error;
            }
            if (message.instanceId != null && message.hasOwnProperty("instanceId"))
                if (!$util.isInteger(message.instanceId) && !(message.instanceId && $util.isInteger(message.instanceId.low) && $util.isInteger(message.instanceId.high)))
                    return "instanceId: integer|Long expected";
            if (message.pushServiceTokenList != null && message.hasOwnProperty("pushServiceTokenList")) {
                if (!Array.isArray(message.pushServiceTokenList))
                    return "pushServiceTokenList: array expected";
                for (let i = 0; i < message.pushServiceTokenList.length; ++i) {
                    let error = $root.AcFunDanmu.PushServiceToken.verify(message.pushServiceTokenList[i]);
                    if (error)
                        return "pushServiceTokenList." + error;
                }
            }
            if (message.keepaliveIntervalSec != null && message.hasOwnProperty("keepaliveIntervalSec"))
                if (!$util.isInteger(message.keepaliveIntervalSec))
                    return "keepaliveIntervalSec: integer expected";
            if (message.ztCommonInfo != null && message.hasOwnProperty("ztCommonInfo")) {
                let error = $root.AcFunDanmu.ZtCommonInfo.verify(message.ztCommonInfo);
                if (error)
                    return "ztCommonInfo." + error;
            }
            return null;
        };

        /**
         * Creates a RegisterRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.RegisterRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.RegisterRequest} RegisterRequest
         */
        RegisterRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.RegisterRequest)
                return object;
            let message = new $root.AcFunDanmu.RegisterRequest();
            if (object.appInfo != null) {
                if (typeof object.appInfo !== "object")
                    throw TypeError(".AcFunDanmu.RegisterRequest.appInfo: object expected");
                message.appInfo = $root.AcFunDanmu.AppInfo.fromObject(object.appInfo);
            }
            if (object.deviceInfo != null) {
                if (typeof object.deviceInfo !== "object")
                    throw TypeError(".AcFunDanmu.RegisterRequest.deviceInfo: object expected");
                message.deviceInfo = $root.AcFunDanmu.DeviceInfo.fromObject(object.deviceInfo);
            }
            if (object.envInfo != null) {
                if (typeof object.envInfo !== "object")
                    throw TypeError(".AcFunDanmu.RegisterRequest.envInfo: object expected");
                message.envInfo = $root.AcFunDanmu.EnvInfo.fromObject(object.envInfo);
            }
            switch (object.presenceStatus) {
            case "kPresenceOffline":
            case 0:
                message.presenceStatus = 0;
                break;
            case "kPresenceOnline":
            case 1:
                message.presenceStatus = 1;
                break;
            }
            switch (object.appActiveStatus) {
            case "kInvalid":
            case 0:
                message.appActiveStatus = 0;
                break;
            case "kAppInForeground":
            case 1:
                message.appActiveStatus = 1;
                break;
            case "kAppinBackground":
            case 2:
                message.appActiveStatus = 2;
                break;
            }
            if (object.appCustomStatus != null)
                if (typeof object.appCustomStatus === "string")
                    $util.base64.decode(object.appCustomStatus, message.appCustomStatus = $util.newBuffer($util.base64.length(object.appCustomStatus)), 0);
                else if (object.appCustomStatus.length)
                    message.appCustomStatus = object.appCustomStatus;
            if (object.pushServiceToken != null) {
                if (typeof object.pushServiceToken !== "object")
                    throw TypeError(".AcFunDanmu.RegisterRequest.pushServiceToken: object expected");
                message.pushServiceToken = $root.AcFunDanmu.PushServiceToken.fromObject(object.pushServiceToken);
            }
            if (object.instanceId != null)
                if ($util.Long)
                    (message.instanceId = $util.Long.fromValue(object.instanceId)).unsigned = false;
                else if (typeof object.instanceId === "string")
                    message.instanceId = parseInt(object.instanceId, 10);
                else if (typeof object.instanceId === "number")
                    message.instanceId = object.instanceId;
                else if (typeof object.instanceId === "object")
                    message.instanceId = new $util.LongBits(object.instanceId.low >>> 0, object.instanceId.high >>> 0).toNumber();
            if (object.pushServiceTokenList) {
                if (!Array.isArray(object.pushServiceTokenList))
                    throw TypeError(".AcFunDanmu.RegisterRequest.pushServiceTokenList: array expected");
                message.pushServiceTokenList = [];
                for (let i = 0; i < object.pushServiceTokenList.length; ++i) {
                    if (typeof object.pushServiceTokenList[i] !== "object")
                        throw TypeError(".AcFunDanmu.RegisterRequest.pushServiceTokenList: object expected");
                    message.pushServiceTokenList[i] = $root.AcFunDanmu.PushServiceToken.fromObject(object.pushServiceTokenList[i]);
                }
            }
            if (object.keepaliveIntervalSec != null)
                message.keepaliveIntervalSec = object.keepaliveIntervalSec | 0;
            if (object.ztCommonInfo != null) {
                if (typeof object.ztCommonInfo !== "object")
                    throw TypeError(".AcFunDanmu.RegisterRequest.ztCommonInfo: object expected");
                message.ztCommonInfo = $root.AcFunDanmu.ZtCommonInfo.fromObject(object.ztCommonInfo);
            }
            return message;
        };

        /**
         * Creates a plain object from a RegisterRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.RegisterRequest
         * @static
         * @param {AcFunDanmu.RegisterRequest} message RegisterRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RegisterRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.pushServiceTokenList = [];
            if (options.defaults) {
                object.appInfo = null;
                object.deviceInfo = null;
                object.envInfo = null;
                object.presenceStatus = options.enums === String ? "kPresenceOffline" : 0;
                object.appActiveStatus = options.enums === String ? "kInvalid" : 0;
                if (options.bytes === String)
                    object.appCustomStatus = "";
                else {
                    object.appCustomStatus = [];
                    if (options.bytes !== Array)
                        object.appCustomStatus = $util.newBuffer(object.appCustomStatus);
                }
                object.pushServiceToken = null;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.instanceId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.instanceId = options.longs === String ? "0" : 0;
                object.keepaliveIntervalSec = 0;
                object.ztCommonInfo = null;
            }
            if (message.appInfo != null && message.hasOwnProperty("appInfo"))
                object.appInfo = $root.AcFunDanmu.AppInfo.toObject(message.appInfo, options);
            if (message.deviceInfo != null && message.hasOwnProperty("deviceInfo"))
                object.deviceInfo = $root.AcFunDanmu.DeviceInfo.toObject(message.deviceInfo, options);
            if (message.envInfo != null && message.hasOwnProperty("envInfo"))
                object.envInfo = $root.AcFunDanmu.EnvInfo.toObject(message.envInfo, options);
            if (message.presenceStatus != null && message.hasOwnProperty("presenceStatus"))
                object.presenceStatus = options.enums === String ? $root.AcFunDanmu.RegisterRequest.PresenceStatus[message.presenceStatus] : message.presenceStatus;
            if (message.appActiveStatus != null && message.hasOwnProperty("appActiveStatus"))
                object.appActiveStatus = options.enums === String ? $root.AcFunDanmu.RegisterRequest.ActiveStatus[message.appActiveStatus] : message.appActiveStatus;
            if (message.appCustomStatus != null && message.hasOwnProperty("appCustomStatus"))
                object.appCustomStatus = options.bytes === String ? $util.base64.encode(message.appCustomStatus, 0, message.appCustomStatus.length) : options.bytes === Array ? Array.prototype.slice.call(message.appCustomStatus) : message.appCustomStatus;
            if (message.pushServiceToken != null && message.hasOwnProperty("pushServiceToken"))
                object.pushServiceToken = $root.AcFunDanmu.PushServiceToken.toObject(message.pushServiceToken, options);
            if (message.instanceId != null && message.hasOwnProperty("instanceId"))
                if (typeof message.instanceId === "number")
                    object.instanceId = options.longs === String ? String(message.instanceId) : message.instanceId;
                else
                    object.instanceId = options.longs === String ? $util.Long.prototype.toString.call(message.instanceId) : options.longs === Number ? new $util.LongBits(message.instanceId.low >>> 0, message.instanceId.high >>> 0).toNumber() : message.instanceId;
            if (message.pushServiceTokenList && message.pushServiceTokenList.length) {
                object.pushServiceTokenList = [];
                for (let j = 0; j < message.pushServiceTokenList.length; ++j)
                    object.pushServiceTokenList[j] = $root.AcFunDanmu.PushServiceToken.toObject(message.pushServiceTokenList[j], options);
            }
            if (message.keepaliveIntervalSec != null && message.hasOwnProperty("keepaliveIntervalSec"))
                object.keepaliveIntervalSec = message.keepaliveIntervalSec;
            if (message.ztCommonInfo != null && message.hasOwnProperty("ztCommonInfo"))
                object.ztCommonInfo = $root.AcFunDanmu.ZtCommonInfo.toObject(message.ztCommonInfo, options);
            return object;
        };

        /**
         * Converts this RegisterRequest to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.RegisterRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RegisterRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * PresenceStatus enum.
         * @name AcFunDanmu.RegisterRequest.PresenceStatus
         * @enum {number}
         * @property {number} kPresenceOffline=0 kPresenceOffline value
         * @property {number} kPresenceOnline=1 kPresenceOnline value
         */
        RegisterRequest.PresenceStatus = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "kPresenceOffline"] = 0;
            values[valuesById[1] = "kPresenceOnline"] = 1;
            return values;
        })();

        /**
         * ActiveStatus enum.
         * @name AcFunDanmu.RegisterRequest.ActiveStatus
         * @enum {number}
         * @property {number} kInvalid=0 kInvalid value
         * @property {number} kAppInForeground=1 kAppInForeground value
         * @property {number} kAppinBackground=2 kAppinBackground value
         */
        RegisterRequest.ActiveStatus = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "kInvalid"] = 0;
            values[valuesById[1] = "kAppInForeground"] = 1;
            values[valuesById[2] = "kAppinBackground"] = 2;
            return values;
        })();

        return RegisterRequest;
    })();

    AcFunDanmu.RegisterResponse = (function() {

        /**
         * Properties of a RegisterResponse.
         * @memberof AcFunDanmu
         * @interface IRegisterResponse
         * @property {AcFunDanmu.IAccessPointsConfig|null} [accessPointsConfig] RegisterResponse accessPointsConfig
         * @property {Uint8Array|null} [sessKey] RegisterResponse sessKey
         * @property {number|Long|null} [instanceId] RegisterResponse instanceId
         * @property {AcFunDanmu.ISdkOption|null} [sdkOption] RegisterResponse sdkOption
         * @property {AcFunDanmu.IAccessPointsConfig|null} [accessPointsCOnfigIpv6] RegisterResponse accessPointsCOnfigIpv6
         */

        /**
         * Constructs a new RegisterResponse.
         * @memberof AcFunDanmu
         * @classdesc Represents a RegisterResponse.
         * @implements IRegisterResponse
         * @constructor
         * @param {AcFunDanmu.IRegisterResponse=} [properties] Properties to set
         */
        function RegisterResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RegisterResponse accessPointsConfig.
         * @member {AcFunDanmu.IAccessPointsConfig|null|undefined} accessPointsConfig
         * @memberof AcFunDanmu.RegisterResponse
         * @instance
         */
        RegisterResponse.prototype.accessPointsConfig = null;

        /**
         * RegisterResponse sessKey.
         * @member {Uint8Array} sessKey
         * @memberof AcFunDanmu.RegisterResponse
         * @instance
         */
        RegisterResponse.prototype.sessKey = $util.newBuffer([]);

        /**
         * RegisterResponse instanceId.
         * @member {number|Long} instanceId
         * @memberof AcFunDanmu.RegisterResponse
         * @instance
         */
        RegisterResponse.prototype.instanceId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * RegisterResponse sdkOption.
         * @member {AcFunDanmu.ISdkOption|null|undefined} sdkOption
         * @memberof AcFunDanmu.RegisterResponse
         * @instance
         */
        RegisterResponse.prototype.sdkOption = null;

        /**
         * RegisterResponse accessPointsCOnfigIpv6.
         * @member {AcFunDanmu.IAccessPointsConfig|null|undefined} accessPointsCOnfigIpv6
         * @memberof AcFunDanmu.RegisterResponse
         * @instance
         */
        RegisterResponse.prototype.accessPointsCOnfigIpv6 = null;

        /**
         * Creates a new RegisterResponse instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.RegisterResponse
         * @static
         * @param {AcFunDanmu.IRegisterResponse=} [properties] Properties to set
         * @returns {AcFunDanmu.RegisterResponse} RegisterResponse instance
         */
        RegisterResponse.create = function create(properties) {
            return new RegisterResponse(properties);
        };

        /**
         * Encodes the specified RegisterResponse message. Does not implicitly {@link AcFunDanmu.RegisterResponse.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.RegisterResponse
         * @static
         * @param {AcFunDanmu.IRegisterResponse} message RegisterResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.accessPointsConfig != null && Object.hasOwnProperty.call(message, "accessPointsConfig"))
                $root.AcFunDanmu.AccessPointsConfig.encode(message.accessPointsConfig, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.sessKey != null && Object.hasOwnProperty.call(message, "sessKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.sessKey);
            if (message.instanceId != null && Object.hasOwnProperty.call(message, "instanceId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.instanceId);
            if (message.sdkOption != null && Object.hasOwnProperty.call(message, "sdkOption"))
                $root.AcFunDanmu.SdkOption.encode(message.sdkOption, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.accessPointsCOnfigIpv6 != null && Object.hasOwnProperty.call(message, "accessPointsCOnfigIpv6"))
                $root.AcFunDanmu.AccessPointsConfig.encode(message.accessPointsCOnfigIpv6, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified RegisterResponse message, length delimited. Does not implicitly {@link AcFunDanmu.RegisterResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.RegisterResponse
         * @static
         * @param {AcFunDanmu.IRegisterResponse} message RegisterResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RegisterResponse message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.RegisterResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.RegisterResponse} RegisterResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.RegisterResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.accessPointsConfig = $root.AcFunDanmu.AccessPointsConfig.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.sessKey = reader.bytes();
                    break;
                case 3:
                    message.instanceId = reader.int64();
                    break;
                case 4:
                    message.sdkOption = $root.AcFunDanmu.SdkOption.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.accessPointsCOnfigIpv6 = $root.AcFunDanmu.AccessPointsConfig.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RegisterResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.RegisterResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.RegisterResponse} RegisterResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RegisterResponse message.
         * @function verify
         * @memberof AcFunDanmu.RegisterResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RegisterResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.accessPointsConfig != null && message.hasOwnProperty("accessPointsConfig")) {
                let error = $root.AcFunDanmu.AccessPointsConfig.verify(message.accessPointsConfig);
                if (error)
                    return "accessPointsConfig." + error;
            }
            if (message.sessKey != null && message.hasOwnProperty("sessKey"))
                if (!(message.sessKey && typeof message.sessKey.length === "number" || $util.isString(message.sessKey)))
                    return "sessKey: buffer expected";
            if (message.instanceId != null && message.hasOwnProperty("instanceId"))
                if (!$util.isInteger(message.instanceId) && !(message.instanceId && $util.isInteger(message.instanceId.low) && $util.isInteger(message.instanceId.high)))
                    return "instanceId: integer|Long expected";
            if (message.sdkOption != null && message.hasOwnProperty("sdkOption")) {
                let error = $root.AcFunDanmu.SdkOption.verify(message.sdkOption);
                if (error)
                    return "sdkOption." + error;
            }
            if (message.accessPointsCOnfigIpv6 != null && message.hasOwnProperty("accessPointsCOnfigIpv6")) {
                let error = $root.AcFunDanmu.AccessPointsConfig.verify(message.accessPointsCOnfigIpv6);
                if (error)
                    return "accessPointsCOnfigIpv6." + error;
            }
            return null;
        };

        /**
         * Creates a RegisterResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.RegisterResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.RegisterResponse} RegisterResponse
         */
        RegisterResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.RegisterResponse)
                return object;
            let message = new $root.AcFunDanmu.RegisterResponse();
            if (object.accessPointsConfig != null) {
                if (typeof object.accessPointsConfig !== "object")
                    throw TypeError(".AcFunDanmu.RegisterResponse.accessPointsConfig: object expected");
                message.accessPointsConfig = $root.AcFunDanmu.AccessPointsConfig.fromObject(object.accessPointsConfig);
            }
            if (object.sessKey != null)
                if (typeof object.sessKey === "string")
                    $util.base64.decode(object.sessKey, message.sessKey = $util.newBuffer($util.base64.length(object.sessKey)), 0);
                else if (object.sessKey.length)
                    message.sessKey = object.sessKey;
            if (object.instanceId != null)
                if ($util.Long)
                    (message.instanceId = $util.Long.fromValue(object.instanceId)).unsigned = false;
                else if (typeof object.instanceId === "string")
                    message.instanceId = parseInt(object.instanceId, 10);
                else if (typeof object.instanceId === "number")
                    message.instanceId = object.instanceId;
                else if (typeof object.instanceId === "object")
                    message.instanceId = new $util.LongBits(object.instanceId.low >>> 0, object.instanceId.high >>> 0).toNumber();
            if (object.sdkOption != null) {
                if (typeof object.sdkOption !== "object")
                    throw TypeError(".AcFunDanmu.RegisterResponse.sdkOption: object expected");
                message.sdkOption = $root.AcFunDanmu.SdkOption.fromObject(object.sdkOption);
            }
            if (object.accessPointsCOnfigIpv6 != null) {
                if (typeof object.accessPointsCOnfigIpv6 !== "object")
                    throw TypeError(".AcFunDanmu.RegisterResponse.accessPointsCOnfigIpv6: object expected");
                message.accessPointsCOnfigIpv6 = $root.AcFunDanmu.AccessPointsConfig.fromObject(object.accessPointsCOnfigIpv6);
            }
            return message;
        };

        /**
         * Creates a plain object from a RegisterResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.RegisterResponse
         * @static
         * @param {AcFunDanmu.RegisterResponse} message RegisterResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RegisterResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.accessPointsConfig = null;
                if (options.bytes === String)
                    object.sessKey = "";
                else {
                    object.sessKey = [];
                    if (options.bytes !== Array)
                        object.sessKey = $util.newBuffer(object.sessKey);
                }
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.instanceId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.instanceId = options.longs === String ? "0" : 0;
                object.sdkOption = null;
                object.accessPointsCOnfigIpv6 = null;
            }
            if (message.accessPointsConfig != null && message.hasOwnProperty("accessPointsConfig"))
                object.accessPointsConfig = $root.AcFunDanmu.AccessPointsConfig.toObject(message.accessPointsConfig, options);
            if (message.sessKey != null && message.hasOwnProperty("sessKey"))
                object.sessKey = options.bytes === String ? $util.base64.encode(message.sessKey, 0, message.sessKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.sessKey) : message.sessKey;
            if (message.instanceId != null && message.hasOwnProperty("instanceId"))
                if (typeof message.instanceId === "number")
                    object.instanceId = options.longs === String ? String(message.instanceId) : message.instanceId;
                else
                    object.instanceId = options.longs === String ? $util.Long.prototype.toString.call(message.instanceId) : options.longs === Number ? new $util.LongBits(message.instanceId.low >>> 0, message.instanceId.high >>> 0).toNumber() : message.instanceId;
            if (message.sdkOption != null && message.hasOwnProperty("sdkOption"))
                object.sdkOption = $root.AcFunDanmu.SdkOption.toObject(message.sdkOption, options);
            if (message.accessPointsCOnfigIpv6 != null && message.hasOwnProperty("accessPointsCOnfigIpv6"))
                object.accessPointsCOnfigIpv6 = $root.AcFunDanmu.AccessPointsConfig.toObject(message.accessPointsCOnfigIpv6, options);
            return object;
        };

        /**
         * Converts this RegisterResponse to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.RegisterResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RegisterResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RegisterResponse;
    })();

    AcFunDanmu.ZtCommonInfo = (function() {

        /**
         * Properties of a ZtCommonInfo.
         * @memberof AcFunDanmu
         * @interface IZtCommonInfo
         * @property {string|null} [kpn] ZtCommonInfo kpn
         * @property {string|null} [kpf] ZtCommonInfo kpf
         * @property {string|null} [subBiz] ZtCommonInfo subBiz
         * @property {number|Long|null} [uid] ZtCommonInfo uid
         * @property {string|null} [did] ZtCommonInfo did
         * @property {number|Long|null} [clientIp] ZtCommonInfo clientIp
         * @property {string|null} [appVer] ZtCommonInfo appVer
         * @property {string|null} [ver] ZtCommonInfo ver
         * @property {string|null} [lat] ZtCommonInfo lat
         * @property {string|null} [lon] ZtCommonInfo lon
         * @property {string|null} [mond] ZtCommonInfo mond
         * @property {string|null} [net] ZtCommonInfo net
         * @property {string|null} [sys] ZtCommonInfo sys
         * @property {string|null} [c] ZtCommonInfo c
         * @property {string|null} [language] ZtCommonInfo language
         * @property {string|null} [countryCode] ZtCommonInfo countryCode
         */

        /**
         * Constructs a new ZtCommonInfo.
         * @memberof AcFunDanmu
         * @classdesc Represents a ZtCommonInfo.
         * @implements IZtCommonInfo
         * @constructor
         * @param {AcFunDanmu.IZtCommonInfo=} [properties] Properties to set
         */
        function ZtCommonInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ZtCommonInfo kpn.
         * @member {string} kpn
         * @memberof AcFunDanmu.ZtCommonInfo
         * @instance
         */
        ZtCommonInfo.prototype.kpn = "";

        /**
         * ZtCommonInfo kpf.
         * @member {string} kpf
         * @memberof AcFunDanmu.ZtCommonInfo
         * @instance
         */
        ZtCommonInfo.prototype.kpf = "";

        /**
         * ZtCommonInfo subBiz.
         * @member {string} subBiz
         * @memberof AcFunDanmu.ZtCommonInfo
         * @instance
         */
        ZtCommonInfo.prototype.subBiz = "";

        /**
         * ZtCommonInfo uid.
         * @member {number|Long} uid
         * @memberof AcFunDanmu.ZtCommonInfo
         * @instance
         */
        ZtCommonInfo.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ZtCommonInfo did.
         * @member {string} did
         * @memberof AcFunDanmu.ZtCommonInfo
         * @instance
         */
        ZtCommonInfo.prototype.did = "";

        /**
         * ZtCommonInfo clientIp.
         * @member {number|Long} clientIp
         * @memberof AcFunDanmu.ZtCommonInfo
         * @instance
         */
        ZtCommonInfo.prototype.clientIp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ZtCommonInfo appVer.
         * @member {string} appVer
         * @memberof AcFunDanmu.ZtCommonInfo
         * @instance
         */
        ZtCommonInfo.prototype.appVer = "";

        /**
         * ZtCommonInfo ver.
         * @member {string} ver
         * @memberof AcFunDanmu.ZtCommonInfo
         * @instance
         */
        ZtCommonInfo.prototype.ver = "";

        /**
         * ZtCommonInfo lat.
         * @member {string} lat
         * @memberof AcFunDanmu.ZtCommonInfo
         * @instance
         */
        ZtCommonInfo.prototype.lat = "";

        /**
         * ZtCommonInfo lon.
         * @member {string} lon
         * @memberof AcFunDanmu.ZtCommonInfo
         * @instance
         */
        ZtCommonInfo.prototype.lon = "";

        /**
         * ZtCommonInfo mond.
         * @member {string} mond
         * @memberof AcFunDanmu.ZtCommonInfo
         * @instance
         */
        ZtCommonInfo.prototype.mond = "";

        /**
         * ZtCommonInfo net.
         * @member {string} net
         * @memberof AcFunDanmu.ZtCommonInfo
         * @instance
         */
        ZtCommonInfo.prototype.net = "";

        /**
         * ZtCommonInfo sys.
         * @member {string} sys
         * @memberof AcFunDanmu.ZtCommonInfo
         * @instance
         */
        ZtCommonInfo.prototype.sys = "";

        /**
         * ZtCommonInfo c.
         * @member {string} c
         * @memberof AcFunDanmu.ZtCommonInfo
         * @instance
         */
        ZtCommonInfo.prototype.c = "";

        /**
         * ZtCommonInfo language.
         * @member {string} language
         * @memberof AcFunDanmu.ZtCommonInfo
         * @instance
         */
        ZtCommonInfo.prototype.language = "";

        /**
         * ZtCommonInfo countryCode.
         * @member {string} countryCode
         * @memberof AcFunDanmu.ZtCommonInfo
         * @instance
         */
        ZtCommonInfo.prototype.countryCode = "";

        /**
         * Creates a new ZtCommonInfo instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.ZtCommonInfo
         * @static
         * @param {AcFunDanmu.IZtCommonInfo=} [properties] Properties to set
         * @returns {AcFunDanmu.ZtCommonInfo} ZtCommonInfo instance
         */
        ZtCommonInfo.create = function create(properties) {
            return new ZtCommonInfo(properties);
        };

        /**
         * Encodes the specified ZtCommonInfo message. Does not implicitly {@link AcFunDanmu.ZtCommonInfo.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.ZtCommonInfo
         * @static
         * @param {AcFunDanmu.IZtCommonInfo} message ZtCommonInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ZtCommonInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.kpn != null && Object.hasOwnProperty.call(message, "kpn"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.kpn);
            if (message.kpf != null && Object.hasOwnProperty.call(message, "kpf"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.kpf);
            if (message.subBiz != null && Object.hasOwnProperty.call(message, "subBiz"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.subBiz);
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.uid);
            if (message.did != null && Object.hasOwnProperty.call(message, "did"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.did);
            if (message.clientIp != null && Object.hasOwnProperty.call(message, "clientIp"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.clientIp);
            if (message.appVer != null && Object.hasOwnProperty.call(message, "appVer"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.appVer);
            if (message.ver != null && Object.hasOwnProperty.call(message, "ver"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.ver);
            if (message.lat != null && Object.hasOwnProperty.call(message, "lat"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.lat);
            if (message.lon != null && Object.hasOwnProperty.call(message, "lon"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.lon);
            if (message.mond != null && Object.hasOwnProperty.call(message, "mond"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.mond);
            if (message.net != null && Object.hasOwnProperty.call(message, "net"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.net);
            if (message.sys != null && Object.hasOwnProperty.call(message, "sys"))
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.sys);
            if (message.c != null && Object.hasOwnProperty.call(message, "c"))
                writer.uint32(/* id 14, wireType 2 =*/114).string(message.c);
            if (message.language != null && Object.hasOwnProperty.call(message, "language"))
                writer.uint32(/* id 15, wireType 2 =*/122).string(message.language);
            if (message.countryCode != null && Object.hasOwnProperty.call(message, "countryCode"))
                writer.uint32(/* id 16, wireType 2 =*/130).string(message.countryCode);
            return writer;
        };

        /**
         * Encodes the specified ZtCommonInfo message, length delimited. Does not implicitly {@link AcFunDanmu.ZtCommonInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.ZtCommonInfo
         * @static
         * @param {AcFunDanmu.IZtCommonInfo} message ZtCommonInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ZtCommonInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ZtCommonInfo message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.ZtCommonInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.ZtCommonInfo} ZtCommonInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ZtCommonInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.ZtCommonInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.kpn = reader.string();
                    break;
                case 2:
                    message.kpf = reader.string();
                    break;
                case 3:
                    message.subBiz = reader.string();
                    break;
                case 4:
                    message.uid = reader.int64();
                    break;
                case 5:
                    message.did = reader.string();
                    break;
                case 6:
                    message.clientIp = reader.int64();
                    break;
                case 7:
                    message.appVer = reader.string();
                    break;
                case 8:
                    message.ver = reader.string();
                    break;
                case 9:
                    message.lat = reader.string();
                    break;
                case 10:
                    message.lon = reader.string();
                    break;
                case 11:
                    message.mond = reader.string();
                    break;
                case 12:
                    message.net = reader.string();
                    break;
                case 13:
                    message.sys = reader.string();
                    break;
                case 14:
                    message.c = reader.string();
                    break;
                case 15:
                    message.language = reader.string();
                    break;
                case 16:
                    message.countryCode = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ZtCommonInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.ZtCommonInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.ZtCommonInfo} ZtCommonInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ZtCommonInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ZtCommonInfo message.
         * @function verify
         * @memberof AcFunDanmu.ZtCommonInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ZtCommonInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.kpn != null && message.hasOwnProperty("kpn"))
                if (!$util.isString(message.kpn))
                    return "kpn: string expected";
            if (message.kpf != null && message.hasOwnProperty("kpf"))
                if (!$util.isString(message.kpf))
                    return "kpf: string expected";
            if (message.subBiz != null && message.hasOwnProperty("subBiz"))
                if (!$util.isString(message.subBiz))
                    return "subBiz: string expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            if (message.did != null && message.hasOwnProperty("did"))
                if (!$util.isString(message.did))
                    return "did: string expected";
            if (message.clientIp != null && message.hasOwnProperty("clientIp"))
                if (!$util.isInteger(message.clientIp) && !(message.clientIp && $util.isInteger(message.clientIp.low) && $util.isInteger(message.clientIp.high)))
                    return "clientIp: integer|Long expected";
            if (message.appVer != null && message.hasOwnProperty("appVer"))
                if (!$util.isString(message.appVer))
                    return "appVer: string expected";
            if (message.ver != null && message.hasOwnProperty("ver"))
                if (!$util.isString(message.ver))
                    return "ver: string expected";
            if (message.lat != null && message.hasOwnProperty("lat"))
                if (!$util.isString(message.lat))
                    return "lat: string expected";
            if (message.lon != null && message.hasOwnProperty("lon"))
                if (!$util.isString(message.lon))
                    return "lon: string expected";
            if (message.mond != null && message.hasOwnProperty("mond"))
                if (!$util.isString(message.mond))
                    return "mond: string expected";
            if (message.net != null && message.hasOwnProperty("net"))
                if (!$util.isString(message.net))
                    return "net: string expected";
            if (message.sys != null && message.hasOwnProperty("sys"))
                if (!$util.isString(message.sys))
                    return "sys: string expected";
            if (message.c != null && message.hasOwnProperty("c"))
                if (!$util.isString(message.c))
                    return "c: string expected";
            if (message.language != null && message.hasOwnProperty("language"))
                if (!$util.isString(message.language))
                    return "language: string expected";
            if (message.countryCode != null && message.hasOwnProperty("countryCode"))
                if (!$util.isString(message.countryCode))
                    return "countryCode: string expected";
            return null;
        };

        /**
         * Creates a ZtCommonInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.ZtCommonInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.ZtCommonInfo} ZtCommonInfo
         */
        ZtCommonInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.ZtCommonInfo)
                return object;
            let message = new $root.AcFunDanmu.ZtCommonInfo();
            if (object.kpn != null)
                message.kpn = String(object.kpn);
            if (object.kpf != null)
                message.kpf = String(object.kpf);
            if (object.subBiz != null)
                message.subBiz = String(object.subBiz);
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            if (object.did != null)
                message.did = String(object.did);
            if (object.clientIp != null)
                if ($util.Long)
                    (message.clientIp = $util.Long.fromValue(object.clientIp)).unsigned = false;
                else if (typeof object.clientIp === "string")
                    message.clientIp = parseInt(object.clientIp, 10);
                else if (typeof object.clientIp === "number")
                    message.clientIp = object.clientIp;
                else if (typeof object.clientIp === "object")
                    message.clientIp = new $util.LongBits(object.clientIp.low >>> 0, object.clientIp.high >>> 0).toNumber();
            if (object.appVer != null)
                message.appVer = String(object.appVer);
            if (object.ver != null)
                message.ver = String(object.ver);
            if (object.lat != null)
                message.lat = String(object.lat);
            if (object.lon != null)
                message.lon = String(object.lon);
            if (object.mond != null)
                message.mond = String(object.mond);
            if (object.net != null)
                message.net = String(object.net);
            if (object.sys != null)
                message.sys = String(object.sys);
            if (object.c != null)
                message.c = String(object.c);
            if (object.language != null)
                message.language = String(object.language);
            if (object.countryCode != null)
                message.countryCode = String(object.countryCode);
            return message;
        };

        /**
         * Creates a plain object from a ZtCommonInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.ZtCommonInfo
         * @static
         * @param {AcFunDanmu.ZtCommonInfo} message ZtCommonInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ZtCommonInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.kpn = "";
                object.kpf = "";
                object.subBiz = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
                object.did = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.clientIp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.clientIp = options.longs === String ? "0" : 0;
                object.appVer = "";
                object.ver = "";
                object.lat = "";
                object.lon = "";
                object.mond = "";
                object.net = "";
                object.sys = "";
                object.c = "";
                object.language = "";
                object.countryCode = "";
            }
            if (message.kpn != null && message.hasOwnProperty("kpn"))
                object.kpn = message.kpn;
            if (message.kpf != null && message.hasOwnProperty("kpf"))
                object.kpf = message.kpf;
            if (message.subBiz != null && message.hasOwnProperty("subBiz"))
                object.subBiz = message.subBiz;
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            if (message.did != null && message.hasOwnProperty("did"))
                object.did = message.did;
            if (message.clientIp != null && message.hasOwnProperty("clientIp"))
                if (typeof message.clientIp === "number")
                    object.clientIp = options.longs === String ? String(message.clientIp) : message.clientIp;
                else
                    object.clientIp = options.longs === String ? $util.Long.prototype.toString.call(message.clientIp) : options.longs === Number ? new $util.LongBits(message.clientIp.low >>> 0, message.clientIp.high >>> 0).toNumber() : message.clientIp;
            if (message.appVer != null && message.hasOwnProperty("appVer"))
                object.appVer = message.appVer;
            if (message.ver != null && message.hasOwnProperty("ver"))
                object.ver = message.ver;
            if (message.lat != null && message.hasOwnProperty("lat"))
                object.lat = message.lat;
            if (message.lon != null && message.hasOwnProperty("lon"))
                object.lon = message.lon;
            if (message.mond != null && message.hasOwnProperty("mond"))
                object.mond = message.mond;
            if (message.net != null && message.hasOwnProperty("net"))
                object.net = message.net;
            if (message.sys != null && message.hasOwnProperty("sys"))
                object.sys = message.sys;
            if (message.c != null && message.hasOwnProperty("c"))
                object.c = message.c;
            if (message.language != null && message.hasOwnProperty("language"))
                object.language = message.language;
            if (message.countryCode != null && message.hasOwnProperty("countryCode"))
                object.countryCode = message.countryCode;
            return object;
        };

        /**
         * Converts this ZtCommonInfo to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.ZtCommonInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ZtCommonInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ZtCommonInfo;
    })();

    AcFunDanmu.PushServiceToken = (function() {

        /**
         * Properties of a PushServiceToken.
         * @memberof AcFunDanmu
         * @interface IPushServiceToken
         * @property {AcFunDanmu.PushServiceToken.PushType|null} [pushType] PushServiceToken pushType
         * @property {Uint8Array|null} [token] PushServiceToken token
         * @property {boolean|null} [isPassThrough] PushServiceToken isPassThrough
         */

        /**
         * Constructs a new PushServiceToken.
         * @memberof AcFunDanmu
         * @classdesc Represents a PushServiceToken.
         * @implements IPushServiceToken
         * @constructor
         * @param {AcFunDanmu.IPushServiceToken=} [properties] Properties to set
         */
        function PushServiceToken(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PushServiceToken pushType.
         * @member {AcFunDanmu.PushServiceToken.PushType} pushType
         * @memberof AcFunDanmu.PushServiceToken
         * @instance
         */
        PushServiceToken.prototype.pushType = 0;

        /**
         * PushServiceToken token.
         * @member {Uint8Array} token
         * @memberof AcFunDanmu.PushServiceToken
         * @instance
         */
        PushServiceToken.prototype.token = $util.newBuffer([]);

        /**
         * PushServiceToken isPassThrough.
         * @member {boolean} isPassThrough
         * @memberof AcFunDanmu.PushServiceToken
         * @instance
         */
        PushServiceToken.prototype.isPassThrough = false;

        /**
         * Creates a new PushServiceToken instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.PushServiceToken
         * @static
         * @param {AcFunDanmu.IPushServiceToken=} [properties] Properties to set
         * @returns {AcFunDanmu.PushServiceToken} PushServiceToken instance
         */
        PushServiceToken.create = function create(properties) {
            return new PushServiceToken(properties);
        };

        /**
         * Encodes the specified PushServiceToken message. Does not implicitly {@link AcFunDanmu.PushServiceToken.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.PushServiceToken
         * @static
         * @param {AcFunDanmu.IPushServiceToken} message PushServiceToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PushServiceToken.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pushType != null && Object.hasOwnProperty.call(message, "pushType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.pushType);
            if (message.token != null && Object.hasOwnProperty.call(message, "token"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.token);
            if (message.isPassThrough != null && Object.hasOwnProperty.call(message, "isPassThrough"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isPassThrough);
            return writer;
        };

        /**
         * Encodes the specified PushServiceToken message, length delimited. Does not implicitly {@link AcFunDanmu.PushServiceToken.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.PushServiceToken
         * @static
         * @param {AcFunDanmu.IPushServiceToken} message PushServiceToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PushServiceToken.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PushServiceToken message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.PushServiceToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.PushServiceToken} PushServiceToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PushServiceToken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.PushServiceToken();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.pushType = reader.int32();
                    break;
                case 2:
                    message.token = reader.bytes();
                    break;
                case 3:
                    message.isPassThrough = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PushServiceToken message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.PushServiceToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.PushServiceToken} PushServiceToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PushServiceToken.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PushServiceToken message.
         * @function verify
         * @memberof AcFunDanmu.PushServiceToken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PushServiceToken.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pushType != null && message.hasOwnProperty("pushType"))
                switch (message.pushType) {
                default:
                    return "pushType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                    break;
                }
            if (message.token != null && message.hasOwnProperty("token"))
                if (!(message.token && typeof message.token.length === "number" || $util.isString(message.token)))
                    return "token: buffer expected";
            if (message.isPassThrough != null && message.hasOwnProperty("isPassThrough"))
                if (typeof message.isPassThrough !== "boolean")
                    return "isPassThrough: boolean expected";
            return null;
        };

        /**
         * Creates a PushServiceToken message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.PushServiceToken
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.PushServiceToken} PushServiceToken
         */
        PushServiceToken.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.PushServiceToken)
                return object;
            let message = new $root.AcFunDanmu.PushServiceToken();
            switch (object.pushType) {
            case "kPushTypeInvalid":
            case 0:
                message.pushType = 0;
                break;
            case "kPushTypeAPNS":
            case 1:
                message.pushType = 1;
                break;
            case "kPushTypeXmPush":
            case 2:
                message.pushType = 2;
                break;
            case "kPushTypeJgPush":
            case 3:
                message.pushType = 3;
                break;
            case "kPushTypeGtPUsh":
            case 4:
                message.pushType = 4;
                break;
            case "kPushTypeOpPush":
            case 5:
                message.pushType = 5;
                break;
            case "kPushTYpeVvPush":
            case 6:
                message.pushType = 6;
                break;
            case "kPushTypeHwPush":
            case 7:
                message.pushType = 7;
                break;
            case "kPushTYpeFcm":
            case 8:
                message.pushType = 8;
                break;
            }
            if (object.token != null)
                if (typeof object.token === "string")
                    $util.base64.decode(object.token, message.token = $util.newBuffer($util.base64.length(object.token)), 0);
                else if (object.token.length)
                    message.token = object.token;
            if (object.isPassThrough != null)
                message.isPassThrough = Boolean(object.isPassThrough);
            return message;
        };

        /**
         * Creates a plain object from a PushServiceToken message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.PushServiceToken
         * @static
         * @param {AcFunDanmu.PushServiceToken} message PushServiceToken
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PushServiceToken.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.pushType = options.enums === String ? "kPushTypeInvalid" : 0;
                if (options.bytes === String)
                    object.token = "";
                else {
                    object.token = [];
                    if (options.bytes !== Array)
                        object.token = $util.newBuffer(object.token);
                }
                object.isPassThrough = false;
            }
            if (message.pushType != null && message.hasOwnProperty("pushType"))
                object.pushType = options.enums === String ? $root.AcFunDanmu.PushServiceToken.PushType[message.pushType] : message.pushType;
            if (message.token != null && message.hasOwnProperty("token"))
                object.token = options.bytes === String ? $util.base64.encode(message.token, 0, message.token.length) : options.bytes === Array ? Array.prototype.slice.call(message.token) : message.token;
            if (message.isPassThrough != null && message.hasOwnProperty("isPassThrough"))
                object.isPassThrough = message.isPassThrough;
            return object;
        };

        /**
         * Converts this PushServiceToken to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.PushServiceToken
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PushServiceToken.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * PushType enum.
         * @name AcFunDanmu.PushServiceToken.PushType
         * @enum {number}
         * @property {number} kPushTypeInvalid=0 kPushTypeInvalid value
         * @property {number} kPushTypeAPNS=1 kPushTypeAPNS value
         * @property {number} kPushTypeXmPush=2 kPushTypeXmPush value
         * @property {number} kPushTypeJgPush=3 kPushTypeJgPush value
         * @property {number} kPushTypeGtPUsh=4 kPushTypeGtPUsh value
         * @property {number} kPushTypeOpPush=5 kPushTypeOpPush value
         * @property {number} kPushTYpeVvPush=6 kPushTYpeVvPush value
         * @property {number} kPushTypeHwPush=7 kPushTypeHwPush value
         * @property {number} kPushTYpeFcm=8 kPushTYpeFcm value
         */
        PushServiceToken.PushType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "kPushTypeInvalid"] = 0;
            values[valuesById[1] = "kPushTypeAPNS"] = 1;
            values[valuesById[2] = "kPushTypeXmPush"] = 2;
            values[valuesById[3] = "kPushTypeJgPush"] = 3;
            values[valuesById[4] = "kPushTypeGtPUsh"] = 4;
            values[valuesById[5] = "kPushTypeOpPush"] = 5;
            values[valuesById[6] = "kPushTYpeVvPush"] = 6;
            values[valuesById[7] = "kPushTypeHwPush"] = 7;
            values[valuesById[8] = "kPushTYpeFcm"] = 8;
            return values;
        })();

        return PushServiceToken;
    })();

    AcFunDanmu.SdkOption = (function() {

        /**
         * Properties of a SdkOption.
         * @memberof AcFunDanmu
         * @interface ISdkOption
         * @property {number|null} [reportIntervalSeconds] SdkOption reportIntervalSeconds
         * @property {string|null} [reportSecurity] SdkOption reportSecurity
         * @property {number|null} [lz4CompressionThresholdBytes] SdkOption lz4CompressionThresholdBytes
         * @property {Array.<string>|null} [netCheckServers] SdkOption netCheckServers
         */

        /**
         * Constructs a new SdkOption.
         * @memberof AcFunDanmu
         * @classdesc Represents a SdkOption.
         * @implements ISdkOption
         * @constructor
         * @param {AcFunDanmu.ISdkOption=} [properties] Properties to set
         */
        function SdkOption(properties) {
            this.netCheckServers = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SdkOption reportIntervalSeconds.
         * @member {number} reportIntervalSeconds
         * @memberof AcFunDanmu.SdkOption
         * @instance
         */
        SdkOption.prototype.reportIntervalSeconds = 0;

        /**
         * SdkOption reportSecurity.
         * @member {string} reportSecurity
         * @memberof AcFunDanmu.SdkOption
         * @instance
         */
        SdkOption.prototype.reportSecurity = "";

        /**
         * SdkOption lz4CompressionThresholdBytes.
         * @member {number} lz4CompressionThresholdBytes
         * @memberof AcFunDanmu.SdkOption
         * @instance
         */
        SdkOption.prototype.lz4CompressionThresholdBytes = 0;

        /**
         * SdkOption netCheckServers.
         * @member {Array.<string>} netCheckServers
         * @memberof AcFunDanmu.SdkOption
         * @instance
         */
        SdkOption.prototype.netCheckServers = $util.emptyArray;

        /**
         * Creates a new SdkOption instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.SdkOption
         * @static
         * @param {AcFunDanmu.ISdkOption=} [properties] Properties to set
         * @returns {AcFunDanmu.SdkOption} SdkOption instance
         */
        SdkOption.create = function create(properties) {
            return new SdkOption(properties);
        };

        /**
         * Encodes the specified SdkOption message. Does not implicitly {@link AcFunDanmu.SdkOption.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.SdkOption
         * @static
         * @param {AcFunDanmu.ISdkOption} message SdkOption message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SdkOption.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reportIntervalSeconds != null && Object.hasOwnProperty.call(message, "reportIntervalSeconds"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.reportIntervalSeconds);
            if (message.reportSecurity != null && Object.hasOwnProperty.call(message, "reportSecurity"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.reportSecurity);
            if (message.lz4CompressionThresholdBytes != null && Object.hasOwnProperty.call(message, "lz4CompressionThresholdBytes"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.lz4CompressionThresholdBytes);
            if (message.netCheckServers != null && message.netCheckServers.length)
                for (let i = 0; i < message.netCheckServers.length; ++i)
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.netCheckServers[i]);
            return writer;
        };

        /**
         * Encodes the specified SdkOption message, length delimited. Does not implicitly {@link AcFunDanmu.SdkOption.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.SdkOption
         * @static
         * @param {AcFunDanmu.ISdkOption} message SdkOption message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SdkOption.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SdkOption message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.SdkOption
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.SdkOption} SdkOption
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SdkOption.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.SdkOption();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.reportIntervalSeconds = reader.int32();
                    break;
                case 2:
                    message.reportSecurity = reader.string();
                    break;
                case 3:
                    message.lz4CompressionThresholdBytes = reader.int32();
                    break;
                case 4:
                    if (!(message.netCheckServers && message.netCheckServers.length))
                        message.netCheckServers = [];
                    message.netCheckServers.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SdkOption message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.SdkOption
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.SdkOption} SdkOption
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SdkOption.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SdkOption message.
         * @function verify
         * @memberof AcFunDanmu.SdkOption
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SdkOption.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reportIntervalSeconds != null && message.hasOwnProperty("reportIntervalSeconds"))
                if (!$util.isInteger(message.reportIntervalSeconds))
                    return "reportIntervalSeconds: integer expected";
            if (message.reportSecurity != null && message.hasOwnProperty("reportSecurity"))
                if (!$util.isString(message.reportSecurity))
                    return "reportSecurity: string expected";
            if (message.lz4CompressionThresholdBytes != null && message.hasOwnProperty("lz4CompressionThresholdBytes"))
                if (!$util.isInteger(message.lz4CompressionThresholdBytes))
                    return "lz4CompressionThresholdBytes: integer expected";
            if (message.netCheckServers != null && message.hasOwnProperty("netCheckServers")) {
                if (!Array.isArray(message.netCheckServers))
                    return "netCheckServers: array expected";
                for (let i = 0; i < message.netCheckServers.length; ++i)
                    if (!$util.isString(message.netCheckServers[i]))
                        return "netCheckServers: string[] expected";
            }
            return null;
        };

        /**
         * Creates a SdkOption message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.SdkOption
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.SdkOption} SdkOption
         */
        SdkOption.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.SdkOption)
                return object;
            let message = new $root.AcFunDanmu.SdkOption();
            if (object.reportIntervalSeconds != null)
                message.reportIntervalSeconds = object.reportIntervalSeconds | 0;
            if (object.reportSecurity != null)
                message.reportSecurity = String(object.reportSecurity);
            if (object.lz4CompressionThresholdBytes != null)
                message.lz4CompressionThresholdBytes = object.lz4CompressionThresholdBytes | 0;
            if (object.netCheckServers) {
                if (!Array.isArray(object.netCheckServers))
                    throw TypeError(".AcFunDanmu.SdkOption.netCheckServers: array expected");
                message.netCheckServers = [];
                for (let i = 0; i < object.netCheckServers.length; ++i)
                    message.netCheckServers[i] = String(object.netCheckServers[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a SdkOption message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.SdkOption
         * @static
         * @param {AcFunDanmu.SdkOption} message SdkOption
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SdkOption.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.netCheckServers = [];
            if (options.defaults) {
                object.reportIntervalSeconds = 0;
                object.reportSecurity = "";
                object.lz4CompressionThresholdBytes = 0;
            }
            if (message.reportIntervalSeconds != null && message.hasOwnProperty("reportIntervalSeconds"))
                object.reportIntervalSeconds = message.reportIntervalSeconds;
            if (message.reportSecurity != null && message.hasOwnProperty("reportSecurity"))
                object.reportSecurity = message.reportSecurity;
            if (message.lz4CompressionThresholdBytes != null && message.hasOwnProperty("lz4CompressionThresholdBytes"))
                object.lz4CompressionThresholdBytes = message.lz4CompressionThresholdBytes;
            if (message.netCheckServers && message.netCheckServers.length) {
                object.netCheckServers = [];
                for (let j = 0; j < message.netCheckServers.length; ++j)
                    object.netCheckServers[j] = message.netCheckServers[j];
            }
            return object;
        };

        /**
         * Converts this SdkOption to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.SdkOption
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SdkOption.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SdkOption;
    })();

    /**
     * LinkErrorCode enum.
     * @name AcFunDanmu.LinkErrorCode
     * @enum {number}
     * @property {number} SUCC=0 SUCC value
     * @property {number} BASIC_MIN=10000 BASIC_MIN value
     * @property {number} INTERNEL_ERROR=10001 INTERNEL_ERROR value
     * @property {number} SERVICE_UNAVAILABLE=10002 SERVICE_UNAVAILABLE value
     * @property {number} SERVICE_TIMEOUT=10003 SERVICE_TIMEOUT value
     * @property {number} INVALID_TOKEN=10004 INVALID_TOKEN value
     * @property {number} REG_ENCYRPT_WITHOUT_TOKEN=10005 REG_ENCYRPT_WITHOUT_TOKEN value
     * @property {number} PARSE_PB_HDR_FAIL=10006 PARSE_PB_HDR_FAIL value
     * @property {number} PARSE_PB_PLD_FAIL=10007 PARSE_PB_PLD_FAIL value
     * @property {number} PARSE_PB_FAIL=10008 PARSE_PB_FAIL value
     * @property {number} DECODED_LEN_FAIL=10009 DECODED_LEN_FAIL value
     * @property {number} INVALID_KEY=10010 INVALID_KEY value
     * @property {number} ENCRYPT_FAIL=10011 ENCRYPT_FAIL value
     * @property {number} DECRYPT_FAIL=10012 DECRYPT_FAIL value
     * @property {number} INVALID_TAG=10013 INVALID_TAG value
     * @property {number} INVALID_VER=10014 INVALID_VER value
     * @property {number} INVALID_COMPRESS_TYPE=10016 INVALID_COMPRESS_TYPE value
     * @property {number} INVALID_ENCRYPT_TYPE=10017 INVALID_ENCRYPT_TYPE value
     * @property {number} NOT_REGISTER=10018 NOT_REGISTER value
     * @property {number} USER_NOT_ONLINE=10019 USER_NOT_ONLINE value
     * @property {number} INVALID_COMMAND=10020 INVALID_COMMAND value
     * @property {number} PUSH_UNREGISTER_ERROR=10021 PUSH_UNREGISTER_ERROR value
     * @property {number} INVALID_SID=10022 INVALID_SID value
     * @property {number} INVALID_INSTANCE_ID=10023 INVALID_INSTANCE_ID value
     * @property {number} CLIENT_LOCALE_NOT_MATCH=10024 CLIENT_LOCALE_NOT_MATCH value
     * @property {number} INVALID_TOKEN_PASSWORD_CHANGED=10025 INVALID_TOKEN_PASSWORD_CHANGED value
     * @property {number} INVALID_TOKEN_TOKEN_EXPIRED=10026 INVALID_TOKEN_TOKEN_EXPIRED value
     * @property {number} INVALID_TOKEN_TOKEN_VALUE_ERROR=10027 INVALID_TOKEN_TOKEN_VALUE_ERROR value
     * @property {number} INVALID_TOKEN_LOGIN_ON_OTHER_DEVICE=10028 INVALID_TOKEN_LOGIN_ON_OTHER_DEVICE value
     * @property {number} FORCE_RECONNECT=10029 FORCE_RECONNECT value
     * @property {number} CLIENT_TIMEOUT=10030 CLIENT_TIMEOUT value
     * @property {number} INVALID_ARGUMENT=10031 INVALID_ARGUMENT value
     * @property {number} INVALID_FORMAT_TOKEN=10032 INVALID_FORMAT_TOKEN value
     * @property {number} EMPTY_PAYLOAD=10033 EMPTY_PAYLOAD value
     * @property {number} COMPRESS_FAIL=10034 COMPRESS_FAIL value
     * @property {number} DECOMPRESS_FAIL=10035 DECOMPRESS_FAIL value
     * @property {number} OUT_OF_ORDER=10036 OUT_OF_ORDER value
     * @property {number} BASIC_MAX=19999 BASIC_MAX value
     */
    AcFunDanmu.LinkErrorCode = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "SUCC"] = 0;
        values[valuesById[10000] = "BASIC_MIN"] = 10000;
        values[valuesById[10001] = "INTERNEL_ERROR"] = 10001;
        values[valuesById[10002] = "SERVICE_UNAVAILABLE"] = 10002;
        values[valuesById[10003] = "SERVICE_TIMEOUT"] = 10003;
        values[valuesById[10004] = "INVALID_TOKEN"] = 10004;
        values[valuesById[10005] = "REG_ENCYRPT_WITHOUT_TOKEN"] = 10005;
        values[valuesById[10006] = "PARSE_PB_HDR_FAIL"] = 10006;
        values[valuesById[10007] = "PARSE_PB_PLD_FAIL"] = 10007;
        values[valuesById[10008] = "PARSE_PB_FAIL"] = 10008;
        values[valuesById[10009] = "DECODED_LEN_FAIL"] = 10009;
        values[valuesById[10010] = "INVALID_KEY"] = 10010;
        values[valuesById[10011] = "ENCRYPT_FAIL"] = 10011;
        values[valuesById[10012] = "DECRYPT_FAIL"] = 10012;
        values[valuesById[10013] = "INVALID_TAG"] = 10013;
        values[valuesById[10014] = "INVALID_VER"] = 10014;
        values[valuesById[10016] = "INVALID_COMPRESS_TYPE"] = 10016;
        values[valuesById[10017] = "INVALID_ENCRYPT_TYPE"] = 10017;
        values[valuesById[10018] = "NOT_REGISTER"] = 10018;
        values[valuesById[10019] = "USER_NOT_ONLINE"] = 10019;
        values[valuesById[10020] = "INVALID_COMMAND"] = 10020;
        values[valuesById[10021] = "PUSH_UNREGISTER_ERROR"] = 10021;
        values[valuesById[10022] = "INVALID_SID"] = 10022;
        values[valuesById[10023] = "INVALID_INSTANCE_ID"] = 10023;
        values[valuesById[10024] = "CLIENT_LOCALE_NOT_MATCH"] = 10024;
        values[valuesById[10025] = "INVALID_TOKEN_PASSWORD_CHANGED"] = 10025;
        values[valuesById[10026] = "INVALID_TOKEN_TOKEN_EXPIRED"] = 10026;
        values[valuesById[10027] = "INVALID_TOKEN_TOKEN_VALUE_ERROR"] = 10027;
        values[valuesById[10028] = "INVALID_TOKEN_LOGIN_ON_OTHER_DEVICE"] = 10028;
        values[valuesById[10029] = "FORCE_RECONNECT"] = 10029;
        values[valuesById[10030] = "CLIENT_TIMEOUT"] = 10030;
        values[valuesById[10031] = "INVALID_ARGUMENT"] = 10031;
        values[valuesById[10032] = "INVALID_FORMAT_TOKEN"] = 10032;
        values[valuesById[10033] = "EMPTY_PAYLOAD"] = 10033;
        values[valuesById[10034] = "COMPRESS_FAIL"] = 10034;
        values[valuesById[10035] = "DECOMPRESS_FAIL"] = 10035;
        values[valuesById[10036] = "OUT_OF_ORDER"] = 10036;
        values[valuesById[19999] = "BASIC_MAX"] = 19999;
        return values;
    })();

    AcFunDanmu.PacketHeader = (function() {

        /**
         * Properties of a PacketHeader.
         * @memberof AcFunDanmu
         * @interface IPacketHeader
         * @property {number|null} [appId] PacketHeader appId
         * @property {number|Long|null} [uid] PacketHeader uid
         * @property {number|Long|null} [instanceId] PacketHeader instanceId
         * @property {number|null} [flags] PacketHeader flags
         * @property {AcFunDanmu.PacketHeader.EncodingType|null} [encodingType] PacketHeader encodingType
         * @property {number|null} [decodedPayloadLen] PacketHeader decodedPayloadLen
         * @property {AcFunDanmu.PacketHeader.EncryptionMode|null} [encryptionMode] PacketHeader encryptionMode
         * @property {AcFunDanmu.ITokenInfo|null} [tokenInfo] PacketHeader tokenInfo
         * @property {number|Long|null} [seqId] PacketHeader seqId
         * @property {Array.<AcFunDanmu.PacketHeader.Feature>|null} [features] PacketHeader features
         * @property {string|null} [kpn] PacketHeader kpn
         */

        /**
         * Constructs a new PacketHeader.
         * @memberof AcFunDanmu
         * @classdesc Represents a PacketHeader.
         * @implements IPacketHeader
         * @constructor
         * @param {AcFunDanmu.IPacketHeader=} [properties] Properties to set
         */
        function PacketHeader(properties) {
            this.features = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PacketHeader appId.
         * @member {number} appId
         * @memberof AcFunDanmu.PacketHeader
         * @instance
         */
        PacketHeader.prototype.appId = 0;

        /**
         * PacketHeader uid.
         * @member {number|Long} uid
         * @memberof AcFunDanmu.PacketHeader
         * @instance
         */
        PacketHeader.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PacketHeader instanceId.
         * @member {number|Long} instanceId
         * @memberof AcFunDanmu.PacketHeader
         * @instance
         */
        PacketHeader.prototype.instanceId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PacketHeader flags.
         * @member {number} flags
         * @memberof AcFunDanmu.PacketHeader
         * @instance
         */
        PacketHeader.prototype.flags = 0;

        /**
         * PacketHeader encodingType.
         * @member {AcFunDanmu.PacketHeader.EncodingType} encodingType
         * @memberof AcFunDanmu.PacketHeader
         * @instance
         */
        PacketHeader.prototype.encodingType = 0;

        /**
         * PacketHeader decodedPayloadLen.
         * @member {number} decodedPayloadLen
         * @memberof AcFunDanmu.PacketHeader
         * @instance
         */
        PacketHeader.prototype.decodedPayloadLen = 0;

        /**
         * PacketHeader encryptionMode.
         * @member {AcFunDanmu.PacketHeader.EncryptionMode} encryptionMode
         * @memberof AcFunDanmu.PacketHeader
         * @instance
         */
        PacketHeader.prototype.encryptionMode = 0;

        /**
         * PacketHeader tokenInfo.
         * @member {AcFunDanmu.ITokenInfo|null|undefined} tokenInfo
         * @memberof AcFunDanmu.PacketHeader
         * @instance
         */
        PacketHeader.prototype.tokenInfo = null;

        /**
         * PacketHeader seqId.
         * @member {number|Long} seqId
         * @memberof AcFunDanmu.PacketHeader
         * @instance
         */
        PacketHeader.prototype.seqId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PacketHeader features.
         * @member {Array.<AcFunDanmu.PacketHeader.Feature>} features
         * @memberof AcFunDanmu.PacketHeader
         * @instance
         */
        PacketHeader.prototype.features = $util.emptyArray;

        /**
         * PacketHeader kpn.
         * @member {string} kpn
         * @memberof AcFunDanmu.PacketHeader
         * @instance
         */
        PacketHeader.prototype.kpn = "";

        /**
         * Creates a new PacketHeader instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.PacketHeader
         * @static
         * @param {AcFunDanmu.IPacketHeader=} [properties] Properties to set
         * @returns {AcFunDanmu.PacketHeader} PacketHeader instance
         */
        PacketHeader.create = function create(properties) {
            return new PacketHeader(properties);
        };

        /**
         * Encodes the specified PacketHeader message. Does not implicitly {@link AcFunDanmu.PacketHeader.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.PacketHeader
         * @static
         * @param {AcFunDanmu.IPacketHeader} message PacketHeader message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PacketHeader.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.appId != null && Object.hasOwnProperty.call(message, "appId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.appId);
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.uid);
            if (message.instanceId != null && Object.hasOwnProperty.call(message, "instanceId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.instanceId);
            if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.flags);
            if (message.encodingType != null && Object.hasOwnProperty.call(message, "encodingType"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.encodingType);
            if (message.decodedPayloadLen != null && Object.hasOwnProperty.call(message, "decodedPayloadLen"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.decodedPayloadLen);
            if (message.encryptionMode != null && Object.hasOwnProperty.call(message, "encryptionMode"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.encryptionMode);
            if (message.tokenInfo != null && Object.hasOwnProperty.call(message, "tokenInfo"))
                $root.AcFunDanmu.TokenInfo.encode(message.tokenInfo, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.seqId != null && Object.hasOwnProperty.call(message, "seqId"))
                writer.uint32(/* id 10, wireType 0 =*/80).int64(message.seqId);
            if (message.features != null && message.features.length) {
                writer.uint32(/* id 11, wireType 2 =*/90).fork();
                for (let i = 0; i < message.features.length; ++i)
                    writer.int32(message.features[i]);
                writer.ldelim();
            }
            if (message.kpn != null && Object.hasOwnProperty.call(message, "kpn"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.kpn);
            return writer;
        };

        /**
         * Encodes the specified PacketHeader message, length delimited. Does not implicitly {@link AcFunDanmu.PacketHeader.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.PacketHeader
         * @static
         * @param {AcFunDanmu.IPacketHeader} message PacketHeader message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PacketHeader.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PacketHeader message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.PacketHeader
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.PacketHeader} PacketHeader
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PacketHeader.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.PacketHeader();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.appId = reader.int32();
                    break;
                case 2:
                    message.uid = reader.int64();
                    break;
                case 3:
                    message.instanceId = reader.int64();
                    break;
                case 5:
                    message.flags = reader.uint32();
                    break;
                case 6:
                    message.encodingType = reader.int32();
                    break;
                case 7:
                    message.decodedPayloadLen = reader.int32();
                    break;
                case 8:
                    message.encryptionMode = reader.int32();
                    break;
                case 9:
                    message.tokenInfo = $root.AcFunDanmu.TokenInfo.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.seqId = reader.int64();
                    break;
                case 11:
                    if (!(message.features && message.features.length))
                        message.features = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.features.push(reader.int32());
                    } else
                        message.features.push(reader.int32());
                    break;
                case 12:
                    message.kpn = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PacketHeader message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.PacketHeader
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.PacketHeader} PacketHeader
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PacketHeader.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PacketHeader message.
         * @function verify
         * @memberof AcFunDanmu.PacketHeader
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PacketHeader.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.appId != null && message.hasOwnProperty("appId"))
                if (!$util.isInteger(message.appId))
                    return "appId: integer expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            if (message.instanceId != null && message.hasOwnProperty("instanceId"))
                if (!$util.isInteger(message.instanceId) && !(message.instanceId && $util.isInteger(message.instanceId.low) && $util.isInteger(message.instanceId.high)))
                    return "instanceId: integer|Long expected";
            if (message.flags != null && message.hasOwnProperty("flags"))
                if (!$util.isInteger(message.flags))
                    return "flags: integer expected";
            if (message.encodingType != null && message.hasOwnProperty("encodingType"))
                switch (message.encodingType) {
                default:
                    return "encodingType: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.decodedPayloadLen != null && message.hasOwnProperty("decodedPayloadLen"))
                if (!$util.isInteger(message.decodedPayloadLen))
                    return "decodedPayloadLen: integer expected";
            if (message.encryptionMode != null && message.hasOwnProperty("encryptionMode"))
                switch (message.encryptionMode) {
                default:
                    return "encryptionMode: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.tokenInfo != null && message.hasOwnProperty("tokenInfo")) {
                let error = $root.AcFunDanmu.TokenInfo.verify(message.tokenInfo);
                if (error)
                    return "tokenInfo." + error;
            }
            if (message.seqId != null && message.hasOwnProperty("seqId"))
                if (!$util.isInteger(message.seqId) && !(message.seqId && $util.isInteger(message.seqId.low) && $util.isInteger(message.seqId.high)))
                    return "seqId: integer|Long expected";
            if (message.features != null && message.hasOwnProperty("features")) {
                if (!Array.isArray(message.features))
                    return "features: array expected";
                for (let i = 0; i < message.features.length; ++i)
                    switch (message.features[i]) {
                    default:
                        return "features: enum value[] expected";
                    case 0:
                    case 1:
                        break;
                    }
            }
            if (message.kpn != null && message.hasOwnProperty("kpn"))
                if (!$util.isString(message.kpn))
                    return "kpn: string expected";
            return null;
        };

        /**
         * Creates a PacketHeader message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.PacketHeader
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.PacketHeader} PacketHeader
         */
        PacketHeader.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.PacketHeader)
                return object;
            let message = new $root.AcFunDanmu.PacketHeader();
            if (object.appId != null)
                message.appId = object.appId | 0;
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            if (object.instanceId != null)
                if ($util.Long)
                    (message.instanceId = $util.Long.fromValue(object.instanceId)).unsigned = false;
                else if (typeof object.instanceId === "string")
                    message.instanceId = parseInt(object.instanceId, 10);
                else if (typeof object.instanceId === "number")
                    message.instanceId = object.instanceId;
                else if (typeof object.instanceId === "object")
                    message.instanceId = new $util.LongBits(object.instanceId.low >>> 0, object.instanceId.high >>> 0).toNumber();
            if (object.flags != null)
                message.flags = object.flags >>> 0;
            switch (object.encodingType) {
            case "kEncodingNone":
            case 0:
                message.encodingType = 0;
                break;
            case "kEncodingLz4":
            case 1:
                message.encodingType = 1;
                break;
            }
            if (object.decodedPayloadLen != null)
                message.decodedPayloadLen = object.decodedPayloadLen | 0;
            switch (object.encryptionMode) {
            case "kEncryptionNone":
            case 0:
                message.encryptionMode = 0;
                break;
            case "kEncryptionServiceToken":
            case 1:
                message.encryptionMode = 1;
                break;
            case "kEncryptionSessionKey":
            case 2:
                message.encryptionMode = 2;
                break;
            }
            if (object.tokenInfo != null) {
                if (typeof object.tokenInfo !== "object")
                    throw TypeError(".AcFunDanmu.PacketHeader.tokenInfo: object expected");
                message.tokenInfo = $root.AcFunDanmu.TokenInfo.fromObject(object.tokenInfo);
            }
            if (object.seqId != null)
                if ($util.Long)
                    (message.seqId = $util.Long.fromValue(object.seqId)).unsigned = false;
                else if (typeof object.seqId === "string")
                    message.seqId = parseInt(object.seqId, 10);
                else if (typeof object.seqId === "number")
                    message.seqId = object.seqId;
                else if (typeof object.seqId === "object")
                    message.seqId = new $util.LongBits(object.seqId.low >>> 0, object.seqId.high >>> 0).toNumber();
            if (object.features) {
                if (!Array.isArray(object.features))
                    throw TypeError(".AcFunDanmu.PacketHeader.features: array expected");
                message.features = [];
                for (let i = 0; i < object.features.length; ++i)
                    switch (object.features[i]) {
                    default:
                    case "kReserve":
                    case 0:
                        message.features[i] = 0;
                        break;
                    case "kCompressLz4":
                    case 1:
                        message.features[i] = 1;
                        break;
                    }
            }
            if (object.kpn != null)
                message.kpn = String(object.kpn);
            return message;
        };

        /**
         * Creates a plain object from a PacketHeader message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.PacketHeader
         * @static
         * @param {AcFunDanmu.PacketHeader} message PacketHeader
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PacketHeader.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.features = [];
            if (options.defaults) {
                object.appId = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.instanceId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.instanceId = options.longs === String ? "0" : 0;
                object.flags = 0;
                object.encodingType = options.enums === String ? "kEncodingNone" : 0;
                object.decodedPayloadLen = 0;
                object.encryptionMode = options.enums === String ? "kEncryptionNone" : 0;
                object.tokenInfo = null;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.seqId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.seqId = options.longs === String ? "0" : 0;
                object.kpn = "";
            }
            if (message.appId != null && message.hasOwnProperty("appId"))
                object.appId = message.appId;
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            if (message.instanceId != null && message.hasOwnProperty("instanceId"))
                if (typeof message.instanceId === "number")
                    object.instanceId = options.longs === String ? String(message.instanceId) : message.instanceId;
                else
                    object.instanceId = options.longs === String ? $util.Long.prototype.toString.call(message.instanceId) : options.longs === Number ? new $util.LongBits(message.instanceId.low >>> 0, message.instanceId.high >>> 0).toNumber() : message.instanceId;
            if (message.flags != null && message.hasOwnProperty("flags"))
                object.flags = message.flags;
            if (message.encodingType != null && message.hasOwnProperty("encodingType"))
                object.encodingType = options.enums === String ? $root.AcFunDanmu.PacketHeader.EncodingType[message.encodingType] : message.encodingType;
            if (message.decodedPayloadLen != null && message.hasOwnProperty("decodedPayloadLen"))
                object.decodedPayloadLen = message.decodedPayloadLen;
            if (message.encryptionMode != null && message.hasOwnProperty("encryptionMode"))
                object.encryptionMode = options.enums === String ? $root.AcFunDanmu.PacketHeader.EncryptionMode[message.encryptionMode] : message.encryptionMode;
            if (message.tokenInfo != null && message.hasOwnProperty("tokenInfo"))
                object.tokenInfo = $root.AcFunDanmu.TokenInfo.toObject(message.tokenInfo, options);
            if (message.seqId != null && message.hasOwnProperty("seqId"))
                if (typeof message.seqId === "number")
                    object.seqId = options.longs === String ? String(message.seqId) : message.seqId;
                else
                    object.seqId = options.longs === String ? $util.Long.prototype.toString.call(message.seqId) : options.longs === Number ? new $util.LongBits(message.seqId.low >>> 0, message.seqId.high >>> 0).toNumber() : message.seqId;
            if (message.features && message.features.length) {
                object.features = [];
                for (let j = 0; j < message.features.length; ++j)
                    object.features[j] = options.enums === String ? $root.AcFunDanmu.PacketHeader.Feature[message.features[j]] : message.features[j];
            }
            if (message.kpn != null && message.hasOwnProperty("kpn"))
                object.kpn = message.kpn;
            return object;
        };

        /**
         * Converts this PacketHeader to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.PacketHeader
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PacketHeader.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Flags enum.
         * @name AcFunDanmu.PacketHeader.Flags
         * @enum {number}
         * @property {number} kDirUpstream=0 kDirUpstream value
         * @property {number} kDirDownstream=1 kDirDownstream value
         * @property {number} kDirMask=1 kDirMask value
         */
        PacketHeader.Flags = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "kDirUpstream"] = 0;
            values[valuesById[1] = "kDirDownstream"] = 1;
            values["kDirMask"] = 1;
            return values;
        })();

        /**
         * EncodingType enum.
         * @name AcFunDanmu.PacketHeader.EncodingType
         * @enum {number}
         * @property {number} kEncodingNone=0 kEncodingNone value
         * @property {number} kEncodingLz4=1 kEncodingLz4 value
         */
        PacketHeader.EncodingType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "kEncodingNone"] = 0;
            values[valuesById[1] = "kEncodingLz4"] = 1;
            return values;
        })();

        /**
         * EncryptionMode enum.
         * @name AcFunDanmu.PacketHeader.EncryptionMode
         * @enum {number}
         * @property {number} kEncryptionNone=0 kEncryptionNone value
         * @property {number} kEncryptionServiceToken=1 kEncryptionServiceToken value
         * @property {number} kEncryptionSessionKey=2 kEncryptionSessionKey value
         */
        PacketHeader.EncryptionMode = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "kEncryptionNone"] = 0;
            values[valuesById[1] = "kEncryptionServiceToken"] = 1;
            values[valuesById[2] = "kEncryptionSessionKey"] = 2;
            return values;
        })();

        /**
         * Feature enum.
         * @name AcFunDanmu.PacketHeader.Feature
         * @enum {number}
         * @property {number} kReserve=0 kReserve value
         * @property {number} kCompressLz4=1 kCompressLz4 value
         */
        PacketHeader.Feature = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "kReserve"] = 0;
            values[valuesById[1] = "kCompressLz4"] = 1;
            return values;
        })();

        return PacketHeader;
    })();

    AcFunDanmu.TokenInfo = (function() {

        /**
         * Properties of a TokenInfo.
         * @memberof AcFunDanmu
         * @interface ITokenInfo
         * @property {AcFunDanmu.TokenInfo.TokenType|null} [tokenType] TokenInfo tokenType
         * @property {Uint8Array|null} [token] TokenInfo token
         */

        /**
         * Constructs a new TokenInfo.
         * @memberof AcFunDanmu
         * @classdesc Represents a TokenInfo.
         * @implements ITokenInfo
         * @constructor
         * @param {AcFunDanmu.ITokenInfo=} [properties] Properties to set
         */
        function TokenInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TokenInfo tokenType.
         * @member {AcFunDanmu.TokenInfo.TokenType} tokenType
         * @memberof AcFunDanmu.TokenInfo
         * @instance
         */
        TokenInfo.prototype.tokenType = 0;

        /**
         * TokenInfo token.
         * @member {Uint8Array} token
         * @memberof AcFunDanmu.TokenInfo
         * @instance
         */
        TokenInfo.prototype.token = $util.newBuffer([]);

        /**
         * Creates a new TokenInfo instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.TokenInfo
         * @static
         * @param {AcFunDanmu.ITokenInfo=} [properties] Properties to set
         * @returns {AcFunDanmu.TokenInfo} TokenInfo instance
         */
        TokenInfo.create = function create(properties) {
            return new TokenInfo(properties);
        };

        /**
         * Encodes the specified TokenInfo message. Does not implicitly {@link AcFunDanmu.TokenInfo.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.TokenInfo
         * @static
         * @param {AcFunDanmu.ITokenInfo} message TokenInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tokenType != null && Object.hasOwnProperty.call(message, "tokenType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tokenType);
            if (message.token != null && Object.hasOwnProperty.call(message, "token"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.token);
            return writer;
        };

        /**
         * Encodes the specified TokenInfo message, length delimited. Does not implicitly {@link AcFunDanmu.TokenInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.TokenInfo
         * @static
         * @param {AcFunDanmu.ITokenInfo} message TokenInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TokenInfo message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.TokenInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.TokenInfo} TokenInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.TokenInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tokenType = reader.int32();
                    break;
                case 2:
                    message.token = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TokenInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.TokenInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.TokenInfo} TokenInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TokenInfo message.
         * @function verify
         * @memberof AcFunDanmu.TokenInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TokenInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tokenType != null && message.hasOwnProperty("tokenType"))
                switch (message.tokenType) {
                default:
                    return "tokenType: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.token != null && message.hasOwnProperty("token"))
                if (!(message.token && typeof message.token.length === "number" || $util.isString(message.token)))
                    return "token: buffer expected";
            return null;
        };

        /**
         * Creates a TokenInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.TokenInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.TokenInfo} TokenInfo
         */
        TokenInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.TokenInfo)
                return object;
            let message = new $root.AcFunDanmu.TokenInfo();
            switch (object.tokenType) {
            case "kInvalid":
            case 0:
                message.tokenType = 0;
                break;
            case "kServiceToken":
            case 1:
                message.tokenType = 1;
                break;
            }
            if (object.token != null)
                if (typeof object.token === "string")
                    $util.base64.decode(object.token, message.token = $util.newBuffer($util.base64.length(object.token)), 0);
                else if (object.token.length)
                    message.token = object.token;
            return message;
        };

        /**
         * Creates a plain object from a TokenInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.TokenInfo
         * @static
         * @param {AcFunDanmu.TokenInfo} message TokenInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TokenInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.tokenType = options.enums === String ? "kInvalid" : 0;
                if (options.bytes === String)
                    object.token = "";
                else {
                    object.token = [];
                    if (options.bytes !== Array)
                        object.token = $util.newBuffer(object.token);
                }
            }
            if (message.tokenType != null && message.hasOwnProperty("tokenType"))
                object.tokenType = options.enums === String ? $root.AcFunDanmu.TokenInfo.TokenType[message.tokenType] : message.tokenType;
            if (message.token != null && message.hasOwnProperty("token"))
                object.token = options.bytes === String ? $util.base64.encode(message.token, 0, message.token.length) : options.bytes === Array ? Array.prototype.slice.call(message.token) : message.token;
            return object;
        };

        /**
         * Converts this TokenInfo to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.TokenInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TokenInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * TokenType enum.
         * @name AcFunDanmu.TokenInfo.TokenType
         * @enum {number}
         * @property {number} kInvalid=0 kInvalid value
         * @property {number} kServiceToken=1 kServiceToken value
         */
        TokenInfo.TokenType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "kInvalid"] = 0;
            values[valuesById[1] = "kServiceToken"] = 1;
            return values;
        })();

        return TokenInfo;
    })();

    AcFunDanmu.PingRequest = (function() {

        /**
         * Properties of a PingRequest.
         * @memberof AcFunDanmu
         * @interface IPingRequest
         * @property {AcFunDanmu.PingRequest.PingType|null} [pingType] PingRequest pingType
         * @property {number|null} [pingRound] PingRequest pingRound
         */

        /**
         * Constructs a new PingRequest.
         * @memberof AcFunDanmu
         * @classdesc Represents a PingRequest.
         * @implements IPingRequest
         * @constructor
         * @param {AcFunDanmu.IPingRequest=} [properties] Properties to set
         */
        function PingRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PingRequest pingType.
         * @member {AcFunDanmu.PingRequest.PingType} pingType
         * @memberof AcFunDanmu.PingRequest
         * @instance
         */
        PingRequest.prototype.pingType = 0;

        /**
         * PingRequest pingRound.
         * @member {number} pingRound
         * @memberof AcFunDanmu.PingRequest
         * @instance
         */
        PingRequest.prototype.pingRound = 0;

        /**
         * Creates a new PingRequest instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.PingRequest
         * @static
         * @param {AcFunDanmu.IPingRequest=} [properties] Properties to set
         * @returns {AcFunDanmu.PingRequest} PingRequest instance
         */
        PingRequest.create = function create(properties) {
            return new PingRequest(properties);
        };

        /**
         * Encodes the specified PingRequest message. Does not implicitly {@link AcFunDanmu.PingRequest.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.PingRequest
         * @static
         * @param {AcFunDanmu.IPingRequest} message PingRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PingRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pingType != null && Object.hasOwnProperty.call(message, "pingType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.pingType);
            if (message.pingRound != null && Object.hasOwnProperty.call(message, "pingRound"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.pingRound);
            return writer;
        };

        /**
         * Encodes the specified PingRequest message, length delimited. Does not implicitly {@link AcFunDanmu.PingRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.PingRequest
         * @static
         * @param {AcFunDanmu.IPingRequest} message PingRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PingRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PingRequest message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.PingRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.PingRequest} PingRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PingRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.PingRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.pingType = reader.int32();
                    break;
                case 2:
                    message.pingRound = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PingRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.PingRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.PingRequest} PingRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PingRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PingRequest message.
         * @function verify
         * @memberof AcFunDanmu.PingRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PingRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pingType != null && message.hasOwnProperty("pingType"))
                switch (message.pingType) {
                default:
                    return "pingType: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.pingRound != null && message.hasOwnProperty("pingRound"))
                if (!$util.isInteger(message.pingRound))
                    return "pingRound: integer expected";
            return null;
        };

        /**
         * Creates a PingRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.PingRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.PingRequest} PingRequest
         */
        PingRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.PingRequest)
                return object;
            let message = new $root.AcFunDanmu.PingRequest();
            switch (object.pingType) {
            case "kInvalid":
            case 0:
                message.pingType = 0;
                break;
            case "kPriorRegister":
            case 1:
                message.pingType = 1;
                break;
            case "kPostRegister":
            case 2:
                message.pingType = 2;
                break;
            }
            if (object.pingRound != null)
                message.pingRound = object.pingRound >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a PingRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.PingRequest
         * @static
         * @param {AcFunDanmu.PingRequest} message PingRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PingRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.pingType = options.enums === String ? "kInvalid" : 0;
                object.pingRound = 0;
            }
            if (message.pingType != null && message.hasOwnProperty("pingType"))
                object.pingType = options.enums === String ? $root.AcFunDanmu.PingRequest.PingType[message.pingType] : message.pingType;
            if (message.pingRound != null && message.hasOwnProperty("pingRound"))
                object.pingRound = message.pingRound;
            return object;
        };

        /**
         * Converts this PingRequest to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.PingRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PingRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * PingType enum.
         * @name AcFunDanmu.PingRequest.PingType
         * @enum {number}
         * @property {number} kInvalid=0 kInvalid value
         * @property {number} kPriorRegister=1 kPriorRegister value
         * @property {number} kPostRegister=2 kPostRegister value
         */
        PingRequest.PingType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "kInvalid"] = 0;
            values[valuesById[1] = "kPriorRegister"] = 1;
            values[valuesById[2] = "kPostRegister"] = 2;
            return values;
        })();

        return PingRequest;
    })();

    AcFunDanmu.PingResponse = (function() {

        /**
         * Properties of a PingResponse.
         * @memberof AcFunDanmu
         * @interface IPingResponse
         * @property {number|null} [serverTimestamp] PingResponse serverTimestamp
         * @property {number|null} [clientIp] PingResponse clientIp
         * @property {number|null} [redirectIp] PingResponse redirectIp
         * @property {number|null} [redirectPort] PingResponse redirectPort
         */

        /**
         * Constructs a new PingResponse.
         * @memberof AcFunDanmu
         * @classdesc Represents a PingResponse.
         * @implements IPingResponse
         * @constructor
         * @param {AcFunDanmu.IPingResponse=} [properties] Properties to set
         */
        function PingResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PingResponse serverTimestamp.
         * @member {number} serverTimestamp
         * @memberof AcFunDanmu.PingResponse
         * @instance
         */
        PingResponse.prototype.serverTimestamp = 0;

        /**
         * PingResponse clientIp.
         * @member {number} clientIp
         * @memberof AcFunDanmu.PingResponse
         * @instance
         */
        PingResponse.prototype.clientIp = 0;

        /**
         * PingResponse redirectIp.
         * @member {number} redirectIp
         * @memberof AcFunDanmu.PingResponse
         * @instance
         */
        PingResponse.prototype.redirectIp = 0;

        /**
         * PingResponse redirectPort.
         * @member {number} redirectPort
         * @memberof AcFunDanmu.PingResponse
         * @instance
         */
        PingResponse.prototype.redirectPort = 0;

        /**
         * Creates a new PingResponse instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.PingResponse
         * @static
         * @param {AcFunDanmu.IPingResponse=} [properties] Properties to set
         * @returns {AcFunDanmu.PingResponse} PingResponse instance
         */
        PingResponse.create = function create(properties) {
            return new PingResponse(properties);
        };

        /**
         * Encodes the specified PingResponse message. Does not implicitly {@link AcFunDanmu.PingResponse.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.PingResponse
         * @static
         * @param {AcFunDanmu.IPingResponse} message PingResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PingResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.serverTimestamp != null && Object.hasOwnProperty.call(message, "serverTimestamp"))
                writer.uint32(/* id 1, wireType 5 =*/13).sfixed32(message.serverTimestamp);
            if (message.clientIp != null && Object.hasOwnProperty.call(message, "clientIp"))
                writer.uint32(/* id 2, wireType 5 =*/21).fixed32(message.clientIp);
            if (message.redirectIp != null && Object.hasOwnProperty.call(message, "redirectIp"))
                writer.uint32(/* id 3, wireType 5 =*/29).fixed32(message.redirectIp);
            if (message.redirectPort != null && Object.hasOwnProperty.call(message, "redirectPort"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.redirectPort);
            return writer;
        };

        /**
         * Encodes the specified PingResponse message, length delimited. Does not implicitly {@link AcFunDanmu.PingResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.PingResponse
         * @static
         * @param {AcFunDanmu.IPingResponse} message PingResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PingResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PingResponse message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.PingResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.PingResponse} PingResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PingResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.PingResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.serverTimestamp = reader.sfixed32();
                    break;
                case 2:
                    message.clientIp = reader.fixed32();
                    break;
                case 3:
                    message.redirectIp = reader.fixed32();
                    break;
                case 4:
                    message.redirectPort = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PingResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.PingResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.PingResponse} PingResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PingResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PingResponse message.
         * @function verify
         * @memberof AcFunDanmu.PingResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PingResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.serverTimestamp != null && message.hasOwnProperty("serverTimestamp"))
                if (!$util.isInteger(message.serverTimestamp))
                    return "serverTimestamp: integer expected";
            if (message.clientIp != null && message.hasOwnProperty("clientIp"))
                if (!$util.isInteger(message.clientIp))
                    return "clientIp: integer expected";
            if (message.redirectIp != null && message.hasOwnProperty("redirectIp"))
                if (!$util.isInteger(message.redirectIp))
                    return "redirectIp: integer expected";
            if (message.redirectPort != null && message.hasOwnProperty("redirectPort"))
                if (!$util.isInteger(message.redirectPort))
                    return "redirectPort: integer expected";
            return null;
        };

        /**
         * Creates a PingResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.PingResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.PingResponse} PingResponse
         */
        PingResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.PingResponse)
                return object;
            let message = new $root.AcFunDanmu.PingResponse();
            if (object.serverTimestamp != null)
                message.serverTimestamp = object.serverTimestamp | 0;
            if (object.clientIp != null)
                message.clientIp = object.clientIp >>> 0;
            if (object.redirectIp != null)
                message.redirectIp = object.redirectIp >>> 0;
            if (object.redirectPort != null)
                message.redirectPort = object.redirectPort >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a PingResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.PingResponse
         * @static
         * @param {AcFunDanmu.PingResponse} message PingResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PingResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.serverTimestamp = 0;
                object.clientIp = 0;
                object.redirectIp = 0;
                object.redirectPort = 0;
            }
            if (message.serverTimestamp != null && message.hasOwnProperty("serverTimestamp"))
                object.serverTimestamp = message.serverTimestamp;
            if (message.clientIp != null && message.hasOwnProperty("clientIp"))
                object.clientIp = message.clientIp;
            if (message.redirectIp != null && message.hasOwnProperty("redirectIp"))
                object.redirectIp = message.redirectIp;
            if (message.redirectPort != null && message.hasOwnProperty("redirectPort"))
                object.redirectPort = message.redirectPort;
            return object;
        };

        /**
         * Converts this PingResponse to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.PingResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PingResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PingResponse;
    })();

    AcFunDanmu.RequestBasicInfo = (function() {

        /**
         * Properties of a RequestBasicInfo.
         * @memberof AcFunDanmu
         * @interface IRequestBasicInfo
         * @property {AcFunDanmu.DeviceInfo.PlatformType|null} [clientType] RequestBasicInfo clientType
         * @property {string|null} [deviceId] RequestBasicInfo deviceId
         * @property {string|null} [clientIp] RequestBasicInfo clientIp
         * @property {string|null} [appVersion] RequestBasicInfo appVersion
         * @property {string|null} [channel] RequestBasicInfo channel
         * @property {AcFunDanmu.IAppInfo|null} [appInfo] RequestBasicInfo appInfo
         * @property {AcFunDanmu.IDeviceInfo|null} [deviceInfo] RequestBasicInfo deviceInfo
         * @property {AcFunDanmu.IEnvInfo|null} [envInfo] RequestBasicInfo envInfo
         * @property {number|null} [clientPort] RequestBasicInfo clientPort
         * @property {string|null} [location] RequestBasicInfo location
         * @property {string|null} [kpf] RequestBasicInfo kpf
         */

        /**
         * Constructs a new RequestBasicInfo.
         * @memberof AcFunDanmu
         * @classdesc Represents a RequestBasicInfo.
         * @implements IRequestBasicInfo
         * @constructor
         * @param {AcFunDanmu.IRequestBasicInfo=} [properties] Properties to set
         */
        function RequestBasicInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RequestBasicInfo clientType.
         * @member {AcFunDanmu.DeviceInfo.PlatformType} clientType
         * @memberof AcFunDanmu.RequestBasicInfo
         * @instance
         */
        RequestBasicInfo.prototype.clientType = 0;

        /**
         * RequestBasicInfo deviceId.
         * @member {string} deviceId
         * @memberof AcFunDanmu.RequestBasicInfo
         * @instance
         */
        RequestBasicInfo.prototype.deviceId = "";

        /**
         * RequestBasicInfo clientIp.
         * @member {string} clientIp
         * @memberof AcFunDanmu.RequestBasicInfo
         * @instance
         */
        RequestBasicInfo.prototype.clientIp = "";

        /**
         * RequestBasicInfo appVersion.
         * @member {string} appVersion
         * @memberof AcFunDanmu.RequestBasicInfo
         * @instance
         */
        RequestBasicInfo.prototype.appVersion = "";

        /**
         * RequestBasicInfo channel.
         * @member {string} channel
         * @memberof AcFunDanmu.RequestBasicInfo
         * @instance
         */
        RequestBasicInfo.prototype.channel = "";

        /**
         * RequestBasicInfo appInfo.
         * @member {AcFunDanmu.IAppInfo|null|undefined} appInfo
         * @memberof AcFunDanmu.RequestBasicInfo
         * @instance
         */
        RequestBasicInfo.prototype.appInfo = null;

        /**
         * RequestBasicInfo deviceInfo.
         * @member {AcFunDanmu.IDeviceInfo|null|undefined} deviceInfo
         * @memberof AcFunDanmu.RequestBasicInfo
         * @instance
         */
        RequestBasicInfo.prototype.deviceInfo = null;

        /**
         * RequestBasicInfo envInfo.
         * @member {AcFunDanmu.IEnvInfo|null|undefined} envInfo
         * @memberof AcFunDanmu.RequestBasicInfo
         * @instance
         */
        RequestBasicInfo.prototype.envInfo = null;

        /**
         * RequestBasicInfo clientPort.
         * @member {number} clientPort
         * @memberof AcFunDanmu.RequestBasicInfo
         * @instance
         */
        RequestBasicInfo.prototype.clientPort = 0;

        /**
         * RequestBasicInfo location.
         * @member {string} location
         * @memberof AcFunDanmu.RequestBasicInfo
         * @instance
         */
        RequestBasicInfo.prototype.location = "";

        /**
         * RequestBasicInfo kpf.
         * @member {string} kpf
         * @memberof AcFunDanmu.RequestBasicInfo
         * @instance
         */
        RequestBasicInfo.prototype.kpf = "";

        /**
         * Creates a new RequestBasicInfo instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.RequestBasicInfo
         * @static
         * @param {AcFunDanmu.IRequestBasicInfo=} [properties] Properties to set
         * @returns {AcFunDanmu.RequestBasicInfo} RequestBasicInfo instance
         */
        RequestBasicInfo.create = function create(properties) {
            return new RequestBasicInfo(properties);
        };

        /**
         * Encodes the specified RequestBasicInfo message. Does not implicitly {@link AcFunDanmu.RequestBasicInfo.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.RequestBasicInfo
         * @static
         * @param {AcFunDanmu.IRequestBasicInfo} message RequestBasicInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestBasicInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.clientType != null && Object.hasOwnProperty.call(message, "clientType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.clientType);
            if (message.deviceId != null && Object.hasOwnProperty.call(message, "deviceId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.deviceId);
            if (message.clientIp != null && Object.hasOwnProperty.call(message, "clientIp"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.clientIp);
            if (message.appVersion != null && Object.hasOwnProperty.call(message, "appVersion"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.appVersion);
            if (message.channel != null && Object.hasOwnProperty.call(message, "channel"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.channel);
            if (message.appInfo != null && Object.hasOwnProperty.call(message, "appInfo"))
                $root.AcFunDanmu.AppInfo.encode(message.appInfo, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.deviceInfo != null && Object.hasOwnProperty.call(message, "deviceInfo"))
                $root.AcFunDanmu.DeviceInfo.encode(message.deviceInfo, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.envInfo != null && Object.hasOwnProperty.call(message, "envInfo"))
                $root.AcFunDanmu.EnvInfo.encode(message.envInfo, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.clientPort != null && Object.hasOwnProperty.call(message, "clientPort"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.clientPort);
            if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.location);
            if (message.kpf != null && Object.hasOwnProperty.call(message, "kpf"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.kpf);
            return writer;
        };

        /**
         * Encodes the specified RequestBasicInfo message, length delimited. Does not implicitly {@link AcFunDanmu.RequestBasicInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.RequestBasicInfo
         * @static
         * @param {AcFunDanmu.IRequestBasicInfo} message RequestBasicInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestBasicInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RequestBasicInfo message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.RequestBasicInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.RequestBasicInfo} RequestBasicInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestBasicInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.RequestBasicInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.clientType = reader.int32();
                    break;
                case 2:
                    message.deviceId = reader.string();
                    break;
                case 3:
                    message.clientIp = reader.string();
                    break;
                case 4:
                    message.appVersion = reader.string();
                    break;
                case 5:
                    message.channel = reader.string();
                    break;
                case 6:
                    message.appInfo = $root.AcFunDanmu.AppInfo.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.deviceInfo = $root.AcFunDanmu.DeviceInfo.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.envInfo = $root.AcFunDanmu.EnvInfo.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.clientPort = reader.int32();
                    break;
                case 10:
                    message.location = reader.string();
                    break;
                case 11:
                    message.kpf = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RequestBasicInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.RequestBasicInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.RequestBasicInfo} RequestBasicInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestBasicInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RequestBasicInfo message.
         * @function verify
         * @memberof AcFunDanmu.RequestBasicInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RequestBasicInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.clientType != null && message.hasOwnProperty("clientType"))
                switch (message.clientType) {
                default:
                    return "clientType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                    break;
                }
            if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                if (!$util.isString(message.deviceId))
                    return "deviceId: string expected";
            if (message.clientIp != null && message.hasOwnProperty("clientIp"))
                if (!$util.isString(message.clientIp))
                    return "clientIp: string expected";
            if (message.appVersion != null && message.hasOwnProperty("appVersion"))
                if (!$util.isString(message.appVersion))
                    return "appVersion: string expected";
            if (message.channel != null && message.hasOwnProperty("channel"))
                if (!$util.isString(message.channel))
                    return "channel: string expected";
            if (message.appInfo != null && message.hasOwnProperty("appInfo")) {
                let error = $root.AcFunDanmu.AppInfo.verify(message.appInfo);
                if (error)
                    return "appInfo." + error;
            }
            if (message.deviceInfo != null && message.hasOwnProperty("deviceInfo")) {
                let error = $root.AcFunDanmu.DeviceInfo.verify(message.deviceInfo);
                if (error)
                    return "deviceInfo." + error;
            }
            if (message.envInfo != null && message.hasOwnProperty("envInfo")) {
                let error = $root.AcFunDanmu.EnvInfo.verify(message.envInfo);
                if (error)
                    return "envInfo." + error;
            }
            if (message.clientPort != null && message.hasOwnProperty("clientPort"))
                if (!$util.isInteger(message.clientPort))
                    return "clientPort: integer expected";
            if (message.location != null && message.hasOwnProperty("location"))
                if (!$util.isString(message.location))
                    return "location: string expected";
            if (message.kpf != null && message.hasOwnProperty("kpf"))
                if (!$util.isString(message.kpf))
                    return "kpf: string expected";
            return null;
        };

        /**
         * Creates a RequestBasicInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.RequestBasicInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.RequestBasicInfo} RequestBasicInfo
         */
        RequestBasicInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.RequestBasicInfo)
                return object;
            let message = new $root.AcFunDanmu.RequestBasicInfo();
            switch (object.clientType) {
            case "kInvalid":
            case 0:
                message.clientType = 0;
                break;
            case "kAndroid":
            case 1:
                message.clientType = 1;
                break;
            case "kiOS":
            case 2:
                message.clientType = 2;
                break;
            case "kWindows":
            case 3:
                message.clientType = 3;
                break;
            case "WECHAT_ANDROID":
            case 4:
                message.clientType = 4;
                break;
            case "WECHAT_IOS":
            case 5:
                message.clientType = 5;
                break;
            case "H5":
            case 6:
                message.clientType = 6;
                break;
            case "H5_ANDROID":
            case 7:
                message.clientType = 7;
                break;
            case "H5_IOS":
            case 8:
                message.clientType = 8;
                break;
            case "H5_WINDOWS":
            case 9:
                message.clientType = 9;
                break;
            case "H5_MAC":
            case 10:
                message.clientType = 10;
                break;
            case "kPlatformNum":
            case 11:
                message.clientType = 11;
                break;
            }
            if (object.deviceId != null)
                message.deviceId = String(object.deviceId);
            if (object.clientIp != null)
                message.clientIp = String(object.clientIp);
            if (object.appVersion != null)
                message.appVersion = String(object.appVersion);
            if (object.channel != null)
                message.channel = String(object.channel);
            if (object.appInfo != null) {
                if (typeof object.appInfo !== "object")
                    throw TypeError(".AcFunDanmu.RequestBasicInfo.appInfo: object expected");
                message.appInfo = $root.AcFunDanmu.AppInfo.fromObject(object.appInfo);
            }
            if (object.deviceInfo != null) {
                if (typeof object.deviceInfo !== "object")
                    throw TypeError(".AcFunDanmu.RequestBasicInfo.deviceInfo: object expected");
                message.deviceInfo = $root.AcFunDanmu.DeviceInfo.fromObject(object.deviceInfo);
            }
            if (object.envInfo != null) {
                if (typeof object.envInfo !== "object")
                    throw TypeError(".AcFunDanmu.RequestBasicInfo.envInfo: object expected");
                message.envInfo = $root.AcFunDanmu.EnvInfo.fromObject(object.envInfo);
            }
            if (object.clientPort != null)
                message.clientPort = object.clientPort | 0;
            if (object.location != null)
                message.location = String(object.location);
            if (object.kpf != null)
                message.kpf = String(object.kpf);
            return message;
        };

        /**
         * Creates a plain object from a RequestBasicInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.RequestBasicInfo
         * @static
         * @param {AcFunDanmu.RequestBasicInfo} message RequestBasicInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RequestBasicInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.clientType = options.enums === String ? "kInvalid" : 0;
                object.deviceId = "";
                object.clientIp = "";
                object.appVersion = "";
                object.channel = "";
                object.appInfo = null;
                object.deviceInfo = null;
                object.envInfo = null;
                object.clientPort = 0;
                object.location = "";
                object.kpf = "";
            }
            if (message.clientType != null && message.hasOwnProperty("clientType"))
                object.clientType = options.enums === String ? $root.AcFunDanmu.DeviceInfo.PlatformType[message.clientType] : message.clientType;
            if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                object.deviceId = message.deviceId;
            if (message.clientIp != null && message.hasOwnProperty("clientIp"))
                object.clientIp = message.clientIp;
            if (message.appVersion != null && message.hasOwnProperty("appVersion"))
                object.appVersion = message.appVersion;
            if (message.channel != null && message.hasOwnProperty("channel"))
                object.channel = message.channel;
            if (message.appInfo != null && message.hasOwnProperty("appInfo"))
                object.appInfo = $root.AcFunDanmu.AppInfo.toObject(message.appInfo, options);
            if (message.deviceInfo != null && message.hasOwnProperty("deviceInfo"))
                object.deviceInfo = $root.AcFunDanmu.DeviceInfo.toObject(message.deviceInfo, options);
            if (message.envInfo != null && message.hasOwnProperty("envInfo"))
                object.envInfo = $root.AcFunDanmu.EnvInfo.toObject(message.envInfo, options);
            if (message.clientPort != null && message.hasOwnProperty("clientPort"))
                object.clientPort = message.clientPort;
            if (message.location != null && message.hasOwnProperty("location"))
                object.location = message.location;
            if (message.kpf != null && message.hasOwnProperty("kpf"))
                object.kpf = message.kpf;
            return object;
        };

        /**
         * Converts this RequestBasicInfo to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.RequestBasicInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RequestBasicInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RequestBasicInfo;
    })();

    AcFunDanmu.SettingInfo = (function() {

        /**
         * Properties of a SettingInfo.
         * @memberof AcFunDanmu
         * @interface ISettingInfo
         * @property {string|null} [locale] SettingInfo locale
         * @property {number|null} [timezone] SettingInfo timezone
         */

        /**
         * Constructs a new SettingInfo.
         * @memberof AcFunDanmu
         * @classdesc Represents a SettingInfo.
         * @implements ISettingInfo
         * @constructor
         * @param {AcFunDanmu.ISettingInfo=} [properties] Properties to set
         */
        function SettingInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SettingInfo locale.
         * @member {string} locale
         * @memberof AcFunDanmu.SettingInfo
         * @instance
         */
        SettingInfo.prototype.locale = "";

        /**
         * SettingInfo timezone.
         * @member {number} timezone
         * @memberof AcFunDanmu.SettingInfo
         * @instance
         */
        SettingInfo.prototype.timezone = 0;

        /**
         * Creates a new SettingInfo instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.SettingInfo
         * @static
         * @param {AcFunDanmu.ISettingInfo=} [properties] Properties to set
         * @returns {AcFunDanmu.SettingInfo} SettingInfo instance
         */
        SettingInfo.create = function create(properties) {
            return new SettingInfo(properties);
        };

        /**
         * Encodes the specified SettingInfo message. Does not implicitly {@link AcFunDanmu.SettingInfo.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.SettingInfo
         * @static
         * @param {AcFunDanmu.ISettingInfo} message SettingInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SettingInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.locale != null && Object.hasOwnProperty.call(message, "locale"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.locale);
            if (message.timezone != null && Object.hasOwnProperty.call(message, "timezone"))
                writer.uint32(/* id 2, wireType 0 =*/16).sint32(message.timezone);
            return writer;
        };

        /**
         * Encodes the specified SettingInfo message, length delimited. Does not implicitly {@link AcFunDanmu.SettingInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.SettingInfo
         * @static
         * @param {AcFunDanmu.ISettingInfo} message SettingInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SettingInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SettingInfo message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.SettingInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.SettingInfo} SettingInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SettingInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.SettingInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.locale = reader.string();
                    break;
                case 2:
                    message.timezone = reader.sint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SettingInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.SettingInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.SettingInfo} SettingInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SettingInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SettingInfo message.
         * @function verify
         * @memberof AcFunDanmu.SettingInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SettingInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.locale != null && message.hasOwnProperty("locale"))
                if (!$util.isString(message.locale))
                    return "locale: string expected";
            if (message.timezone != null && message.hasOwnProperty("timezone"))
                if (!$util.isInteger(message.timezone))
                    return "timezone: integer expected";
            return null;
        };

        /**
         * Creates a SettingInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.SettingInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.SettingInfo} SettingInfo
         */
        SettingInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.SettingInfo)
                return object;
            let message = new $root.AcFunDanmu.SettingInfo();
            if (object.locale != null)
                message.locale = String(object.locale);
            if (object.timezone != null)
                message.timezone = object.timezone | 0;
            return message;
        };

        /**
         * Creates a plain object from a SettingInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.SettingInfo
         * @static
         * @param {AcFunDanmu.SettingInfo} message SettingInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SettingInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.locale = "";
                object.timezone = 0;
            }
            if (message.locale != null && message.hasOwnProperty("locale"))
                object.locale = message.locale;
            if (message.timezone != null && message.hasOwnProperty("timezone"))
                object.timezone = message.timezone;
            return object;
        };

        /**
         * Converts this SettingInfo to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.SettingInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SettingInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SettingInfo;
    })();

    AcFunDanmu.UnregisterRequest = (function() {

        /**
         * Properties of an UnregisterRequest.
         * @memberof AcFunDanmu
         * @interface IUnregisterRequest
         */

        /**
         * Constructs a new UnregisterRequest.
         * @memberof AcFunDanmu
         * @classdesc Represents an UnregisterRequest.
         * @implements IUnregisterRequest
         * @constructor
         * @param {AcFunDanmu.IUnregisterRequest=} [properties] Properties to set
         */
        function UnregisterRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new UnregisterRequest instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.UnregisterRequest
         * @static
         * @param {AcFunDanmu.IUnregisterRequest=} [properties] Properties to set
         * @returns {AcFunDanmu.UnregisterRequest} UnregisterRequest instance
         */
        UnregisterRequest.create = function create(properties) {
            return new UnregisterRequest(properties);
        };

        /**
         * Encodes the specified UnregisterRequest message. Does not implicitly {@link AcFunDanmu.UnregisterRequest.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.UnregisterRequest
         * @static
         * @param {AcFunDanmu.IUnregisterRequest} message UnregisterRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnregisterRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified UnregisterRequest message, length delimited. Does not implicitly {@link AcFunDanmu.UnregisterRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.UnregisterRequest
         * @static
         * @param {AcFunDanmu.IUnregisterRequest} message UnregisterRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnregisterRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UnregisterRequest message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.UnregisterRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.UnregisterRequest} UnregisterRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnregisterRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.UnregisterRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UnregisterRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.UnregisterRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.UnregisterRequest} UnregisterRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnregisterRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UnregisterRequest message.
         * @function verify
         * @memberof AcFunDanmu.UnregisterRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UnregisterRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates an UnregisterRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.UnregisterRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.UnregisterRequest} UnregisterRequest
         */
        UnregisterRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.UnregisterRequest)
                return object;
            return new $root.AcFunDanmu.UnregisterRequest();
        };

        /**
         * Creates a plain object from an UnregisterRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.UnregisterRequest
         * @static
         * @param {AcFunDanmu.UnregisterRequest} message UnregisterRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UnregisterRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this UnregisterRequest to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.UnregisterRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UnregisterRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UnregisterRequest;
    })();

    AcFunDanmu.UnregisterResponse = (function() {

        /**
         * Properties of an UnregisterResponse.
         * @memberof AcFunDanmu
         * @interface IUnregisterResponse
         */

        /**
         * Constructs a new UnregisterResponse.
         * @memberof AcFunDanmu
         * @classdesc Represents an UnregisterResponse.
         * @implements IUnregisterResponse
         * @constructor
         * @param {AcFunDanmu.IUnregisterResponse=} [properties] Properties to set
         */
        function UnregisterResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new UnregisterResponse instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.UnregisterResponse
         * @static
         * @param {AcFunDanmu.IUnregisterResponse=} [properties] Properties to set
         * @returns {AcFunDanmu.UnregisterResponse} UnregisterResponse instance
         */
        UnregisterResponse.create = function create(properties) {
            return new UnregisterResponse(properties);
        };

        /**
         * Encodes the specified UnregisterResponse message. Does not implicitly {@link AcFunDanmu.UnregisterResponse.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.UnregisterResponse
         * @static
         * @param {AcFunDanmu.IUnregisterResponse} message UnregisterResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnregisterResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified UnregisterResponse message, length delimited. Does not implicitly {@link AcFunDanmu.UnregisterResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.UnregisterResponse
         * @static
         * @param {AcFunDanmu.IUnregisterResponse} message UnregisterResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnregisterResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UnregisterResponse message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.UnregisterResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.UnregisterResponse} UnregisterResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnregisterResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.UnregisterResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UnregisterResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.UnregisterResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.UnregisterResponse} UnregisterResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnregisterResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UnregisterResponse message.
         * @function verify
         * @memberof AcFunDanmu.UnregisterResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UnregisterResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates an UnregisterResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.UnregisterResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.UnregisterResponse} UnregisterResponse
         */
        UnregisterResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.UnregisterResponse)
                return object;
            return new $root.AcFunDanmu.UnregisterResponse();
        };

        /**
         * Creates a plain object from an UnregisterResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.UnregisterResponse
         * @static
         * @param {AcFunDanmu.UnregisterResponse} message UnregisterResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UnregisterResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this UnregisterResponse to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.UnregisterResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UnregisterResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UnregisterResponse;
    })();

    AcFunDanmu.UpstreamPayload = (function() {

        /**
         * Properties of an UpstreamPayload.
         * @memberof AcFunDanmu
         * @interface IUpstreamPayload
         * @property {string|null} [command] UpstreamPayload command
         * @property {number|Long|null} [seqId] UpstreamPayload seqId
         * @property {number|null} [retryCount] UpstreamPayload retryCount
         * @property {Uint8Array|null} [payloadData] UpstreamPayload payloadData
         * @property {AcFunDanmu.IUserInstance|null} [userInstance] UpstreamPayload userInstance
         * @property {number|null} [errorCode] UpstreamPayload errorCode
         * @property {AcFunDanmu.ISettingInfo|null} [settingInfo] UpstreamPayload settingInfo
         * @property {AcFunDanmu.IRequestBasicInfo|null} [requestBasicInfo] UpstreamPayload requestBasicInfo
         * @property {string|null} [subBiz] UpstreamPayload subBiz
         * @property {AcFunDanmu.IFrontendInfo|null} [frontendInfo] UpstreamPayload frontendInfo
         * @property {string|null} [kpn] UpstreamPayload kpn
         * @property {boolean|null} [anonymouseUser] UpstreamPayload anonymouseUser
         */

        /**
         * Constructs a new UpstreamPayload.
         * @memberof AcFunDanmu
         * @classdesc Represents an UpstreamPayload.
         * @implements IUpstreamPayload
         * @constructor
         * @param {AcFunDanmu.IUpstreamPayload=} [properties] Properties to set
         */
        function UpstreamPayload(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpstreamPayload command.
         * @member {string} command
         * @memberof AcFunDanmu.UpstreamPayload
         * @instance
         */
        UpstreamPayload.prototype.command = "";

        /**
         * UpstreamPayload seqId.
         * @member {number|Long} seqId
         * @memberof AcFunDanmu.UpstreamPayload
         * @instance
         */
        UpstreamPayload.prototype.seqId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * UpstreamPayload retryCount.
         * @member {number} retryCount
         * @memberof AcFunDanmu.UpstreamPayload
         * @instance
         */
        UpstreamPayload.prototype.retryCount = 0;

        /**
         * UpstreamPayload payloadData.
         * @member {Uint8Array} payloadData
         * @memberof AcFunDanmu.UpstreamPayload
         * @instance
         */
        UpstreamPayload.prototype.payloadData = $util.newBuffer([]);

        /**
         * UpstreamPayload userInstance.
         * @member {AcFunDanmu.IUserInstance|null|undefined} userInstance
         * @memberof AcFunDanmu.UpstreamPayload
         * @instance
         */
        UpstreamPayload.prototype.userInstance = null;

        /**
         * UpstreamPayload errorCode.
         * @member {number} errorCode
         * @memberof AcFunDanmu.UpstreamPayload
         * @instance
         */
        UpstreamPayload.prototype.errorCode = 0;

        /**
         * UpstreamPayload settingInfo.
         * @member {AcFunDanmu.ISettingInfo|null|undefined} settingInfo
         * @memberof AcFunDanmu.UpstreamPayload
         * @instance
         */
        UpstreamPayload.prototype.settingInfo = null;

        /**
         * UpstreamPayload requestBasicInfo.
         * @member {AcFunDanmu.IRequestBasicInfo|null|undefined} requestBasicInfo
         * @memberof AcFunDanmu.UpstreamPayload
         * @instance
         */
        UpstreamPayload.prototype.requestBasicInfo = null;

        /**
         * UpstreamPayload subBiz.
         * @member {string} subBiz
         * @memberof AcFunDanmu.UpstreamPayload
         * @instance
         */
        UpstreamPayload.prototype.subBiz = "";

        /**
         * UpstreamPayload frontendInfo.
         * @member {AcFunDanmu.IFrontendInfo|null|undefined} frontendInfo
         * @memberof AcFunDanmu.UpstreamPayload
         * @instance
         */
        UpstreamPayload.prototype.frontendInfo = null;

        /**
         * UpstreamPayload kpn.
         * @member {string} kpn
         * @memberof AcFunDanmu.UpstreamPayload
         * @instance
         */
        UpstreamPayload.prototype.kpn = "";

        /**
         * UpstreamPayload anonymouseUser.
         * @member {boolean} anonymouseUser
         * @memberof AcFunDanmu.UpstreamPayload
         * @instance
         */
        UpstreamPayload.prototype.anonymouseUser = false;

        /**
         * Creates a new UpstreamPayload instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.UpstreamPayload
         * @static
         * @param {AcFunDanmu.IUpstreamPayload=} [properties] Properties to set
         * @returns {AcFunDanmu.UpstreamPayload} UpstreamPayload instance
         */
        UpstreamPayload.create = function create(properties) {
            return new UpstreamPayload(properties);
        };

        /**
         * Encodes the specified UpstreamPayload message. Does not implicitly {@link AcFunDanmu.UpstreamPayload.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.UpstreamPayload
         * @static
         * @param {AcFunDanmu.IUpstreamPayload} message UpstreamPayload message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpstreamPayload.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.command != null && Object.hasOwnProperty.call(message, "command"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.command);
            if (message.seqId != null && Object.hasOwnProperty.call(message, "seqId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.seqId);
            if (message.retryCount != null && Object.hasOwnProperty.call(message, "retryCount"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.retryCount);
            if (message.payloadData != null && Object.hasOwnProperty.call(message, "payloadData"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.payloadData);
            if (message.userInstance != null && Object.hasOwnProperty.call(message, "userInstance"))
                $root.AcFunDanmu.UserInstance.encode(message.userInstance, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.errorCode != null && Object.hasOwnProperty.call(message, "errorCode"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.errorCode);
            if (message.settingInfo != null && Object.hasOwnProperty.call(message, "settingInfo"))
                $root.AcFunDanmu.SettingInfo.encode(message.settingInfo, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.requestBasicInfo != null && Object.hasOwnProperty.call(message, "requestBasicInfo"))
                $root.AcFunDanmu.RequestBasicInfo.encode(message.requestBasicInfo, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.subBiz != null && Object.hasOwnProperty.call(message, "subBiz"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.subBiz);
            if (message.frontendInfo != null && Object.hasOwnProperty.call(message, "frontendInfo"))
                $root.AcFunDanmu.FrontendInfo.encode(message.frontendInfo, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.kpn != null && Object.hasOwnProperty.call(message, "kpn"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.kpn);
            if (message.anonymouseUser != null && Object.hasOwnProperty.call(message, "anonymouseUser"))
                writer.uint32(/* id 12, wireType 0 =*/96).bool(message.anonymouseUser);
            return writer;
        };

        /**
         * Encodes the specified UpstreamPayload message, length delimited. Does not implicitly {@link AcFunDanmu.UpstreamPayload.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.UpstreamPayload
         * @static
         * @param {AcFunDanmu.IUpstreamPayload} message UpstreamPayload message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpstreamPayload.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpstreamPayload message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.UpstreamPayload
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.UpstreamPayload} UpstreamPayload
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpstreamPayload.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.UpstreamPayload();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.command = reader.string();
                    break;
                case 2:
                    message.seqId = reader.int64();
                    break;
                case 3:
                    message.retryCount = reader.uint32();
                    break;
                case 4:
                    message.payloadData = reader.bytes();
                    break;
                case 5:
                    message.userInstance = $root.AcFunDanmu.UserInstance.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.errorCode = reader.int32();
                    break;
                case 7:
                    message.settingInfo = $root.AcFunDanmu.SettingInfo.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.requestBasicInfo = $root.AcFunDanmu.RequestBasicInfo.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.subBiz = reader.string();
                    break;
                case 10:
                    message.frontendInfo = $root.AcFunDanmu.FrontendInfo.decode(reader, reader.uint32());
                    break;
                case 11:
                    message.kpn = reader.string();
                    break;
                case 12:
                    message.anonymouseUser = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpstreamPayload message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.UpstreamPayload
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.UpstreamPayload} UpstreamPayload
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpstreamPayload.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpstreamPayload message.
         * @function verify
         * @memberof AcFunDanmu.UpstreamPayload
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpstreamPayload.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.command != null && message.hasOwnProperty("command"))
                if (!$util.isString(message.command))
                    return "command: string expected";
            if (message.seqId != null && message.hasOwnProperty("seqId"))
                if (!$util.isInteger(message.seqId) && !(message.seqId && $util.isInteger(message.seqId.low) && $util.isInteger(message.seqId.high)))
                    return "seqId: integer|Long expected";
            if (message.retryCount != null && message.hasOwnProperty("retryCount"))
                if (!$util.isInteger(message.retryCount))
                    return "retryCount: integer expected";
            if (message.payloadData != null && message.hasOwnProperty("payloadData"))
                if (!(message.payloadData && typeof message.payloadData.length === "number" || $util.isString(message.payloadData)))
                    return "payloadData: buffer expected";
            if (message.userInstance != null && message.hasOwnProperty("userInstance")) {
                let error = $root.AcFunDanmu.UserInstance.verify(message.userInstance);
                if (error)
                    return "userInstance." + error;
            }
            if (message.errorCode != null && message.hasOwnProperty("errorCode"))
                if (!$util.isInteger(message.errorCode))
                    return "errorCode: integer expected";
            if (message.settingInfo != null && message.hasOwnProperty("settingInfo")) {
                let error = $root.AcFunDanmu.SettingInfo.verify(message.settingInfo);
                if (error)
                    return "settingInfo." + error;
            }
            if (message.requestBasicInfo != null && message.hasOwnProperty("requestBasicInfo")) {
                let error = $root.AcFunDanmu.RequestBasicInfo.verify(message.requestBasicInfo);
                if (error)
                    return "requestBasicInfo." + error;
            }
            if (message.subBiz != null && message.hasOwnProperty("subBiz"))
                if (!$util.isString(message.subBiz))
                    return "subBiz: string expected";
            if (message.frontendInfo != null && message.hasOwnProperty("frontendInfo")) {
                let error = $root.AcFunDanmu.FrontendInfo.verify(message.frontendInfo);
                if (error)
                    return "frontendInfo." + error;
            }
            if (message.kpn != null && message.hasOwnProperty("kpn"))
                if (!$util.isString(message.kpn))
                    return "kpn: string expected";
            if (message.anonymouseUser != null && message.hasOwnProperty("anonymouseUser"))
                if (typeof message.anonymouseUser !== "boolean")
                    return "anonymouseUser: boolean expected";
            return null;
        };

        /**
         * Creates an UpstreamPayload message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.UpstreamPayload
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.UpstreamPayload} UpstreamPayload
         */
        UpstreamPayload.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.UpstreamPayload)
                return object;
            let message = new $root.AcFunDanmu.UpstreamPayload();
            if (object.command != null)
                message.command = String(object.command);
            if (object.seqId != null)
                if ($util.Long)
                    (message.seqId = $util.Long.fromValue(object.seqId)).unsigned = false;
                else if (typeof object.seqId === "string")
                    message.seqId = parseInt(object.seqId, 10);
                else if (typeof object.seqId === "number")
                    message.seqId = object.seqId;
                else if (typeof object.seqId === "object")
                    message.seqId = new $util.LongBits(object.seqId.low >>> 0, object.seqId.high >>> 0).toNumber();
            if (object.retryCount != null)
                message.retryCount = object.retryCount >>> 0;
            if (object.payloadData != null)
                if (typeof object.payloadData === "string")
                    $util.base64.decode(object.payloadData, message.payloadData = $util.newBuffer($util.base64.length(object.payloadData)), 0);
                else if (object.payloadData.length)
                    message.payloadData = object.payloadData;
            if (object.userInstance != null) {
                if (typeof object.userInstance !== "object")
                    throw TypeError(".AcFunDanmu.UpstreamPayload.userInstance: object expected");
                message.userInstance = $root.AcFunDanmu.UserInstance.fromObject(object.userInstance);
            }
            if (object.errorCode != null)
                message.errorCode = object.errorCode | 0;
            if (object.settingInfo != null) {
                if (typeof object.settingInfo !== "object")
                    throw TypeError(".AcFunDanmu.UpstreamPayload.settingInfo: object expected");
                message.settingInfo = $root.AcFunDanmu.SettingInfo.fromObject(object.settingInfo);
            }
            if (object.requestBasicInfo != null) {
                if (typeof object.requestBasicInfo !== "object")
                    throw TypeError(".AcFunDanmu.UpstreamPayload.requestBasicInfo: object expected");
                message.requestBasicInfo = $root.AcFunDanmu.RequestBasicInfo.fromObject(object.requestBasicInfo);
            }
            if (object.subBiz != null)
                message.subBiz = String(object.subBiz);
            if (object.frontendInfo != null) {
                if (typeof object.frontendInfo !== "object")
                    throw TypeError(".AcFunDanmu.UpstreamPayload.frontendInfo: object expected");
                message.frontendInfo = $root.AcFunDanmu.FrontendInfo.fromObject(object.frontendInfo);
            }
            if (object.kpn != null)
                message.kpn = String(object.kpn);
            if (object.anonymouseUser != null)
                message.anonymouseUser = Boolean(object.anonymouseUser);
            return message;
        };

        /**
         * Creates a plain object from an UpstreamPayload message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.UpstreamPayload
         * @static
         * @param {AcFunDanmu.UpstreamPayload} message UpstreamPayload
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpstreamPayload.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.command = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.seqId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.seqId = options.longs === String ? "0" : 0;
                object.retryCount = 0;
                if (options.bytes === String)
                    object.payloadData = "";
                else {
                    object.payloadData = [];
                    if (options.bytes !== Array)
                        object.payloadData = $util.newBuffer(object.payloadData);
                }
                object.userInstance = null;
                object.errorCode = 0;
                object.settingInfo = null;
                object.requestBasicInfo = null;
                object.subBiz = "";
                object.frontendInfo = null;
                object.kpn = "";
                object.anonymouseUser = false;
            }
            if (message.command != null && message.hasOwnProperty("command"))
                object.command = message.command;
            if (message.seqId != null && message.hasOwnProperty("seqId"))
                if (typeof message.seqId === "number")
                    object.seqId = options.longs === String ? String(message.seqId) : message.seqId;
                else
                    object.seqId = options.longs === String ? $util.Long.prototype.toString.call(message.seqId) : options.longs === Number ? new $util.LongBits(message.seqId.low >>> 0, message.seqId.high >>> 0).toNumber() : message.seqId;
            if (message.retryCount != null && message.hasOwnProperty("retryCount"))
                object.retryCount = message.retryCount;
            if (message.payloadData != null && message.hasOwnProperty("payloadData"))
                object.payloadData = options.bytes === String ? $util.base64.encode(message.payloadData, 0, message.payloadData.length) : options.bytes === Array ? Array.prototype.slice.call(message.payloadData) : message.payloadData;
            if (message.userInstance != null && message.hasOwnProperty("userInstance"))
                object.userInstance = $root.AcFunDanmu.UserInstance.toObject(message.userInstance, options);
            if (message.errorCode != null && message.hasOwnProperty("errorCode"))
                object.errorCode = message.errorCode;
            if (message.settingInfo != null && message.hasOwnProperty("settingInfo"))
                object.settingInfo = $root.AcFunDanmu.SettingInfo.toObject(message.settingInfo, options);
            if (message.requestBasicInfo != null && message.hasOwnProperty("requestBasicInfo"))
                object.requestBasicInfo = $root.AcFunDanmu.RequestBasicInfo.toObject(message.requestBasicInfo, options);
            if (message.subBiz != null && message.hasOwnProperty("subBiz"))
                object.subBiz = message.subBiz;
            if (message.frontendInfo != null && message.hasOwnProperty("frontendInfo"))
                object.frontendInfo = $root.AcFunDanmu.FrontendInfo.toObject(message.frontendInfo, options);
            if (message.kpn != null && message.hasOwnProperty("kpn"))
                object.kpn = message.kpn;
            if (message.anonymouseUser != null && message.hasOwnProperty("anonymouseUser"))
                object.anonymouseUser = message.anonymouseUser;
            return object;
        };

        /**
         * Converts this UpstreamPayload to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.UpstreamPayload
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpstreamPayload.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UpstreamPayload;
    })();

    AcFunDanmu.UserInstance = (function() {

        /**
         * Properties of a UserInstance.
         * @memberof AcFunDanmu
         * @interface IUserInstance
         * @property {AcFunDanmu.IUser|null} [user] UserInstance user
         * @property {number|Long|null} [instanceId] UserInstance instanceId
         */

        /**
         * Constructs a new UserInstance.
         * @memberof AcFunDanmu
         * @classdesc Represents a UserInstance.
         * @implements IUserInstance
         * @constructor
         * @param {AcFunDanmu.IUserInstance=} [properties] Properties to set
         */
        function UserInstance(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserInstance user.
         * @member {AcFunDanmu.IUser|null|undefined} user
         * @memberof AcFunDanmu.UserInstance
         * @instance
         */
        UserInstance.prototype.user = null;

        /**
         * UserInstance instanceId.
         * @member {number|Long} instanceId
         * @memberof AcFunDanmu.UserInstance
         * @instance
         */
        UserInstance.prototype.instanceId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new UserInstance instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.UserInstance
         * @static
         * @param {AcFunDanmu.IUserInstance=} [properties] Properties to set
         * @returns {AcFunDanmu.UserInstance} UserInstance instance
         */
        UserInstance.create = function create(properties) {
            return new UserInstance(properties);
        };

        /**
         * Encodes the specified UserInstance message. Does not implicitly {@link AcFunDanmu.UserInstance.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.UserInstance
         * @static
         * @param {AcFunDanmu.IUserInstance} message UserInstance message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserInstance.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.user != null && Object.hasOwnProperty.call(message, "user"))
                $root.AcFunDanmu.User.encode(message.user, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.instanceId != null && Object.hasOwnProperty.call(message, "instanceId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.instanceId);
            return writer;
        };

        /**
         * Encodes the specified UserInstance message, length delimited. Does not implicitly {@link AcFunDanmu.UserInstance.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.UserInstance
         * @static
         * @param {AcFunDanmu.IUserInstance} message UserInstance message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserInstance.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserInstance message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.UserInstance
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.UserInstance} UserInstance
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserInstance.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.UserInstance();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.user = $root.AcFunDanmu.User.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.instanceId = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserInstance message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.UserInstance
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.UserInstance} UserInstance
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserInstance.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserInstance message.
         * @function verify
         * @memberof AcFunDanmu.UserInstance
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserInstance.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.user != null && message.hasOwnProperty("user")) {
                let error = $root.AcFunDanmu.User.verify(message.user);
                if (error)
                    return "user." + error;
            }
            if (message.instanceId != null && message.hasOwnProperty("instanceId"))
                if (!$util.isInteger(message.instanceId) && !(message.instanceId && $util.isInteger(message.instanceId.low) && $util.isInteger(message.instanceId.high)))
                    return "instanceId: integer|Long expected";
            return null;
        };

        /**
         * Creates a UserInstance message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.UserInstance
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.UserInstance} UserInstance
         */
        UserInstance.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.UserInstance)
                return object;
            let message = new $root.AcFunDanmu.UserInstance();
            if (object.user != null) {
                if (typeof object.user !== "object")
                    throw TypeError(".AcFunDanmu.UserInstance.user: object expected");
                message.user = $root.AcFunDanmu.User.fromObject(object.user);
            }
            if (object.instanceId != null)
                if ($util.Long)
                    (message.instanceId = $util.Long.fromValue(object.instanceId)).unsigned = false;
                else if (typeof object.instanceId === "string")
                    message.instanceId = parseInt(object.instanceId, 10);
                else if (typeof object.instanceId === "number")
                    message.instanceId = object.instanceId;
                else if (typeof object.instanceId === "object")
                    message.instanceId = new $util.LongBits(object.instanceId.low >>> 0, object.instanceId.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a UserInstance message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.UserInstance
         * @static
         * @param {AcFunDanmu.UserInstance} message UserInstance
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserInstance.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.user = null;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.instanceId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.instanceId = options.longs === String ? "0" : 0;
            }
            if (message.user != null && message.hasOwnProperty("user"))
                object.user = $root.AcFunDanmu.User.toObject(message.user, options);
            if (message.instanceId != null && message.hasOwnProperty("instanceId"))
                if (typeof message.instanceId === "number")
                    object.instanceId = options.longs === String ? String(message.instanceId) : message.instanceId;
                else
                    object.instanceId = options.longs === String ? $util.Long.prototype.toString.call(message.instanceId) : options.longs === Number ? new $util.LongBits(message.instanceId.low >>> 0, message.instanceId.high >>> 0).toNumber() : message.instanceId;
            return object;
        };

        /**
         * Converts this UserInstance to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.UserInstance
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserInstance.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UserInstance;
    })();

    AcFunDanmu.User = (function() {

        /**
         * Properties of a User.
         * @memberof AcFunDanmu
         * @interface IUser
         * @property {number|null} [appId] User appId
         * @property {number|Long|null} [uid] User uid
         */

        /**
         * Constructs a new User.
         * @memberof AcFunDanmu
         * @classdesc Represents a User.
         * @implements IUser
         * @constructor
         * @param {AcFunDanmu.IUser=} [properties] Properties to set
         */
        function User(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * User appId.
         * @member {number} appId
         * @memberof AcFunDanmu.User
         * @instance
         */
        User.prototype.appId = 0;

        /**
         * User uid.
         * @member {number|Long} uid
         * @memberof AcFunDanmu.User
         * @instance
         */
        User.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new User instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.User
         * @static
         * @param {AcFunDanmu.IUser=} [properties] Properties to set
         * @returns {AcFunDanmu.User} User instance
         */
        User.create = function create(properties) {
            return new User(properties);
        };

        /**
         * Encodes the specified User message. Does not implicitly {@link AcFunDanmu.User.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.User
         * @static
         * @param {AcFunDanmu.IUser} message User message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        User.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.appId != null && Object.hasOwnProperty.call(message, "appId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.appId);
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.uid);
            return writer;
        };

        /**
         * Encodes the specified User message, length delimited. Does not implicitly {@link AcFunDanmu.User.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.User
         * @static
         * @param {AcFunDanmu.IUser} message User message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        User.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a User message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.User
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.User} User
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        User.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.User();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.appId = reader.int32();
                    break;
                case 2:
                    message.uid = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a User message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.User
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.User} User
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        User.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a User message.
         * @function verify
         * @memberof AcFunDanmu.User
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        User.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.appId != null && message.hasOwnProperty("appId"))
                if (!$util.isInteger(message.appId))
                    return "appId: integer expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            return null;
        };

        /**
         * Creates a User message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.User
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.User} User
         */
        User.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.User)
                return object;
            let message = new $root.AcFunDanmu.User();
            if (object.appId != null)
                message.appId = object.appId | 0;
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a User message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.User
         * @static
         * @param {AcFunDanmu.User} message User
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        User.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.appId = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
            }
            if (message.appId != null && message.hasOwnProperty("appId"))
                object.appId = message.appId;
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            return object;
        };

        /**
         * Converts this User to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.User
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        User.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return User;
    })();

    AcFunDanmu.ZtLiveCsCmd = (function() {

        /**
         * Properties of a ZtLiveCsCmd.
         * @memberof AcFunDanmu
         * @interface IZtLiveCsCmd
         * @property {string|null} [cmdType] ZtLiveCsCmd cmdType
         * @property {Uint8Array|null} [payload] ZtLiveCsCmd payload
         * @property {string|null} [ticket] ZtLiveCsCmd ticket
         * @property {string|null} [liveId] ZtLiveCsCmd liveId
         */

        /**
         * Constructs a new ZtLiveCsCmd.
         * @memberof AcFunDanmu
         * @classdesc Represents a ZtLiveCsCmd.
         * @implements IZtLiveCsCmd
         * @constructor
         * @param {AcFunDanmu.IZtLiveCsCmd=} [properties] Properties to set
         */
        function ZtLiveCsCmd(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ZtLiveCsCmd cmdType.
         * @member {string} cmdType
         * @memberof AcFunDanmu.ZtLiveCsCmd
         * @instance
         */
        ZtLiveCsCmd.prototype.cmdType = "";

        /**
         * ZtLiveCsCmd payload.
         * @member {Uint8Array} payload
         * @memberof AcFunDanmu.ZtLiveCsCmd
         * @instance
         */
        ZtLiveCsCmd.prototype.payload = $util.newBuffer([]);

        /**
         * ZtLiveCsCmd ticket.
         * @member {string} ticket
         * @memberof AcFunDanmu.ZtLiveCsCmd
         * @instance
         */
        ZtLiveCsCmd.prototype.ticket = "";

        /**
         * ZtLiveCsCmd liveId.
         * @member {string} liveId
         * @memberof AcFunDanmu.ZtLiveCsCmd
         * @instance
         */
        ZtLiveCsCmd.prototype.liveId = "";

        /**
         * Creates a new ZtLiveCsCmd instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.ZtLiveCsCmd
         * @static
         * @param {AcFunDanmu.IZtLiveCsCmd=} [properties] Properties to set
         * @returns {AcFunDanmu.ZtLiveCsCmd} ZtLiveCsCmd instance
         */
        ZtLiveCsCmd.create = function create(properties) {
            return new ZtLiveCsCmd(properties);
        };

        /**
         * Encodes the specified ZtLiveCsCmd message. Does not implicitly {@link AcFunDanmu.ZtLiveCsCmd.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.ZtLiveCsCmd
         * @static
         * @param {AcFunDanmu.IZtLiveCsCmd} message ZtLiveCsCmd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ZtLiveCsCmd.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cmdType != null && Object.hasOwnProperty.call(message, "cmdType"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.cmdType);
            if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.payload);
            if (message.ticket != null && Object.hasOwnProperty.call(message, "ticket"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.ticket);
            if (message.liveId != null && Object.hasOwnProperty.call(message, "liveId"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.liveId);
            return writer;
        };

        /**
         * Encodes the specified ZtLiveCsCmd message, length delimited. Does not implicitly {@link AcFunDanmu.ZtLiveCsCmd.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.ZtLiveCsCmd
         * @static
         * @param {AcFunDanmu.IZtLiveCsCmd} message ZtLiveCsCmd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ZtLiveCsCmd.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ZtLiveCsCmd message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.ZtLiveCsCmd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.ZtLiveCsCmd} ZtLiveCsCmd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ZtLiveCsCmd.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.ZtLiveCsCmd();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.cmdType = reader.string();
                    break;
                case 2:
                    message.payload = reader.bytes();
                    break;
                case 3:
                    message.ticket = reader.string();
                    break;
                case 4:
                    message.liveId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ZtLiveCsCmd message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.ZtLiveCsCmd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.ZtLiveCsCmd} ZtLiveCsCmd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ZtLiveCsCmd.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ZtLiveCsCmd message.
         * @function verify
         * @memberof AcFunDanmu.ZtLiveCsCmd
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ZtLiveCsCmd.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.cmdType != null && message.hasOwnProperty("cmdType"))
                if (!$util.isString(message.cmdType))
                    return "cmdType: string expected";
            if (message.payload != null && message.hasOwnProperty("payload"))
                if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                    return "payload: buffer expected";
            if (message.ticket != null && message.hasOwnProperty("ticket"))
                if (!$util.isString(message.ticket))
                    return "ticket: string expected";
            if (message.liveId != null && message.hasOwnProperty("liveId"))
                if (!$util.isString(message.liveId))
                    return "liveId: string expected";
            return null;
        };

        /**
         * Creates a ZtLiveCsCmd message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.ZtLiveCsCmd
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.ZtLiveCsCmd} ZtLiveCsCmd
         */
        ZtLiveCsCmd.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.ZtLiveCsCmd)
                return object;
            let message = new $root.AcFunDanmu.ZtLiveCsCmd();
            if (object.cmdType != null)
                message.cmdType = String(object.cmdType);
            if (object.payload != null)
                if (typeof object.payload === "string")
                    $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                else if (object.payload.length)
                    message.payload = object.payload;
            if (object.ticket != null)
                message.ticket = String(object.ticket);
            if (object.liveId != null)
                message.liveId = String(object.liveId);
            return message;
        };

        /**
         * Creates a plain object from a ZtLiveCsCmd message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.ZtLiveCsCmd
         * @static
         * @param {AcFunDanmu.ZtLiveCsCmd} message ZtLiveCsCmd
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ZtLiveCsCmd.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.cmdType = "";
                if (options.bytes === String)
                    object.payload = "";
                else {
                    object.payload = [];
                    if (options.bytes !== Array)
                        object.payload = $util.newBuffer(object.payload);
                }
                object.ticket = "";
                object.liveId = "";
            }
            if (message.cmdType != null && message.hasOwnProperty("cmdType"))
                object.cmdType = message.cmdType;
            if (message.payload != null && message.hasOwnProperty("payload"))
                object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
            if (message.ticket != null && message.hasOwnProperty("ticket"))
                object.ticket = message.ticket;
            if (message.liveId != null && message.hasOwnProperty("liveId"))
                object.liveId = message.liveId;
            return object;
        };

        /**
         * Converts this ZtLiveCsCmd to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.ZtLiveCsCmd
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ZtLiveCsCmd.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ZtLiveCsCmd;
    })();

    AcFunDanmu.ZtLiveCsCmdAck = (function() {

        /**
         * Properties of a ZtLiveCsCmdAck.
         * @memberof AcFunDanmu
         * @interface IZtLiveCsCmdAck
         * @property {string|null} [cmdAckType] ZtLiveCsCmdAck cmdAckType
         * @property {number|Long|null} [errorCode] ZtLiveCsCmdAck errorCode
         * @property {string|null} [errorMsg] ZtLiveCsCmdAck errorMsg
         * @property {Uint8Array|null} [payload] ZtLiveCsCmdAck payload
         */

        /**
         * Constructs a new ZtLiveCsCmdAck.
         * @memberof AcFunDanmu
         * @classdesc Represents a ZtLiveCsCmdAck.
         * @implements IZtLiveCsCmdAck
         * @constructor
         * @param {AcFunDanmu.IZtLiveCsCmdAck=} [properties] Properties to set
         */
        function ZtLiveCsCmdAck(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ZtLiveCsCmdAck cmdAckType.
         * @member {string} cmdAckType
         * @memberof AcFunDanmu.ZtLiveCsCmdAck
         * @instance
         */
        ZtLiveCsCmdAck.prototype.cmdAckType = "";

        /**
         * ZtLiveCsCmdAck errorCode.
         * @member {number|Long} errorCode
         * @memberof AcFunDanmu.ZtLiveCsCmdAck
         * @instance
         */
        ZtLiveCsCmdAck.prototype.errorCode = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ZtLiveCsCmdAck errorMsg.
         * @member {string} errorMsg
         * @memberof AcFunDanmu.ZtLiveCsCmdAck
         * @instance
         */
        ZtLiveCsCmdAck.prototype.errorMsg = "";

        /**
         * ZtLiveCsCmdAck payload.
         * @member {Uint8Array} payload
         * @memberof AcFunDanmu.ZtLiveCsCmdAck
         * @instance
         */
        ZtLiveCsCmdAck.prototype.payload = $util.newBuffer([]);

        /**
         * Creates a new ZtLiveCsCmdAck instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.ZtLiveCsCmdAck
         * @static
         * @param {AcFunDanmu.IZtLiveCsCmdAck=} [properties] Properties to set
         * @returns {AcFunDanmu.ZtLiveCsCmdAck} ZtLiveCsCmdAck instance
         */
        ZtLiveCsCmdAck.create = function create(properties) {
            return new ZtLiveCsCmdAck(properties);
        };

        /**
         * Encodes the specified ZtLiveCsCmdAck message. Does not implicitly {@link AcFunDanmu.ZtLiveCsCmdAck.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.ZtLiveCsCmdAck
         * @static
         * @param {AcFunDanmu.IZtLiveCsCmdAck} message ZtLiveCsCmdAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ZtLiveCsCmdAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cmdAckType != null && Object.hasOwnProperty.call(message, "cmdAckType"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.cmdAckType);
            if (message.errorCode != null && Object.hasOwnProperty.call(message, "errorCode"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.errorCode);
            if (message.errorMsg != null && Object.hasOwnProperty.call(message, "errorMsg"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.errorMsg);
            if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.payload);
            return writer;
        };

        /**
         * Encodes the specified ZtLiveCsCmdAck message, length delimited. Does not implicitly {@link AcFunDanmu.ZtLiveCsCmdAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.ZtLiveCsCmdAck
         * @static
         * @param {AcFunDanmu.IZtLiveCsCmdAck} message ZtLiveCsCmdAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ZtLiveCsCmdAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ZtLiveCsCmdAck message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.ZtLiveCsCmdAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.ZtLiveCsCmdAck} ZtLiveCsCmdAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ZtLiveCsCmdAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.ZtLiveCsCmdAck();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.cmdAckType = reader.string();
                    break;
                case 2:
                    message.errorCode = reader.int64();
                    break;
                case 3:
                    message.errorMsg = reader.string();
                    break;
                case 4:
                    message.payload = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ZtLiveCsCmdAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.ZtLiveCsCmdAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.ZtLiveCsCmdAck} ZtLiveCsCmdAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ZtLiveCsCmdAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ZtLiveCsCmdAck message.
         * @function verify
         * @memberof AcFunDanmu.ZtLiveCsCmdAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ZtLiveCsCmdAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.cmdAckType != null && message.hasOwnProperty("cmdAckType"))
                if (!$util.isString(message.cmdAckType))
                    return "cmdAckType: string expected";
            if (message.errorCode != null && message.hasOwnProperty("errorCode"))
                if (!$util.isInteger(message.errorCode) && !(message.errorCode && $util.isInteger(message.errorCode.low) && $util.isInteger(message.errorCode.high)))
                    return "errorCode: integer|Long expected";
            if (message.errorMsg != null && message.hasOwnProperty("errorMsg"))
                if (!$util.isString(message.errorMsg))
                    return "errorMsg: string expected";
            if (message.payload != null && message.hasOwnProperty("payload"))
                if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                    return "payload: buffer expected";
            return null;
        };

        /**
         * Creates a ZtLiveCsCmdAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.ZtLiveCsCmdAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.ZtLiveCsCmdAck} ZtLiveCsCmdAck
         */
        ZtLiveCsCmdAck.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.ZtLiveCsCmdAck)
                return object;
            let message = new $root.AcFunDanmu.ZtLiveCsCmdAck();
            if (object.cmdAckType != null)
                message.cmdAckType = String(object.cmdAckType);
            if (object.errorCode != null)
                if ($util.Long)
                    (message.errorCode = $util.Long.fromValue(object.errorCode)).unsigned = false;
                else if (typeof object.errorCode === "string")
                    message.errorCode = parseInt(object.errorCode, 10);
                else if (typeof object.errorCode === "number")
                    message.errorCode = object.errorCode;
                else if (typeof object.errorCode === "object")
                    message.errorCode = new $util.LongBits(object.errorCode.low >>> 0, object.errorCode.high >>> 0).toNumber();
            if (object.errorMsg != null)
                message.errorMsg = String(object.errorMsg);
            if (object.payload != null)
                if (typeof object.payload === "string")
                    $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                else if (object.payload.length)
                    message.payload = object.payload;
            return message;
        };

        /**
         * Creates a plain object from a ZtLiveCsCmdAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.ZtLiveCsCmdAck
         * @static
         * @param {AcFunDanmu.ZtLiveCsCmdAck} message ZtLiveCsCmdAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ZtLiveCsCmdAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.cmdAckType = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.errorCode = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.errorCode = options.longs === String ? "0" : 0;
                object.errorMsg = "";
                if (options.bytes === String)
                    object.payload = "";
                else {
                    object.payload = [];
                    if (options.bytes !== Array)
                        object.payload = $util.newBuffer(object.payload);
                }
            }
            if (message.cmdAckType != null && message.hasOwnProperty("cmdAckType"))
                object.cmdAckType = message.cmdAckType;
            if (message.errorCode != null && message.hasOwnProperty("errorCode"))
                if (typeof message.errorCode === "number")
                    object.errorCode = options.longs === String ? String(message.errorCode) : message.errorCode;
                else
                    object.errorCode = options.longs === String ? $util.Long.prototype.toString.call(message.errorCode) : options.longs === Number ? new $util.LongBits(message.errorCode.low >>> 0, message.errorCode.high >>> 0).toNumber() : message.errorCode;
            if (message.errorMsg != null && message.hasOwnProperty("errorMsg"))
                object.errorMsg = message.errorMsg;
            if (message.payload != null && message.hasOwnProperty("payload"))
                object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
            return object;
        };

        /**
         * Converts this ZtLiveCsCmdAck to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.ZtLiveCsCmdAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ZtLiveCsCmdAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ZtLiveCsCmdAck;
    })();

    AcFunDanmu.ZtLiveCsEnterRoom = (function() {

        /**
         * Properties of a ZtLiveCsEnterRoom.
         * @memberof AcFunDanmu
         * @interface IZtLiveCsEnterRoom
         * @property {boolean|null} [isAuthor] ZtLiveCsEnterRoom isAuthor
         * @property {number|null} [reconnectCount] ZtLiveCsEnterRoom reconnectCount
         * @property {number|null} [lastErrorCode] ZtLiveCsEnterRoom lastErrorCode
         * @property {string|null} [enterRoomAttach] ZtLiveCsEnterRoom enterRoomAttach
         * @property {string|null} [clientLiveSdkVersion] ZtLiveCsEnterRoom clientLiveSdkVersion
         */

        /**
         * Constructs a new ZtLiveCsEnterRoom.
         * @memberof AcFunDanmu
         * @classdesc Represents a ZtLiveCsEnterRoom.
         * @implements IZtLiveCsEnterRoom
         * @constructor
         * @param {AcFunDanmu.IZtLiveCsEnterRoom=} [properties] Properties to set
         */
        function ZtLiveCsEnterRoom(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ZtLiveCsEnterRoom isAuthor.
         * @member {boolean} isAuthor
         * @memberof AcFunDanmu.ZtLiveCsEnterRoom
         * @instance
         */
        ZtLiveCsEnterRoom.prototype.isAuthor = false;

        /**
         * ZtLiveCsEnterRoom reconnectCount.
         * @member {number} reconnectCount
         * @memberof AcFunDanmu.ZtLiveCsEnterRoom
         * @instance
         */
        ZtLiveCsEnterRoom.prototype.reconnectCount = 0;

        /**
         * ZtLiveCsEnterRoom lastErrorCode.
         * @member {number} lastErrorCode
         * @memberof AcFunDanmu.ZtLiveCsEnterRoom
         * @instance
         */
        ZtLiveCsEnterRoom.prototype.lastErrorCode = 0;

        /**
         * ZtLiveCsEnterRoom enterRoomAttach.
         * @member {string} enterRoomAttach
         * @memberof AcFunDanmu.ZtLiveCsEnterRoom
         * @instance
         */
        ZtLiveCsEnterRoom.prototype.enterRoomAttach = "";

        /**
         * ZtLiveCsEnterRoom clientLiveSdkVersion.
         * @member {string} clientLiveSdkVersion
         * @memberof AcFunDanmu.ZtLiveCsEnterRoom
         * @instance
         */
        ZtLiveCsEnterRoom.prototype.clientLiveSdkVersion = "";

        /**
         * Creates a new ZtLiveCsEnterRoom instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.ZtLiveCsEnterRoom
         * @static
         * @param {AcFunDanmu.IZtLiveCsEnterRoom=} [properties] Properties to set
         * @returns {AcFunDanmu.ZtLiveCsEnterRoom} ZtLiveCsEnterRoom instance
         */
        ZtLiveCsEnterRoom.create = function create(properties) {
            return new ZtLiveCsEnterRoom(properties);
        };

        /**
         * Encodes the specified ZtLiveCsEnterRoom message. Does not implicitly {@link AcFunDanmu.ZtLiveCsEnterRoom.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.ZtLiveCsEnterRoom
         * @static
         * @param {AcFunDanmu.IZtLiveCsEnterRoom} message ZtLiveCsEnterRoom message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ZtLiveCsEnterRoom.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.isAuthor != null && Object.hasOwnProperty.call(message, "isAuthor"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isAuthor);
            if (message.reconnectCount != null && Object.hasOwnProperty.call(message, "reconnectCount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.reconnectCount);
            if (message.lastErrorCode != null && Object.hasOwnProperty.call(message, "lastErrorCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.lastErrorCode);
            if (message.enterRoomAttach != null && Object.hasOwnProperty.call(message, "enterRoomAttach"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.enterRoomAttach);
            if (message.clientLiveSdkVersion != null && Object.hasOwnProperty.call(message, "clientLiveSdkVersion"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.clientLiveSdkVersion);
            return writer;
        };

        /**
         * Encodes the specified ZtLiveCsEnterRoom message, length delimited. Does not implicitly {@link AcFunDanmu.ZtLiveCsEnterRoom.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.ZtLiveCsEnterRoom
         * @static
         * @param {AcFunDanmu.IZtLiveCsEnterRoom} message ZtLiveCsEnterRoom message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ZtLiveCsEnterRoom.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ZtLiveCsEnterRoom message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.ZtLiveCsEnterRoom
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.ZtLiveCsEnterRoom} ZtLiveCsEnterRoom
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ZtLiveCsEnterRoom.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.ZtLiveCsEnterRoom();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.isAuthor = reader.bool();
                    break;
                case 2:
                    message.reconnectCount = reader.int32();
                    break;
                case 3:
                    message.lastErrorCode = reader.int32();
                    break;
                case 4:
                    message.enterRoomAttach = reader.string();
                    break;
                case 5:
                    message.clientLiveSdkVersion = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ZtLiveCsEnterRoom message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.ZtLiveCsEnterRoom
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.ZtLiveCsEnterRoom} ZtLiveCsEnterRoom
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ZtLiveCsEnterRoom.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ZtLiveCsEnterRoom message.
         * @function verify
         * @memberof AcFunDanmu.ZtLiveCsEnterRoom
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ZtLiveCsEnterRoom.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.isAuthor != null && message.hasOwnProperty("isAuthor"))
                if (typeof message.isAuthor !== "boolean")
                    return "isAuthor: boolean expected";
            if (message.reconnectCount != null && message.hasOwnProperty("reconnectCount"))
                if (!$util.isInteger(message.reconnectCount))
                    return "reconnectCount: integer expected";
            if (message.lastErrorCode != null && message.hasOwnProperty("lastErrorCode"))
                if (!$util.isInteger(message.lastErrorCode))
                    return "lastErrorCode: integer expected";
            if (message.enterRoomAttach != null && message.hasOwnProperty("enterRoomAttach"))
                if (!$util.isString(message.enterRoomAttach))
                    return "enterRoomAttach: string expected";
            if (message.clientLiveSdkVersion != null && message.hasOwnProperty("clientLiveSdkVersion"))
                if (!$util.isString(message.clientLiveSdkVersion))
                    return "clientLiveSdkVersion: string expected";
            return null;
        };

        /**
         * Creates a ZtLiveCsEnterRoom message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.ZtLiveCsEnterRoom
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.ZtLiveCsEnterRoom} ZtLiveCsEnterRoom
         */
        ZtLiveCsEnterRoom.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.ZtLiveCsEnterRoom)
                return object;
            let message = new $root.AcFunDanmu.ZtLiveCsEnterRoom();
            if (object.isAuthor != null)
                message.isAuthor = Boolean(object.isAuthor);
            if (object.reconnectCount != null)
                message.reconnectCount = object.reconnectCount | 0;
            if (object.lastErrorCode != null)
                message.lastErrorCode = object.lastErrorCode | 0;
            if (object.enterRoomAttach != null)
                message.enterRoomAttach = String(object.enterRoomAttach);
            if (object.clientLiveSdkVersion != null)
                message.clientLiveSdkVersion = String(object.clientLiveSdkVersion);
            return message;
        };

        /**
         * Creates a plain object from a ZtLiveCsEnterRoom message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.ZtLiveCsEnterRoom
         * @static
         * @param {AcFunDanmu.ZtLiveCsEnterRoom} message ZtLiveCsEnterRoom
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ZtLiveCsEnterRoom.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.isAuthor = false;
                object.reconnectCount = 0;
                object.lastErrorCode = 0;
                object.enterRoomAttach = "";
                object.clientLiveSdkVersion = "";
            }
            if (message.isAuthor != null && message.hasOwnProperty("isAuthor"))
                object.isAuthor = message.isAuthor;
            if (message.reconnectCount != null && message.hasOwnProperty("reconnectCount"))
                object.reconnectCount = message.reconnectCount;
            if (message.lastErrorCode != null && message.hasOwnProperty("lastErrorCode"))
                object.lastErrorCode = message.lastErrorCode;
            if (message.enterRoomAttach != null && message.hasOwnProperty("enterRoomAttach"))
                object.enterRoomAttach = message.enterRoomAttach;
            if (message.clientLiveSdkVersion != null && message.hasOwnProperty("clientLiveSdkVersion"))
                object.clientLiveSdkVersion = message.clientLiveSdkVersion;
            return object;
        };

        /**
         * Converts this ZtLiveCsEnterRoom to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.ZtLiveCsEnterRoom
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ZtLiveCsEnterRoom.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ZtLiveCsEnterRoom;
    })();

    AcFunDanmu.ZtLiveCsEnterRoomAck = (function() {

        /**
         * Properties of a ZtLiveCsEnterRoomAck.
         * @memberof AcFunDanmu
         * @interface IZtLiveCsEnterRoomAck
         * @property {number|Long|null} [heartbeatIntervalMs] ZtLiveCsEnterRoomAck heartbeatIntervalMs
         */

        /**
         * Constructs a new ZtLiveCsEnterRoomAck.
         * @memberof AcFunDanmu
         * @classdesc Represents a ZtLiveCsEnterRoomAck.
         * @implements IZtLiveCsEnterRoomAck
         * @constructor
         * @param {AcFunDanmu.IZtLiveCsEnterRoomAck=} [properties] Properties to set
         */
        function ZtLiveCsEnterRoomAck(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ZtLiveCsEnterRoomAck heartbeatIntervalMs.
         * @member {number|Long} heartbeatIntervalMs
         * @memberof AcFunDanmu.ZtLiveCsEnterRoomAck
         * @instance
         */
        ZtLiveCsEnterRoomAck.prototype.heartbeatIntervalMs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new ZtLiveCsEnterRoomAck instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.ZtLiveCsEnterRoomAck
         * @static
         * @param {AcFunDanmu.IZtLiveCsEnterRoomAck=} [properties] Properties to set
         * @returns {AcFunDanmu.ZtLiveCsEnterRoomAck} ZtLiveCsEnterRoomAck instance
         */
        ZtLiveCsEnterRoomAck.create = function create(properties) {
            return new ZtLiveCsEnterRoomAck(properties);
        };

        /**
         * Encodes the specified ZtLiveCsEnterRoomAck message. Does not implicitly {@link AcFunDanmu.ZtLiveCsEnterRoomAck.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.ZtLiveCsEnterRoomAck
         * @static
         * @param {AcFunDanmu.IZtLiveCsEnterRoomAck} message ZtLiveCsEnterRoomAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ZtLiveCsEnterRoomAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.heartbeatIntervalMs != null && Object.hasOwnProperty.call(message, "heartbeatIntervalMs"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.heartbeatIntervalMs);
            return writer;
        };

        /**
         * Encodes the specified ZtLiveCsEnterRoomAck message, length delimited. Does not implicitly {@link AcFunDanmu.ZtLiveCsEnterRoomAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.ZtLiveCsEnterRoomAck
         * @static
         * @param {AcFunDanmu.IZtLiveCsEnterRoomAck} message ZtLiveCsEnterRoomAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ZtLiveCsEnterRoomAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ZtLiveCsEnterRoomAck message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.ZtLiveCsEnterRoomAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.ZtLiveCsEnterRoomAck} ZtLiveCsEnterRoomAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ZtLiveCsEnterRoomAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.ZtLiveCsEnterRoomAck();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.heartbeatIntervalMs = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ZtLiveCsEnterRoomAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.ZtLiveCsEnterRoomAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.ZtLiveCsEnterRoomAck} ZtLiveCsEnterRoomAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ZtLiveCsEnterRoomAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ZtLiveCsEnterRoomAck message.
         * @function verify
         * @memberof AcFunDanmu.ZtLiveCsEnterRoomAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ZtLiveCsEnterRoomAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.heartbeatIntervalMs != null && message.hasOwnProperty("heartbeatIntervalMs"))
                if (!$util.isInteger(message.heartbeatIntervalMs) && !(message.heartbeatIntervalMs && $util.isInteger(message.heartbeatIntervalMs.low) && $util.isInteger(message.heartbeatIntervalMs.high)))
                    return "heartbeatIntervalMs: integer|Long expected";
            return null;
        };

        /**
         * Creates a ZtLiveCsEnterRoomAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.ZtLiveCsEnterRoomAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.ZtLiveCsEnterRoomAck} ZtLiveCsEnterRoomAck
         */
        ZtLiveCsEnterRoomAck.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.ZtLiveCsEnterRoomAck)
                return object;
            let message = new $root.AcFunDanmu.ZtLiveCsEnterRoomAck();
            if (object.heartbeatIntervalMs != null)
                if ($util.Long)
                    (message.heartbeatIntervalMs = $util.Long.fromValue(object.heartbeatIntervalMs)).unsigned = false;
                else if (typeof object.heartbeatIntervalMs === "string")
                    message.heartbeatIntervalMs = parseInt(object.heartbeatIntervalMs, 10);
                else if (typeof object.heartbeatIntervalMs === "number")
                    message.heartbeatIntervalMs = object.heartbeatIntervalMs;
                else if (typeof object.heartbeatIntervalMs === "object")
                    message.heartbeatIntervalMs = new $util.LongBits(object.heartbeatIntervalMs.low >>> 0, object.heartbeatIntervalMs.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a ZtLiveCsEnterRoomAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.ZtLiveCsEnterRoomAck
         * @static
         * @param {AcFunDanmu.ZtLiveCsEnterRoomAck} message ZtLiveCsEnterRoomAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ZtLiveCsEnterRoomAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.heartbeatIntervalMs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.heartbeatIntervalMs = options.longs === String ? "0" : 0;
            if (message.heartbeatIntervalMs != null && message.hasOwnProperty("heartbeatIntervalMs"))
                if (typeof message.heartbeatIntervalMs === "number")
                    object.heartbeatIntervalMs = options.longs === String ? String(message.heartbeatIntervalMs) : message.heartbeatIntervalMs;
                else
                    object.heartbeatIntervalMs = options.longs === String ? $util.Long.prototype.toString.call(message.heartbeatIntervalMs) : options.longs === Number ? new $util.LongBits(message.heartbeatIntervalMs.low >>> 0, message.heartbeatIntervalMs.high >>> 0).toNumber() : message.heartbeatIntervalMs;
            return object;
        };

        /**
         * Converts this ZtLiveCsEnterRoomAck to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.ZtLiveCsEnterRoomAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ZtLiveCsEnterRoomAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ZtLiveCsEnterRoomAck;
    })();

    AcFunDanmu.ZtLiveCsUserExit = (function() {

        /**
         * Properties of a ZtLiveCsUserExit.
         * @memberof AcFunDanmu
         * @interface IZtLiveCsUserExit
         */

        /**
         * Constructs a new ZtLiveCsUserExit.
         * @memberof AcFunDanmu
         * @classdesc Represents a ZtLiveCsUserExit.
         * @implements IZtLiveCsUserExit
         * @constructor
         * @param {AcFunDanmu.IZtLiveCsUserExit=} [properties] Properties to set
         */
        function ZtLiveCsUserExit(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ZtLiveCsUserExit instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.ZtLiveCsUserExit
         * @static
         * @param {AcFunDanmu.IZtLiveCsUserExit=} [properties] Properties to set
         * @returns {AcFunDanmu.ZtLiveCsUserExit} ZtLiveCsUserExit instance
         */
        ZtLiveCsUserExit.create = function create(properties) {
            return new ZtLiveCsUserExit(properties);
        };

        /**
         * Encodes the specified ZtLiveCsUserExit message. Does not implicitly {@link AcFunDanmu.ZtLiveCsUserExit.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.ZtLiveCsUserExit
         * @static
         * @param {AcFunDanmu.IZtLiveCsUserExit} message ZtLiveCsUserExit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ZtLiveCsUserExit.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ZtLiveCsUserExit message, length delimited. Does not implicitly {@link AcFunDanmu.ZtLiveCsUserExit.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.ZtLiveCsUserExit
         * @static
         * @param {AcFunDanmu.IZtLiveCsUserExit} message ZtLiveCsUserExit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ZtLiveCsUserExit.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ZtLiveCsUserExit message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.ZtLiveCsUserExit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.ZtLiveCsUserExit} ZtLiveCsUserExit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ZtLiveCsUserExit.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.ZtLiveCsUserExit();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ZtLiveCsUserExit message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.ZtLiveCsUserExit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.ZtLiveCsUserExit} ZtLiveCsUserExit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ZtLiveCsUserExit.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ZtLiveCsUserExit message.
         * @function verify
         * @memberof AcFunDanmu.ZtLiveCsUserExit
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ZtLiveCsUserExit.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a ZtLiveCsUserExit message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.ZtLiveCsUserExit
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.ZtLiveCsUserExit} ZtLiveCsUserExit
         */
        ZtLiveCsUserExit.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.ZtLiveCsUserExit)
                return object;
            return new $root.AcFunDanmu.ZtLiveCsUserExit();
        };

        /**
         * Creates a plain object from a ZtLiveCsUserExit message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.ZtLiveCsUserExit
         * @static
         * @param {AcFunDanmu.ZtLiveCsUserExit} message ZtLiveCsUserExit
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ZtLiveCsUserExit.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ZtLiveCsUserExit to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.ZtLiveCsUserExit
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ZtLiveCsUserExit.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ZtLiveCsUserExit;
    })();

    AcFunDanmu.ZtLiveCsUserExitAck = (function() {

        /**
         * Properties of a ZtLiveCsUserExitAck.
         * @memberof AcFunDanmu
         * @interface IZtLiveCsUserExitAck
         */

        /**
         * Constructs a new ZtLiveCsUserExitAck.
         * @memberof AcFunDanmu
         * @classdesc Represents a ZtLiveCsUserExitAck.
         * @implements IZtLiveCsUserExitAck
         * @constructor
         * @param {AcFunDanmu.IZtLiveCsUserExitAck=} [properties] Properties to set
         */
        function ZtLiveCsUserExitAck(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ZtLiveCsUserExitAck instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.ZtLiveCsUserExitAck
         * @static
         * @param {AcFunDanmu.IZtLiveCsUserExitAck=} [properties] Properties to set
         * @returns {AcFunDanmu.ZtLiveCsUserExitAck} ZtLiveCsUserExitAck instance
         */
        ZtLiveCsUserExitAck.create = function create(properties) {
            return new ZtLiveCsUserExitAck(properties);
        };

        /**
         * Encodes the specified ZtLiveCsUserExitAck message. Does not implicitly {@link AcFunDanmu.ZtLiveCsUserExitAck.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.ZtLiveCsUserExitAck
         * @static
         * @param {AcFunDanmu.IZtLiveCsUserExitAck} message ZtLiveCsUserExitAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ZtLiveCsUserExitAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ZtLiveCsUserExitAck message, length delimited. Does not implicitly {@link AcFunDanmu.ZtLiveCsUserExitAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.ZtLiveCsUserExitAck
         * @static
         * @param {AcFunDanmu.IZtLiveCsUserExitAck} message ZtLiveCsUserExitAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ZtLiveCsUserExitAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ZtLiveCsUserExitAck message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.ZtLiveCsUserExitAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.ZtLiveCsUserExitAck} ZtLiveCsUserExitAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ZtLiveCsUserExitAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.ZtLiveCsUserExitAck();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ZtLiveCsUserExitAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.ZtLiveCsUserExitAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.ZtLiveCsUserExitAck} ZtLiveCsUserExitAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ZtLiveCsUserExitAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ZtLiveCsUserExitAck message.
         * @function verify
         * @memberof AcFunDanmu.ZtLiveCsUserExitAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ZtLiveCsUserExitAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a ZtLiveCsUserExitAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.ZtLiveCsUserExitAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.ZtLiveCsUserExitAck} ZtLiveCsUserExitAck
         */
        ZtLiveCsUserExitAck.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.ZtLiveCsUserExitAck)
                return object;
            return new $root.AcFunDanmu.ZtLiveCsUserExitAck();
        };

        /**
         * Creates a plain object from a ZtLiveCsUserExitAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.ZtLiveCsUserExitAck
         * @static
         * @param {AcFunDanmu.ZtLiveCsUserExitAck} message ZtLiveCsUserExitAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ZtLiveCsUserExitAck.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ZtLiveCsUserExitAck to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.ZtLiveCsUserExitAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ZtLiveCsUserExitAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ZtLiveCsUserExitAck;
    })();

    AcFunDanmu.ZtLiveCsHeartbeat = (function() {

        /**
         * Properties of a ZtLiveCsHeartbeat.
         * @memberof AcFunDanmu
         * @interface IZtLiveCsHeartbeat
         * @property {number|Long|null} [clientTimestampMs] ZtLiveCsHeartbeat clientTimestampMs
         * @property {number|Long|null} [sequence] ZtLiveCsHeartbeat sequence
         */

        /**
         * Constructs a new ZtLiveCsHeartbeat.
         * @memberof AcFunDanmu
         * @classdesc Represents a ZtLiveCsHeartbeat.
         * @implements IZtLiveCsHeartbeat
         * @constructor
         * @param {AcFunDanmu.IZtLiveCsHeartbeat=} [properties] Properties to set
         */
        function ZtLiveCsHeartbeat(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ZtLiveCsHeartbeat clientTimestampMs.
         * @member {number|Long} clientTimestampMs
         * @memberof AcFunDanmu.ZtLiveCsHeartbeat
         * @instance
         */
        ZtLiveCsHeartbeat.prototype.clientTimestampMs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ZtLiveCsHeartbeat sequence.
         * @member {number|Long} sequence
         * @memberof AcFunDanmu.ZtLiveCsHeartbeat
         * @instance
         */
        ZtLiveCsHeartbeat.prototype.sequence = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new ZtLiveCsHeartbeat instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.ZtLiveCsHeartbeat
         * @static
         * @param {AcFunDanmu.IZtLiveCsHeartbeat=} [properties] Properties to set
         * @returns {AcFunDanmu.ZtLiveCsHeartbeat} ZtLiveCsHeartbeat instance
         */
        ZtLiveCsHeartbeat.create = function create(properties) {
            return new ZtLiveCsHeartbeat(properties);
        };

        /**
         * Encodes the specified ZtLiveCsHeartbeat message. Does not implicitly {@link AcFunDanmu.ZtLiveCsHeartbeat.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.ZtLiveCsHeartbeat
         * @static
         * @param {AcFunDanmu.IZtLiveCsHeartbeat} message ZtLiveCsHeartbeat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ZtLiveCsHeartbeat.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.clientTimestampMs != null && Object.hasOwnProperty.call(message, "clientTimestampMs"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.clientTimestampMs);
            if (message.sequence != null && Object.hasOwnProperty.call(message, "sequence"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.sequence);
            return writer;
        };

        /**
         * Encodes the specified ZtLiveCsHeartbeat message, length delimited. Does not implicitly {@link AcFunDanmu.ZtLiveCsHeartbeat.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.ZtLiveCsHeartbeat
         * @static
         * @param {AcFunDanmu.IZtLiveCsHeartbeat} message ZtLiveCsHeartbeat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ZtLiveCsHeartbeat.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ZtLiveCsHeartbeat message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.ZtLiveCsHeartbeat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.ZtLiveCsHeartbeat} ZtLiveCsHeartbeat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ZtLiveCsHeartbeat.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.ZtLiveCsHeartbeat();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.clientTimestampMs = reader.int64();
                    break;
                case 2:
                    message.sequence = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ZtLiveCsHeartbeat message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.ZtLiveCsHeartbeat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.ZtLiveCsHeartbeat} ZtLiveCsHeartbeat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ZtLiveCsHeartbeat.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ZtLiveCsHeartbeat message.
         * @function verify
         * @memberof AcFunDanmu.ZtLiveCsHeartbeat
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ZtLiveCsHeartbeat.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.clientTimestampMs != null && message.hasOwnProperty("clientTimestampMs"))
                if (!$util.isInteger(message.clientTimestampMs) && !(message.clientTimestampMs && $util.isInteger(message.clientTimestampMs.low) && $util.isInteger(message.clientTimestampMs.high)))
                    return "clientTimestampMs: integer|Long expected";
            if (message.sequence != null && message.hasOwnProperty("sequence"))
                if (!$util.isInteger(message.sequence) && !(message.sequence && $util.isInteger(message.sequence.low) && $util.isInteger(message.sequence.high)))
                    return "sequence: integer|Long expected";
            return null;
        };

        /**
         * Creates a ZtLiveCsHeartbeat message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.ZtLiveCsHeartbeat
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.ZtLiveCsHeartbeat} ZtLiveCsHeartbeat
         */
        ZtLiveCsHeartbeat.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.ZtLiveCsHeartbeat)
                return object;
            let message = new $root.AcFunDanmu.ZtLiveCsHeartbeat();
            if (object.clientTimestampMs != null)
                if ($util.Long)
                    (message.clientTimestampMs = $util.Long.fromValue(object.clientTimestampMs)).unsigned = false;
                else if (typeof object.clientTimestampMs === "string")
                    message.clientTimestampMs = parseInt(object.clientTimestampMs, 10);
                else if (typeof object.clientTimestampMs === "number")
                    message.clientTimestampMs = object.clientTimestampMs;
                else if (typeof object.clientTimestampMs === "object")
                    message.clientTimestampMs = new $util.LongBits(object.clientTimestampMs.low >>> 0, object.clientTimestampMs.high >>> 0).toNumber();
            if (object.sequence != null)
                if ($util.Long)
                    (message.sequence = $util.Long.fromValue(object.sequence)).unsigned = false;
                else if (typeof object.sequence === "string")
                    message.sequence = parseInt(object.sequence, 10);
                else if (typeof object.sequence === "number")
                    message.sequence = object.sequence;
                else if (typeof object.sequence === "object")
                    message.sequence = new $util.LongBits(object.sequence.low >>> 0, object.sequence.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a ZtLiveCsHeartbeat message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.ZtLiveCsHeartbeat
         * @static
         * @param {AcFunDanmu.ZtLiveCsHeartbeat} message ZtLiveCsHeartbeat
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ZtLiveCsHeartbeat.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.clientTimestampMs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.clientTimestampMs = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.sequence = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.sequence = options.longs === String ? "0" : 0;
            }
            if (message.clientTimestampMs != null && message.hasOwnProperty("clientTimestampMs"))
                if (typeof message.clientTimestampMs === "number")
                    object.clientTimestampMs = options.longs === String ? String(message.clientTimestampMs) : message.clientTimestampMs;
                else
                    object.clientTimestampMs = options.longs === String ? $util.Long.prototype.toString.call(message.clientTimestampMs) : options.longs === Number ? new $util.LongBits(message.clientTimestampMs.low >>> 0, message.clientTimestampMs.high >>> 0).toNumber() : message.clientTimestampMs;
            if (message.sequence != null && message.hasOwnProperty("sequence"))
                if (typeof message.sequence === "number")
                    object.sequence = options.longs === String ? String(message.sequence) : message.sequence;
                else
                    object.sequence = options.longs === String ? $util.Long.prototype.toString.call(message.sequence) : options.longs === Number ? new $util.LongBits(message.sequence.low >>> 0, message.sequence.high >>> 0).toNumber() : message.sequence;
            return object;
        };

        /**
         * Converts this ZtLiveCsHeartbeat to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.ZtLiveCsHeartbeat
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ZtLiveCsHeartbeat.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ZtLiveCsHeartbeat;
    })();

    AcFunDanmu.ZtLiveCsHeartbeatAck = (function() {

        /**
         * Properties of a ZtLiveCsHeartbeatAck.
         * @memberof AcFunDanmu
         * @interface IZtLiveCsHeartbeatAck
         * @property {number|Long|null} [serverTimestampMs] ZtLiveCsHeartbeatAck serverTimestampMs
         * @property {number|Long|null} [clientTimestampMs] ZtLiveCsHeartbeatAck clientTimestampMs
         * @property {number|Long|null} [clientSequence] ZtLiveCsHeartbeatAck clientSequence
         */

        /**
         * Constructs a new ZtLiveCsHeartbeatAck.
         * @memberof AcFunDanmu
         * @classdesc Represents a ZtLiveCsHeartbeatAck.
         * @implements IZtLiveCsHeartbeatAck
         * @constructor
         * @param {AcFunDanmu.IZtLiveCsHeartbeatAck=} [properties] Properties to set
         */
        function ZtLiveCsHeartbeatAck(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ZtLiveCsHeartbeatAck serverTimestampMs.
         * @member {number|Long} serverTimestampMs
         * @memberof AcFunDanmu.ZtLiveCsHeartbeatAck
         * @instance
         */
        ZtLiveCsHeartbeatAck.prototype.serverTimestampMs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ZtLiveCsHeartbeatAck clientTimestampMs.
         * @member {number|Long} clientTimestampMs
         * @memberof AcFunDanmu.ZtLiveCsHeartbeatAck
         * @instance
         */
        ZtLiveCsHeartbeatAck.prototype.clientTimestampMs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ZtLiveCsHeartbeatAck clientSequence.
         * @member {number|Long} clientSequence
         * @memberof AcFunDanmu.ZtLiveCsHeartbeatAck
         * @instance
         */
        ZtLiveCsHeartbeatAck.prototype.clientSequence = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new ZtLiveCsHeartbeatAck instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.ZtLiveCsHeartbeatAck
         * @static
         * @param {AcFunDanmu.IZtLiveCsHeartbeatAck=} [properties] Properties to set
         * @returns {AcFunDanmu.ZtLiveCsHeartbeatAck} ZtLiveCsHeartbeatAck instance
         */
        ZtLiveCsHeartbeatAck.create = function create(properties) {
            return new ZtLiveCsHeartbeatAck(properties);
        };

        /**
         * Encodes the specified ZtLiveCsHeartbeatAck message. Does not implicitly {@link AcFunDanmu.ZtLiveCsHeartbeatAck.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.ZtLiveCsHeartbeatAck
         * @static
         * @param {AcFunDanmu.IZtLiveCsHeartbeatAck} message ZtLiveCsHeartbeatAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ZtLiveCsHeartbeatAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.serverTimestampMs != null && Object.hasOwnProperty.call(message, "serverTimestampMs"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.serverTimestampMs);
            if (message.clientTimestampMs != null && Object.hasOwnProperty.call(message, "clientTimestampMs"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.clientTimestampMs);
            if (message.clientSequence != null && Object.hasOwnProperty.call(message, "clientSequence"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.clientSequence);
            return writer;
        };

        /**
         * Encodes the specified ZtLiveCsHeartbeatAck message, length delimited. Does not implicitly {@link AcFunDanmu.ZtLiveCsHeartbeatAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.ZtLiveCsHeartbeatAck
         * @static
         * @param {AcFunDanmu.IZtLiveCsHeartbeatAck} message ZtLiveCsHeartbeatAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ZtLiveCsHeartbeatAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ZtLiveCsHeartbeatAck message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.ZtLiveCsHeartbeatAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.ZtLiveCsHeartbeatAck} ZtLiveCsHeartbeatAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ZtLiveCsHeartbeatAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.ZtLiveCsHeartbeatAck();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.serverTimestampMs = reader.int64();
                    break;
                case 2:
                    message.clientTimestampMs = reader.int64();
                    break;
                case 3:
                    message.clientSequence = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ZtLiveCsHeartbeatAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.ZtLiveCsHeartbeatAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.ZtLiveCsHeartbeatAck} ZtLiveCsHeartbeatAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ZtLiveCsHeartbeatAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ZtLiveCsHeartbeatAck message.
         * @function verify
         * @memberof AcFunDanmu.ZtLiveCsHeartbeatAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ZtLiveCsHeartbeatAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.serverTimestampMs != null && message.hasOwnProperty("serverTimestampMs"))
                if (!$util.isInteger(message.serverTimestampMs) && !(message.serverTimestampMs && $util.isInteger(message.serverTimestampMs.low) && $util.isInteger(message.serverTimestampMs.high)))
                    return "serverTimestampMs: integer|Long expected";
            if (message.clientTimestampMs != null && message.hasOwnProperty("clientTimestampMs"))
                if (!$util.isInteger(message.clientTimestampMs) && !(message.clientTimestampMs && $util.isInteger(message.clientTimestampMs.low) && $util.isInteger(message.clientTimestampMs.high)))
                    return "clientTimestampMs: integer|Long expected";
            if (message.clientSequence != null && message.hasOwnProperty("clientSequence"))
                if (!$util.isInteger(message.clientSequence) && !(message.clientSequence && $util.isInteger(message.clientSequence.low) && $util.isInteger(message.clientSequence.high)))
                    return "clientSequence: integer|Long expected";
            return null;
        };

        /**
         * Creates a ZtLiveCsHeartbeatAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.ZtLiveCsHeartbeatAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.ZtLiveCsHeartbeatAck} ZtLiveCsHeartbeatAck
         */
        ZtLiveCsHeartbeatAck.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.ZtLiveCsHeartbeatAck)
                return object;
            let message = new $root.AcFunDanmu.ZtLiveCsHeartbeatAck();
            if (object.serverTimestampMs != null)
                if ($util.Long)
                    (message.serverTimestampMs = $util.Long.fromValue(object.serverTimestampMs)).unsigned = false;
                else if (typeof object.serverTimestampMs === "string")
                    message.serverTimestampMs = parseInt(object.serverTimestampMs, 10);
                else if (typeof object.serverTimestampMs === "number")
                    message.serverTimestampMs = object.serverTimestampMs;
                else if (typeof object.serverTimestampMs === "object")
                    message.serverTimestampMs = new $util.LongBits(object.serverTimestampMs.low >>> 0, object.serverTimestampMs.high >>> 0).toNumber();
            if (object.clientTimestampMs != null)
                if ($util.Long)
                    (message.clientTimestampMs = $util.Long.fromValue(object.clientTimestampMs)).unsigned = false;
                else if (typeof object.clientTimestampMs === "string")
                    message.clientTimestampMs = parseInt(object.clientTimestampMs, 10);
                else if (typeof object.clientTimestampMs === "number")
                    message.clientTimestampMs = object.clientTimestampMs;
                else if (typeof object.clientTimestampMs === "object")
                    message.clientTimestampMs = new $util.LongBits(object.clientTimestampMs.low >>> 0, object.clientTimestampMs.high >>> 0).toNumber();
            if (object.clientSequence != null)
                if ($util.Long)
                    (message.clientSequence = $util.Long.fromValue(object.clientSequence)).unsigned = false;
                else if (typeof object.clientSequence === "string")
                    message.clientSequence = parseInt(object.clientSequence, 10);
                else if (typeof object.clientSequence === "number")
                    message.clientSequence = object.clientSequence;
                else if (typeof object.clientSequence === "object")
                    message.clientSequence = new $util.LongBits(object.clientSequence.low >>> 0, object.clientSequence.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a ZtLiveCsHeartbeatAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.ZtLiveCsHeartbeatAck
         * @static
         * @param {AcFunDanmu.ZtLiveCsHeartbeatAck} message ZtLiveCsHeartbeatAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ZtLiveCsHeartbeatAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.serverTimestampMs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.serverTimestampMs = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.clientTimestampMs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.clientTimestampMs = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.clientSequence = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.clientSequence = options.longs === String ? "0" : 0;
            }
            if (message.serverTimestampMs != null && message.hasOwnProperty("serverTimestampMs"))
                if (typeof message.serverTimestampMs === "number")
                    object.serverTimestampMs = options.longs === String ? String(message.serverTimestampMs) : message.serverTimestampMs;
                else
                    object.serverTimestampMs = options.longs === String ? $util.Long.prototype.toString.call(message.serverTimestampMs) : options.longs === Number ? new $util.LongBits(message.serverTimestampMs.low >>> 0, message.serverTimestampMs.high >>> 0).toNumber() : message.serverTimestampMs;
            if (message.clientTimestampMs != null && message.hasOwnProperty("clientTimestampMs"))
                if (typeof message.clientTimestampMs === "number")
                    object.clientTimestampMs = options.longs === String ? String(message.clientTimestampMs) : message.clientTimestampMs;
                else
                    object.clientTimestampMs = options.longs === String ? $util.Long.prototype.toString.call(message.clientTimestampMs) : options.longs === Number ? new $util.LongBits(message.clientTimestampMs.low >>> 0, message.clientTimestampMs.high >>> 0).toNumber() : message.clientTimestampMs;
            if (message.clientSequence != null && message.hasOwnProperty("clientSequence"))
                if (typeof message.clientSequence === "number")
                    object.clientSequence = options.longs === String ? String(message.clientSequence) : message.clientSequence;
                else
                    object.clientSequence = options.longs === String ? $util.Long.prototype.toString.call(message.clientSequence) : options.longs === Number ? new $util.LongBits(message.clientSequence.low >>> 0, message.clientSequence.high >>> 0).toNumber() : message.clientSequence;
            return object;
        };

        /**
         * Converts this ZtLiveCsHeartbeatAck to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.ZtLiveCsHeartbeatAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ZtLiveCsHeartbeatAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ZtLiveCsHeartbeatAck;
    })();

    AcFunDanmu.ZtLiveScMessage = (function() {

        /**
         * Properties of a ZtLiveScMessage.
         * @memberof AcFunDanmu
         * @interface IZtLiveScMessage
         * @property {string|null} [messageType] ZtLiveScMessage messageType
         * @property {AcFunDanmu.ZtLiveScMessage.CompressionType|null} [compressionType] ZtLiveScMessage compressionType
         * @property {Uint8Array|null} [payload] ZtLiveScMessage payload
         * @property {string|null} [liveId] ZtLiveScMessage liveId
         * @property {string|null} [ticket] ZtLiveScMessage ticket
         * @property {number|Long|null} [serverTimestampMs] ZtLiveScMessage serverTimestampMs
         */

        /**
         * Constructs a new ZtLiveScMessage.
         * @memberof AcFunDanmu
         * @classdesc Represents a ZtLiveScMessage.
         * @implements IZtLiveScMessage
         * @constructor
         * @param {AcFunDanmu.IZtLiveScMessage=} [properties] Properties to set
         */
        function ZtLiveScMessage(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ZtLiveScMessage messageType.
         * @member {string} messageType
         * @memberof AcFunDanmu.ZtLiveScMessage
         * @instance
         */
        ZtLiveScMessage.prototype.messageType = "";

        /**
         * ZtLiveScMessage compressionType.
         * @member {AcFunDanmu.ZtLiveScMessage.CompressionType} compressionType
         * @memberof AcFunDanmu.ZtLiveScMessage
         * @instance
         */
        ZtLiveScMessage.prototype.compressionType = 0;

        /**
         * ZtLiveScMessage payload.
         * @member {Uint8Array} payload
         * @memberof AcFunDanmu.ZtLiveScMessage
         * @instance
         */
        ZtLiveScMessage.prototype.payload = $util.newBuffer([]);

        /**
         * ZtLiveScMessage liveId.
         * @member {string} liveId
         * @memberof AcFunDanmu.ZtLiveScMessage
         * @instance
         */
        ZtLiveScMessage.prototype.liveId = "";

        /**
         * ZtLiveScMessage ticket.
         * @member {string} ticket
         * @memberof AcFunDanmu.ZtLiveScMessage
         * @instance
         */
        ZtLiveScMessage.prototype.ticket = "";

        /**
         * ZtLiveScMessage serverTimestampMs.
         * @member {number|Long} serverTimestampMs
         * @memberof AcFunDanmu.ZtLiveScMessage
         * @instance
         */
        ZtLiveScMessage.prototype.serverTimestampMs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new ZtLiveScMessage instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.ZtLiveScMessage
         * @static
         * @param {AcFunDanmu.IZtLiveScMessage=} [properties] Properties to set
         * @returns {AcFunDanmu.ZtLiveScMessage} ZtLiveScMessage instance
         */
        ZtLiveScMessage.create = function create(properties) {
            return new ZtLiveScMessage(properties);
        };

        /**
         * Encodes the specified ZtLiveScMessage message. Does not implicitly {@link AcFunDanmu.ZtLiveScMessage.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.ZtLiveScMessage
         * @static
         * @param {AcFunDanmu.IZtLiveScMessage} message ZtLiveScMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ZtLiveScMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.messageType != null && Object.hasOwnProperty.call(message, "messageType"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.messageType);
            if (message.compressionType != null && Object.hasOwnProperty.call(message, "compressionType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.compressionType);
            if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.payload);
            if (message.liveId != null && Object.hasOwnProperty.call(message, "liveId"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.liveId);
            if (message.ticket != null && Object.hasOwnProperty.call(message, "ticket"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.ticket);
            if (message.serverTimestampMs != null && Object.hasOwnProperty.call(message, "serverTimestampMs"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.serverTimestampMs);
            return writer;
        };

        /**
         * Encodes the specified ZtLiveScMessage message, length delimited. Does not implicitly {@link AcFunDanmu.ZtLiveScMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.ZtLiveScMessage
         * @static
         * @param {AcFunDanmu.IZtLiveScMessage} message ZtLiveScMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ZtLiveScMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ZtLiveScMessage message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.ZtLiveScMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.ZtLiveScMessage} ZtLiveScMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ZtLiveScMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.ZtLiveScMessage();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.messageType = reader.string();
                    break;
                case 2:
                    message.compressionType = reader.int32();
                    break;
                case 3:
                    message.payload = reader.bytes();
                    break;
                case 4:
                    message.liveId = reader.string();
                    break;
                case 5:
                    message.ticket = reader.string();
                    break;
                case 6:
                    message.serverTimestampMs = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ZtLiveScMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.ZtLiveScMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.ZtLiveScMessage} ZtLiveScMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ZtLiveScMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ZtLiveScMessage message.
         * @function verify
         * @memberof AcFunDanmu.ZtLiveScMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ZtLiveScMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.messageType != null && message.hasOwnProperty("messageType"))
                if (!$util.isString(message.messageType))
                    return "messageType: string expected";
            if (message.compressionType != null && message.hasOwnProperty("compressionType"))
                switch (message.compressionType) {
                default:
                    return "compressionType: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.payload != null && message.hasOwnProperty("payload"))
                if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                    return "payload: buffer expected";
            if (message.liveId != null && message.hasOwnProperty("liveId"))
                if (!$util.isString(message.liveId))
                    return "liveId: string expected";
            if (message.ticket != null && message.hasOwnProperty("ticket"))
                if (!$util.isString(message.ticket))
                    return "ticket: string expected";
            if (message.serverTimestampMs != null && message.hasOwnProperty("serverTimestampMs"))
                if (!$util.isInteger(message.serverTimestampMs) && !(message.serverTimestampMs && $util.isInteger(message.serverTimestampMs.low) && $util.isInteger(message.serverTimestampMs.high)))
                    return "serverTimestampMs: integer|Long expected";
            return null;
        };

        /**
         * Creates a ZtLiveScMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.ZtLiveScMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.ZtLiveScMessage} ZtLiveScMessage
         */
        ZtLiveScMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.ZtLiveScMessage)
                return object;
            let message = new $root.AcFunDanmu.ZtLiveScMessage();
            if (object.messageType != null)
                message.messageType = String(object.messageType);
            switch (object.compressionType) {
            case "UNKNOWN":
            case 0:
                message.compressionType = 0;
                break;
            case "NONE":
            case 1:
                message.compressionType = 1;
                break;
            case "GZIP":
            case 2:
                message.compressionType = 2;
                break;
            }
            if (object.payload != null)
                if (typeof object.payload === "string")
                    $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                else if (object.payload.length)
                    message.payload = object.payload;
            if (object.liveId != null)
                message.liveId = String(object.liveId);
            if (object.ticket != null)
                message.ticket = String(object.ticket);
            if (object.serverTimestampMs != null)
                if ($util.Long)
                    (message.serverTimestampMs = $util.Long.fromValue(object.serverTimestampMs)).unsigned = false;
                else if (typeof object.serverTimestampMs === "string")
                    message.serverTimestampMs = parseInt(object.serverTimestampMs, 10);
                else if (typeof object.serverTimestampMs === "number")
                    message.serverTimestampMs = object.serverTimestampMs;
                else if (typeof object.serverTimestampMs === "object")
                    message.serverTimestampMs = new $util.LongBits(object.serverTimestampMs.low >>> 0, object.serverTimestampMs.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a ZtLiveScMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.ZtLiveScMessage
         * @static
         * @param {AcFunDanmu.ZtLiveScMessage} message ZtLiveScMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ZtLiveScMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.messageType = "";
                object.compressionType = options.enums === String ? "UNKNOWN" : 0;
                if (options.bytes === String)
                    object.payload = "";
                else {
                    object.payload = [];
                    if (options.bytes !== Array)
                        object.payload = $util.newBuffer(object.payload);
                }
                object.liveId = "";
                object.ticket = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.serverTimestampMs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.serverTimestampMs = options.longs === String ? "0" : 0;
            }
            if (message.messageType != null && message.hasOwnProperty("messageType"))
                object.messageType = message.messageType;
            if (message.compressionType != null && message.hasOwnProperty("compressionType"))
                object.compressionType = options.enums === String ? $root.AcFunDanmu.ZtLiveScMessage.CompressionType[message.compressionType] : message.compressionType;
            if (message.payload != null && message.hasOwnProperty("payload"))
                object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
            if (message.liveId != null && message.hasOwnProperty("liveId"))
                object.liveId = message.liveId;
            if (message.ticket != null && message.hasOwnProperty("ticket"))
                object.ticket = message.ticket;
            if (message.serverTimestampMs != null && message.hasOwnProperty("serverTimestampMs"))
                if (typeof message.serverTimestampMs === "number")
                    object.serverTimestampMs = options.longs === String ? String(message.serverTimestampMs) : message.serverTimestampMs;
                else
                    object.serverTimestampMs = options.longs === String ? $util.Long.prototype.toString.call(message.serverTimestampMs) : options.longs === Number ? new $util.LongBits(message.serverTimestampMs.low >>> 0, message.serverTimestampMs.high >>> 0).toNumber() : message.serverTimestampMs;
            return object;
        };

        /**
         * Converts this ZtLiveScMessage to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.ZtLiveScMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ZtLiveScMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * CompressionType enum.
         * @name AcFunDanmu.ZtLiveScMessage.CompressionType
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} NONE=1 NONE value
         * @property {number} GZIP=2 GZIP value
         */
        ZtLiveScMessage.CompressionType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "NONE"] = 1;
            values[valuesById[2] = "GZIP"] = 2;
            return values;
        })();

        return ZtLiveScMessage;
    })();

    AcFunDanmu.ZtLiveActionSignalItem = (function() {

        /**
         * Properties of a ZtLiveActionSignalItem.
         * @memberof AcFunDanmu
         * @interface IZtLiveActionSignalItem
         * @property {string|null} [singalType] ZtLiveActionSignalItem singalType
         * @property {Array.<Uint8Array>|null} [payload] ZtLiveActionSignalItem payload
         */

        /**
         * Constructs a new ZtLiveActionSignalItem.
         * @memberof AcFunDanmu
         * @classdesc Represents a ZtLiveActionSignalItem.
         * @implements IZtLiveActionSignalItem
         * @constructor
         * @param {AcFunDanmu.IZtLiveActionSignalItem=} [properties] Properties to set
         */
        function ZtLiveActionSignalItem(properties) {
            this.payload = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ZtLiveActionSignalItem singalType.
         * @member {string} singalType
         * @memberof AcFunDanmu.ZtLiveActionSignalItem
         * @instance
         */
        ZtLiveActionSignalItem.prototype.singalType = "";

        /**
         * ZtLiveActionSignalItem payload.
         * @member {Array.<Uint8Array>} payload
         * @memberof AcFunDanmu.ZtLiveActionSignalItem
         * @instance
         */
        ZtLiveActionSignalItem.prototype.payload = $util.emptyArray;

        /**
         * Creates a new ZtLiveActionSignalItem instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.ZtLiveActionSignalItem
         * @static
         * @param {AcFunDanmu.IZtLiveActionSignalItem=} [properties] Properties to set
         * @returns {AcFunDanmu.ZtLiveActionSignalItem} ZtLiveActionSignalItem instance
         */
        ZtLiveActionSignalItem.create = function create(properties) {
            return new ZtLiveActionSignalItem(properties);
        };

        /**
         * Encodes the specified ZtLiveActionSignalItem message. Does not implicitly {@link AcFunDanmu.ZtLiveActionSignalItem.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.ZtLiveActionSignalItem
         * @static
         * @param {AcFunDanmu.IZtLiveActionSignalItem} message ZtLiveActionSignalItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ZtLiveActionSignalItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.singalType != null && Object.hasOwnProperty.call(message, "singalType"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.singalType);
            if (message.payload != null && message.payload.length)
                for (let i = 0; i < message.payload.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.payload[i]);
            return writer;
        };

        /**
         * Encodes the specified ZtLiveActionSignalItem message, length delimited. Does not implicitly {@link AcFunDanmu.ZtLiveActionSignalItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.ZtLiveActionSignalItem
         * @static
         * @param {AcFunDanmu.IZtLiveActionSignalItem} message ZtLiveActionSignalItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ZtLiveActionSignalItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ZtLiveActionSignalItem message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.ZtLiveActionSignalItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.ZtLiveActionSignalItem} ZtLiveActionSignalItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ZtLiveActionSignalItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.ZtLiveActionSignalItem();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.singalType = reader.string();
                    break;
                case 2:
                    if (!(message.payload && message.payload.length))
                        message.payload = [];
                    message.payload.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ZtLiveActionSignalItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.ZtLiveActionSignalItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.ZtLiveActionSignalItem} ZtLiveActionSignalItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ZtLiveActionSignalItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ZtLiveActionSignalItem message.
         * @function verify
         * @memberof AcFunDanmu.ZtLiveActionSignalItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ZtLiveActionSignalItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.singalType != null && message.hasOwnProperty("singalType"))
                if (!$util.isString(message.singalType))
                    return "singalType: string expected";
            if (message.payload != null && message.hasOwnProperty("payload")) {
                if (!Array.isArray(message.payload))
                    return "payload: array expected";
                for (let i = 0; i < message.payload.length; ++i)
                    if (!(message.payload[i] && typeof message.payload[i].length === "number" || $util.isString(message.payload[i])))
                        return "payload: buffer[] expected";
            }
            return null;
        };

        /**
         * Creates a ZtLiveActionSignalItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.ZtLiveActionSignalItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.ZtLiveActionSignalItem} ZtLiveActionSignalItem
         */
        ZtLiveActionSignalItem.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.ZtLiveActionSignalItem)
                return object;
            let message = new $root.AcFunDanmu.ZtLiveActionSignalItem();
            if (object.singalType != null)
                message.singalType = String(object.singalType);
            if (object.payload) {
                if (!Array.isArray(object.payload))
                    throw TypeError(".AcFunDanmu.ZtLiveActionSignalItem.payload: array expected");
                message.payload = [];
                for (let i = 0; i < object.payload.length; ++i)
                    if (typeof object.payload[i] === "string")
                        $util.base64.decode(object.payload[i], message.payload[i] = $util.newBuffer($util.base64.length(object.payload[i])), 0);
                    else if (object.payload[i].length)
                        message.payload[i] = object.payload[i];
            }
            return message;
        };

        /**
         * Creates a plain object from a ZtLiveActionSignalItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.ZtLiveActionSignalItem
         * @static
         * @param {AcFunDanmu.ZtLiveActionSignalItem} message ZtLiveActionSignalItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ZtLiveActionSignalItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.payload = [];
            if (options.defaults)
                object.singalType = "";
            if (message.singalType != null && message.hasOwnProperty("singalType"))
                object.singalType = message.singalType;
            if (message.payload && message.payload.length) {
                object.payload = [];
                for (let j = 0; j < message.payload.length; ++j)
                    object.payload[j] = options.bytes === String ? $util.base64.encode(message.payload[j], 0, message.payload[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.payload[j]) : message.payload[j];
            }
            return object;
        };

        /**
         * Converts this ZtLiveActionSignalItem to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.ZtLiveActionSignalItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ZtLiveActionSignalItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ZtLiveActionSignalItem;
    })();

    AcFunDanmu.ZtLiveScActionSignal = (function() {

        /**
         * Properties of a ZtLiveScActionSignal.
         * @memberof AcFunDanmu
         * @interface IZtLiveScActionSignal
         * @property {Array.<AcFunDanmu.IZtLiveActionSignalItem>|null} [item] ZtLiveScActionSignal item
         */

        /**
         * Constructs a new ZtLiveScActionSignal.
         * @memberof AcFunDanmu
         * @classdesc Represents a ZtLiveScActionSignal.
         * @implements IZtLiveScActionSignal
         * @constructor
         * @param {AcFunDanmu.IZtLiveScActionSignal=} [properties] Properties to set
         */
        function ZtLiveScActionSignal(properties) {
            this.item = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ZtLiveScActionSignal item.
         * @member {Array.<AcFunDanmu.IZtLiveActionSignalItem>} item
         * @memberof AcFunDanmu.ZtLiveScActionSignal
         * @instance
         */
        ZtLiveScActionSignal.prototype.item = $util.emptyArray;

        /**
         * Creates a new ZtLiveScActionSignal instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.ZtLiveScActionSignal
         * @static
         * @param {AcFunDanmu.IZtLiveScActionSignal=} [properties] Properties to set
         * @returns {AcFunDanmu.ZtLiveScActionSignal} ZtLiveScActionSignal instance
         */
        ZtLiveScActionSignal.create = function create(properties) {
            return new ZtLiveScActionSignal(properties);
        };

        /**
         * Encodes the specified ZtLiveScActionSignal message. Does not implicitly {@link AcFunDanmu.ZtLiveScActionSignal.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.ZtLiveScActionSignal
         * @static
         * @param {AcFunDanmu.IZtLiveScActionSignal} message ZtLiveScActionSignal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ZtLiveScActionSignal.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.item != null && message.item.length)
                for (let i = 0; i < message.item.length; ++i)
                    $root.AcFunDanmu.ZtLiveActionSignalItem.encode(message.item[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ZtLiveScActionSignal message, length delimited. Does not implicitly {@link AcFunDanmu.ZtLiveScActionSignal.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.ZtLiveScActionSignal
         * @static
         * @param {AcFunDanmu.IZtLiveScActionSignal} message ZtLiveScActionSignal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ZtLiveScActionSignal.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ZtLiveScActionSignal message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.ZtLiveScActionSignal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.ZtLiveScActionSignal} ZtLiveScActionSignal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ZtLiveScActionSignal.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.ZtLiveScActionSignal();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.item && message.item.length))
                        message.item = [];
                    message.item.push($root.AcFunDanmu.ZtLiveActionSignalItem.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ZtLiveScActionSignal message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.ZtLiveScActionSignal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.ZtLiveScActionSignal} ZtLiveScActionSignal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ZtLiveScActionSignal.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ZtLiveScActionSignal message.
         * @function verify
         * @memberof AcFunDanmu.ZtLiveScActionSignal
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ZtLiveScActionSignal.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.item != null && message.hasOwnProperty("item")) {
                if (!Array.isArray(message.item))
                    return "item: array expected";
                for (let i = 0; i < message.item.length; ++i) {
                    let error = $root.AcFunDanmu.ZtLiveActionSignalItem.verify(message.item[i]);
                    if (error)
                        return "item." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ZtLiveScActionSignal message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.ZtLiveScActionSignal
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.ZtLiveScActionSignal} ZtLiveScActionSignal
         */
        ZtLiveScActionSignal.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.ZtLiveScActionSignal)
                return object;
            let message = new $root.AcFunDanmu.ZtLiveScActionSignal();
            if (object.item) {
                if (!Array.isArray(object.item))
                    throw TypeError(".AcFunDanmu.ZtLiveScActionSignal.item: array expected");
                message.item = [];
                for (let i = 0; i < object.item.length; ++i) {
                    if (typeof object.item[i] !== "object")
                        throw TypeError(".AcFunDanmu.ZtLiveScActionSignal.item: object expected");
                    message.item[i] = $root.AcFunDanmu.ZtLiveActionSignalItem.fromObject(object.item[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ZtLiveScActionSignal message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.ZtLiveScActionSignal
         * @static
         * @param {AcFunDanmu.ZtLiveScActionSignal} message ZtLiveScActionSignal
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ZtLiveScActionSignal.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.item = [];
            if (message.item && message.item.length) {
                object.item = [];
                for (let j = 0; j < message.item.length; ++j)
                    object.item[j] = $root.AcFunDanmu.ZtLiveActionSignalItem.toObject(message.item[j], options);
            }
            return object;
        };

        /**
         * Converts this ZtLiveScActionSignal to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.ZtLiveScActionSignal
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ZtLiveScActionSignal.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ZtLiveScActionSignal;
    })();

    AcFunDanmu.ZtLiveStateSignalItem = (function() {

        /**
         * Properties of a ZtLiveStateSignalItem.
         * @memberof AcFunDanmu
         * @interface IZtLiveStateSignalItem
         * @property {string|null} [singalType] ZtLiveStateSignalItem singalType
         * @property {Uint8Array|null} [payload] ZtLiveStateSignalItem payload
         */

        /**
         * Constructs a new ZtLiveStateSignalItem.
         * @memberof AcFunDanmu
         * @classdesc Represents a ZtLiveStateSignalItem.
         * @implements IZtLiveStateSignalItem
         * @constructor
         * @param {AcFunDanmu.IZtLiveStateSignalItem=} [properties] Properties to set
         */
        function ZtLiveStateSignalItem(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ZtLiveStateSignalItem singalType.
         * @member {string} singalType
         * @memberof AcFunDanmu.ZtLiveStateSignalItem
         * @instance
         */
        ZtLiveStateSignalItem.prototype.singalType = "";

        /**
         * ZtLiveStateSignalItem payload.
         * @member {Uint8Array} payload
         * @memberof AcFunDanmu.ZtLiveStateSignalItem
         * @instance
         */
        ZtLiveStateSignalItem.prototype.payload = $util.newBuffer([]);

        /**
         * Creates a new ZtLiveStateSignalItem instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.ZtLiveStateSignalItem
         * @static
         * @param {AcFunDanmu.IZtLiveStateSignalItem=} [properties] Properties to set
         * @returns {AcFunDanmu.ZtLiveStateSignalItem} ZtLiveStateSignalItem instance
         */
        ZtLiveStateSignalItem.create = function create(properties) {
            return new ZtLiveStateSignalItem(properties);
        };

        /**
         * Encodes the specified ZtLiveStateSignalItem message. Does not implicitly {@link AcFunDanmu.ZtLiveStateSignalItem.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.ZtLiveStateSignalItem
         * @static
         * @param {AcFunDanmu.IZtLiveStateSignalItem} message ZtLiveStateSignalItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ZtLiveStateSignalItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.singalType != null && Object.hasOwnProperty.call(message, "singalType"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.singalType);
            if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.payload);
            return writer;
        };

        /**
         * Encodes the specified ZtLiveStateSignalItem message, length delimited. Does not implicitly {@link AcFunDanmu.ZtLiveStateSignalItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.ZtLiveStateSignalItem
         * @static
         * @param {AcFunDanmu.IZtLiveStateSignalItem} message ZtLiveStateSignalItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ZtLiveStateSignalItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ZtLiveStateSignalItem message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.ZtLiveStateSignalItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.ZtLiveStateSignalItem} ZtLiveStateSignalItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ZtLiveStateSignalItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.ZtLiveStateSignalItem();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.singalType = reader.string();
                    break;
                case 2:
                    message.payload = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ZtLiveStateSignalItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.ZtLiveStateSignalItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.ZtLiveStateSignalItem} ZtLiveStateSignalItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ZtLiveStateSignalItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ZtLiveStateSignalItem message.
         * @function verify
         * @memberof AcFunDanmu.ZtLiveStateSignalItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ZtLiveStateSignalItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.singalType != null && message.hasOwnProperty("singalType"))
                if (!$util.isString(message.singalType))
                    return "singalType: string expected";
            if (message.payload != null && message.hasOwnProperty("payload"))
                if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                    return "payload: buffer expected";
            return null;
        };

        /**
         * Creates a ZtLiveStateSignalItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.ZtLiveStateSignalItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.ZtLiveStateSignalItem} ZtLiveStateSignalItem
         */
        ZtLiveStateSignalItem.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.ZtLiveStateSignalItem)
                return object;
            let message = new $root.AcFunDanmu.ZtLiveStateSignalItem();
            if (object.singalType != null)
                message.singalType = String(object.singalType);
            if (object.payload != null)
                if (typeof object.payload === "string")
                    $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                else if (object.payload.length)
                    message.payload = object.payload;
            return message;
        };

        /**
         * Creates a plain object from a ZtLiveStateSignalItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.ZtLiveStateSignalItem
         * @static
         * @param {AcFunDanmu.ZtLiveStateSignalItem} message ZtLiveStateSignalItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ZtLiveStateSignalItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.singalType = "";
                if (options.bytes === String)
                    object.payload = "";
                else {
                    object.payload = [];
                    if (options.bytes !== Array)
                        object.payload = $util.newBuffer(object.payload);
                }
            }
            if (message.singalType != null && message.hasOwnProperty("singalType"))
                object.singalType = message.singalType;
            if (message.payload != null && message.hasOwnProperty("payload"))
                object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
            return object;
        };

        /**
         * Converts this ZtLiveStateSignalItem to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.ZtLiveStateSignalItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ZtLiveStateSignalItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ZtLiveStateSignalItem;
    })();

    AcFunDanmu.ZtLiveScStateSignal = (function() {

        /**
         * Properties of a ZtLiveScStateSignal.
         * @memberof AcFunDanmu
         * @interface IZtLiveScStateSignal
         * @property {Array.<AcFunDanmu.IZtLiveStateSignalItem>|null} [item] ZtLiveScStateSignal item
         */

        /**
         * Constructs a new ZtLiveScStateSignal.
         * @memberof AcFunDanmu
         * @classdesc Represents a ZtLiveScStateSignal.
         * @implements IZtLiveScStateSignal
         * @constructor
         * @param {AcFunDanmu.IZtLiveScStateSignal=} [properties] Properties to set
         */
        function ZtLiveScStateSignal(properties) {
            this.item = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ZtLiveScStateSignal item.
         * @member {Array.<AcFunDanmu.IZtLiveStateSignalItem>} item
         * @memberof AcFunDanmu.ZtLiveScStateSignal
         * @instance
         */
        ZtLiveScStateSignal.prototype.item = $util.emptyArray;

        /**
         * Creates a new ZtLiveScStateSignal instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.ZtLiveScStateSignal
         * @static
         * @param {AcFunDanmu.IZtLiveScStateSignal=} [properties] Properties to set
         * @returns {AcFunDanmu.ZtLiveScStateSignal} ZtLiveScStateSignal instance
         */
        ZtLiveScStateSignal.create = function create(properties) {
            return new ZtLiveScStateSignal(properties);
        };

        /**
         * Encodes the specified ZtLiveScStateSignal message. Does not implicitly {@link AcFunDanmu.ZtLiveScStateSignal.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.ZtLiveScStateSignal
         * @static
         * @param {AcFunDanmu.IZtLiveScStateSignal} message ZtLiveScStateSignal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ZtLiveScStateSignal.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.item != null && message.item.length)
                for (let i = 0; i < message.item.length; ++i)
                    $root.AcFunDanmu.ZtLiveStateSignalItem.encode(message.item[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ZtLiveScStateSignal message, length delimited. Does not implicitly {@link AcFunDanmu.ZtLiveScStateSignal.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.ZtLiveScStateSignal
         * @static
         * @param {AcFunDanmu.IZtLiveScStateSignal} message ZtLiveScStateSignal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ZtLiveScStateSignal.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ZtLiveScStateSignal message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.ZtLiveScStateSignal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.ZtLiveScStateSignal} ZtLiveScStateSignal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ZtLiveScStateSignal.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.ZtLiveScStateSignal();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.item && message.item.length))
                        message.item = [];
                    message.item.push($root.AcFunDanmu.ZtLiveStateSignalItem.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ZtLiveScStateSignal message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.ZtLiveScStateSignal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.ZtLiveScStateSignal} ZtLiveScStateSignal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ZtLiveScStateSignal.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ZtLiveScStateSignal message.
         * @function verify
         * @memberof AcFunDanmu.ZtLiveScStateSignal
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ZtLiveScStateSignal.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.item != null && message.hasOwnProperty("item")) {
                if (!Array.isArray(message.item))
                    return "item: array expected";
                for (let i = 0; i < message.item.length; ++i) {
                    let error = $root.AcFunDanmu.ZtLiveStateSignalItem.verify(message.item[i]);
                    if (error)
                        return "item." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ZtLiveScStateSignal message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.ZtLiveScStateSignal
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.ZtLiveScStateSignal} ZtLiveScStateSignal
         */
        ZtLiveScStateSignal.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.ZtLiveScStateSignal)
                return object;
            let message = new $root.AcFunDanmu.ZtLiveScStateSignal();
            if (object.item) {
                if (!Array.isArray(object.item))
                    throw TypeError(".AcFunDanmu.ZtLiveScStateSignal.item: array expected");
                message.item = [];
                for (let i = 0; i < object.item.length; ++i) {
                    if (typeof object.item[i] !== "object")
                        throw TypeError(".AcFunDanmu.ZtLiveScStateSignal.item: object expected");
                    message.item[i] = $root.AcFunDanmu.ZtLiveStateSignalItem.fromObject(object.item[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ZtLiveScStateSignal message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.ZtLiveScStateSignal
         * @static
         * @param {AcFunDanmu.ZtLiveScStateSignal} message ZtLiveScStateSignal
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ZtLiveScStateSignal.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.item = [];
            if (message.item && message.item.length) {
                object.item = [];
                for (let j = 0; j < message.item.length; ++j)
                    object.item[j] = $root.AcFunDanmu.ZtLiveStateSignalItem.toObject(message.item[j], options);
            }
            return object;
        };

        /**
         * Converts this ZtLiveScStateSignal to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.ZtLiveScStateSignal
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ZtLiveScStateSignal.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ZtLiveScStateSignal;
    })();

    AcFunDanmu.ZtLiveNotifySignalItem = (function() {

        /**
         * Properties of a ZtLiveNotifySignalItem.
         * @memberof AcFunDanmu
         * @interface IZtLiveNotifySignalItem
         * @property {string|null} [signalType] ZtLiveNotifySignalItem signalType
         * @property {Uint8Array|null} [payload] ZtLiveNotifySignalItem payload
         */

        /**
         * Constructs a new ZtLiveNotifySignalItem.
         * @memberof AcFunDanmu
         * @classdesc Represents a ZtLiveNotifySignalItem.
         * @implements IZtLiveNotifySignalItem
         * @constructor
         * @param {AcFunDanmu.IZtLiveNotifySignalItem=} [properties] Properties to set
         */
        function ZtLiveNotifySignalItem(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ZtLiveNotifySignalItem signalType.
         * @member {string} signalType
         * @memberof AcFunDanmu.ZtLiveNotifySignalItem
         * @instance
         */
        ZtLiveNotifySignalItem.prototype.signalType = "";

        /**
         * ZtLiveNotifySignalItem payload.
         * @member {Uint8Array} payload
         * @memberof AcFunDanmu.ZtLiveNotifySignalItem
         * @instance
         */
        ZtLiveNotifySignalItem.prototype.payload = $util.newBuffer([]);

        /**
         * Creates a new ZtLiveNotifySignalItem instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.ZtLiveNotifySignalItem
         * @static
         * @param {AcFunDanmu.IZtLiveNotifySignalItem=} [properties] Properties to set
         * @returns {AcFunDanmu.ZtLiveNotifySignalItem} ZtLiveNotifySignalItem instance
         */
        ZtLiveNotifySignalItem.create = function create(properties) {
            return new ZtLiveNotifySignalItem(properties);
        };

        /**
         * Encodes the specified ZtLiveNotifySignalItem message. Does not implicitly {@link AcFunDanmu.ZtLiveNotifySignalItem.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.ZtLiveNotifySignalItem
         * @static
         * @param {AcFunDanmu.IZtLiveNotifySignalItem} message ZtLiveNotifySignalItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ZtLiveNotifySignalItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.signalType != null && Object.hasOwnProperty.call(message, "signalType"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.signalType);
            if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.payload);
            return writer;
        };

        /**
         * Encodes the specified ZtLiveNotifySignalItem message, length delimited. Does not implicitly {@link AcFunDanmu.ZtLiveNotifySignalItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.ZtLiveNotifySignalItem
         * @static
         * @param {AcFunDanmu.IZtLiveNotifySignalItem} message ZtLiveNotifySignalItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ZtLiveNotifySignalItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ZtLiveNotifySignalItem message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.ZtLiveNotifySignalItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.ZtLiveNotifySignalItem} ZtLiveNotifySignalItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ZtLiveNotifySignalItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.ZtLiveNotifySignalItem();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.signalType = reader.string();
                    break;
                case 2:
                    message.payload = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ZtLiveNotifySignalItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.ZtLiveNotifySignalItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.ZtLiveNotifySignalItem} ZtLiveNotifySignalItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ZtLiveNotifySignalItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ZtLiveNotifySignalItem message.
         * @function verify
         * @memberof AcFunDanmu.ZtLiveNotifySignalItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ZtLiveNotifySignalItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.signalType != null && message.hasOwnProperty("signalType"))
                if (!$util.isString(message.signalType))
                    return "signalType: string expected";
            if (message.payload != null && message.hasOwnProperty("payload"))
                if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                    return "payload: buffer expected";
            return null;
        };

        /**
         * Creates a ZtLiveNotifySignalItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.ZtLiveNotifySignalItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.ZtLiveNotifySignalItem} ZtLiveNotifySignalItem
         */
        ZtLiveNotifySignalItem.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.ZtLiveNotifySignalItem)
                return object;
            let message = new $root.AcFunDanmu.ZtLiveNotifySignalItem();
            if (object.signalType != null)
                message.signalType = String(object.signalType);
            if (object.payload != null)
                if (typeof object.payload === "string")
                    $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                else if (object.payload.length)
                    message.payload = object.payload;
            return message;
        };

        /**
         * Creates a plain object from a ZtLiveNotifySignalItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.ZtLiveNotifySignalItem
         * @static
         * @param {AcFunDanmu.ZtLiveNotifySignalItem} message ZtLiveNotifySignalItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ZtLiveNotifySignalItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.signalType = "";
                if (options.bytes === String)
                    object.payload = "";
                else {
                    object.payload = [];
                    if (options.bytes !== Array)
                        object.payload = $util.newBuffer(object.payload);
                }
            }
            if (message.signalType != null && message.hasOwnProperty("signalType"))
                object.signalType = message.signalType;
            if (message.payload != null && message.hasOwnProperty("payload"))
                object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
            return object;
        };

        /**
         * Converts this ZtLiveNotifySignalItem to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.ZtLiveNotifySignalItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ZtLiveNotifySignalItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ZtLiveNotifySignalItem;
    })();

    AcFunDanmu.ZtLiveScNotifySignal = (function() {

        /**
         * Properties of a ZtLiveScNotifySignal.
         * @memberof AcFunDanmu
         * @interface IZtLiveScNotifySignal
         * @property {Array.<AcFunDanmu.IZtLiveNotifySignalItem>|null} [item] ZtLiveScNotifySignal item
         */

        /**
         * Constructs a new ZtLiveScNotifySignal.
         * @memberof AcFunDanmu
         * @classdesc Represents a ZtLiveScNotifySignal.
         * @implements IZtLiveScNotifySignal
         * @constructor
         * @param {AcFunDanmu.IZtLiveScNotifySignal=} [properties] Properties to set
         */
        function ZtLiveScNotifySignal(properties) {
            this.item = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ZtLiveScNotifySignal item.
         * @member {Array.<AcFunDanmu.IZtLiveNotifySignalItem>} item
         * @memberof AcFunDanmu.ZtLiveScNotifySignal
         * @instance
         */
        ZtLiveScNotifySignal.prototype.item = $util.emptyArray;

        /**
         * Creates a new ZtLiveScNotifySignal instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.ZtLiveScNotifySignal
         * @static
         * @param {AcFunDanmu.IZtLiveScNotifySignal=} [properties] Properties to set
         * @returns {AcFunDanmu.ZtLiveScNotifySignal} ZtLiveScNotifySignal instance
         */
        ZtLiveScNotifySignal.create = function create(properties) {
            return new ZtLiveScNotifySignal(properties);
        };

        /**
         * Encodes the specified ZtLiveScNotifySignal message. Does not implicitly {@link AcFunDanmu.ZtLiveScNotifySignal.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.ZtLiveScNotifySignal
         * @static
         * @param {AcFunDanmu.IZtLiveScNotifySignal} message ZtLiveScNotifySignal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ZtLiveScNotifySignal.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.item != null && message.item.length)
                for (let i = 0; i < message.item.length; ++i)
                    $root.AcFunDanmu.ZtLiveNotifySignalItem.encode(message.item[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ZtLiveScNotifySignal message, length delimited. Does not implicitly {@link AcFunDanmu.ZtLiveScNotifySignal.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.ZtLiveScNotifySignal
         * @static
         * @param {AcFunDanmu.IZtLiveScNotifySignal} message ZtLiveScNotifySignal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ZtLiveScNotifySignal.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ZtLiveScNotifySignal message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.ZtLiveScNotifySignal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.ZtLiveScNotifySignal} ZtLiveScNotifySignal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ZtLiveScNotifySignal.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.ZtLiveScNotifySignal();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.item && message.item.length))
                        message.item = [];
                    message.item.push($root.AcFunDanmu.ZtLiveNotifySignalItem.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ZtLiveScNotifySignal message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.ZtLiveScNotifySignal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.ZtLiveScNotifySignal} ZtLiveScNotifySignal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ZtLiveScNotifySignal.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ZtLiveScNotifySignal message.
         * @function verify
         * @memberof AcFunDanmu.ZtLiveScNotifySignal
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ZtLiveScNotifySignal.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.item != null && message.hasOwnProperty("item")) {
                if (!Array.isArray(message.item))
                    return "item: array expected";
                for (let i = 0; i < message.item.length; ++i) {
                    let error = $root.AcFunDanmu.ZtLiveNotifySignalItem.verify(message.item[i]);
                    if (error)
                        return "item." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ZtLiveScNotifySignal message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.ZtLiveScNotifySignal
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.ZtLiveScNotifySignal} ZtLiveScNotifySignal
         */
        ZtLiveScNotifySignal.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.ZtLiveScNotifySignal)
                return object;
            let message = new $root.AcFunDanmu.ZtLiveScNotifySignal();
            if (object.item) {
                if (!Array.isArray(object.item))
                    throw TypeError(".AcFunDanmu.ZtLiveScNotifySignal.item: array expected");
                message.item = [];
                for (let i = 0; i < object.item.length; ++i) {
                    if (typeof object.item[i] !== "object")
                        throw TypeError(".AcFunDanmu.ZtLiveScNotifySignal.item: object expected");
                    message.item[i] = $root.AcFunDanmu.ZtLiveNotifySignalItem.fromObject(object.item[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ZtLiveScNotifySignal message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.ZtLiveScNotifySignal
         * @static
         * @param {AcFunDanmu.ZtLiveScNotifySignal} message ZtLiveScNotifySignal
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ZtLiveScNotifySignal.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.item = [];
            if (message.item && message.item.length) {
                object.item = [];
                for (let j = 0; j < message.item.length; ++j)
                    object.item[j] = $root.AcFunDanmu.ZtLiveNotifySignalItem.toObject(message.item[j], options);
            }
            return object;
        };

        /**
         * Converts this ZtLiveScNotifySignal to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.ZtLiveScNotifySignal
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ZtLiveScNotifySignal.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ZtLiveScNotifySignal;
    })();

    AcFunDanmu.ZtLiveScStatusChanged = (function() {

        /**
         * Properties of a ZtLiveScStatusChanged.
         * @memberof AcFunDanmu
         * @interface IZtLiveScStatusChanged
         * @property {AcFunDanmu.ZtLiveScStatusChanged.Type|null} [type] ZtLiveScStatusChanged type
         * @property {number|Long|null} [maxRandomDelayMs] ZtLiveScStatusChanged maxRandomDelayMs
         * @property {AcFunDanmu.ZtLiveScStatusChanged.IBannedInfo|null} [bannedInfo] ZtLiveScStatusChanged bannedInfo
         */

        /**
         * Constructs a new ZtLiveScStatusChanged.
         * @memberof AcFunDanmu
         * @classdesc Represents a ZtLiveScStatusChanged.
         * @implements IZtLiveScStatusChanged
         * @constructor
         * @param {AcFunDanmu.IZtLiveScStatusChanged=} [properties] Properties to set
         */
        function ZtLiveScStatusChanged(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ZtLiveScStatusChanged type.
         * @member {AcFunDanmu.ZtLiveScStatusChanged.Type} type
         * @memberof AcFunDanmu.ZtLiveScStatusChanged
         * @instance
         */
        ZtLiveScStatusChanged.prototype.type = 0;

        /**
         * ZtLiveScStatusChanged maxRandomDelayMs.
         * @member {number|Long} maxRandomDelayMs
         * @memberof AcFunDanmu.ZtLiveScStatusChanged
         * @instance
         */
        ZtLiveScStatusChanged.prototype.maxRandomDelayMs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ZtLiveScStatusChanged bannedInfo.
         * @member {AcFunDanmu.ZtLiveScStatusChanged.IBannedInfo|null|undefined} bannedInfo
         * @memberof AcFunDanmu.ZtLiveScStatusChanged
         * @instance
         */
        ZtLiveScStatusChanged.prototype.bannedInfo = null;

        /**
         * Creates a new ZtLiveScStatusChanged instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.ZtLiveScStatusChanged
         * @static
         * @param {AcFunDanmu.IZtLiveScStatusChanged=} [properties] Properties to set
         * @returns {AcFunDanmu.ZtLiveScStatusChanged} ZtLiveScStatusChanged instance
         */
        ZtLiveScStatusChanged.create = function create(properties) {
            return new ZtLiveScStatusChanged(properties);
        };

        /**
         * Encodes the specified ZtLiveScStatusChanged message. Does not implicitly {@link AcFunDanmu.ZtLiveScStatusChanged.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.ZtLiveScStatusChanged
         * @static
         * @param {AcFunDanmu.IZtLiveScStatusChanged} message ZtLiveScStatusChanged message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ZtLiveScStatusChanged.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.maxRandomDelayMs != null && Object.hasOwnProperty.call(message, "maxRandomDelayMs"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.maxRandomDelayMs);
            if (message.bannedInfo != null && Object.hasOwnProperty.call(message, "bannedInfo"))
                $root.AcFunDanmu.ZtLiveScStatusChanged.BannedInfo.encode(message.bannedInfo, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ZtLiveScStatusChanged message, length delimited. Does not implicitly {@link AcFunDanmu.ZtLiveScStatusChanged.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.ZtLiveScStatusChanged
         * @static
         * @param {AcFunDanmu.IZtLiveScStatusChanged} message ZtLiveScStatusChanged message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ZtLiveScStatusChanged.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ZtLiveScStatusChanged message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.ZtLiveScStatusChanged
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.ZtLiveScStatusChanged} ZtLiveScStatusChanged
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ZtLiveScStatusChanged.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.ZtLiveScStatusChanged();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.maxRandomDelayMs = reader.int64();
                    break;
                case 3:
                    message.bannedInfo = $root.AcFunDanmu.ZtLiveScStatusChanged.BannedInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ZtLiveScStatusChanged message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.ZtLiveScStatusChanged
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.ZtLiveScStatusChanged} ZtLiveScStatusChanged
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ZtLiveScStatusChanged.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ZtLiveScStatusChanged message.
         * @function verify
         * @memberof AcFunDanmu.ZtLiveScStatusChanged
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ZtLiveScStatusChanged.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.maxRandomDelayMs != null && message.hasOwnProperty("maxRandomDelayMs"))
                if (!$util.isInteger(message.maxRandomDelayMs) && !(message.maxRandomDelayMs && $util.isInteger(message.maxRandomDelayMs.low) && $util.isInteger(message.maxRandomDelayMs.high)))
                    return "maxRandomDelayMs: integer|Long expected";
            if (message.bannedInfo != null && message.hasOwnProperty("bannedInfo")) {
                let error = $root.AcFunDanmu.ZtLiveScStatusChanged.BannedInfo.verify(message.bannedInfo);
                if (error)
                    return "bannedInfo." + error;
            }
            return null;
        };

        /**
         * Creates a ZtLiveScStatusChanged message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.ZtLiveScStatusChanged
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.ZtLiveScStatusChanged} ZtLiveScStatusChanged
         */
        ZtLiveScStatusChanged.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.ZtLiveScStatusChanged)
                return object;
            let message = new $root.AcFunDanmu.ZtLiveScStatusChanged();
            switch (object.type) {
            case "UNKNOWN":
            case 0:
                message.type = 0;
                break;
            case "LIVE_CLOSED":
            case 1:
                message.type = 1;
                break;
            case "LIVE_REOPENED":
            case 2:
                message.type = 2;
                break;
            case "LIVE_URL_CHANGED":
            case 3:
                message.type = 3;
                break;
            case "LIVE_BANNED":
            case 4:
                message.type = 4;
                break;
            }
            if (object.maxRandomDelayMs != null)
                if ($util.Long)
                    (message.maxRandomDelayMs = $util.Long.fromValue(object.maxRandomDelayMs)).unsigned = false;
                else if (typeof object.maxRandomDelayMs === "string")
                    message.maxRandomDelayMs = parseInt(object.maxRandomDelayMs, 10);
                else if (typeof object.maxRandomDelayMs === "number")
                    message.maxRandomDelayMs = object.maxRandomDelayMs;
                else if (typeof object.maxRandomDelayMs === "object")
                    message.maxRandomDelayMs = new $util.LongBits(object.maxRandomDelayMs.low >>> 0, object.maxRandomDelayMs.high >>> 0).toNumber();
            if (object.bannedInfo != null) {
                if (typeof object.bannedInfo !== "object")
                    throw TypeError(".AcFunDanmu.ZtLiveScStatusChanged.bannedInfo: object expected");
                message.bannedInfo = $root.AcFunDanmu.ZtLiveScStatusChanged.BannedInfo.fromObject(object.bannedInfo);
            }
            return message;
        };

        /**
         * Creates a plain object from a ZtLiveScStatusChanged message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.ZtLiveScStatusChanged
         * @static
         * @param {AcFunDanmu.ZtLiveScStatusChanged} message ZtLiveScStatusChanged
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ZtLiveScStatusChanged.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.type = options.enums === String ? "UNKNOWN" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.maxRandomDelayMs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.maxRandomDelayMs = options.longs === String ? "0" : 0;
                object.bannedInfo = null;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.AcFunDanmu.ZtLiveScStatusChanged.Type[message.type] : message.type;
            if (message.maxRandomDelayMs != null && message.hasOwnProperty("maxRandomDelayMs"))
                if (typeof message.maxRandomDelayMs === "number")
                    object.maxRandomDelayMs = options.longs === String ? String(message.maxRandomDelayMs) : message.maxRandomDelayMs;
                else
                    object.maxRandomDelayMs = options.longs === String ? $util.Long.prototype.toString.call(message.maxRandomDelayMs) : options.longs === Number ? new $util.LongBits(message.maxRandomDelayMs.low >>> 0, message.maxRandomDelayMs.high >>> 0).toNumber() : message.maxRandomDelayMs;
            if (message.bannedInfo != null && message.hasOwnProperty("bannedInfo"))
                object.bannedInfo = $root.AcFunDanmu.ZtLiveScStatusChanged.BannedInfo.toObject(message.bannedInfo, options);
            return object;
        };

        /**
         * Converts this ZtLiveScStatusChanged to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.ZtLiveScStatusChanged
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ZtLiveScStatusChanged.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Type enum.
         * @name AcFunDanmu.ZtLiveScStatusChanged.Type
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} LIVE_CLOSED=1 LIVE_CLOSED value
         * @property {number} LIVE_REOPENED=2 LIVE_REOPENED value
         * @property {number} LIVE_URL_CHANGED=3 LIVE_URL_CHANGED value
         * @property {number} LIVE_BANNED=4 LIVE_BANNED value
         */
        ZtLiveScStatusChanged.Type = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "LIVE_CLOSED"] = 1;
            values[valuesById[2] = "LIVE_REOPENED"] = 2;
            values[valuesById[3] = "LIVE_URL_CHANGED"] = 3;
            values[valuesById[4] = "LIVE_BANNED"] = 4;
            return values;
        })();

        ZtLiveScStatusChanged.BannedInfo = (function() {

            /**
             * Properties of a BannedInfo.
             * @memberof AcFunDanmu.ZtLiveScStatusChanged
             * @interface IBannedInfo
             * @property {string|null} [banReason] BannedInfo banReason
             */

            /**
             * Constructs a new BannedInfo.
             * @memberof AcFunDanmu.ZtLiveScStatusChanged
             * @classdesc Represents a BannedInfo.
             * @implements IBannedInfo
             * @constructor
             * @param {AcFunDanmu.ZtLiveScStatusChanged.IBannedInfo=} [properties] Properties to set
             */
            function BannedInfo(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BannedInfo banReason.
             * @member {string} banReason
             * @memberof AcFunDanmu.ZtLiveScStatusChanged.BannedInfo
             * @instance
             */
            BannedInfo.prototype.banReason = "";

            /**
             * Creates a new BannedInfo instance using the specified properties.
             * @function create
             * @memberof AcFunDanmu.ZtLiveScStatusChanged.BannedInfo
             * @static
             * @param {AcFunDanmu.ZtLiveScStatusChanged.IBannedInfo=} [properties] Properties to set
             * @returns {AcFunDanmu.ZtLiveScStatusChanged.BannedInfo} BannedInfo instance
             */
            BannedInfo.create = function create(properties) {
                return new BannedInfo(properties);
            };

            /**
             * Encodes the specified BannedInfo message. Does not implicitly {@link AcFunDanmu.ZtLiveScStatusChanged.BannedInfo.verify|verify} messages.
             * @function encode
             * @memberof AcFunDanmu.ZtLiveScStatusChanged.BannedInfo
             * @static
             * @param {AcFunDanmu.ZtLiveScStatusChanged.IBannedInfo} message BannedInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BannedInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.banReason != null && Object.hasOwnProperty.call(message, "banReason"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.banReason);
                return writer;
            };

            /**
             * Encodes the specified BannedInfo message, length delimited. Does not implicitly {@link AcFunDanmu.ZtLiveScStatusChanged.BannedInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof AcFunDanmu.ZtLiveScStatusChanged.BannedInfo
             * @static
             * @param {AcFunDanmu.ZtLiveScStatusChanged.IBannedInfo} message BannedInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BannedInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BannedInfo message from the specified reader or buffer.
             * @function decode
             * @memberof AcFunDanmu.ZtLiveScStatusChanged.BannedInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {AcFunDanmu.ZtLiveScStatusChanged.BannedInfo} BannedInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BannedInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.ZtLiveScStatusChanged.BannedInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.banReason = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BannedInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof AcFunDanmu.ZtLiveScStatusChanged.BannedInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {AcFunDanmu.ZtLiveScStatusChanged.BannedInfo} BannedInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BannedInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BannedInfo message.
             * @function verify
             * @memberof AcFunDanmu.ZtLiveScStatusChanged.BannedInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BannedInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.banReason != null && message.hasOwnProperty("banReason"))
                    if (!$util.isString(message.banReason))
                        return "banReason: string expected";
                return null;
            };

            /**
             * Creates a BannedInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof AcFunDanmu.ZtLiveScStatusChanged.BannedInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {AcFunDanmu.ZtLiveScStatusChanged.BannedInfo} BannedInfo
             */
            BannedInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.AcFunDanmu.ZtLiveScStatusChanged.BannedInfo)
                    return object;
                let message = new $root.AcFunDanmu.ZtLiveScStatusChanged.BannedInfo();
                if (object.banReason != null)
                    message.banReason = String(object.banReason);
                return message;
            };

            /**
             * Creates a plain object from a BannedInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof AcFunDanmu.ZtLiveScStatusChanged.BannedInfo
             * @static
             * @param {AcFunDanmu.ZtLiveScStatusChanged.BannedInfo} message BannedInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BannedInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.banReason = "";
                if (message.banReason != null && message.hasOwnProperty("banReason"))
                    object.banReason = message.banReason;
                return object;
            };

            /**
             * Converts this BannedInfo to JSON.
             * @function toJSON
             * @memberof AcFunDanmu.ZtLiveScStatusChanged.BannedInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BannedInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BannedInfo;
        })();

        return ZtLiveScStatusChanged;
    })();

    AcFunDanmu.ZtLiveScTicketInvalid = (function() {

        /**
         * Properties of a ZtLiveScTicketInvalid.
         * @memberof AcFunDanmu
         * @interface IZtLiveScTicketInvalid
         */

        /**
         * Constructs a new ZtLiveScTicketInvalid.
         * @memberof AcFunDanmu
         * @classdesc Represents a ZtLiveScTicketInvalid.
         * @implements IZtLiveScTicketInvalid
         * @constructor
         * @param {AcFunDanmu.IZtLiveScTicketInvalid=} [properties] Properties to set
         */
        function ZtLiveScTicketInvalid(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ZtLiveScTicketInvalid instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.ZtLiveScTicketInvalid
         * @static
         * @param {AcFunDanmu.IZtLiveScTicketInvalid=} [properties] Properties to set
         * @returns {AcFunDanmu.ZtLiveScTicketInvalid} ZtLiveScTicketInvalid instance
         */
        ZtLiveScTicketInvalid.create = function create(properties) {
            return new ZtLiveScTicketInvalid(properties);
        };

        /**
         * Encodes the specified ZtLiveScTicketInvalid message. Does not implicitly {@link AcFunDanmu.ZtLiveScTicketInvalid.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.ZtLiveScTicketInvalid
         * @static
         * @param {AcFunDanmu.IZtLiveScTicketInvalid} message ZtLiveScTicketInvalid message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ZtLiveScTicketInvalid.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ZtLiveScTicketInvalid message, length delimited. Does not implicitly {@link AcFunDanmu.ZtLiveScTicketInvalid.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.ZtLiveScTicketInvalid
         * @static
         * @param {AcFunDanmu.IZtLiveScTicketInvalid} message ZtLiveScTicketInvalid message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ZtLiveScTicketInvalid.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ZtLiveScTicketInvalid message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.ZtLiveScTicketInvalid
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.ZtLiveScTicketInvalid} ZtLiveScTicketInvalid
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ZtLiveScTicketInvalid.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.ZtLiveScTicketInvalid();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ZtLiveScTicketInvalid message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.ZtLiveScTicketInvalid
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.ZtLiveScTicketInvalid} ZtLiveScTicketInvalid
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ZtLiveScTicketInvalid.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ZtLiveScTicketInvalid message.
         * @function verify
         * @memberof AcFunDanmu.ZtLiveScTicketInvalid
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ZtLiveScTicketInvalid.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a ZtLiveScTicketInvalid message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.ZtLiveScTicketInvalid
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.ZtLiveScTicketInvalid} ZtLiveScTicketInvalid
         */
        ZtLiveScTicketInvalid.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.ZtLiveScTicketInvalid)
                return object;
            return new $root.AcFunDanmu.ZtLiveScTicketInvalid();
        };

        /**
         * Creates a plain object from a ZtLiveScTicketInvalid message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.ZtLiveScTicketInvalid
         * @static
         * @param {AcFunDanmu.ZtLiveScTicketInvalid} message ZtLiveScTicketInvalid
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ZtLiveScTicketInvalid.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ZtLiveScTicketInvalid to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.ZtLiveScTicketInvalid
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ZtLiveScTicketInvalid.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ZtLiveScTicketInvalid;
    })();

    AcFunDanmu.ZtLiveUserInfo = (function() {

        /**
         * Properties of a ZtLiveUserInfo.
         * @memberof AcFunDanmu
         * @interface IZtLiveUserInfo
         * @property {number|Long|null} [userId] ZtLiveUserInfo userId
         * @property {string|null} [nickname] ZtLiveUserInfo nickname
         * @property {Array.<AcFunDanmu.IImageCdnNode>|null} [avatar] ZtLiveUserInfo avatar
         */

        /**
         * Constructs a new ZtLiveUserInfo.
         * @memberof AcFunDanmu
         * @classdesc Represents a ZtLiveUserInfo.
         * @implements IZtLiveUserInfo
         * @constructor
         * @param {AcFunDanmu.IZtLiveUserInfo=} [properties] Properties to set
         */
        function ZtLiveUserInfo(properties) {
            this.avatar = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ZtLiveUserInfo userId.
         * @member {number|Long} userId
         * @memberof AcFunDanmu.ZtLiveUserInfo
         * @instance
         */
        ZtLiveUserInfo.prototype.userId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ZtLiveUserInfo nickname.
         * @member {string} nickname
         * @memberof AcFunDanmu.ZtLiveUserInfo
         * @instance
         */
        ZtLiveUserInfo.prototype.nickname = "";

        /**
         * ZtLiveUserInfo avatar.
         * @member {Array.<AcFunDanmu.IImageCdnNode>} avatar
         * @memberof AcFunDanmu.ZtLiveUserInfo
         * @instance
         */
        ZtLiveUserInfo.prototype.avatar = $util.emptyArray;

        /**
         * Creates a new ZtLiveUserInfo instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.ZtLiveUserInfo
         * @static
         * @param {AcFunDanmu.IZtLiveUserInfo=} [properties] Properties to set
         * @returns {AcFunDanmu.ZtLiveUserInfo} ZtLiveUserInfo instance
         */
        ZtLiveUserInfo.create = function create(properties) {
            return new ZtLiveUserInfo(properties);
        };

        /**
         * Encodes the specified ZtLiveUserInfo message. Does not implicitly {@link AcFunDanmu.ZtLiveUserInfo.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.ZtLiveUserInfo
         * @static
         * @param {AcFunDanmu.IZtLiveUserInfo} message ZtLiveUserInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ZtLiveUserInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.userId);
            if (message.nickname != null && Object.hasOwnProperty.call(message, "nickname"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.nickname);
            if (message.avatar != null && message.avatar.length)
                for (let i = 0; i < message.avatar.length; ++i)
                    $root.AcFunDanmu.ImageCdnNode.encode(message.avatar[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ZtLiveUserInfo message, length delimited. Does not implicitly {@link AcFunDanmu.ZtLiveUserInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.ZtLiveUserInfo
         * @static
         * @param {AcFunDanmu.IZtLiveUserInfo} message ZtLiveUserInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ZtLiveUserInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ZtLiveUserInfo message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.ZtLiveUserInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.ZtLiveUserInfo} ZtLiveUserInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ZtLiveUserInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.ZtLiveUserInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userId = reader.int64();
                    break;
                case 2:
                    message.nickname = reader.string();
                    break;
                case 3:
                    if (!(message.avatar && message.avatar.length))
                        message.avatar = [];
                    message.avatar.push($root.AcFunDanmu.ImageCdnNode.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ZtLiveUserInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.ZtLiveUserInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.ZtLiveUserInfo} ZtLiveUserInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ZtLiveUserInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ZtLiveUserInfo message.
         * @function verify
         * @memberof AcFunDanmu.ZtLiveUserInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ZtLiveUserInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isInteger(message.userId) && !(message.userId && $util.isInteger(message.userId.low) && $util.isInteger(message.userId.high)))
                    return "userId: integer|Long expected";
            if (message.nickname != null && message.hasOwnProperty("nickname"))
                if (!$util.isString(message.nickname))
                    return "nickname: string expected";
            if (message.avatar != null && message.hasOwnProperty("avatar")) {
                if (!Array.isArray(message.avatar))
                    return "avatar: array expected";
                for (let i = 0; i < message.avatar.length; ++i) {
                    let error = $root.AcFunDanmu.ImageCdnNode.verify(message.avatar[i]);
                    if (error)
                        return "avatar." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ZtLiveUserInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.ZtLiveUserInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.ZtLiveUserInfo} ZtLiveUserInfo
         */
        ZtLiveUserInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.ZtLiveUserInfo)
                return object;
            let message = new $root.AcFunDanmu.ZtLiveUserInfo();
            if (object.userId != null)
                if ($util.Long)
                    (message.userId = $util.Long.fromValue(object.userId)).unsigned = false;
                else if (typeof object.userId === "string")
                    message.userId = parseInt(object.userId, 10);
                else if (typeof object.userId === "number")
                    message.userId = object.userId;
                else if (typeof object.userId === "object")
                    message.userId = new $util.LongBits(object.userId.low >>> 0, object.userId.high >>> 0).toNumber();
            if (object.nickname != null)
                message.nickname = String(object.nickname);
            if (object.avatar) {
                if (!Array.isArray(object.avatar))
                    throw TypeError(".AcFunDanmu.ZtLiveUserInfo.avatar: array expected");
                message.avatar = [];
                for (let i = 0; i < object.avatar.length; ++i) {
                    if (typeof object.avatar[i] !== "object")
                        throw TypeError(".AcFunDanmu.ZtLiveUserInfo.avatar: object expected");
                    message.avatar[i] = $root.AcFunDanmu.ImageCdnNode.fromObject(object.avatar[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ZtLiveUserInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.ZtLiveUserInfo
         * @static
         * @param {AcFunDanmu.ZtLiveUserInfo} message ZtLiveUserInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ZtLiveUserInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.avatar = [];
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.userId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.userId = options.longs === String ? "0" : 0;
                object.nickname = "";
            }
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (typeof message.userId === "number")
                    object.userId = options.longs === String ? String(message.userId) : message.userId;
                else
                    object.userId = options.longs === String ? $util.Long.prototype.toString.call(message.userId) : options.longs === Number ? new $util.LongBits(message.userId.low >>> 0, message.userId.high >>> 0).toNumber() : message.userId;
            if (message.nickname != null && message.hasOwnProperty("nickname"))
                object.nickname = message.nickname;
            if (message.avatar && message.avatar.length) {
                object.avatar = [];
                for (let j = 0; j < message.avatar.length; ++j)
                    object.avatar[j] = $root.AcFunDanmu.ImageCdnNode.toObject(message.avatar[j], options);
            }
            return object;
        };

        /**
         * Converts this ZtLiveUserInfo to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.ZtLiveUserInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ZtLiveUserInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ZtLiveUserInfo;
    })();

    AcFunDanmu.ImageCdnNode = (function() {

        /**
         * Properties of an ImageCdnNode.
         * @memberof AcFunDanmu
         * @interface IImageCdnNode
         * @property {string|null} [cdn] ImageCdnNode cdn
         * @property {string|null} [url] ImageCdnNode url
         * @property {string|null} [urlPattern] ImageCdnNode urlPattern
         */

        /**
         * Constructs a new ImageCdnNode.
         * @memberof AcFunDanmu
         * @classdesc Represents an ImageCdnNode.
         * @implements IImageCdnNode
         * @constructor
         * @param {AcFunDanmu.IImageCdnNode=} [properties] Properties to set
         */
        function ImageCdnNode(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ImageCdnNode cdn.
         * @member {string} cdn
         * @memberof AcFunDanmu.ImageCdnNode
         * @instance
         */
        ImageCdnNode.prototype.cdn = "";

        /**
         * ImageCdnNode url.
         * @member {string} url
         * @memberof AcFunDanmu.ImageCdnNode
         * @instance
         */
        ImageCdnNode.prototype.url = "";

        /**
         * ImageCdnNode urlPattern.
         * @member {string} urlPattern
         * @memberof AcFunDanmu.ImageCdnNode
         * @instance
         */
        ImageCdnNode.prototype.urlPattern = "";

        /**
         * Creates a new ImageCdnNode instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.ImageCdnNode
         * @static
         * @param {AcFunDanmu.IImageCdnNode=} [properties] Properties to set
         * @returns {AcFunDanmu.ImageCdnNode} ImageCdnNode instance
         */
        ImageCdnNode.create = function create(properties) {
            return new ImageCdnNode(properties);
        };

        /**
         * Encodes the specified ImageCdnNode message. Does not implicitly {@link AcFunDanmu.ImageCdnNode.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.ImageCdnNode
         * @static
         * @param {AcFunDanmu.IImageCdnNode} message ImageCdnNode message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImageCdnNode.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cdn != null && Object.hasOwnProperty.call(message, "cdn"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.cdn);
            if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.url);
            if (message.urlPattern != null && Object.hasOwnProperty.call(message, "urlPattern"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.urlPattern);
            return writer;
        };

        /**
         * Encodes the specified ImageCdnNode message, length delimited. Does not implicitly {@link AcFunDanmu.ImageCdnNode.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.ImageCdnNode
         * @static
         * @param {AcFunDanmu.IImageCdnNode} message ImageCdnNode message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImageCdnNode.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ImageCdnNode message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.ImageCdnNode
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.ImageCdnNode} ImageCdnNode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImageCdnNode.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.ImageCdnNode();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.cdn = reader.string();
                    break;
                case 2:
                    message.url = reader.string();
                    break;
                case 3:
                    message.urlPattern = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ImageCdnNode message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.ImageCdnNode
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.ImageCdnNode} ImageCdnNode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImageCdnNode.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ImageCdnNode message.
         * @function verify
         * @memberof AcFunDanmu.ImageCdnNode
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ImageCdnNode.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.cdn != null && message.hasOwnProperty("cdn"))
                if (!$util.isString(message.cdn))
                    return "cdn: string expected";
            if (message.url != null && message.hasOwnProperty("url"))
                if (!$util.isString(message.url))
                    return "url: string expected";
            if (message.urlPattern != null && message.hasOwnProperty("urlPattern"))
                if (!$util.isString(message.urlPattern))
                    return "urlPattern: string expected";
            return null;
        };

        /**
         * Creates an ImageCdnNode message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.ImageCdnNode
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.ImageCdnNode} ImageCdnNode
         */
        ImageCdnNode.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.ImageCdnNode)
                return object;
            let message = new $root.AcFunDanmu.ImageCdnNode();
            if (object.cdn != null)
                message.cdn = String(object.cdn);
            if (object.url != null)
                message.url = String(object.url);
            if (object.urlPattern != null)
                message.urlPattern = String(object.urlPattern);
            return message;
        };

        /**
         * Creates a plain object from an ImageCdnNode message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.ImageCdnNode
         * @static
         * @param {AcFunDanmu.ImageCdnNode} message ImageCdnNode
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ImageCdnNode.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.cdn = "";
                object.url = "";
                object.urlPattern = "";
            }
            if (message.cdn != null && message.hasOwnProperty("cdn"))
                object.cdn = message.cdn;
            if (message.url != null && message.hasOwnProperty("url"))
                object.url = message.url;
            if (message.urlPattern != null && message.hasOwnProperty("urlPattern"))
                object.urlPattern = message.urlPattern;
            return object;
        };

        /**
         * Converts this ImageCdnNode to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.ImageCdnNode
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ImageCdnNode.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ImageCdnNode;
    })();

    /**
     * ChatMediaType enum.
     * @name AcFunDanmu.ChatMediaType
     * @enum {number}
     * @property {number} UNKNOWN=0 UNKNOWN value
     * @property {number} AUDIO=1 AUDIO value
     * @property {number} VIDEO=2 VIDEO value
     */
    AcFunDanmu.ChatMediaType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "UNKNOWN"] = 0;
        values[valuesById[1] = "AUDIO"] = 1;
        values[valuesById[2] = "VIDEO"] = 2;
        return values;
    })();

    AcFunDanmu.CommonActionSignalComment = (function() {

        /**
         * Properties of a CommonActionSignalComment.
         * @memberof AcFunDanmu
         * @interface ICommonActionSignalComment
         * @property {string|null} [content] CommonActionSignalComment content
         * @property {number|Long|null} [sendTimeMs] CommonActionSignalComment sendTimeMs
         * @property {AcFunDanmu.IZtLiveUserInfo|null} [userInfo] CommonActionSignalComment userInfo
         */

        /**
         * Constructs a new CommonActionSignalComment.
         * @memberof AcFunDanmu
         * @classdesc Represents a CommonActionSignalComment.
         * @implements ICommonActionSignalComment
         * @constructor
         * @param {AcFunDanmu.ICommonActionSignalComment=} [properties] Properties to set
         */
        function CommonActionSignalComment(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CommonActionSignalComment content.
         * @member {string} content
         * @memberof AcFunDanmu.CommonActionSignalComment
         * @instance
         */
        CommonActionSignalComment.prototype.content = "";

        /**
         * CommonActionSignalComment sendTimeMs.
         * @member {number|Long} sendTimeMs
         * @memberof AcFunDanmu.CommonActionSignalComment
         * @instance
         */
        CommonActionSignalComment.prototype.sendTimeMs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * CommonActionSignalComment userInfo.
         * @member {AcFunDanmu.IZtLiveUserInfo|null|undefined} userInfo
         * @memberof AcFunDanmu.CommonActionSignalComment
         * @instance
         */
        CommonActionSignalComment.prototype.userInfo = null;

        /**
         * Creates a new CommonActionSignalComment instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.CommonActionSignalComment
         * @static
         * @param {AcFunDanmu.ICommonActionSignalComment=} [properties] Properties to set
         * @returns {AcFunDanmu.CommonActionSignalComment} CommonActionSignalComment instance
         */
        CommonActionSignalComment.create = function create(properties) {
            return new CommonActionSignalComment(properties);
        };

        /**
         * Encodes the specified CommonActionSignalComment message. Does not implicitly {@link AcFunDanmu.CommonActionSignalComment.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.CommonActionSignalComment
         * @static
         * @param {AcFunDanmu.ICommonActionSignalComment} message CommonActionSignalComment message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommonActionSignalComment.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.content != null && Object.hasOwnProperty.call(message, "content"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.content);
            if (message.sendTimeMs != null && Object.hasOwnProperty.call(message, "sendTimeMs"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.sendTimeMs);
            if (message.userInfo != null && Object.hasOwnProperty.call(message, "userInfo"))
                $root.AcFunDanmu.ZtLiveUserInfo.encode(message.userInfo, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CommonActionSignalComment message, length delimited. Does not implicitly {@link AcFunDanmu.CommonActionSignalComment.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.CommonActionSignalComment
         * @static
         * @param {AcFunDanmu.ICommonActionSignalComment} message CommonActionSignalComment message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommonActionSignalComment.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CommonActionSignalComment message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.CommonActionSignalComment
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.CommonActionSignalComment} CommonActionSignalComment
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommonActionSignalComment.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.CommonActionSignalComment();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.content = reader.string();
                    break;
                case 2:
                    message.sendTimeMs = reader.int64();
                    break;
                case 3:
                    message.userInfo = $root.AcFunDanmu.ZtLiveUserInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CommonActionSignalComment message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.CommonActionSignalComment
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.CommonActionSignalComment} CommonActionSignalComment
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommonActionSignalComment.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CommonActionSignalComment message.
         * @function verify
         * @memberof AcFunDanmu.CommonActionSignalComment
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CommonActionSignalComment.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.content != null && message.hasOwnProperty("content"))
                if (!$util.isString(message.content))
                    return "content: string expected";
            if (message.sendTimeMs != null && message.hasOwnProperty("sendTimeMs"))
                if (!$util.isInteger(message.sendTimeMs) && !(message.sendTimeMs && $util.isInteger(message.sendTimeMs.low) && $util.isInteger(message.sendTimeMs.high)))
                    return "sendTimeMs: integer|Long expected";
            if (message.userInfo != null && message.hasOwnProperty("userInfo")) {
                let error = $root.AcFunDanmu.ZtLiveUserInfo.verify(message.userInfo);
                if (error)
                    return "userInfo." + error;
            }
            return null;
        };

        /**
         * Creates a CommonActionSignalComment message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.CommonActionSignalComment
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.CommonActionSignalComment} CommonActionSignalComment
         */
        CommonActionSignalComment.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.CommonActionSignalComment)
                return object;
            let message = new $root.AcFunDanmu.CommonActionSignalComment();
            if (object.content != null)
                message.content = String(object.content);
            if (object.sendTimeMs != null)
                if ($util.Long)
                    (message.sendTimeMs = $util.Long.fromValue(object.sendTimeMs)).unsigned = false;
                else if (typeof object.sendTimeMs === "string")
                    message.sendTimeMs = parseInt(object.sendTimeMs, 10);
                else if (typeof object.sendTimeMs === "number")
                    message.sendTimeMs = object.sendTimeMs;
                else if (typeof object.sendTimeMs === "object")
                    message.sendTimeMs = new $util.LongBits(object.sendTimeMs.low >>> 0, object.sendTimeMs.high >>> 0).toNumber();
            if (object.userInfo != null) {
                if (typeof object.userInfo !== "object")
                    throw TypeError(".AcFunDanmu.CommonActionSignalComment.userInfo: object expected");
                message.userInfo = $root.AcFunDanmu.ZtLiveUserInfo.fromObject(object.userInfo);
            }
            return message;
        };

        /**
         * Creates a plain object from a CommonActionSignalComment message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.CommonActionSignalComment
         * @static
         * @param {AcFunDanmu.CommonActionSignalComment} message CommonActionSignalComment
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CommonActionSignalComment.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.content = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.sendTimeMs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.sendTimeMs = options.longs === String ? "0" : 0;
                object.userInfo = null;
            }
            if (message.content != null && message.hasOwnProperty("content"))
                object.content = message.content;
            if (message.sendTimeMs != null && message.hasOwnProperty("sendTimeMs"))
                if (typeof message.sendTimeMs === "number")
                    object.sendTimeMs = options.longs === String ? String(message.sendTimeMs) : message.sendTimeMs;
                else
                    object.sendTimeMs = options.longs === String ? $util.Long.prototype.toString.call(message.sendTimeMs) : options.longs === Number ? new $util.LongBits(message.sendTimeMs.low >>> 0, message.sendTimeMs.high >>> 0).toNumber() : message.sendTimeMs;
            if (message.userInfo != null && message.hasOwnProperty("userInfo"))
                object.userInfo = $root.AcFunDanmu.ZtLiveUserInfo.toObject(message.userInfo, options);
            return object;
        };

        /**
         * Converts this CommonActionSignalComment to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.CommonActionSignalComment
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CommonActionSignalComment.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CommonActionSignalComment;
    })();

    AcFunDanmu.CommonActionSignalLike = (function() {

        /**
         * Properties of a CommonActionSignalLike.
         * @memberof AcFunDanmu
         * @interface ICommonActionSignalLike
         * @property {AcFunDanmu.IZtLiveUserInfo|null} [userInfo] CommonActionSignalLike userInfo
         * @property {number|Long|null} [sendTimeMs] CommonActionSignalLike sendTimeMs
         */

        /**
         * Constructs a new CommonActionSignalLike.
         * @memberof AcFunDanmu
         * @classdesc Represents a CommonActionSignalLike.
         * @implements ICommonActionSignalLike
         * @constructor
         * @param {AcFunDanmu.ICommonActionSignalLike=} [properties] Properties to set
         */
        function CommonActionSignalLike(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CommonActionSignalLike userInfo.
         * @member {AcFunDanmu.IZtLiveUserInfo|null|undefined} userInfo
         * @memberof AcFunDanmu.CommonActionSignalLike
         * @instance
         */
        CommonActionSignalLike.prototype.userInfo = null;

        /**
         * CommonActionSignalLike sendTimeMs.
         * @member {number|Long} sendTimeMs
         * @memberof AcFunDanmu.CommonActionSignalLike
         * @instance
         */
        CommonActionSignalLike.prototype.sendTimeMs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new CommonActionSignalLike instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.CommonActionSignalLike
         * @static
         * @param {AcFunDanmu.ICommonActionSignalLike=} [properties] Properties to set
         * @returns {AcFunDanmu.CommonActionSignalLike} CommonActionSignalLike instance
         */
        CommonActionSignalLike.create = function create(properties) {
            return new CommonActionSignalLike(properties);
        };

        /**
         * Encodes the specified CommonActionSignalLike message. Does not implicitly {@link AcFunDanmu.CommonActionSignalLike.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.CommonActionSignalLike
         * @static
         * @param {AcFunDanmu.ICommonActionSignalLike} message CommonActionSignalLike message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommonActionSignalLike.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userInfo != null && Object.hasOwnProperty.call(message, "userInfo"))
                $root.AcFunDanmu.ZtLiveUserInfo.encode(message.userInfo, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.sendTimeMs != null && Object.hasOwnProperty.call(message, "sendTimeMs"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.sendTimeMs);
            return writer;
        };

        /**
         * Encodes the specified CommonActionSignalLike message, length delimited. Does not implicitly {@link AcFunDanmu.CommonActionSignalLike.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.CommonActionSignalLike
         * @static
         * @param {AcFunDanmu.ICommonActionSignalLike} message CommonActionSignalLike message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommonActionSignalLike.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CommonActionSignalLike message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.CommonActionSignalLike
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.CommonActionSignalLike} CommonActionSignalLike
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommonActionSignalLike.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.CommonActionSignalLike();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userInfo = $root.AcFunDanmu.ZtLiveUserInfo.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.sendTimeMs = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CommonActionSignalLike message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.CommonActionSignalLike
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.CommonActionSignalLike} CommonActionSignalLike
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommonActionSignalLike.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CommonActionSignalLike message.
         * @function verify
         * @memberof AcFunDanmu.CommonActionSignalLike
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CommonActionSignalLike.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userInfo != null && message.hasOwnProperty("userInfo")) {
                let error = $root.AcFunDanmu.ZtLiveUserInfo.verify(message.userInfo);
                if (error)
                    return "userInfo." + error;
            }
            if (message.sendTimeMs != null && message.hasOwnProperty("sendTimeMs"))
                if (!$util.isInteger(message.sendTimeMs) && !(message.sendTimeMs && $util.isInteger(message.sendTimeMs.low) && $util.isInteger(message.sendTimeMs.high)))
                    return "sendTimeMs: integer|Long expected";
            return null;
        };

        /**
         * Creates a CommonActionSignalLike message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.CommonActionSignalLike
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.CommonActionSignalLike} CommonActionSignalLike
         */
        CommonActionSignalLike.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.CommonActionSignalLike)
                return object;
            let message = new $root.AcFunDanmu.CommonActionSignalLike();
            if (object.userInfo != null) {
                if (typeof object.userInfo !== "object")
                    throw TypeError(".AcFunDanmu.CommonActionSignalLike.userInfo: object expected");
                message.userInfo = $root.AcFunDanmu.ZtLiveUserInfo.fromObject(object.userInfo);
            }
            if (object.sendTimeMs != null)
                if ($util.Long)
                    (message.sendTimeMs = $util.Long.fromValue(object.sendTimeMs)).unsigned = false;
                else if (typeof object.sendTimeMs === "string")
                    message.sendTimeMs = parseInt(object.sendTimeMs, 10);
                else if (typeof object.sendTimeMs === "number")
                    message.sendTimeMs = object.sendTimeMs;
                else if (typeof object.sendTimeMs === "object")
                    message.sendTimeMs = new $util.LongBits(object.sendTimeMs.low >>> 0, object.sendTimeMs.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a CommonActionSignalLike message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.CommonActionSignalLike
         * @static
         * @param {AcFunDanmu.CommonActionSignalLike} message CommonActionSignalLike
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CommonActionSignalLike.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.userInfo = null;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.sendTimeMs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.sendTimeMs = options.longs === String ? "0" : 0;
            }
            if (message.userInfo != null && message.hasOwnProperty("userInfo"))
                object.userInfo = $root.AcFunDanmu.ZtLiveUserInfo.toObject(message.userInfo, options);
            if (message.sendTimeMs != null && message.hasOwnProperty("sendTimeMs"))
                if (typeof message.sendTimeMs === "number")
                    object.sendTimeMs = options.longs === String ? String(message.sendTimeMs) : message.sendTimeMs;
                else
                    object.sendTimeMs = options.longs === String ? $util.Long.prototype.toString.call(message.sendTimeMs) : options.longs === Number ? new $util.LongBits(message.sendTimeMs.low >>> 0, message.sendTimeMs.high >>> 0).toNumber() : message.sendTimeMs;
            return object;
        };

        /**
         * Converts this CommonActionSignalLike to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.CommonActionSignalLike
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CommonActionSignalLike.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CommonActionSignalLike;
    })();

    AcFunDanmu.CommonActionSignalUserEnterRoom = (function() {

        /**
         * Properties of a CommonActionSignalUserEnterRoom.
         * @memberof AcFunDanmu
         * @interface ICommonActionSignalUserEnterRoom
         * @property {AcFunDanmu.IZtLiveUserInfo|null} [userInfo] CommonActionSignalUserEnterRoom userInfo
         * @property {number|Long|null} [sendTimeMs] CommonActionSignalUserEnterRoom sendTimeMs
         */

        /**
         * Constructs a new CommonActionSignalUserEnterRoom.
         * @memberof AcFunDanmu
         * @classdesc Represents a CommonActionSignalUserEnterRoom.
         * @implements ICommonActionSignalUserEnterRoom
         * @constructor
         * @param {AcFunDanmu.ICommonActionSignalUserEnterRoom=} [properties] Properties to set
         */
        function CommonActionSignalUserEnterRoom(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CommonActionSignalUserEnterRoom userInfo.
         * @member {AcFunDanmu.IZtLiveUserInfo|null|undefined} userInfo
         * @memberof AcFunDanmu.CommonActionSignalUserEnterRoom
         * @instance
         */
        CommonActionSignalUserEnterRoom.prototype.userInfo = null;

        /**
         * CommonActionSignalUserEnterRoom sendTimeMs.
         * @member {number|Long} sendTimeMs
         * @memberof AcFunDanmu.CommonActionSignalUserEnterRoom
         * @instance
         */
        CommonActionSignalUserEnterRoom.prototype.sendTimeMs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new CommonActionSignalUserEnterRoom instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.CommonActionSignalUserEnterRoom
         * @static
         * @param {AcFunDanmu.ICommonActionSignalUserEnterRoom=} [properties] Properties to set
         * @returns {AcFunDanmu.CommonActionSignalUserEnterRoom} CommonActionSignalUserEnterRoom instance
         */
        CommonActionSignalUserEnterRoom.create = function create(properties) {
            return new CommonActionSignalUserEnterRoom(properties);
        };

        /**
         * Encodes the specified CommonActionSignalUserEnterRoom message. Does not implicitly {@link AcFunDanmu.CommonActionSignalUserEnterRoom.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.CommonActionSignalUserEnterRoom
         * @static
         * @param {AcFunDanmu.ICommonActionSignalUserEnterRoom} message CommonActionSignalUserEnterRoom message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommonActionSignalUserEnterRoom.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userInfo != null && Object.hasOwnProperty.call(message, "userInfo"))
                $root.AcFunDanmu.ZtLiveUserInfo.encode(message.userInfo, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.sendTimeMs != null && Object.hasOwnProperty.call(message, "sendTimeMs"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.sendTimeMs);
            return writer;
        };

        /**
         * Encodes the specified CommonActionSignalUserEnterRoom message, length delimited. Does not implicitly {@link AcFunDanmu.CommonActionSignalUserEnterRoom.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.CommonActionSignalUserEnterRoom
         * @static
         * @param {AcFunDanmu.ICommonActionSignalUserEnterRoom} message CommonActionSignalUserEnterRoom message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommonActionSignalUserEnterRoom.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CommonActionSignalUserEnterRoom message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.CommonActionSignalUserEnterRoom
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.CommonActionSignalUserEnterRoom} CommonActionSignalUserEnterRoom
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommonActionSignalUserEnterRoom.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.CommonActionSignalUserEnterRoom();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userInfo = $root.AcFunDanmu.ZtLiveUserInfo.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.sendTimeMs = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CommonActionSignalUserEnterRoom message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.CommonActionSignalUserEnterRoom
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.CommonActionSignalUserEnterRoom} CommonActionSignalUserEnterRoom
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommonActionSignalUserEnterRoom.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CommonActionSignalUserEnterRoom message.
         * @function verify
         * @memberof AcFunDanmu.CommonActionSignalUserEnterRoom
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CommonActionSignalUserEnterRoom.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userInfo != null && message.hasOwnProperty("userInfo")) {
                let error = $root.AcFunDanmu.ZtLiveUserInfo.verify(message.userInfo);
                if (error)
                    return "userInfo." + error;
            }
            if (message.sendTimeMs != null && message.hasOwnProperty("sendTimeMs"))
                if (!$util.isInteger(message.sendTimeMs) && !(message.sendTimeMs && $util.isInteger(message.sendTimeMs.low) && $util.isInteger(message.sendTimeMs.high)))
                    return "sendTimeMs: integer|Long expected";
            return null;
        };

        /**
         * Creates a CommonActionSignalUserEnterRoom message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.CommonActionSignalUserEnterRoom
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.CommonActionSignalUserEnterRoom} CommonActionSignalUserEnterRoom
         */
        CommonActionSignalUserEnterRoom.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.CommonActionSignalUserEnterRoom)
                return object;
            let message = new $root.AcFunDanmu.CommonActionSignalUserEnterRoom();
            if (object.userInfo != null) {
                if (typeof object.userInfo !== "object")
                    throw TypeError(".AcFunDanmu.CommonActionSignalUserEnterRoom.userInfo: object expected");
                message.userInfo = $root.AcFunDanmu.ZtLiveUserInfo.fromObject(object.userInfo);
            }
            if (object.sendTimeMs != null)
                if ($util.Long)
                    (message.sendTimeMs = $util.Long.fromValue(object.sendTimeMs)).unsigned = false;
                else if (typeof object.sendTimeMs === "string")
                    message.sendTimeMs = parseInt(object.sendTimeMs, 10);
                else if (typeof object.sendTimeMs === "number")
                    message.sendTimeMs = object.sendTimeMs;
                else if (typeof object.sendTimeMs === "object")
                    message.sendTimeMs = new $util.LongBits(object.sendTimeMs.low >>> 0, object.sendTimeMs.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a CommonActionSignalUserEnterRoom message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.CommonActionSignalUserEnterRoom
         * @static
         * @param {AcFunDanmu.CommonActionSignalUserEnterRoom} message CommonActionSignalUserEnterRoom
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CommonActionSignalUserEnterRoom.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.userInfo = null;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.sendTimeMs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.sendTimeMs = options.longs === String ? "0" : 0;
            }
            if (message.userInfo != null && message.hasOwnProperty("userInfo"))
                object.userInfo = $root.AcFunDanmu.ZtLiveUserInfo.toObject(message.userInfo, options);
            if (message.sendTimeMs != null && message.hasOwnProperty("sendTimeMs"))
                if (typeof message.sendTimeMs === "number")
                    object.sendTimeMs = options.longs === String ? String(message.sendTimeMs) : message.sendTimeMs;
                else
                    object.sendTimeMs = options.longs === String ? $util.Long.prototype.toString.call(message.sendTimeMs) : options.longs === Number ? new $util.LongBits(message.sendTimeMs.low >>> 0, message.sendTimeMs.high >>> 0).toNumber() : message.sendTimeMs;
            return object;
        };

        /**
         * Converts this CommonActionSignalUserEnterRoom to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.CommonActionSignalUserEnterRoom
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CommonActionSignalUserEnterRoom.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CommonActionSignalUserEnterRoom;
    })();

    AcFunDanmu.CommonActionSignalUserFollowAuthor = (function() {

        /**
         * Properties of a CommonActionSignalUserFollowAuthor.
         * @memberof AcFunDanmu
         * @interface ICommonActionSignalUserFollowAuthor
         * @property {AcFunDanmu.IZtLiveUserInfo|null} [userInfo] CommonActionSignalUserFollowAuthor userInfo
         * @property {number|Long|null} [sendTimeMs] CommonActionSignalUserFollowAuthor sendTimeMs
         */

        /**
         * Constructs a new CommonActionSignalUserFollowAuthor.
         * @memberof AcFunDanmu
         * @classdesc Represents a CommonActionSignalUserFollowAuthor.
         * @implements ICommonActionSignalUserFollowAuthor
         * @constructor
         * @param {AcFunDanmu.ICommonActionSignalUserFollowAuthor=} [properties] Properties to set
         */
        function CommonActionSignalUserFollowAuthor(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CommonActionSignalUserFollowAuthor userInfo.
         * @member {AcFunDanmu.IZtLiveUserInfo|null|undefined} userInfo
         * @memberof AcFunDanmu.CommonActionSignalUserFollowAuthor
         * @instance
         */
        CommonActionSignalUserFollowAuthor.prototype.userInfo = null;

        /**
         * CommonActionSignalUserFollowAuthor sendTimeMs.
         * @member {number|Long} sendTimeMs
         * @memberof AcFunDanmu.CommonActionSignalUserFollowAuthor
         * @instance
         */
        CommonActionSignalUserFollowAuthor.prototype.sendTimeMs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new CommonActionSignalUserFollowAuthor instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.CommonActionSignalUserFollowAuthor
         * @static
         * @param {AcFunDanmu.ICommonActionSignalUserFollowAuthor=} [properties] Properties to set
         * @returns {AcFunDanmu.CommonActionSignalUserFollowAuthor} CommonActionSignalUserFollowAuthor instance
         */
        CommonActionSignalUserFollowAuthor.create = function create(properties) {
            return new CommonActionSignalUserFollowAuthor(properties);
        };

        /**
         * Encodes the specified CommonActionSignalUserFollowAuthor message. Does not implicitly {@link AcFunDanmu.CommonActionSignalUserFollowAuthor.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.CommonActionSignalUserFollowAuthor
         * @static
         * @param {AcFunDanmu.ICommonActionSignalUserFollowAuthor} message CommonActionSignalUserFollowAuthor message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommonActionSignalUserFollowAuthor.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userInfo != null && Object.hasOwnProperty.call(message, "userInfo"))
                $root.AcFunDanmu.ZtLiveUserInfo.encode(message.userInfo, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.sendTimeMs != null && Object.hasOwnProperty.call(message, "sendTimeMs"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.sendTimeMs);
            return writer;
        };

        /**
         * Encodes the specified CommonActionSignalUserFollowAuthor message, length delimited. Does not implicitly {@link AcFunDanmu.CommonActionSignalUserFollowAuthor.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.CommonActionSignalUserFollowAuthor
         * @static
         * @param {AcFunDanmu.ICommonActionSignalUserFollowAuthor} message CommonActionSignalUserFollowAuthor message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommonActionSignalUserFollowAuthor.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CommonActionSignalUserFollowAuthor message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.CommonActionSignalUserFollowAuthor
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.CommonActionSignalUserFollowAuthor} CommonActionSignalUserFollowAuthor
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommonActionSignalUserFollowAuthor.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.CommonActionSignalUserFollowAuthor();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userInfo = $root.AcFunDanmu.ZtLiveUserInfo.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.sendTimeMs = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CommonActionSignalUserFollowAuthor message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.CommonActionSignalUserFollowAuthor
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.CommonActionSignalUserFollowAuthor} CommonActionSignalUserFollowAuthor
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommonActionSignalUserFollowAuthor.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CommonActionSignalUserFollowAuthor message.
         * @function verify
         * @memberof AcFunDanmu.CommonActionSignalUserFollowAuthor
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CommonActionSignalUserFollowAuthor.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userInfo != null && message.hasOwnProperty("userInfo")) {
                let error = $root.AcFunDanmu.ZtLiveUserInfo.verify(message.userInfo);
                if (error)
                    return "userInfo." + error;
            }
            if (message.sendTimeMs != null && message.hasOwnProperty("sendTimeMs"))
                if (!$util.isInteger(message.sendTimeMs) && !(message.sendTimeMs && $util.isInteger(message.sendTimeMs.low) && $util.isInteger(message.sendTimeMs.high)))
                    return "sendTimeMs: integer|Long expected";
            return null;
        };

        /**
         * Creates a CommonActionSignalUserFollowAuthor message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.CommonActionSignalUserFollowAuthor
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.CommonActionSignalUserFollowAuthor} CommonActionSignalUserFollowAuthor
         */
        CommonActionSignalUserFollowAuthor.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.CommonActionSignalUserFollowAuthor)
                return object;
            let message = new $root.AcFunDanmu.CommonActionSignalUserFollowAuthor();
            if (object.userInfo != null) {
                if (typeof object.userInfo !== "object")
                    throw TypeError(".AcFunDanmu.CommonActionSignalUserFollowAuthor.userInfo: object expected");
                message.userInfo = $root.AcFunDanmu.ZtLiveUserInfo.fromObject(object.userInfo);
            }
            if (object.sendTimeMs != null)
                if ($util.Long)
                    (message.sendTimeMs = $util.Long.fromValue(object.sendTimeMs)).unsigned = false;
                else if (typeof object.sendTimeMs === "string")
                    message.sendTimeMs = parseInt(object.sendTimeMs, 10);
                else if (typeof object.sendTimeMs === "number")
                    message.sendTimeMs = object.sendTimeMs;
                else if (typeof object.sendTimeMs === "object")
                    message.sendTimeMs = new $util.LongBits(object.sendTimeMs.low >>> 0, object.sendTimeMs.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a CommonActionSignalUserFollowAuthor message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.CommonActionSignalUserFollowAuthor
         * @static
         * @param {AcFunDanmu.CommonActionSignalUserFollowAuthor} message CommonActionSignalUserFollowAuthor
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CommonActionSignalUserFollowAuthor.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.userInfo = null;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.sendTimeMs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.sendTimeMs = options.longs === String ? "0" : 0;
            }
            if (message.userInfo != null && message.hasOwnProperty("userInfo"))
                object.userInfo = $root.AcFunDanmu.ZtLiveUserInfo.toObject(message.userInfo, options);
            if (message.sendTimeMs != null && message.hasOwnProperty("sendTimeMs"))
                if (typeof message.sendTimeMs === "number")
                    object.sendTimeMs = options.longs === String ? String(message.sendTimeMs) : message.sendTimeMs;
                else
                    object.sendTimeMs = options.longs === String ? $util.Long.prototype.toString.call(message.sendTimeMs) : options.longs === Number ? new $util.LongBits(message.sendTimeMs.low >>> 0, message.sendTimeMs.high >>> 0).toNumber() : message.sendTimeMs;
            return object;
        };

        /**
         * Converts this CommonActionSignalUserFollowAuthor to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.CommonActionSignalUserFollowAuthor
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CommonActionSignalUserFollowAuthor.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CommonActionSignalUserFollowAuthor;
    })();

    AcFunDanmu.CommonActionSignalGift = (function() {

        /**
         * Properties of a CommonActionSignalGift.
         * @memberof AcFunDanmu
         * @interface ICommonActionSignalGift
         * @property {AcFunDanmu.IZtLiveUserInfo|null} [user] CommonActionSignalGift user
         * @property {number|Long|null} [sendTimeMs] CommonActionSignalGift sendTimeMs
         * @property {number|null} [giftId] CommonActionSignalGift giftId
         * @property {number|null} [count] CommonActionSignalGift count
         * @property {number|null} [combo] CommonActionSignalGift combo
         * @property {number|null} [value] CommonActionSignalGift value
         * @property {string|null} [comboId] CommonActionSignalGift comboId
         * @property {number|null} [slotDisplayDurationMs] CommonActionSignalGift slotDisplayDurationMs
         * @property {number|null} [expireDurationMs] CommonActionSignalGift expireDurationMs
         */

        /**
         * Constructs a new CommonActionSignalGift.
         * @memberof AcFunDanmu
         * @classdesc Represents a CommonActionSignalGift.
         * @implements ICommonActionSignalGift
         * @constructor
         * @param {AcFunDanmu.ICommonActionSignalGift=} [properties] Properties to set
         */
        function CommonActionSignalGift(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CommonActionSignalGift user.
         * @member {AcFunDanmu.IZtLiveUserInfo|null|undefined} user
         * @memberof AcFunDanmu.CommonActionSignalGift
         * @instance
         */
        CommonActionSignalGift.prototype.user = null;

        /**
         * CommonActionSignalGift sendTimeMs.
         * @member {number|Long} sendTimeMs
         * @memberof AcFunDanmu.CommonActionSignalGift
         * @instance
         */
        CommonActionSignalGift.prototype.sendTimeMs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * CommonActionSignalGift giftId.
         * @member {number} giftId
         * @memberof AcFunDanmu.CommonActionSignalGift
         * @instance
         */
        CommonActionSignalGift.prototype.giftId = 0;

        /**
         * CommonActionSignalGift count.
         * @member {number} count
         * @memberof AcFunDanmu.CommonActionSignalGift
         * @instance
         */
        CommonActionSignalGift.prototype.count = 0;

        /**
         * CommonActionSignalGift combo.
         * @member {number} combo
         * @memberof AcFunDanmu.CommonActionSignalGift
         * @instance
         */
        CommonActionSignalGift.prototype.combo = 0;

        /**
         * CommonActionSignalGift value.
         * @member {number} value
         * @memberof AcFunDanmu.CommonActionSignalGift
         * @instance
         */
        CommonActionSignalGift.prototype.value = 0;

        /**
         * CommonActionSignalGift comboId.
         * @member {string} comboId
         * @memberof AcFunDanmu.CommonActionSignalGift
         * @instance
         */
        CommonActionSignalGift.prototype.comboId = "";

        /**
         * CommonActionSignalGift slotDisplayDurationMs.
         * @member {number} slotDisplayDurationMs
         * @memberof AcFunDanmu.CommonActionSignalGift
         * @instance
         */
        CommonActionSignalGift.prototype.slotDisplayDurationMs = 0;

        /**
         * CommonActionSignalGift expireDurationMs.
         * @member {number} expireDurationMs
         * @memberof AcFunDanmu.CommonActionSignalGift
         * @instance
         */
        CommonActionSignalGift.prototype.expireDurationMs = 0;

        /**
         * Creates a new CommonActionSignalGift instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.CommonActionSignalGift
         * @static
         * @param {AcFunDanmu.ICommonActionSignalGift=} [properties] Properties to set
         * @returns {AcFunDanmu.CommonActionSignalGift} CommonActionSignalGift instance
         */
        CommonActionSignalGift.create = function create(properties) {
            return new CommonActionSignalGift(properties);
        };

        /**
         * Encodes the specified CommonActionSignalGift message. Does not implicitly {@link AcFunDanmu.CommonActionSignalGift.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.CommonActionSignalGift
         * @static
         * @param {AcFunDanmu.ICommonActionSignalGift} message CommonActionSignalGift message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommonActionSignalGift.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.user != null && Object.hasOwnProperty.call(message, "user"))
                $root.AcFunDanmu.ZtLiveUserInfo.encode(message.user, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.sendTimeMs != null && Object.hasOwnProperty.call(message, "sendTimeMs"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.sendTimeMs);
            if (message.giftId != null && Object.hasOwnProperty.call(message, "giftId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.giftId);
            if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.count);
            if (message.combo != null && Object.hasOwnProperty.call(message, "combo"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.combo);
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.value);
            if (message.comboId != null && Object.hasOwnProperty.call(message, "comboId"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.comboId);
            if (message.slotDisplayDurationMs != null && Object.hasOwnProperty.call(message, "slotDisplayDurationMs"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.slotDisplayDurationMs);
            if (message.expireDurationMs != null && Object.hasOwnProperty.call(message, "expireDurationMs"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.expireDurationMs);
            return writer;
        };

        /**
         * Encodes the specified CommonActionSignalGift message, length delimited. Does not implicitly {@link AcFunDanmu.CommonActionSignalGift.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.CommonActionSignalGift
         * @static
         * @param {AcFunDanmu.ICommonActionSignalGift} message CommonActionSignalGift message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommonActionSignalGift.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CommonActionSignalGift message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.CommonActionSignalGift
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.CommonActionSignalGift} CommonActionSignalGift
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommonActionSignalGift.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.CommonActionSignalGift();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.user = $root.AcFunDanmu.ZtLiveUserInfo.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.sendTimeMs = reader.int64();
                    break;
                case 3:
                    message.giftId = reader.int32();
                    break;
                case 4:
                    message.count = reader.int32();
                    break;
                case 5:
                    message.combo = reader.int32();
                    break;
                case 6:
                    message.value = reader.int32();
                    break;
                case 7:
                    message.comboId = reader.string();
                    break;
                case 8:
                    message.slotDisplayDurationMs = reader.int32();
                    break;
                case 9:
                    message.expireDurationMs = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CommonActionSignalGift message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.CommonActionSignalGift
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.CommonActionSignalGift} CommonActionSignalGift
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommonActionSignalGift.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CommonActionSignalGift message.
         * @function verify
         * @memberof AcFunDanmu.CommonActionSignalGift
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CommonActionSignalGift.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.user != null && message.hasOwnProperty("user")) {
                let error = $root.AcFunDanmu.ZtLiveUserInfo.verify(message.user);
                if (error)
                    return "user." + error;
            }
            if (message.sendTimeMs != null && message.hasOwnProperty("sendTimeMs"))
                if (!$util.isInteger(message.sendTimeMs) && !(message.sendTimeMs && $util.isInteger(message.sendTimeMs.low) && $util.isInteger(message.sendTimeMs.high)))
                    return "sendTimeMs: integer|Long expected";
            if (message.giftId != null && message.hasOwnProperty("giftId"))
                if (!$util.isInteger(message.giftId))
                    return "giftId: integer expected";
            if (message.count != null && message.hasOwnProperty("count"))
                if (!$util.isInteger(message.count))
                    return "count: integer expected";
            if (message.combo != null && message.hasOwnProperty("combo"))
                if (!$util.isInteger(message.combo))
                    return "combo: integer expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isInteger(message.value))
                    return "value: integer expected";
            if (message.comboId != null && message.hasOwnProperty("comboId"))
                if (!$util.isString(message.comboId))
                    return "comboId: string expected";
            if (message.slotDisplayDurationMs != null && message.hasOwnProperty("slotDisplayDurationMs"))
                if (!$util.isInteger(message.slotDisplayDurationMs))
                    return "slotDisplayDurationMs: integer expected";
            if (message.expireDurationMs != null && message.hasOwnProperty("expireDurationMs"))
                if (!$util.isInteger(message.expireDurationMs))
                    return "expireDurationMs: integer expected";
            return null;
        };

        /**
         * Creates a CommonActionSignalGift message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.CommonActionSignalGift
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.CommonActionSignalGift} CommonActionSignalGift
         */
        CommonActionSignalGift.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.CommonActionSignalGift)
                return object;
            let message = new $root.AcFunDanmu.CommonActionSignalGift();
            if (object.user != null) {
                if (typeof object.user !== "object")
                    throw TypeError(".AcFunDanmu.CommonActionSignalGift.user: object expected");
                message.user = $root.AcFunDanmu.ZtLiveUserInfo.fromObject(object.user);
            }
            if (object.sendTimeMs != null)
                if ($util.Long)
                    (message.sendTimeMs = $util.Long.fromValue(object.sendTimeMs)).unsigned = false;
                else if (typeof object.sendTimeMs === "string")
                    message.sendTimeMs = parseInt(object.sendTimeMs, 10);
                else if (typeof object.sendTimeMs === "number")
                    message.sendTimeMs = object.sendTimeMs;
                else if (typeof object.sendTimeMs === "object")
                    message.sendTimeMs = new $util.LongBits(object.sendTimeMs.low >>> 0, object.sendTimeMs.high >>> 0).toNumber();
            if (object.giftId != null)
                message.giftId = object.giftId | 0;
            if (object.count != null)
                message.count = object.count | 0;
            if (object.combo != null)
                message.combo = object.combo | 0;
            if (object.value != null)
                message.value = object.value | 0;
            if (object.comboId != null)
                message.comboId = String(object.comboId);
            if (object.slotDisplayDurationMs != null)
                message.slotDisplayDurationMs = object.slotDisplayDurationMs | 0;
            if (object.expireDurationMs != null)
                message.expireDurationMs = object.expireDurationMs | 0;
            return message;
        };

        /**
         * Creates a plain object from a CommonActionSignalGift message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.CommonActionSignalGift
         * @static
         * @param {AcFunDanmu.CommonActionSignalGift} message CommonActionSignalGift
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CommonActionSignalGift.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.user = null;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.sendTimeMs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.sendTimeMs = options.longs === String ? "0" : 0;
                object.giftId = 0;
                object.count = 0;
                object.combo = 0;
                object.value = 0;
                object.comboId = "";
                object.slotDisplayDurationMs = 0;
                object.expireDurationMs = 0;
            }
            if (message.user != null && message.hasOwnProperty("user"))
                object.user = $root.AcFunDanmu.ZtLiveUserInfo.toObject(message.user, options);
            if (message.sendTimeMs != null && message.hasOwnProperty("sendTimeMs"))
                if (typeof message.sendTimeMs === "number")
                    object.sendTimeMs = options.longs === String ? String(message.sendTimeMs) : message.sendTimeMs;
                else
                    object.sendTimeMs = options.longs === String ? $util.Long.prototype.toString.call(message.sendTimeMs) : options.longs === Number ? new $util.LongBits(message.sendTimeMs.low >>> 0, message.sendTimeMs.high >>> 0).toNumber() : message.sendTimeMs;
            if (message.giftId != null && message.hasOwnProperty("giftId"))
                object.giftId = message.giftId;
            if (message.count != null && message.hasOwnProperty("count"))
                object.count = message.count;
            if (message.combo != null && message.hasOwnProperty("combo"))
                object.combo = message.combo;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            if (message.comboId != null && message.hasOwnProperty("comboId"))
                object.comboId = message.comboId;
            if (message.slotDisplayDurationMs != null && message.hasOwnProperty("slotDisplayDurationMs"))
                object.slotDisplayDurationMs = message.slotDisplayDurationMs;
            if (message.expireDurationMs != null && message.hasOwnProperty("expireDurationMs"))
                object.expireDurationMs = message.expireDurationMs;
            return object;
        };

        /**
         * Converts this CommonActionSignalGift to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.CommonActionSignalGift
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CommonActionSignalGift.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CommonActionSignalGift;
    })();

    AcFunDanmu.CommonNotifySignalKickedOut = (function() {

        /**
         * Properties of a CommonNotifySignalKickedOut.
         * @memberof AcFunDanmu
         * @interface ICommonNotifySignalKickedOut
         * @property {string|null} [reason] CommonNotifySignalKickedOut reason
         */

        /**
         * Constructs a new CommonNotifySignalKickedOut.
         * @memberof AcFunDanmu
         * @classdesc Represents a CommonNotifySignalKickedOut.
         * @implements ICommonNotifySignalKickedOut
         * @constructor
         * @param {AcFunDanmu.ICommonNotifySignalKickedOut=} [properties] Properties to set
         */
        function CommonNotifySignalKickedOut(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CommonNotifySignalKickedOut reason.
         * @member {string} reason
         * @memberof AcFunDanmu.CommonNotifySignalKickedOut
         * @instance
         */
        CommonNotifySignalKickedOut.prototype.reason = "";

        /**
         * Creates a new CommonNotifySignalKickedOut instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.CommonNotifySignalKickedOut
         * @static
         * @param {AcFunDanmu.ICommonNotifySignalKickedOut=} [properties] Properties to set
         * @returns {AcFunDanmu.CommonNotifySignalKickedOut} CommonNotifySignalKickedOut instance
         */
        CommonNotifySignalKickedOut.create = function create(properties) {
            return new CommonNotifySignalKickedOut(properties);
        };

        /**
         * Encodes the specified CommonNotifySignalKickedOut message. Does not implicitly {@link AcFunDanmu.CommonNotifySignalKickedOut.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.CommonNotifySignalKickedOut
         * @static
         * @param {AcFunDanmu.ICommonNotifySignalKickedOut} message CommonNotifySignalKickedOut message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommonNotifySignalKickedOut.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.reason);
            return writer;
        };

        /**
         * Encodes the specified CommonNotifySignalKickedOut message, length delimited. Does not implicitly {@link AcFunDanmu.CommonNotifySignalKickedOut.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.CommonNotifySignalKickedOut
         * @static
         * @param {AcFunDanmu.ICommonNotifySignalKickedOut} message CommonNotifySignalKickedOut message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommonNotifySignalKickedOut.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CommonNotifySignalKickedOut message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.CommonNotifySignalKickedOut
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.CommonNotifySignalKickedOut} CommonNotifySignalKickedOut
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommonNotifySignalKickedOut.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.CommonNotifySignalKickedOut();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.reason = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CommonNotifySignalKickedOut message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.CommonNotifySignalKickedOut
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.CommonNotifySignalKickedOut} CommonNotifySignalKickedOut
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommonNotifySignalKickedOut.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CommonNotifySignalKickedOut message.
         * @function verify
         * @memberof AcFunDanmu.CommonNotifySignalKickedOut
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CommonNotifySignalKickedOut.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reason != null && message.hasOwnProperty("reason"))
                if (!$util.isString(message.reason))
                    return "reason: string expected";
            return null;
        };

        /**
         * Creates a CommonNotifySignalKickedOut message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.CommonNotifySignalKickedOut
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.CommonNotifySignalKickedOut} CommonNotifySignalKickedOut
         */
        CommonNotifySignalKickedOut.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.CommonNotifySignalKickedOut)
                return object;
            let message = new $root.AcFunDanmu.CommonNotifySignalKickedOut();
            if (object.reason != null)
                message.reason = String(object.reason);
            return message;
        };

        /**
         * Creates a plain object from a CommonNotifySignalKickedOut message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.CommonNotifySignalKickedOut
         * @static
         * @param {AcFunDanmu.CommonNotifySignalKickedOut} message CommonNotifySignalKickedOut
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CommonNotifySignalKickedOut.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.reason = "";
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = message.reason;
            return object;
        };

        /**
         * Converts this CommonNotifySignalKickedOut to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.CommonNotifySignalKickedOut
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CommonNotifySignalKickedOut.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CommonNotifySignalKickedOut;
    })();

    AcFunDanmu.CommonNotifySignalViolationAlert = (function() {

        /**
         * Properties of a CommonNotifySignalViolationAlert.
         * @memberof AcFunDanmu
         * @interface ICommonNotifySignalViolationAlert
         * @property {string|null} [violationContent] CommonNotifySignalViolationAlert violationContent
         */

        /**
         * Constructs a new CommonNotifySignalViolationAlert.
         * @memberof AcFunDanmu
         * @classdesc Represents a CommonNotifySignalViolationAlert.
         * @implements ICommonNotifySignalViolationAlert
         * @constructor
         * @param {AcFunDanmu.ICommonNotifySignalViolationAlert=} [properties] Properties to set
         */
        function CommonNotifySignalViolationAlert(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CommonNotifySignalViolationAlert violationContent.
         * @member {string} violationContent
         * @memberof AcFunDanmu.CommonNotifySignalViolationAlert
         * @instance
         */
        CommonNotifySignalViolationAlert.prototype.violationContent = "";

        /**
         * Creates a new CommonNotifySignalViolationAlert instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.CommonNotifySignalViolationAlert
         * @static
         * @param {AcFunDanmu.ICommonNotifySignalViolationAlert=} [properties] Properties to set
         * @returns {AcFunDanmu.CommonNotifySignalViolationAlert} CommonNotifySignalViolationAlert instance
         */
        CommonNotifySignalViolationAlert.create = function create(properties) {
            return new CommonNotifySignalViolationAlert(properties);
        };

        /**
         * Encodes the specified CommonNotifySignalViolationAlert message. Does not implicitly {@link AcFunDanmu.CommonNotifySignalViolationAlert.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.CommonNotifySignalViolationAlert
         * @static
         * @param {AcFunDanmu.ICommonNotifySignalViolationAlert} message CommonNotifySignalViolationAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommonNotifySignalViolationAlert.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.violationContent != null && Object.hasOwnProperty.call(message, "violationContent"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.violationContent);
            return writer;
        };

        /**
         * Encodes the specified CommonNotifySignalViolationAlert message, length delimited. Does not implicitly {@link AcFunDanmu.CommonNotifySignalViolationAlert.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.CommonNotifySignalViolationAlert
         * @static
         * @param {AcFunDanmu.ICommonNotifySignalViolationAlert} message CommonNotifySignalViolationAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommonNotifySignalViolationAlert.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CommonNotifySignalViolationAlert message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.CommonNotifySignalViolationAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.CommonNotifySignalViolationAlert} CommonNotifySignalViolationAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommonNotifySignalViolationAlert.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.CommonNotifySignalViolationAlert();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.violationContent = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CommonNotifySignalViolationAlert message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.CommonNotifySignalViolationAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.CommonNotifySignalViolationAlert} CommonNotifySignalViolationAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommonNotifySignalViolationAlert.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CommonNotifySignalViolationAlert message.
         * @function verify
         * @memberof AcFunDanmu.CommonNotifySignalViolationAlert
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CommonNotifySignalViolationAlert.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.violationContent != null && message.hasOwnProperty("violationContent"))
                if (!$util.isString(message.violationContent))
                    return "violationContent: string expected";
            return null;
        };

        /**
         * Creates a CommonNotifySignalViolationAlert message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.CommonNotifySignalViolationAlert
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.CommonNotifySignalViolationAlert} CommonNotifySignalViolationAlert
         */
        CommonNotifySignalViolationAlert.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.CommonNotifySignalViolationAlert)
                return object;
            let message = new $root.AcFunDanmu.CommonNotifySignalViolationAlert();
            if (object.violationContent != null)
                message.violationContent = String(object.violationContent);
            return message;
        };

        /**
         * Creates a plain object from a CommonNotifySignalViolationAlert message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.CommonNotifySignalViolationAlert
         * @static
         * @param {AcFunDanmu.CommonNotifySignalViolationAlert} message CommonNotifySignalViolationAlert
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CommonNotifySignalViolationAlert.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.violationContent = "";
            if (message.violationContent != null && message.hasOwnProperty("violationContent"))
                object.violationContent = message.violationContent;
            return object;
        };

        /**
         * Converts this CommonNotifySignalViolationAlert to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.CommonNotifySignalViolationAlert
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CommonNotifySignalViolationAlert.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CommonNotifySignalViolationAlert;
    })();

    AcFunDanmu.CommonStateSignalDisplayInfo = (function() {

        /**
         * Properties of a CommonStateSignalDisplayInfo.
         * @memberof AcFunDanmu
         * @interface ICommonStateSignalDisplayInfo
         * @property {string|null} [watchingCount] CommonStateSignalDisplayInfo watchingCount
         * @property {string|null} [likeCount] CommonStateSignalDisplayInfo likeCount
         * @property {number|null} [likeDelta] CommonStateSignalDisplayInfo likeDelta
         */

        /**
         * Constructs a new CommonStateSignalDisplayInfo.
         * @memberof AcFunDanmu
         * @classdesc Represents a CommonStateSignalDisplayInfo.
         * @implements ICommonStateSignalDisplayInfo
         * @constructor
         * @param {AcFunDanmu.ICommonStateSignalDisplayInfo=} [properties] Properties to set
         */
        function CommonStateSignalDisplayInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CommonStateSignalDisplayInfo watchingCount.
         * @member {string} watchingCount
         * @memberof AcFunDanmu.CommonStateSignalDisplayInfo
         * @instance
         */
        CommonStateSignalDisplayInfo.prototype.watchingCount = "";

        /**
         * CommonStateSignalDisplayInfo likeCount.
         * @member {string} likeCount
         * @memberof AcFunDanmu.CommonStateSignalDisplayInfo
         * @instance
         */
        CommonStateSignalDisplayInfo.prototype.likeCount = "";

        /**
         * CommonStateSignalDisplayInfo likeDelta.
         * @member {number} likeDelta
         * @memberof AcFunDanmu.CommonStateSignalDisplayInfo
         * @instance
         */
        CommonStateSignalDisplayInfo.prototype.likeDelta = 0;

        /**
         * Creates a new CommonStateSignalDisplayInfo instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.CommonStateSignalDisplayInfo
         * @static
         * @param {AcFunDanmu.ICommonStateSignalDisplayInfo=} [properties] Properties to set
         * @returns {AcFunDanmu.CommonStateSignalDisplayInfo} CommonStateSignalDisplayInfo instance
         */
        CommonStateSignalDisplayInfo.create = function create(properties) {
            return new CommonStateSignalDisplayInfo(properties);
        };

        /**
         * Encodes the specified CommonStateSignalDisplayInfo message. Does not implicitly {@link AcFunDanmu.CommonStateSignalDisplayInfo.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.CommonStateSignalDisplayInfo
         * @static
         * @param {AcFunDanmu.ICommonStateSignalDisplayInfo} message CommonStateSignalDisplayInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommonStateSignalDisplayInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.watchingCount != null && Object.hasOwnProperty.call(message, "watchingCount"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.watchingCount);
            if (message.likeCount != null && Object.hasOwnProperty.call(message, "likeCount"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.likeCount);
            if (message.likeDelta != null && Object.hasOwnProperty.call(message, "likeDelta"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.likeDelta);
            return writer;
        };

        /**
         * Encodes the specified CommonStateSignalDisplayInfo message, length delimited. Does not implicitly {@link AcFunDanmu.CommonStateSignalDisplayInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.CommonStateSignalDisplayInfo
         * @static
         * @param {AcFunDanmu.ICommonStateSignalDisplayInfo} message CommonStateSignalDisplayInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommonStateSignalDisplayInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CommonStateSignalDisplayInfo message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.CommonStateSignalDisplayInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.CommonStateSignalDisplayInfo} CommonStateSignalDisplayInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommonStateSignalDisplayInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.CommonStateSignalDisplayInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.watchingCount = reader.string();
                    break;
                case 2:
                    message.likeCount = reader.string();
                    break;
                case 3:
                    message.likeDelta = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CommonStateSignalDisplayInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.CommonStateSignalDisplayInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.CommonStateSignalDisplayInfo} CommonStateSignalDisplayInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommonStateSignalDisplayInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CommonStateSignalDisplayInfo message.
         * @function verify
         * @memberof AcFunDanmu.CommonStateSignalDisplayInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CommonStateSignalDisplayInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.watchingCount != null && message.hasOwnProperty("watchingCount"))
                if (!$util.isString(message.watchingCount))
                    return "watchingCount: string expected";
            if (message.likeCount != null && message.hasOwnProperty("likeCount"))
                if (!$util.isString(message.likeCount))
                    return "likeCount: string expected";
            if (message.likeDelta != null && message.hasOwnProperty("likeDelta"))
                if (!$util.isInteger(message.likeDelta))
                    return "likeDelta: integer expected";
            return null;
        };

        /**
         * Creates a CommonStateSignalDisplayInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.CommonStateSignalDisplayInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.CommonStateSignalDisplayInfo} CommonStateSignalDisplayInfo
         */
        CommonStateSignalDisplayInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.CommonStateSignalDisplayInfo)
                return object;
            let message = new $root.AcFunDanmu.CommonStateSignalDisplayInfo();
            if (object.watchingCount != null)
                message.watchingCount = String(object.watchingCount);
            if (object.likeCount != null)
                message.likeCount = String(object.likeCount);
            if (object.likeDelta != null)
                message.likeDelta = object.likeDelta | 0;
            return message;
        };

        /**
         * Creates a plain object from a CommonStateSignalDisplayInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.CommonStateSignalDisplayInfo
         * @static
         * @param {AcFunDanmu.CommonStateSignalDisplayInfo} message CommonStateSignalDisplayInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CommonStateSignalDisplayInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.watchingCount = "";
                object.likeCount = "";
                object.likeDelta = 0;
            }
            if (message.watchingCount != null && message.hasOwnProperty("watchingCount"))
                object.watchingCount = message.watchingCount;
            if (message.likeCount != null && message.hasOwnProperty("likeCount"))
                object.likeCount = message.likeCount;
            if (message.likeDelta != null && message.hasOwnProperty("likeDelta"))
                object.likeDelta = message.likeDelta;
            return object;
        };

        /**
         * Converts this CommonStateSignalDisplayInfo to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.CommonStateSignalDisplayInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CommonStateSignalDisplayInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CommonStateSignalDisplayInfo;
    })();

    AcFunDanmu.CommonStateSignalTopUsers = (function() {

        /**
         * Properties of a CommonStateSignalTopUsers.
         * @memberof AcFunDanmu
         * @interface ICommonStateSignalTopUsers
         * @property {Array.<AcFunDanmu.CommonStateSignalTopUsers.ITopUser>|null} [user] CommonStateSignalTopUsers user
         */

        /**
         * Constructs a new CommonStateSignalTopUsers.
         * @memberof AcFunDanmu
         * @classdesc Represents a CommonStateSignalTopUsers.
         * @implements ICommonStateSignalTopUsers
         * @constructor
         * @param {AcFunDanmu.ICommonStateSignalTopUsers=} [properties] Properties to set
         */
        function CommonStateSignalTopUsers(properties) {
            this.user = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CommonStateSignalTopUsers user.
         * @member {Array.<AcFunDanmu.CommonStateSignalTopUsers.ITopUser>} user
         * @memberof AcFunDanmu.CommonStateSignalTopUsers
         * @instance
         */
        CommonStateSignalTopUsers.prototype.user = $util.emptyArray;

        /**
         * Creates a new CommonStateSignalTopUsers instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.CommonStateSignalTopUsers
         * @static
         * @param {AcFunDanmu.ICommonStateSignalTopUsers=} [properties] Properties to set
         * @returns {AcFunDanmu.CommonStateSignalTopUsers} CommonStateSignalTopUsers instance
         */
        CommonStateSignalTopUsers.create = function create(properties) {
            return new CommonStateSignalTopUsers(properties);
        };

        /**
         * Encodes the specified CommonStateSignalTopUsers message. Does not implicitly {@link AcFunDanmu.CommonStateSignalTopUsers.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.CommonStateSignalTopUsers
         * @static
         * @param {AcFunDanmu.ICommonStateSignalTopUsers} message CommonStateSignalTopUsers message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommonStateSignalTopUsers.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.user != null && message.user.length)
                for (let i = 0; i < message.user.length; ++i)
                    $root.AcFunDanmu.CommonStateSignalTopUsers.TopUser.encode(message.user[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CommonStateSignalTopUsers message, length delimited. Does not implicitly {@link AcFunDanmu.CommonStateSignalTopUsers.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.CommonStateSignalTopUsers
         * @static
         * @param {AcFunDanmu.ICommonStateSignalTopUsers} message CommonStateSignalTopUsers message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommonStateSignalTopUsers.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CommonStateSignalTopUsers message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.CommonStateSignalTopUsers
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.CommonStateSignalTopUsers} CommonStateSignalTopUsers
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommonStateSignalTopUsers.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.CommonStateSignalTopUsers();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.user && message.user.length))
                        message.user = [];
                    message.user.push($root.AcFunDanmu.CommonStateSignalTopUsers.TopUser.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CommonStateSignalTopUsers message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.CommonStateSignalTopUsers
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.CommonStateSignalTopUsers} CommonStateSignalTopUsers
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommonStateSignalTopUsers.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CommonStateSignalTopUsers message.
         * @function verify
         * @memberof AcFunDanmu.CommonStateSignalTopUsers
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CommonStateSignalTopUsers.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.user != null && message.hasOwnProperty("user")) {
                if (!Array.isArray(message.user))
                    return "user: array expected";
                for (let i = 0; i < message.user.length; ++i) {
                    let error = $root.AcFunDanmu.CommonStateSignalTopUsers.TopUser.verify(message.user[i]);
                    if (error)
                        return "user." + error;
                }
            }
            return null;
        };

        /**
         * Creates a CommonStateSignalTopUsers message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.CommonStateSignalTopUsers
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.CommonStateSignalTopUsers} CommonStateSignalTopUsers
         */
        CommonStateSignalTopUsers.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.CommonStateSignalTopUsers)
                return object;
            let message = new $root.AcFunDanmu.CommonStateSignalTopUsers();
            if (object.user) {
                if (!Array.isArray(object.user))
                    throw TypeError(".AcFunDanmu.CommonStateSignalTopUsers.user: array expected");
                message.user = [];
                for (let i = 0; i < object.user.length; ++i) {
                    if (typeof object.user[i] !== "object")
                        throw TypeError(".AcFunDanmu.CommonStateSignalTopUsers.user: object expected");
                    message.user[i] = $root.AcFunDanmu.CommonStateSignalTopUsers.TopUser.fromObject(object.user[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a CommonStateSignalTopUsers message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.CommonStateSignalTopUsers
         * @static
         * @param {AcFunDanmu.CommonStateSignalTopUsers} message CommonStateSignalTopUsers
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CommonStateSignalTopUsers.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.user = [];
            if (message.user && message.user.length) {
                object.user = [];
                for (let j = 0; j < message.user.length; ++j)
                    object.user[j] = $root.AcFunDanmu.CommonStateSignalTopUsers.TopUser.toObject(message.user[j], options);
            }
            return object;
        };

        /**
         * Converts this CommonStateSignalTopUsers to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.CommonStateSignalTopUsers
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CommonStateSignalTopUsers.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        CommonStateSignalTopUsers.TopUser = (function() {

            /**
             * Properties of a TopUser.
             * @memberof AcFunDanmu.CommonStateSignalTopUsers
             * @interface ITopUser
             * @property {AcFunDanmu.IZtLiveUserInfo|null} [userInfo] TopUser userInfo
             * @property {string|null} [customWatchingListData] TopUser customWatchingListData
             * @property {string|null} [displaySendAmount] TopUser displaySendAmount
             * @property {boolean|null} [anonymousUser] TopUser anonymousUser
             */

            /**
             * Constructs a new TopUser.
             * @memberof AcFunDanmu.CommonStateSignalTopUsers
             * @classdesc Represents a TopUser.
             * @implements ITopUser
             * @constructor
             * @param {AcFunDanmu.CommonStateSignalTopUsers.ITopUser=} [properties] Properties to set
             */
            function TopUser(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TopUser userInfo.
             * @member {AcFunDanmu.IZtLiveUserInfo|null|undefined} userInfo
             * @memberof AcFunDanmu.CommonStateSignalTopUsers.TopUser
             * @instance
             */
            TopUser.prototype.userInfo = null;

            /**
             * TopUser customWatchingListData.
             * @member {string} customWatchingListData
             * @memberof AcFunDanmu.CommonStateSignalTopUsers.TopUser
             * @instance
             */
            TopUser.prototype.customWatchingListData = "";

            /**
             * TopUser displaySendAmount.
             * @member {string} displaySendAmount
             * @memberof AcFunDanmu.CommonStateSignalTopUsers.TopUser
             * @instance
             */
            TopUser.prototype.displaySendAmount = "";

            /**
             * TopUser anonymousUser.
             * @member {boolean} anonymousUser
             * @memberof AcFunDanmu.CommonStateSignalTopUsers.TopUser
             * @instance
             */
            TopUser.prototype.anonymousUser = false;

            /**
             * Creates a new TopUser instance using the specified properties.
             * @function create
             * @memberof AcFunDanmu.CommonStateSignalTopUsers.TopUser
             * @static
             * @param {AcFunDanmu.CommonStateSignalTopUsers.ITopUser=} [properties] Properties to set
             * @returns {AcFunDanmu.CommonStateSignalTopUsers.TopUser} TopUser instance
             */
            TopUser.create = function create(properties) {
                return new TopUser(properties);
            };

            /**
             * Encodes the specified TopUser message. Does not implicitly {@link AcFunDanmu.CommonStateSignalTopUsers.TopUser.verify|verify} messages.
             * @function encode
             * @memberof AcFunDanmu.CommonStateSignalTopUsers.TopUser
             * @static
             * @param {AcFunDanmu.CommonStateSignalTopUsers.ITopUser} message TopUser message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TopUser.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.userInfo != null && Object.hasOwnProperty.call(message, "userInfo"))
                    $root.AcFunDanmu.ZtLiveUserInfo.encode(message.userInfo, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.customWatchingListData != null && Object.hasOwnProperty.call(message, "customWatchingListData"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.customWatchingListData);
                if (message.displaySendAmount != null && Object.hasOwnProperty.call(message, "displaySendAmount"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.displaySendAmount);
                if (message.anonymousUser != null && Object.hasOwnProperty.call(message, "anonymousUser"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.anonymousUser);
                return writer;
            };

            /**
             * Encodes the specified TopUser message, length delimited. Does not implicitly {@link AcFunDanmu.CommonStateSignalTopUsers.TopUser.verify|verify} messages.
             * @function encodeDelimited
             * @memberof AcFunDanmu.CommonStateSignalTopUsers.TopUser
             * @static
             * @param {AcFunDanmu.CommonStateSignalTopUsers.ITopUser} message TopUser message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TopUser.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TopUser message from the specified reader or buffer.
             * @function decode
             * @memberof AcFunDanmu.CommonStateSignalTopUsers.TopUser
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {AcFunDanmu.CommonStateSignalTopUsers.TopUser} TopUser
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TopUser.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.CommonStateSignalTopUsers.TopUser();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.userInfo = $root.AcFunDanmu.ZtLiveUserInfo.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.customWatchingListData = reader.string();
                        break;
                    case 3:
                        message.displaySendAmount = reader.string();
                        break;
                    case 4:
                        message.anonymousUser = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TopUser message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof AcFunDanmu.CommonStateSignalTopUsers.TopUser
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {AcFunDanmu.CommonStateSignalTopUsers.TopUser} TopUser
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TopUser.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TopUser message.
             * @function verify
             * @memberof AcFunDanmu.CommonStateSignalTopUsers.TopUser
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TopUser.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.userInfo != null && message.hasOwnProperty("userInfo")) {
                    let error = $root.AcFunDanmu.ZtLiveUserInfo.verify(message.userInfo);
                    if (error)
                        return "userInfo." + error;
                }
                if (message.customWatchingListData != null && message.hasOwnProperty("customWatchingListData"))
                    if (!$util.isString(message.customWatchingListData))
                        return "customWatchingListData: string expected";
                if (message.displaySendAmount != null && message.hasOwnProperty("displaySendAmount"))
                    if (!$util.isString(message.displaySendAmount))
                        return "displaySendAmount: string expected";
                if (message.anonymousUser != null && message.hasOwnProperty("anonymousUser"))
                    if (typeof message.anonymousUser !== "boolean")
                        return "anonymousUser: boolean expected";
                return null;
            };

            /**
             * Creates a TopUser message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof AcFunDanmu.CommonStateSignalTopUsers.TopUser
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {AcFunDanmu.CommonStateSignalTopUsers.TopUser} TopUser
             */
            TopUser.fromObject = function fromObject(object) {
                if (object instanceof $root.AcFunDanmu.CommonStateSignalTopUsers.TopUser)
                    return object;
                let message = new $root.AcFunDanmu.CommonStateSignalTopUsers.TopUser();
                if (object.userInfo != null) {
                    if (typeof object.userInfo !== "object")
                        throw TypeError(".AcFunDanmu.CommonStateSignalTopUsers.TopUser.userInfo: object expected");
                    message.userInfo = $root.AcFunDanmu.ZtLiveUserInfo.fromObject(object.userInfo);
                }
                if (object.customWatchingListData != null)
                    message.customWatchingListData = String(object.customWatchingListData);
                if (object.displaySendAmount != null)
                    message.displaySendAmount = String(object.displaySendAmount);
                if (object.anonymousUser != null)
                    message.anonymousUser = Boolean(object.anonymousUser);
                return message;
            };

            /**
             * Creates a plain object from a TopUser message. Also converts values to other types if specified.
             * @function toObject
             * @memberof AcFunDanmu.CommonStateSignalTopUsers.TopUser
             * @static
             * @param {AcFunDanmu.CommonStateSignalTopUsers.TopUser} message TopUser
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TopUser.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.userInfo = null;
                    object.customWatchingListData = "";
                    object.displaySendAmount = "";
                    object.anonymousUser = false;
                }
                if (message.userInfo != null && message.hasOwnProperty("userInfo"))
                    object.userInfo = $root.AcFunDanmu.ZtLiveUserInfo.toObject(message.userInfo, options);
                if (message.customWatchingListData != null && message.hasOwnProperty("customWatchingListData"))
                    object.customWatchingListData = message.customWatchingListData;
                if (message.displaySendAmount != null && message.hasOwnProperty("displaySendAmount"))
                    object.displaySendAmount = message.displaySendAmount;
                if (message.anonymousUser != null && message.hasOwnProperty("anonymousUser"))
                    object.anonymousUser = message.anonymousUser;
                return object;
            };

            /**
             * Converts this TopUser to JSON.
             * @function toJSON
             * @memberof AcFunDanmu.CommonStateSignalTopUsers.TopUser
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TopUser.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TopUser;
        })();

        return CommonStateSignalTopUsers;
    })();

    AcFunDanmu.CommonStateSignalRecentComment = (function() {

        /**
         * Properties of a CommonStateSignalRecentComment.
         * @memberof AcFunDanmu
         * @interface ICommonStateSignalRecentComment
         * @property {Array.<AcFunDanmu.ICommonActionSignalComment>|null} [comment] CommonStateSignalRecentComment comment
         */

        /**
         * Constructs a new CommonStateSignalRecentComment.
         * @memberof AcFunDanmu
         * @classdesc Represents a CommonStateSignalRecentComment.
         * @implements ICommonStateSignalRecentComment
         * @constructor
         * @param {AcFunDanmu.ICommonStateSignalRecentComment=} [properties] Properties to set
         */
        function CommonStateSignalRecentComment(properties) {
            this.comment = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CommonStateSignalRecentComment comment.
         * @member {Array.<AcFunDanmu.ICommonActionSignalComment>} comment
         * @memberof AcFunDanmu.CommonStateSignalRecentComment
         * @instance
         */
        CommonStateSignalRecentComment.prototype.comment = $util.emptyArray;

        /**
         * Creates a new CommonStateSignalRecentComment instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.CommonStateSignalRecentComment
         * @static
         * @param {AcFunDanmu.ICommonStateSignalRecentComment=} [properties] Properties to set
         * @returns {AcFunDanmu.CommonStateSignalRecentComment} CommonStateSignalRecentComment instance
         */
        CommonStateSignalRecentComment.create = function create(properties) {
            return new CommonStateSignalRecentComment(properties);
        };

        /**
         * Encodes the specified CommonStateSignalRecentComment message. Does not implicitly {@link AcFunDanmu.CommonStateSignalRecentComment.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.CommonStateSignalRecentComment
         * @static
         * @param {AcFunDanmu.ICommonStateSignalRecentComment} message CommonStateSignalRecentComment message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommonStateSignalRecentComment.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.comment != null && message.comment.length)
                for (let i = 0; i < message.comment.length; ++i)
                    $root.AcFunDanmu.CommonActionSignalComment.encode(message.comment[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CommonStateSignalRecentComment message, length delimited. Does not implicitly {@link AcFunDanmu.CommonStateSignalRecentComment.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.CommonStateSignalRecentComment
         * @static
         * @param {AcFunDanmu.ICommonStateSignalRecentComment} message CommonStateSignalRecentComment message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommonStateSignalRecentComment.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CommonStateSignalRecentComment message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.CommonStateSignalRecentComment
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.CommonStateSignalRecentComment} CommonStateSignalRecentComment
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommonStateSignalRecentComment.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.CommonStateSignalRecentComment();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.comment && message.comment.length))
                        message.comment = [];
                    message.comment.push($root.AcFunDanmu.CommonActionSignalComment.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CommonStateSignalRecentComment message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.CommonStateSignalRecentComment
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.CommonStateSignalRecentComment} CommonStateSignalRecentComment
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommonStateSignalRecentComment.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CommonStateSignalRecentComment message.
         * @function verify
         * @memberof AcFunDanmu.CommonStateSignalRecentComment
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CommonStateSignalRecentComment.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.comment != null && message.hasOwnProperty("comment")) {
                if (!Array.isArray(message.comment))
                    return "comment: array expected";
                for (let i = 0; i < message.comment.length; ++i) {
                    let error = $root.AcFunDanmu.CommonActionSignalComment.verify(message.comment[i]);
                    if (error)
                        return "comment." + error;
                }
            }
            return null;
        };

        /**
         * Creates a CommonStateSignalRecentComment message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.CommonStateSignalRecentComment
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.CommonStateSignalRecentComment} CommonStateSignalRecentComment
         */
        CommonStateSignalRecentComment.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.CommonStateSignalRecentComment)
                return object;
            let message = new $root.AcFunDanmu.CommonStateSignalRecentComment();
            if (object.comment) {
                if (!Array.isArray(object.comment))
                    throw TypeError(".AcFunDanmu.CommonStateSignalRecentComment.comment: array expected");
                message.comment = [];
                for (let i = 0; i < object.comment.length; ++i) {
                    if (typeof object.comment[i] !== "object")
                        throw TypeError(".AcFunDanmu.CommonStateSignalRecentComment.comment: object expected");
                    message.comment[i] = $root.AcFunDanmu.CommonActionSignalComment.fromObject(object.comment[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a CommonStateSignalRecentComment message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.CommonStateSignalRecentComment
         * @static
         * @param {AcFunDanmu.CommonStateSignalRecentComment} message CommonStateSignalRecentComment
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CommonStateSignalRecentComment.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.comment = [];
            if (message.comment && message.comment.length) {
                object.comment = [];
                for (let j = 0; j < message.comment.length; ++j)
                    object.comment[j] = $root.AcFunDanmu.CommonActionSignalComment.toObject(message.comment[j], options);
            }
            return object;
        };

        /**
         * Converts this CommonStateSignalRecentComment to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.CommonStateSignalRecentComment
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CommonStateSignalRecentComment.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CommonStateSignalRecentComment;
    })();

    /**
     * CsAckErrorCode enum.
     * @name AcFunDanmu.CsAckErrorCode
     * @enum {number}
     * @property {number} SUCCESS_CS_ACK=0 SUCCESS_CS_ACK value
     * @property {number} LIVE_CLOSED=1 LIVE_CLOSED value
     * @property {number} TICKET_ILLEGAL=2 TICKET_ILLEGAL value
     * @property {number} ATTACH_ILLEGAL=3 ATTACH_ILLEGAL value
     * @property {number} USER_NOT_IN_ROOM=4 USER_NOT_IN_ROOM value
     * @property {number} SERVER_ERROR=5 SERVER_ERROR value
     * @property {number} REQUEST_PARAM_INVALID=6 REQUEST_PARAM_INVALID value
     * @property {number} ROOM_NOT_EXIST_IN_STATE_MANAGER=7 ROOM_NOT_EXIST_IN_STATE_MANAGER value
     */
    AcFunDanmu.CsAckErrorCode = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "SUCCESS_CS_ACK"] = 0;
        values[valuesById[1] = "LIVE_CLOSED"] = 1;
        values[valuesById[2] = "TICKET_ILLEGAL"] = 2;
        values[valuesById[3] = "ATTACH_ILLEGAL"] = 3;
        values[valuesById[4] = "USER_NOT_IN_ROOM"] = 4;
        values[valuesById[5] = "SERVER_ERROR"] = 5;
        values[valuesById[6] = "REQUEST_PARAM_INVALID"] = 6;
        values[valuesById[7] = "ROOM_NOT_EXIST_IN_STATE_MANAGER"] = 7;
        return values;
    })();

    /**
     * ZtLiveDownstreamPayloadErrorCode enum.
     * @name AcFunDanmu.ZtLiveDownstreamPayloadErrorCode
     * @enum {number}
     * @property {number} SUCCESS_DOWNSTREAM_PAYLOAD=0 SUCCESS_DOWNSTREAM_PAYLOAD value
     * @property {number} CS_CMD_PARSE_ERROR=100001 CS_CMD_PARSE_ERROR value
     * @property {number} CS_CMD_CMD_NOT_SUPPORT=100002 CS_CMD_CMD_NOT_SUPPORT value
     * @property {number} CS_CMD_TICKET_ILLEGAL=100003 CS_CMD_TICKET_ILLEGAL value
     */
    AcFunDanmu.ZtLiveDownstreamPayloadErrorCode = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "SUCCESS_DOWNSTREAM_PAYLOAD"] = 0;
        values[valuesById[100001] = "CS_CMD_PARSE_ERROR"] = 100001;
        values[valuesById[100002] = "CS_CMD_CMD_NOT_SUPPORT"] = 100002;
        values[valuesById[100003] = "CS_CMD_TICKET_ILLEGAL"] = 100003;
        return values;
    })();

    AcFunDanmu.CommonStateSignalChatCall = (function() {

        /**
         * Properties of a CommonStateSignalChatCall.
         * @memberof AcFunDanmu
         * @interface ICommonStateSignalChatCall
         * @property {string|null} [chatId] CommonStateSignalChatCall chatId
         * @property {string|null} [liveId] CommonStateSignalChatCall liveId
         */

        /**
         * Constructs a new CommonStateSignalChatCall.
         * @memberof AcFunDanmu
         * @classdesc Represents a CommonStateSignalChatCall.
         * @implements ICommonStateSignalChatCall
         * @constructor
         * @param {AcFunDanmu.ICommonStateSignalChatCall=} [properties] Properties to set
         */
        function CommonStateSignalChatCall(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CommonStateSignalChatCall chatId.
         * @member {string} chatId
         * @memberof AcFunDanmu.CommonStateSignalChatCall
         * @instance
         */
        CommonStateSignalChatCall.prototype.chatId = "";

        /**
         * CommonStateSignalChatCall liveId.
         * @member {string} liveId
         * @memberof AcFunDanmu.CommonStateSignalChatCall
         * @instance
         */
        CommonStateSignalChatCall.prototype.liveId = "";

        /**
         * Creates a new CommonStateSignalChatCall instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.CommonStateSignalChatCall
         * @static
         * @param {AcFunDanmu.ICommonStateSignalChatCall=} [properties] Properties to set
         * @returns {AcFunDanmu.CommonStateSignalChatCall} CommonStateSignalChatCall instance
         */
        CommonStateSignalChatCall.create = function create(properties) {
            return new CommonStateSignalChatCall(properties);
        };

        /**
         * Encodes the specified CommonStateSignalChatCall message. Does not implicitly {@link AcFunDanmu.CommonStateSignalChatCall.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.CommonStateSignalChatCall
         * @static
         * @param {AcFunDanmu.ICommonStateSignalChatCall} message CommonStateSignalChatCall message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommonStateSignalChatCall.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chatId != null && Object.hasOwnProperty.call(message, "chatId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.chatId);
            if (message.liveId != null && Object.hasOwnProperty.call(message, "liveId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.liveId);
            return writer;
        };

        /**
         * Encodes the specified CommonStateSignalChatCall message, length delimited. Does not implicitly {@link AcFunDanmu.CommonStateSignalChatCall.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.CommonStateSignalChatCall
         * @static
         * @param {AcFunDanmu.ICommonStateSignalChatCall} message CommonStateSignalChatCall message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommonStateSignalChatCall.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CommonStateSignalChatCall message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.CommonStateSignalChatCall
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.CommonStateSignalChatCall} CommonStateSignalChatCall
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommonStateSignalChatCall.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.CommonStateSignalChatCall();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.chatId = reader.string();
                    break;
                case 2:
                    message.liveId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CommonStateSignalChatCall message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.CommonStateSignalChatCall
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.CommonStateSignalChatCall} CommonStateSignalChatCall
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommonStateSignalChatCall.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CommonStateSignalChatCall message.
         * @function verify
         * @memberof AcFunDanmu.CommonStateSignalChatCall
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CommonStateSignalChatCall.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.chatId != null && message.hasOwnProperty("chatId"))
                if (!$util.isString(message.chatId))
                    return "chatId: string expected";
            if (message.liveId != null && message.hasOwnProperty("liveId"))
                if (!$util.isString(message.liveId))
                    return "liveId: string expected";
            return null;
        };

        /**
         * Creates a CommonStateSignalChatCall message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.CommonStateSignalChatCall
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.CommonStateSignalChatCall} CommonStateSignalChatCall
         */
        CommonStateSignalChatCall.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.CommonStateSignalChatCall)
                return object;
            let message = new $root.AcFunDanmu.CommonStateSignalChatCall();
            if (object.chatId != null)
                message.chatId = String(object.chatId);
            if (object.liveId != null)
                message.liveId = String(object.liveId);
            return message;
        };

        /**
         * Creates a plain object from a CommonStateSignalChatCall message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.CommonStateSignalChatCall
         * @static
         * @param {AcFunDanmu.CommonStateSignalChatCall} message CommonStateSignalChatCall
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CommonStateSignalChatCall.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.chatId = "";
                object.liveId = "";
            }
            if (message.chatId != null && message.hasOwnProperty("chatId"))
                object.chatId = message.chatId;
            if (message.liveId != null && message.hasOwnProperty("liveId"))
                object.liveId = message.liveId;
            return object;
        };

        /**
         * Converts this CommonStateSignalChatCall to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.CommonStateSignalChatCall
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CommonStateSignalChatCall.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CommonStateSignalChatCall;
    })();

    AcFunDanmu.CommonStateSignalChatAccept = (function() {

        /**
         * Properties of a CommonStateSignalChatAccept.
         * @memberof AcFunDanmu
         * @interface ICommonStateSignalChatAccept
         * @property {string|null} [chatId] CommonStateSignalChatAccept chatId
         * @property {AcFunDanmu.ChatMediaType|null} [mediaType] CommonStateSignalChatAccept mediaType
         * @property {string|null} [arraySignalInfo] CommonStateSignalChatAccept arraySignalInfo
         */

        /**
         * Constructs a new CommonStateSignalChatAccept.
         * @memberof AcFunDanmu
         * @classdesc Represents a CommonStateSignalChatAccept.
         * @implements ICommonStateSignalChatAccept
         * @constructor
         * @param {AcFunDanmu.ICommonStateSignalChatAccept=} [properties] Properties to set
         */
        function CommonStateSignalChatAccept(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CommonStateSignalChatAccept chatId.
         * @member {string} chatId
         * @memberof AcFunDanmu.CommonStateSignalChatAccept
         * @instance
         */
        CommonStateSignalChatAccept.prototype.chatId = "";

        /**
         * CommonStateSignalChatAccept mediaType.
         * @member {AcFunDanmu.ChatMediaType} mediaType
         * @memberof AcFunDanmu.CommonStateSignalChatAccept
         * @instance
         */
        CommonStateSignalChatAccept.prototype.mediaType = 0;

        /**
         * CommonStateSignalChatAccept arraySignalInfo.
         * @member {string} arraySignalInfo
         * @memberof AcFunDanmu.CommonStateSignalChatAccept
         * @instance
         */
        CommonStateSignalChatAccept.prototype.arraySignalInfo = "";

        /**
         * Creates a new CommonStateSignalChatAccept instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.CommonStateSignalChatAccept
         * @static
         * @param {AcFunDanmu.ICommonStateSignalChatAccept=} [properties] Properties to set
         * @returns {AcFunDanmu.CommonStateSignalChatAccept} CommonStateSignalChatAccept instance
         */
        CommonStateSignalChatAccept.create = function create(properties) {
            return new CommonStateSignalChatAccept(properties);
        };

        /**
         * Encodes the specified CommonStateSignalChatAccept message. Does not implicitly {@link AcFunDanmu.CommonStateSignalChatAccept.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.CommonStateSignalChatAccept
         * @static
         * @param {AcFunDanmu.ICommonStateSignalChatAccept} message CommonStateSignalChatAccept message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommonStateSignalChatAccept.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chatId != null && Object.hasOwnProperty.call(message, "chatId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.chatId);
            if (message.mediaType != null && Object.hasOwnProperty.call(message, "mediaType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.mediaType);
            if (message.arraySignalInfo != null && Object.hasOwnProperty.call(message, "arraySignalInfo"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.arraySignalInfo);
            return writer;
        };

        /**
         * Encodes the specified CommonStateSignalChatAccept message, length delimited. Does not implicitly {@link AcFunDanmu.CommonStateSignalChatAccept.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.CommonStateSignalChatAccept
         * @static
         * @param {AcFunDanmu.ICommonStateSignalChatAccept} message CommonStateSignalChatAccept message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommonStateSignalChatAccept.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CommonStateSignalChatAccept message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.CommonStateSignalChatAccept
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.CommonStateSignalChatAccept} CommonStateSignalChatAccept
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommonStateSignalChatAccept.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.CommonStateSignalChatAccept();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.chatId = reader.string();
                    break;
                case 2:
                    message.mediaType = reader.int32();
                    break;
                case 3:
                    message.arraySignalInfo = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CommonStateSignalChatAccept message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.CommonStateSignalChatAccept
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.CommonStateSignalChatAccept} CommonStateSignalChatAccept
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommonStateSignalChatAccept.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CommonStateSignalChatAccept message.
         * @function verify
         * @memberof AcFunDanmu.CommonStateSignalChatAccept
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CommonStateSignalChatAccept.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.chatId != null && message.hasOwnProperty("chatId"))
                if (!$util.isString(message.chatId))
                    return "chatId: string expected";
            if (message.mediaType != null && message.hasOwnProperty("mediaType"))
                switch (message.mediaType) {
                default:
                    return "mediaType: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.arraySignalInfo != null && message.hasOwnProperty("arraySignalInfo"))
                if (!$util.isString(message.arraySignalInfo))
                    return "arraySignalInfo: string expected";
            return null;
        };

        /**
         * Creates a CommonStateSignalChatAccept message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.CommonStateSignalChatAccept
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.CommonStateSignalChatAccept} CommonStateSignalChatAccept
         */
        CommonStateSignalChatAccept.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.CommonStateSignalChatAccept)
                return object;
            let message = new $root.AcFunDanmu.CommonStateSignalChatAccept();
            if (object.chatId != null)
                message.chatId = String(object.chatId);
            switch (object.mediaType) {
            case "UNKNOWN":
            case 0:
                message.mediaType = 0;
                break;
            case "AUDIO":
            case 1:
                message.mediaType = 1;
                break;
            case "VIDEO":
            case 2:
                message.mediaType = 2;
                break;
            }
            if (object.arraySignalInfo != null)
                message.arraySignalInfo = String(object.arraySignalInfo);
            return message;
        };

        /**
         * Creates a plain object from a CommonStateSignalChatAccept message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.CommonStateSignalChatAccept
         * @static
         * @param {AcFunDanmu.CommonStateSignalChatAccept} message CommonStateSignalChatAccept
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CommonStateSignalChatAccept.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.chatId = "";
                object.mediaType = options.enums === String ? "UNKNOWN" : 0;
                object.arraySignalInfo = "";
            }
            if (message.chatId != null && message.hasOwnProperty("chatId"))
                object.chatId = message.chatId;
            if (message.mediaType != null && message.hasOwnProperty("mediaType"))
                object.mediaType = options.enums === String ? $root.AcFunDanmu.ChatMediaType[message.mediaType] : message.mediaType;
            if (message.arraySignalInfo != null && message.hasOwnProperty("arraySignalInfo"))
                object.arraySignalInfo = message.arraySignalInfo;
            return object;
        };

        /**
         * Converts this CommonStateSignalChatAccept to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.CommonStateSignalChatAccept
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CommonStateSignalChatAccept.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CommonStateSignalChatAccept;
    })();

    AcFunDanmu.CommonStateSignalChatReady = (function() {

        /**
         * Properties of a CommonStateSignalChatReady.
         * @memberof AcFunDanmu
         * @interface ICommonStateSignalChatReady
         * @property {string|null} [chatId] CommonStateSignalChatReady chatId
         * @property {AcFunDanmu.IZtLiveUserInfo|null} [guestUserInfo] CommonStateSignalChatReady guestUserInfo
         * @property {number|null} [mediaType] CommonStateSignalChatReady mediaType
         */

        /**
         * Constructs a new CommonStateSignalChatReady.
         * @memberof AcFunDanmu
         * @classdesc Represents a CommonStateSignalChatReady.
         * @implements ICommonStateSignalChatReady
         * @constructor
         * @param {AcFunDanmu.ICommonStateSignalChatReady=} [properties] Properties to set
         */
        function CommonStateSignalChatReady(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CommonStateSignalChatReady chatId.
         * @member {string} chatId
         * @memberof AcFunDanmu.CommonStateSignalChatReady
         * @instance
         */
        CommonStateSignalChatReady.prototype.chatId = "";

        /**
         * CommonStateSignalChatReady guestUserInfo.
         * @member {AcFunDanmu.IZtLiveUserInfo|null|undefined} guestUserInfo
         * @memberof AcFunDanmu.CommonStateSignalChatReady
         * @instance
         */
        CommonStateSignalChatReady.prototype.guestUserInfo = null;

        /**
         * CommonStateSignalChatReady mediaType.
         * @member {number} mediaType
         * @memberof AcFunDanmu.CommonStateSignalChatReady
         * @instance
         */
        CommonStateSignalChatReady.prototype.mediaType = 0;

        /**
         * Creates a new CommonStateSignalChatReady instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.CommonStateSignalChatReady
         * @static
         * @param {AcFunDanmu.ICommonStateSignalChatReady=} [properties] Properties to set
         * @returns {AcFunDanmu.CommonStateSignalChatReady} CommonStateSignalChatReady instance
         */
        CommonStateSignalChatReady.create = function create(properties) {
            return new CommonStateSignalChatReady(properties);
        };

        /**
         * Encodes the specified CommonStateSignalChatReady message. Does not implicitly {@link AcFunDanmu.CommonStateSignalChatReady.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.CommonStateSignalChatReady
         * @static
         * @param {AcFunDanmu.ICommonStateSignalChatReady} message CommonStateSignalChatReady message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommonStateSignalChatReady.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chatId != null && Object.hasOwnProperty.call(message, "chatId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.chatId);
            if (message.guestUserInfo != null && Object.hasOwnProperty.call(message, "guestUserInfo"))
                $root.AcFunDanmu.ZtLiveUserInfo.encode(message.guestUserInfo, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.mediaType != null && Object.hasOwnProperty.call(message, "mediaType"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.mediaType);
            return writer;
        };

        /**
         * Encodes the specified CommonStateSignalChatReady message, length delimited. Does not implicitly {@link AcFunDanmu.CommonStateSignalChatReady.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.CommonStateSignalChatReady
         * @static
         * @param {AcFunDanmu.ICommonStateSignalChatReady} message CommonStateSignalChatReady message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommonStateSignalChatReady.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CommonStateSignalChatReady message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.CommonStateSignalChatReady
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.CommonStateSignalChatReady} CommonStateSignalChatReady
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommonStateSignalChatReady.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.CommonStateSignalChatReady();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.chatId = reader.string();
                    break;
                case 2:
                    message.guestUserInfo = $root.AcFunDanmu.ZtLiveUserInfo.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.mediaType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CommonStateSignalChatReady message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.CommonStateSignalChatReady
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.CommonStateSignalChatReady} CommonStateSignalChatReady
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommonStateSignalChatReady.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CommonStateSignalChatReady message.
         * @function verify
         * @memberof AcFunDanmu.CommonStateSignalChatReady
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CommonStateSignalChatReady.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.chatId != null && message.hasOwnProperty("chatId"))
                if (!$util.isString(message.chatId))
                    return "chatId: string expected";
            if (message.guestUserInfo != null && message.hasOwnProperty("guestUserInfo")) {
                let error = $root.AcFunDanmu.ZtLiveUserInfo.verify(message.guestUserInfo);
                if (error)
                    return "guestUserInfo." + error;
            }
            if (message.mediaType != null && message.hasOwnProperty("mediaType"))
                if (!$util.isInteger(message.mediaType))
                    return "mediaType: integer expected";
            return null;
        };

        /**
         * Creates a CommonStateSignalChatReady message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.CommonStateSignalChatReady
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.CommonStateSignalChatReady} CommonStateSignalChatReady
         */
        CommonStateSignalChatReady.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.CommonStateSignalChatReady)
                return object;
            let message = new $root.AcFunDanmu.CommonStateSignalChatReady();
            if (object.chatId != null)
                message.chatId = String(object.chatId);
            if (object.guestUserInfo != null) {
                if (typeof object.guestUserInfo !== "object")
                    throw TypeError(".AcFunDanmu.CommonStateSignalChatReady.guestUserInfo: object expected");
                message.guestUserInfo = $root.AcFunDanmu.ZtLiveUserInfo.fromObject(object.guestUserInfo);
            }
            if (object.mediaType != null)
                message.mediaType = object.mediaType | 0;
            return message;
        };

        /**
         * Creates a plain object from a CommonStateSignalChatReady message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.CommonStateSignalChatReady
         * @static
         * @param {AcFunDanmu.CommonStateSignalChatReady} message CommonStateSignalChatReady
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CommonStateSignalChatReady.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.chatId = "";
                object.guestUserInfo = null;
                object.mediaType = 0;
            }
            if (message.chatId != null && message.hasOwnProperty("chatId"))
                object.chatId = message.chatId;
            if (message.guestUserInfo != null && message.hasOwnProperty("guestUserInfo"))
                object.guestUserInfo = $root.AcFunDanmu.ZtLiveUserInfo.toObject(message.guestUserInfo, options);
            if (message.mediaType != null && message.hasOwnProperty("mediaType"))
                object.mediaType = message.mediaType;
            return object;
        };

        /**
         * Converts this CommonStateSignalChatReady to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.CommonStateSignalChatReady
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CommonStateSignalChatReady.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CommonStateSignalChatReady;
    })();

    AcFunDanmu.CommonStateSignalChatEnd = (function() {

        /**
         * Properties of a CommonStateSignalChatEnd.
         * @memberof AcFunDanmu
         * @interface ICommonStateSignalChatEnd
         * @property {string|null} [chatId] CommonStateSignalChatEnd chatId
         * @property {AcFunDanmu.CommonStateSignalChatEnd.EndType|null} [endType] CommonStateSignalChatEnd endType
         */

        /**
         * Constructs a new CommonStateSignalChatEnd.
         * @memberof AcFunDanmu
         * @classdesc Represents a CommonStateSignalChatEnd.
         * @implements ICommonStateSignalChatEnd
         * @constructor
         * @param {AcFunDanmu.ICommonStateSignalChatEnd=} [properties] Properties to set
         */
        function CommonStateSignalChatEnd(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CommonStateSignalChatEnd chatId.
         * @member {string} chatId
         * @memberof AcFunDanmu.CommonStateSignalChatEnd
         * @instance
         */
        CommonStateSignalChatEnd.prototype.chatId = "";

        /**
         * CommonStateSignalChatEnd endType.
         * @member {AcFunDanmu.CommonStateSignalChatEnd.EndType} endType
         * @memberof AcFunDanmu.CommonStateSignalChatEnd
         * @instance
         */
        CommonStateSignalChatEnd.prototype.endType = 0;

        /**
         * Creates a new CommonStateSignalChatEnd instance using the specified properties.
         * @function create
         * @memberof AcFunDanmu.CommonStateSignalChatEnd
         * @static
         * @param {AcFunDanmu.ICommonStateSignalChatEnd=} [properties] Properties to set
         * @returns {AcFunDanmu.CommonStateSignalChatEnd} CommonStateSignalChatEnd instance
         */
        CommonStateSignalChatEnd.create = function create(properties) {
            return new CommonStateSignalChatEnd(properties);
        };

        /**
         * Encodes the specified CommonStateSignalChatEnd message. Does not implicitly {@link AcFunDanmu.CommonStateSignalChatEnd.verify|verify} messages.
         * @function encode
         * @memberof AcFunDanmu.CommonStateSignalChatEnd
         * @static
         * @param {AcFunDanmu.ICommonStateSignalChatEnd} message CommonStateSignalChatEnd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommonStateSignalChatEnd.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chatId != null && Object.hasOwnProperty.call(message, "chatId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.chatId);
            if (message.endType != null && Object.hasOwnProperty.call(message, "endType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.endType);
            return writer;
        };

        /**
         * Encodes the specified CommonStateSignalChatEnd message, length delimited. Does not implicitly {@link AcFunDanmu.CommonStateSignalChatEnd.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AcFunDanmu.CommonStateSignalChatEnd
         * @static
         * @param {AcFunDanmu.ICommonStateSignalChatEnd} message CommonStateSignalChatEnd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommonStateSignalChatEnd.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CommonStateSignalChatEnd message from the specified reader or buffer.
         * @function decode
         * @memberof AcFunDanmu.CommonStateSignalChatEnd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AcFunDanmu.CommonStateSignalChatEnd} CommonStateSignalChatEnd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommonStateSignalChatEnd.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcFunDanmu.CommonStateSignalChatEnd();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.chatId = reader.string();
                    break;
                case 2:
                    message.endType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CommonStateSignalChatEnd message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AcFunDanmu.CommonStateSignalChatEnd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AcFunDanmu.CommonStateSignalChatEnd} CommonStateSignalChatEnd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommonStateSignalChatEnd.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CommonStateSignalChatEnd message.
         * @function verify
         * @memberof AcFunDanmu.CommonStateSignalChatEnd
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CommonStateSignalChatEnd.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.chatId != null && message.hasOwnProperty("chatId"))
                if (!$util.isString(message.chatId))
                    return "chatId: string expected";
            if (message.endType != null && message.hasOwnProperty("endType"))
                switch (message.endType) {
                default:
                    return "endType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                    break;
                }
            return null;
        };

        /**
         * Creates a CommonStateSignalChatEnd message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AcFunDanmu.CommonStateSignalChatEnd
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AcFunDanmu.CommonStateSignalChatEnd} CommonStateSignalChatEnd
         */
        CommonStateSignalChatEnd.fromObject = function fromObject(object) {
            if (object instanceof $root.AcFunDanmu.CommonStateSignalChatEnd)
                return object;
            let message = new $root.AcFunDanmu.CommonStateSignalChatEnd();
            if (object.chatId != null)
                message.chatId = String(object.chatId);
            switch (object.endType) {
            case "UNKNOWN":
            case 0:
                message.endType = 0;
                break;
            case "CANCEL_BY_AUTHOR":
            case 1:
                message.endType = 1;
                break;
            case "END_BY_AUTHOR":
            case 2:
                message.endType = 2;
                break;
            case "END_BY_GUEST":
            case 3:
                message.endType = 3;
                break;
            case "GUEST_REJECT":
            case 4:
                message.endType = 4;
                break;
            case "GUEST_TIMEOUT":
            case 5:
                message.endType = 5;
                break;
            case "GUEST_HEARTBEAT_TIMEOUT":
            case 6:
                message.endType = 6;
                break;
            case "AUTHOR_HEARTBEAT_TIMEOUT":
            case 7:
                message.endType = 7;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a CommonStateSignalChatEnd message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AcFunDanmu.CommonStateSignalChatEnd
         * @static
         * @param {AcFunDanmu.CommonStateSignalChatEnd} message CommonStateSignalChatEnd
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CommonStateSignalChatEnd.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.chatId = "";
                object.endType = options.enums === String ? "UNKNOWN" : 0;
            }
            if (message.chatId != null && message.hasOwnProperty("chatId"))
                object.chatId = message.chatId;
            if (message.endType != null && message.hasOwnProperty("endType"))
                object.endType = options.enums === String ? $root.AcFunDanmu.CommonStateSignalChatEnd.EndType[message.endType] : message.endType;
            return object;
        };

        /**
         * Converts this CommonStateSignalChatEnd to JSON.
         * @function toJSON
         * @memberof AcFunDanmu.CommonStateSignalChatEnd
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CommonStateSignalChatEnd.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * EndType enum.
         * @name AcFunDanmu.CommonStateSignalChatEnd.EndType
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} CANCEL_BY_AUTHOR=1 CANCEL_BY_AUTHOR value
         * @property {number} END_BY_AUTHOR=2 END_BY_AUTHOR value
         * @property {number} END_BY_GUEST=3 END_BY_GUEST value
         * @property {number} GUEST_REJECT=4 GUEST_REJECT value
         * @property {number} GUEST_TIMEOUT=5 GUEST_TIMEOUT value
         * @property {number} GUEST_HEARTBEAT_TIMEOUT=6 GUEST_HEARTBEAT_TIMEOUT value
         * @property {number} AUTHOR_HEARTBEAT_TIMEOUT=7 AUTHOR_HEARTBEAT_TIMEOUT value
         */
        CommonStateSignalChatEnd.EndType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "CANCEL_BY_AUTHOR"] = 1;
            values[valuesById[2] = "END_BY_AUTHOR"] = 2;
            values[valuesById[3] = "END_BY_GUEST"] = 3;
            values[valuesById[4] = "GUEST_REJECT"] = 4;
            values[valuesById[5] = "GUEST_TIMEOUT"] = 5;
            values[valuesById[6] = "GUEST_HEARTBEAT_TIMEOUT"] = 6;
            values[valuesById[7] = "AUTHOR_HEARTBEAT_TIMEOUT"] = 7;
            return values;
        })();

        return CommonStateSignalChatEnd;
    })();

    return AcFunDanmu;
})();

export { $root as default };
